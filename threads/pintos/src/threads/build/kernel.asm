
kernel.o:     file format elf32-i386


Disassembly of section .text:

c00200b8 <start>:
c00200b8:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
c00200bd:	8e c0                	mov    %eax,%es
c00200bf:	fc                   	cld    
c00200c0:	b4 88                	mov    $0x88,%ah
c00200c2:	cd 15                	int    $0x15
c00200c4:	66 05 00 04          	add    $0x400,%ax
c00200c8:	00 00                	add    %al,(%eax)
c00200ca:	66 3d 00 00          	cmp    $0x0,%ax
c00200ce:	01 00                	add    %eax,(%eax)
c00200d0:	76 06                	jbe    c00200d8 <start+0x20>
c00200d2:	66 b8 00 00          	mov    $0x0,%ax
c00200d6:	01 00                	add    %eax,(%eax)
c00200d8:	66 c1 e8 02          	shr    $0x2,%ax
c00200dc:	67 66 a3 be 01       	addr16 mov %ax,0x1be
c00200e1:	00 00                	add    %al,(%eax)
c00200e3:	e4 64                	in     $0x64,%al
c00200e5:	a8 02                	test   $0x2,%al
c00200e7:	75 fa                	jne    c00200e3 <start+0x2b>
c00200e9:	b0 d1                	mov    $0xd1,%al
c00200eb:	e6 64                	out    %al,$0x64
c00200ed:	e4 64                	in     $0x64,%al
c00200ef:	a8 02                	test   $0x2,%al
c00200f1:	75 fa                	jne    c00200ed <start+0x35>
c00200f3:	b0 df                	mov    $0xdf,%al
c00200f5:	e6 60                	out    %al,$0x60
c00200f7:	e4 64                	in     $0x64,%al
c00200f9:	a8 02                	test   $0x2,%al
c00200fb:	75 fa                	jne    c00200f7 <start+0x3f>
c00200fd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
c0020102:	66 29 c0             	sub    %ax,%ax
c0020105:	66 29 ff             	sub    %di,%di
c0020108:	66 b9 00 04          	mov    $0x400,%cx
c002010c:	00 00                	add    %al,(%eax)
c002010e:	66 f3 ab             	rep stos %ax,%es:(%edi)
c0020111:	66 b8 07 00          	mov    $0x7,%ax
c0020115:	01 00                	add    %eax,(%eax)
c0020117:	66 b9 11 00          	mov    $0x11,%cx
c002011b:	00 00                	add    %al,(%eax)
c002011d:	66 29 ff             	sub    %di,%di
c0020120:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c0020127:	85 
c0020128:	00 0c 83             	add    %cl,(%ebx,%eax,4)
c002012b:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
c0020132:	00 e2                	add    %ah,%dl
c0020134:	eb b8                	jmp    c00200ee <start+0x36>
c0020136:	00 10                	add    %dl,(%eax)
c0020138:	8e c0                	mov    %eax,%es
c002013a:	66 b8 07 00          	mov    $0x7,%ax
c002013e:	00 00                	add    %al,(%eax)
c0020140:	66 b9 00 40          	mov    $0x4000,%cx
c0020144:	00 00                	add    %al,(%eax)
c0020146:	66 29 ff             	sub    %di,%di
c0020149:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020150:	66 
c0020151:	05 00 10 00 00       	add    $0x1000,%eax
c0020156:	e2 f1                	loop   c0020149 <start+0x91>
c0020158:	66 b8 00 f0          	mov    $0xf000,%ax
c002015c:	00 00                	add    %al,(%eax)
c002015e:	0f 22 d8             	mov    %eax,%cr3
c0020161:	fa                   	cli    
c0020162:	67 66 0f 01 15       	lgdtw  (%di)
c0020167:	b8 01 00 00 0f       	mov    $0xf000001,%eax
c002016c:	20 c0                	and    %al,%al
c002016e:	66 0d 05 00          	or     $0x5,%ax
c0020172:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
c0020178:	ea 7f 01 02 c0 08 00 	ljmp   $0x8,$0xc002017f
c002017f:	66 b8 10 00          	mov    $0x10,%ax
c0020183:	8e d8                	mov    %eax,%ds
c0020185:	8e c0                	mov    %eax,%es
c0020187:	8e e0                	mov    %eax,%fs
c0020189:	8e e8                	mov    %eax,%gs
c002018b:	8e d0                	mov    %eax,%ss
c002018d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
c0020193:	bd 00 00 00 00       	mov    $0x0,%ebp
c0020198:	e8 fd 01 00 00       	call   c002039a <main>
c002019d:	eb fe                	jmp    c002019d <start+0xe5>
	...

c00201a0 <gdt>:
	...
c00201a8:	ff                   	(bad)  
c00201a9:	ff 00                	incl   (%eax)
c00201ab:	00 00                	add    %al,(%eax)
c00201ad:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c00201b4:	00                   	.byte 0x0
c00201b5:	92                   	xchg   %eax,%edx
c00201b6:	cf                   	iret   
	...

c00201b8 <gdtdesc>:
c00201b8:	17                   	pop    %ss
c00201b9:	00                   	.byte 0x0
c00201ba:	a0                   	.byte 0xa0
c00201bb:	01 02                	add    %eax,(%edx)
c00201bd:	c0                   	.byte 0xc0

c00201be <init_ram_pages>:
c00201be:	00 00                	add    %al,(%eax)
	...

c00201c2 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c00201c2:	55                   	push   %ebp
c00201c3:	89 e5                	mov    %esp,%ebp
c00201c5:	e8 5e 12 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00201ca:	05 ae a1 01 00       	add    $0x1a1ae,%eax
  return (uintptr_t) va & PGMASK;
c00201cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00201d2:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00201d7:	5d                   	pop    %ebp
c00201d8:	c3                   	ret    

c00201d9 <is_kernel_vaddr>:
}

/* Returns true if VADDR is a kernel virtual address. */
static inline bool
is_kernel_vaddr (const void *vaddr) 
{
c00201d9:	55                   	push   %ebp
c00201da:	89 e5                	mov    %esp,%ebp
c00201dc:	e8 47 12 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00201e1:	05 97 a1 01 00       	add    $0x1a197,%eax
  return vaddr >= PHYS_BASE;
c00201e6:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c00201ed:	0f 97 c0             	seta   %al
}
c00201f0:	5d                   	pop    %ebp
c00201f1:	c3                   	ret    

c00201f2 <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c00201f2:	55                   	push   %ebp
c00201f3:	89 e5                	mov    %esp,%ebp
c00201f5:	53                   	push   %ebx
c00201f6:	83 ec 04             	sub    $0x4,%esp
c00201f9:	e8 2a 12 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00201fe:	05 7a a1 01 00       	add    $0x1a17a,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c0020203:	8b 55 08             	mov    0x8(%ebp),%edx
c0020206:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002020c:	76 28                	jbe    c0020236 <ptov+0x44>
c002020e:	83 ec 0c             	sub    $0xc,%esp
c0020211:	8d 90 c8 70 ff ff    	lea    -0x8f38(%eax),%edx
c0020217:	52                   	push   %edx
c0020218:	8d 90 e3 70 ff ff    	lea    -0x8f1d(%eax),%edx
c002021e:	52                   	push   %edx
c002021f:	8d 90 88 74 ff ff    	lea    -0x8b78(%eax),%edx
c0020225:	52                   	push   %edx
c0020226:	6a 4a                	push   $0x4a
c0020228:	8d 90 fa 70 ff ff    	lea    -0x8f06(%eax),%edx
c002022e:	52                   	push   %edx
c002022f:	89 c3                	mov    %eax,%ebx
c0020231:	e8 2e b5 00 00       	call   c002b764 <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c0020236:	8b 45 08             	mov    0x8(%ebp),%eax
c0020239:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c002023e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020241:	c9                   	leave  
c0020242:	c3                   	ret    

c0020243 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c0020243:	55                   	push   %ebp
c0020244:	89 e5                	mov    %esp,%ebp
c0020246:	53                   	push   %ebx
c0020247:	83 ec 04             	sub    $0x4,%esp
c002024a:	e8 dd 11 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002024f:	81 c3 29 a1 01 00    	add    $0x1a129,%ebx
  ASSERT (is_kernel_vaddr (vaddr));
c0020255:	ff 75 08             	push   0x8(%ebp)
c0020258:	e8 7c ff ff ff       	call   c00201d9 <is_kernel_vaddr>
c002025d:	83 c4 04             	add    $0x4,%esp
c0020260:	84 c0                	test   %al,%al
c0020262:	75 26                	jne    c002028a <vtop+0x47>
c0020264:	83 ec 0c             	sub    $0xc,%esp
c0020267:	8d 83 10 71 ff ff    	lea    -0x8ef0(%ebx),%eax
c002026d:	50                   	push   %eax
c002026e:	8d 83 e3 70 ff ff    	lea    -0x8f1d(%ebx),%eax
c0020274:	50                   	push   %eax
c0020275:	8d 83 b0 74 ff ff    	lea    -0x8b50(%ebx),%eax
c002027b:	50                   	push   %eax
c002027c:	6a 54                	push   $0x54
c002027e:	8d 83 fa 70 ff ff    	lea    -0x8f06(%ebx),%eax
c0020284:	50                   	push   %eax
c0020285:	e8 da b4 00 00       	call   c002b764 <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002028a:	8b 45 08             	mov    0x8(%ebp),%eax
c002028d:	05 00 00 00 40       	add    $0x40000000,%eax
}
c0020292:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020295:	c9                   	leave  
c0020296:	c3                   	ret    

c0020297 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c0020297:	55                   	push   %ebp
c0020298:	89 e5                	mov    %esp,%ebp
c002029a:	e8 89 11 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002029f:	05 d9 a0 01 00       	add    $0x1a0d9,%eax
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c00202a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00202a7:	c1 e8 0c             	shr    $0xc,%eax
c00202aa:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c00202af:	5d                   	pop    %ebp
c00202b0:	c3                   	ret    

c00202b1 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c00202b1:	55                   	push   %ebp
c00202b2:	89 e5                	mov    %esp,%ebp
c00202b4:	e8 6f 11 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00202b9:	05 bf a0 01 00       	add    $0x1a0bf,%eax
  return (uintptr_t) va >> PDSHIFT;
c00202be:	8b 45 08             	mov    0x8(%ebp),%eax
c00202c1:	c1 e8 16             	shr    $0x16,%eax
}
c00202c4:	5d                   	pop    %ebp
c00202c5:	c3                   	ret    

c00202c6 <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c00202c6:	55                   	push   %ebp
c00202c7:	89 e5                	mov    %esp,%ebp
c00202c9:	53                   	push   %ebx
c00202ca:	83 ec 04             	sub    $0x4,%esp
c00202cd:	e8 5a 11 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00202d2:	81 c3 a6 a0 01 00    	add    $0x1a0a6,%ebx
  ASSERT (pg_ofs (pt) == 0);
c00202d8:	ff 75 08             	push   0x8(%ebp)
c00202db:	e8 e2 fe ff ff       	call   c00201c2 <pg_ofs>
c00202e0:	83 c4 04             	add    $0x4,%esp
c00202e3:	85 c0                	test   %eax,%eax
c00202e5:	74 26                	je     c002030d <pde_create+0x47>
c00202e7:	83 ec 0c             	sub    $0xc,%esp
c00202ea:	8d 83 28 71 ff ff    	lea    -0x8ed8(%ebx),%eax
c00202f0:	50                   	push   %eax
c00202f1:	8d 83 e3 70 ff ff    	lea    -0x8f1d(%ebx),%eax
c00202f7:	50                   	push   %eax
c00202f8:	8d 83 90 74 ff ff    	lea    -0x8b70(%ebx),%eax
c00202fe:	50                   	push   %eax
c00202ff:	6a 48                	push   $0x48
c0020301:	8d 83 39 71 ff ff    	lea    -0x8ec7(%ebx),%eax
c0020307:	50                   	push   %eax
c0020308:	e8 57 b4 00 00       	call   c002b764 <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c002030d:	83 ec 0c             	sub    $0xc,%esp
c0020310:	ff 75 08             	push   0x8(%ebp)
c0020313:	e8 2b ff ff ff       	call   c0020243 <vtop>
c0020318:	83 c4 10             	add    $0x10,%esp
c002031b:	83 c8 07             	or     $0x7,%eax
}
c002031e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020321:	c9                   	leave  
c0020322:	c3                   	ret    

c0020323 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c0020323:	55                   	push   %ebp
c0020324:	89 e5                	mov    %esp,%ebp
c0020326:	53                   	push   %ebx
c0020327:	83 ec 14             	sub    $0x14,%esp
c002032a:	e8 fd 10 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002032f:	81 c3 49 a0 01 00    	add    $0x1a049,%ebx
c0020335:	8b 45 0c             	mov    0xc(%ebp),%eax
c0020338:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c002033b:	ff 75 08             	push   0x8(%ebp)
c002033e:	e8 7f fe ff ff       	call   c00201c2 <pg_ofs>
c0020343:	83 c4 04             	add    $0x4,%esp
c0020346:	85 c0                	test   %eax,%eax
c0020348:	74 26                	je     c0020370 <pte_create_kernel+0x4d>
c002034a:	83 ec 0c             	sub    $0xc,%esp
c002034d:	8d 83 4d 71 ff ff    	lea    -0x8eb3(%ebx),%eax
c0020353:	50                   	push   %eax
c0020354:	8d 83 e3 70 ff ff    	lea    -0x8f1d(%ebx),%eax
c002035a:	50                   	push   %eax
c002035b:	8d 83 9c 74 ff ff    	lea    -0x8b64(%ebx),%eax
c0020361:	50                   	push   %eax
c0020362:	6a 58                	push   $0x58
c0020364:	8d 83 39 71 ff ff    	lea    -0x8ec7(%ebx),%eax
c002036a:	50                   	push   %eax
c002036b:	e8 f4 b3 00 00       	call   c002b764 <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c0020370:	83 ec 0c             	sub    $0xc,%esp
c0020373:	ff 75 08             	push   0x8(%ebp)
c0020376:	e8 c8 fe ff ff       	call   c0020243 <vtop>
c002037b:	83 c4 10             	add    $0x10,%esp
c002037e:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c0020382:	74 07                	je     c002038b <pte_create_kernel+0x68>
c0020384:	ba 02 00 00 00       	mov    $0x2,%edx
c0020389:	eb 05                	jmp    c0020390 <pte_create_kernel+0x6d>
c002038b:	ba 00 00 00 00       	mov    $0x0,%edx
c0020390:	09 d0                	or     %edx,%eax
c0020392:	83 c8 01             	or     $0x1,%eax
}
c0020395:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020398:	c9                   	leave  
c0020399:	c3                   	ret    

c002039a <main>:
int main (void) NO_RETURN;

/* Pintos main program. */
int
main (void)
{
c002039a:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c002039e:	83 e4 f0             	and    $0xfffffff0,%esp
c00203a1:	ff 71 fc             	push   -0x4(%ecx)
c00203a4:	55                   	push   %ebp
c00203a5:	89 e5                	mov    %esp,%ebp
c00203a7:	53                   	push   %ebx
c00203a8:	51                   	push   %ecx
c00203a9:	83 ec 10             	sub    $0x10,%esp
c00203ac:	e8 7b 10 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00203b1:	81 c3 c7 9f 01 00    	add    $0x19fc7,%ebx
  char **argv;

  /* Clear BSS. */  
  bss_init ();
c00203b7:	e8 ad 00 00 00       	call   c0020469 <bss_init>

  /* Break command line into arguments and parse options. */
  argv = read_command_line ();
c00203bc:	e8 3e 02 00 00       	call   c00205ff <read_command_line>
c00203c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  argv = parse_options (argv);
c00203c4:	83 ec 0c             	sub    $0xc,%esp
c00203c7:	ff 75 f4             	push   -0xc(%ebp)
c00203ca:	e8 7c 03 00 00       	call   c002074b <parse_options>
c00203cf:	83 c4 10             	add    $0x10,%esp
c00203d2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00203d5:	e8 70 08 00 00       	call   c0020c4a <thread_init>
  console_init ();  
c00203da:	e8 30 da 00 00       	call   c002de0f <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
          init_ram_pages * PGSIZE / 1024);
c00203df:	c7 c0 be 01 02 c0    	mov    $0xc00201be,%eax
c00203e5:	8b 00                	mov    (%eax),%eax
c00203e7:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00203ea:	c1 e8 0a             	shr    $0xa,%eax
c00203ed:	83 ec 08             	sub    $0x8,%esp
c00203f0:	50                   	push   %eax
c00203f1:	8d 83 60 71 ff ff    	lea    -0x8ea0(%ebx),%eax
c00203f7:	50                   	push   %eax
c00203f8:	e8 e8 8a 00 00       	call   c0028ee5 <printf>
c00203fd:	83 c4 10             	add    $0x10,%esp

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c0020400:	8b 83 f0 fb ff ff    	mov    -0x410(%ebx),%eax
c0020406:	83 ec 0c             	sub    $0xc,%esp
c0020409:	50                   	push   %eax
c002040a:	e8 84 3d 00 00       	call   c0024193 <palloc_init>
c002040f:	83 c4 10             	add    $0x10,%esp
  malloc_init ();
c0020412:	e8 32 42 00 00       	call   c0024649 <malloc_init>
  paging_init ();
c0020417:	e8 8f 00 00 00       	call   c00204ab <paging_init>
  tss_init ();
  gdt_init ();
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c002041c:	e8 e3 1a 00 00       	call   c0021f04 <intr_init>
  timer_init ();
c0020421:	e8 d6 4a 00 00       	call   c0024efc <timer_init>
  kbd_init ();
c0020426:	e8 d4 52 00 00       	call   c00256ff <kbd_init>
  input_init ();
c002042b:	e8 84 7a 00 00       	call   c0027eb4 <input_init>
  exception_init ();
  syscall_init ();
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c0020430:	e8 d2 08 00 00       	call   c0020d07 <thread_start>
  serial_init_queue ();
c0020435:	e8 f2 5b 00 00       	call   c002602c <serial_init_queue>
  timer_calibrate ();
c002043a:	e8 13 4b 00 00       	call   c0024f52 <timer_calibrate>
  ide_init ();
  locate_block_devices ();
  filesys_init (format_filesys);
#endif

  printf ("Boot complete.\n");
c002043f:	83 ec 0c             	sub    $0xc,%esp
c0020442:	8d 83 83 71 ff ff    	lea    -0x8e7d(%ebx),%eax
c0020448:	50                   	push   %eax
c0020449:	e8 9e db 00 00       	call   c002dfec <puts>
c002044e:	83 c4 10             	add    $0x10,%esp
  
  /* Run actions specified on kernel command line. */
  run_actions (argv);
c0020451:	83 ec 0c             	sub    $0xc,%esp
c0020454:	ff 75 f4             	push   -0xc(%ebp)
c0020457:	e8 ee 04 00 00       	call   c002094a <run_actions>
c002045c:	83 c4 10             	add    $0x10,%esp

  /* Finish up. */
  shutdown ();
c002045f:	e8 8c 83 00 00       	call   c00287f0 <shutdown>
  thread_exit ();
c0020464:	e8 c1 0f 00 00       	call   c002142a <thread_exit>

c0020469 <bss_init>:

   The start and end of the BSS segment is recorded by the
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
c0020469:	55                   	push   %ebp
c002046a:	89 e5                	mov    %esp,%ebp
c002046c:	53                   	push   %ebx
c002046d:	83 ec 04             	sub    $0x4,%esp
c0020470:	e8 b3 0f 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020475:	05 03 9f 01 00       	add    $0x19f03,%eax
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c002047a:	c7 c2 80 c6 03 c0    	mov    $0xc003c680,%edx
c0020480:	89 d1                	mov    %edx,%ecx
c0020482:	c7 c2 98 aa 03 c0    	mov    $0xc003aa98,%edx
c0020488:	89 d3                	mov    %edx,%ebx
c002048a:	29 d9                	sub    %ebx,%ecx
c002048c:	89 ca                	mov    %ecx,%edx
c002048e:	83 ec 04             	sub    $0x4,%esp
c0020491:	52                   	push   %edx
c0020492:	6a 00                	push   $0x0
c0020494:	c7 c2 98 aa 03 c0    	mov    $0xc003aa98,%edx
c002049a:	52                   	push   %edx
c002049b:	89 c3                	mov    %eax,%ebx
c002049d:	e8 52 a5 00 00       	call   c002a9f4 <memset>
c00204a2:	83 c4 10             	add    $0x10,%esp
}
c00204a5:	90                   	nop
c00204a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00204a9:	c9                   	leave  
c00204aa:	c3                   	ret    

c00204ab <paging_init>:
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */
static void
paging_init (void)
{
c00204ab:	55                   	push   %ebp
c00204ac:	89 e5                	mov    %esp,%ebp
c00204ae:	56                   	push   %esi
c00204af:	53                   	push   %ebx
c00204b0:	83 ec 20             	sub    $0x20,%esp
c00204b3:	e8 74 0f 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00204b8:	81 c3 c0 9e 01 00    	add    $0x19ec0,%ebx
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00204be:	83 ec 0c             	sub    $0xc,%esp
c00204c1:	6a 03                	push   $0x3
c00204c3:	e8 74 3e 00 00       	call   c002433c <palloc_get_page>
c00204c8:	83 c4 10             	add    $0x10,%esp
c00204cb:	89 83 28 07 00 00    	mov    %eax,0x728(%ebx)
c00204d1:	8b 83 28 07 00 00    	mov    0x728(%ebx),%eax
c00204d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pt = NULL;
c00204da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (page = 0; page < init_ram_pages; page++)
c00204e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00204e8:	e9 e4 00 00 00       	jmp    c00205d1 <paging_init+0x126>
    {
      uintptr_t paddr = page * PGSIZE;
c00204ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00204f0:	c1 e0 0c             	shl    $0xc,%eax
c00204f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
      char *vaddr = ptov (paddr);
c00204f6:	83 ec 0c             	sub    $0xc,%esp
c00204f9:	ff 75 e8             	push   -0x18(%ebp)
c00204fc:	e8 f1 fc ff ff       	call   c00201f2 <ptov>
c0020501:	83 c4 10             	add    $0x10,%esp
c0020504:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      size_t pde_idx = pd_no (vaddr);
c0020507:	83 ec 0c             	sub    $0xc,%esp
c002050a:	ff 75 e4             	push   -0x1c(%ebp)
c002050d:	e8 9f fd ff ff       	call   c00202b1 <pd_no>
c0020512:	83 c4 10             	add    $0x10,%esp
c0020515:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t pte_idx = pt_no (vaddr);
c0020518:	83 ec 0c             	sub    $0xc,%esp
c002051b:	ff 75 e4             	push   -0x1c(%ebp)
c002051e:	e8 74 fd ff ff       	call   c0020297 <pt_no>
c0020523:	83 c4 10             	add    $0x10,%esp
c0020526:	89 45 dc             	mov    %eax,-0x24(%ebp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020529:	c7 c0 00 00 02 c0    	mov    $0xc0020000,%eax
c002052f:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0020532:	72 12                	jb     c0020546 <paging_init+0x9b>
c0020534:	c7 c0 00 60 03 c0    	mov    $0xc0036000,%eax
c002053a:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c002053d:	73 07                	jae    c0020546 <paging_init+0x9b>
c002053f:	b8 01 00 00 00       	mov    $0x1,%eax
c0020544:	eb 05                	jmp    c002054b <paging_init+0xa0>
c0020546:	b8 00 00 00 00       	mov    $0x0,%eax
c002054b:	88 45 db             	mov    %al,-0x25(%ebp)
c002054e:	80 65 db 01          	andb   $0x1,-0x25(%ebp)

      if (pd[pde_idx] == 0)
c0020552:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020555:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002055c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002055f:	01 d0                	add    %edx,%eax
c0020561:	8b 00                	mov    (%eax),%eax
c0020563:	85 c0                	test   %eax,%eax
c0020565:	75 30                	jne    c0020597 <paging_init+0xec>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020567:	83 ec 0c             	sub    $0xc,%esp
c002056a:	6a 03                	push   $0x3
c002056c:	e8 cb 3d 00 00       	call   c002433c <palloc_get_page>
c0020571:	83 c4 10             	add    $0x10,%esp
c0020574:	89 45 f4             	mov    %eax,-0xc(%ebp)
          pd[pde_idx] = pde_create (pt);
c0020577:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002057a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020581:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020584:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0020587:	83 ec 0c             	sub    $0xc,%esp
c002058a:	ff 75 f4             	push   -0xc(%ebp)
c002058d:	e8 34 fd ff ff       	call   c00202c6 <pde_create>
c0020592:	83 c4 10             	add    $0x10,%esp
c0020595:	89 06                	mov    %eax,(%esi)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c0020597:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
c002059b:	85 c0                	test   %eax,%eax
c002059d:	0f 95 c0             	setne  %al
c00205a0:	83 f0 01             	xor    $0x1,%eax
c00205a3:	0f b6 c0             	movzbl %al,%eax
c00205a6:	83 e0 01             	and    $0x1,%eax
c00205a9:	0f b6 c0             	movzbl %al,%eax
c00205ac:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00205af:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c00205b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00205b9:	8d 34 11             	lea    (%ecx,%edx,1),%esi
c00205bc:	83 ec 08             	sub    $0x8,%esp
c00205bf:	50                   	push   %eax
c00205c0:	ff 75 e4             	push   -0x1c(%ebp)
c00205c3:	e8 5b fd ff ff       	call   c0020323 <pte_create_kernel>
c00205c8:	83 c4 10             	add    $0x10,%esp
c00205cb:	89 06                	mov    %eax,(%esi)
  for (page = 0; page < init_ram_pages; page++)
c00205cd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00205d1:	c7 c0 be 01 02 c0    	mov    $0xc00201be,%eax
c00205d7:	8b 00                	mov    (%eax),%eax
c00205d9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00205dc:	0f 82 0b ff ff ff    	jb     c00204ed <paging_init+0x42>
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00205e2:	8b 83 28 07 00 00    	mov    0x728(%ebx),%eax
c00205e8:	83 ec 0c             	sub    $0xc,%esp
c00205eb:	50                   	push   %eax
c00205ec:	e8 52 fc ff ff       	call   c0020243 <vtop>
c00205f1:	83 c4 10             	add    $0x10,%esp
c00205f4:	0f 22 d8             	mov    %eax,%cr3
}
c00205f7:	90                   	nop
c00205f8:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00205fb:	5b                   	pop    %ebx
c00205fc:	5e                   	pop    %esi
c00205fd:	5d                   	pop    %ebp
c00205fe:	c3                   	ret    

c00205ff <read_command_line>:

/* Breaks the kernel command line into words and returns them as
   an argv-like array. */
static char **
read_command_line (void) 
{
c00205ff:	55                   	push   %ebp
c0020600:	89 e5                	mov    %esp,%ebp
c0020602:	53                   	push   %ebx
c0020603:	83 ec 14             	sub    $0x14,%esp
c0020606:	e8 21 0e 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002060b:	81 c3 6d 9d 01 00    	add    $0x19d6d,%ebx
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c0020611:	83 ec 0c             	sub    $0xc,%esp
c0020614:	68 3a 7d 00 00       	push   $0x7d3a
c0020619:	e8 d4 fb ff ff       	call   c00201f2 <ptov>
c002061e:	83 c4 10             	add    $0x10,%esp
c0020621:	8b 00                	mov    (%eax),%eax
c0020623:	89 45 ec             	mov    %eax,-0x14(%ebp)
  p = ptov (LOADER_ARGS);
c0020626:	83 ec 0c             	sub    $0xc,%esp
c0020629:	68 3e 7d 00 00       	push   $0x7d3e
c002062e:	e8 bf fb ff ff       	call   c00201f2 <ptov>
c0020633:	83 c4 10             	add    $0x10,%esp
c0020636:	89 45 f4             	mov    %eax,-0xc(%ebp)
  end = p + LOADER_ARGS_LEN;
c0020639:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002063c:	83 e8 80             	sub    $0xffffff80,%eax
c002063f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for (i = 0; i < argc; i++) 
c0020642:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0020649:	eb 53                	jmp    c002069e <read_command_line+0x9f>
    {
      if (p >= end)
c002064b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002064e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0020651:	72 1f                	jb     c0020672 <read_command_line+0x73>
        PANIC ("command line arguments overflow");
c0020653:	8d 83 94 71 ff ff    	lea    -0x8e6c(%ebx),%eax
c0020659:	50                   	push   %eax
c002065a:	8d 83 b8 74 ff ff    	lea    -0x8b48(%ebx),%eax
c0020660:	50                   	push   %eax
c0020661:	68 cf 00 00 00       	push   $0xcf
c0020666:	8d 83 b4 71 ff ff    	lea    -0x8e4c(%ebx),%eax
c002066c:	50                   	push   %eax
c002066d:	e8 f2 b0 00 00       	call   c002b764 <debug_panic>

      argv[i] = p;
c0020672:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020675:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0020678:	89 94 83 48 07 00 00 	mov    %edx,0x748(%ebx,%eax,4)
      p += strnlen (p, end - p) + 1;
c002067f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020682:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0020685:	83 ec 08             	sub    $0x8,%esp
c0020688:	50                   	push   %eax
c0020689:	ff 75 f4             	push   -0xc(%ebp)
c002068c:	e8 38 a4 00 00       	call   c002aac9 <strnlen>
c0020691:	83 c4 10             	add    $0x10,%esp
c0020694:	83 c0 01             	add    $0x1,%eax
c0020697:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < argc; i++) 
c002069a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002069e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00206a1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00206a4:	7c a5                	jl     c002064b <read_command_line+0x4c>
    }
  argv[argc] = NULL;
c00206a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00206a9:	c7 84 83 48 07 00 00 	movl   $0x0,0x748(%ebx,%eax,4)
c00206b0:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c00206b4:	83 ec 0c             	sub    $0xc,%esp
c00206b7:	8d 83 c9 71 ff ff    	lea    -0x8e37(%ebx),%eax
c00206bd:	50                   	push   %eax
c00206be:	e8 22 88 00 00       	call   c0028ee5 <printf>
c00206c3:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00206c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00206cd:	eb 5c                	jmp    c002072b <read_command_line+0x12c>
    if (strchr (argv[i], ' ') == NULL)
c00206cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00206d2:	8b 84 83 48 07 00 00 	mov    0x748(%ebx,%eax,4),%eax
c00206d9:	83 ec 08             	sub    $0x8,%esp
c00206dc:	6a 20                	push   $0x20
c00206de:	50                   	push   %eax
c00206df:	e8 a9 9f 00 00       	call   c002a68d <strchr>
c00206e4:	83 c4 10             	add    $0x10,%esp
c00206e7:	85 c0                	test   %eax,%eax
c00206e9:	75 1f                	jne    c002070a <read_command_line+0x10b>
      printf (" %s", argv[i]);
c00206eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00206ee:	8b 84 83 48 07 00 00 	mov    0x748(%ebx,%eax,4),%eax
c00206f5:	83 ec 08             	sub    $0x8,%esp
c00206f8:	50                   	push   %eax
c00206f9:	8d 83 de 71 ff ff    	lea    -0x8e22(%ebx),%eax
c00206ff:	50                   	push   %eax
c0020700:	e8 e0 87 00 00       	call   c0028ee5 <printf>
c0020705:	83 c4 10             	add    $0x10,%esp
c0020708:	eb 1d                	jmp    c0020727 <read_command_line+0x128>
    else
      printf (" '%s'", argv[i]);
c002070a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002070d:	8b 84 83 48 07 00 00 	mov    0x748(%ebx,%eax,4),%eax
c0020714:	83 ec 08             	sub    $0x8,%esp
c0020717:	50                   	push   %eax
c0020718:	8d 83 e2 71 ff ff    	lea    -0x8e1e(%ebx),%eax
c002071e:	50                   	push   %eax
c002071f:	e8 c1 87 00 00       	call   c0028ee5 <printf>
c0020724:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c0020727:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002072b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002072e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020731:	7c 9c                	jl     c00206cf <read_command_line+0xd0>
  printf ("\n");
c0020733:	83 ec 0c             	sub    $0xc,%esp
c0020736:	6a 0a                	push   $0xa
c0020738:	e8 4b d9 00 00       	call   c002e088 <putchar>
c002073d:	83 c4 10             	add    $0x10,%esp

  return argv;
c0020740:	8d 83 48 07 00 00    	lea    0x748(%ebx),%eax
}
c0020746:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020749:	c9                   	leave  
c002074a:	c3                   	ret    

c002074b <parse_options>:

/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
c002074b:	55                   	push   %ebp
c002074c:	89 e5                	mov    %esp,%ebp
c002074e:	53                   	push   %ebx
c002074f:	83 ec 14             	sub    $0x14,%esp
c0020752:	e8 d5 0c 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0020757:	81 c3 21 9c 01 00    	add    $0x19c21,%ebx
  for (; *argv != NULL && **argv == '-'; argv++)
c002075d:	e9 32 01 00 00       	jmp    c0020894 <parse_options+0x149>
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020762:	8b 45 08             	mov    0x8(%ebp),%eax
c0020765:	8b 00                	mov    (%eax),%eax
c0020767:	83 ec 04             	sub    $0x4,%esp
c002076a:	8d 55 ec             	lea    -0x14(%ebp),%edx
c002076d:	52                   	push   %edx
c002076e:	8d 93 e8 71 ff ff    	lea    -0x8e18(%ebx),%edx
c0020774:	52                   	push   %edx
c0020775:	50                   	push   %eax
c0020776:	e8 39 a1 00 00       	call   c002a8b4 <strtok_r>
c002077b:	83 c4 10             	add    $0x10,%esp
c002077e:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char *value = strtok_r (NULL, "", &save_ptr);
c0020781:	83 ec 04             	sub    $0x4,%esp
c0020784:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0020787:	50                   	push   %eax
c0020788:	8d 83 ea 71 ff ff    	lea    -0x8e16(%ebx),%eax
c002078e:	50                   	push   %eax
c002078f:	6a 00                	push   $0x0
c0020791:	e8 1e a1 00 00       	call   c002a8b4 <strtok_r>
c0020796:	83 c4 10             	add    $0x10,%esp
c0020799:	89 45 f0             	mov    %eax,-0x10(%ebp)
      
      if (!strcmp (name, "-h"))
c002079c:	83 ec 08             	sub    $0x8,%esp
c002079f:	8d 83 eb 71 ff ff    	lea    -0x8e15(%ebx),%eax
c00207a5:	50                   	push   %eax
c00207a6:	ff 75 f4             	push   -0xc(%ebp)
c00207a9:	e8 98 9d 00 00       	call   c002a546 <strcmp>
c00207ae:	83 c4 10             	add    $0x10,%esp
c00207b1:	85 c0                	test   %eax,%eax
c00207b3:	75 0a                	jne    c00207bf <parse_options+0x74>
        usage ();
c00207b5:	e8 ac 02 00 00       	call   c0020a66 <usage>
c00207ba:	e9 d1 00 00 00       	jmp    c0020890 <parse_options+0x145>
      else if (!strcmp (name, "-q"))
c00207bf:	83 ec 08             	sub    $0x8,%esp
c00207c2:	8d 83 ee 71 ff ff    	lea    -0x8e12(%ebx),%eax
c00207c8:	50                   	push   %eax
c00207c9:	ff 75 f4             	push   -0xc(%ebp)
c00207cc:	e8 75 9d 00 00       	call   c002a546 <strcmp>
c00207d1:	83 c4 10             	add    $0x10,%esp
c00207d4:	85 c0                	test   %eax,%eax
c00207d6:	75 12                	jne    c00207ea <parse_options+0x9f>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c00207d8:	83 ec 0c             	sub    $0xc,%esp
c00207db:	6a 01                	push   $0x1
c00207dd:	e8 3d 80 00 00       	call   c002881f <shutdown_configure>
c00207e2:	83 c4 10             	add    $0x10,%esp
c00207e5:	e9 a6 00 00 00       	jmp    c0020890 <parse_options+0x145>
      else if (!strcmp (name, "-r"))
c00207ea:	83 ec 08             	sub    $0x8,%esp
c00207ed:	8d 83 f1 71 ff ff    	lea    -0x8e0f(%ebx),%eax
c00207f3:	50                   	push   %eax
c00207f4:	ff 75 f4             	push   -0xc(%ebp)
c00207f7:	e8 4a 9d 00 00       	call   c002a546 <strcmp>
c00207fc:	83 c4 10             	add    $0x10,%esp
c00207ff:	85 c0                	test   %eax,%eax
c0020801:	75 0f                	jne    c0020812 <parse_options+0xc7>
        shutdown_configure (SHUTDOWN_REBOOT);
c0020803:	83 ec 0c             	sub    $0xc,%esp
c0020806:	6a 02                	push   $0x2
c0020808:	e8 12 80 00 00       	call   c002881f <shutdown_configure>
c002080d:	83 c4 10             	add    $0x10,%esp
c0020810:	eb 7e                	jmp    c0020890 <parse_options+0x145>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c0020812:	83 ec 08             	sub    $0x8,%esp
c0020815:	8d 83 f4 71 ff ff    	lea    -0x8e0c(%ebx),%eax
c002081b:	50                   	push   %eax
c002081c:	ff 75 f4             	push   -0xc(%ebp)
c002081f:	e8 22 9d 00 00       	call   c002a546 <strcmp>
c0020824:	83 c4 10             	add    $0x10,%esp
c0020827:	85 c0                	test   %eax,%eax
c0020829:	75 1c                	jne    c0020847 <parse_options+0xfc>
        random_init (atoi (value));
c002082b:	83 ec 0c             	sub    $0xc,%esp
c002082e:	ff 75 f0             	push   -0x10(%ebp)
c0020831:	e8 fa 95 00 00       	call   c0029e30 <atoi>
c0020836:	83 c4 10             	add    $0x10,%esp
c0020839:	83 ec 0c             	sub    $0xc,%esp
c002083c:	50                   	push   %eax
c002083d:	e8 9d 83 00 00       	call   c0028bdf <random_init>
c0020842:	83 c4 10             	add    $0x10,%esp
c0020845:	eb 49                	jmp    c0020890 <parse_options+0x145>
      else if (!strcmp (name, "-mlfqs"))
c0020847:	83 ec 08             	sub    $0x8,%esp
c002084a:	8d 83 f8 71 ff ff    	lea    -0x8e08(%ebx),%eax
c0020850:	50                   	push   %eax
c0020851:	ff 75 f4             	push   -0xc(%ebp)
c0020854:	e8 ed 9c 00 00       	call   c002a546 <strcmp>
c0020859:	83 c4 10             	add    $0x10,%esp
c002085c:	85 c0                	test   %eax,%eax
c002085e:	75 0b                	jne    c002086b <parse_options+0x120>
        thread_mlfqs = true;
c0020860:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c0020866:	c6 00 01             	movb   $0x1,(%eax)
c0020869:	eb 25                	jmp    c0020890 <parse_options+0x145>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
        user_page_limit = atoi (value);
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c002086b:	83 ec 0c             	sub    $0xc,%esp
c002086e:	ff 75 f4             	push   -0xc(%ebp)
c0020871:	8d 83 00 72 ff ff    	lea    -0x8e00(%ebx),%eax
c0020877:	50                   	push   %eax
c0020878:	8d 83 cc 74 ff ff    	lea    -0x8b34(%ebx),%eax
c002087e:	50                   	push   %eax
c002087f:	68 08 01 00 00       	push   $0x108
c0020884:	8d 83 b4 71 ff ff    	lea    -0x8e4c(%ebx),%eax
c002088a:	50                   	push   %eax
c002088b:	e8 d4 ae 00 00       	call   c002b764 <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020890:	83 45 08 04          	addl   $0x4,0x8(%ebp)
c0020894:	8b 45 08             	mov    0x8(%ebp),%eax
c0020897:	8b 00                	mov    (%eax),%eax
c0020899:	85 c0                	test   %eax,%eax
c002089b:	74 10                	je     c00208ad <parse_options+0x162>
c002089d:	8b 45 08             	mov    0x8(%ebp),%eax
c00208a0:	8b 00                	mov    (%eax),%eax
c00208a2:	0f b6 00             	movzbl (%eax),%eax
c00208a5:	3c 2d                	cmp    $0x2d,%al
c00208a7:	0f 84 b5 fe ff ff    	je     c0020762 <parse_options+0x17>
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c00208ad:	e8 b9 7c 00 00       	call   c002856b <rtc_get_time>
c00208b2:	83 ec 0c             	sub    $0xc,%esp
c00208b5:	50                   	push   %eax
c00208b6:	e8 24 83 00 00       	call   c0028bdf <random_init>
c00208bb:	83 c4 10             	add    $0x10,%esp
  
  return argv;
c00208be:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00208c1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00208c4:	c9                   	leave  
c00208c5:	c3                   	ret    

c00208c6 <run_task>:

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c00208c6:	55                   	push   %ebp
c00208c7:	89 e5                	mov    %esp,%ebp
c00208c9:	53                   	push   %ebx
c00208ca:	83 ec 14             	sub    $0x14,%esp
c00208cd:	e8 5a 0b 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00208d2:	81 c3 a6 9a 01 00    	add    $0x19aa6,%ebx
  const char *task = argv[1];
c00208d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00208db:	8b 40 04             	mov    0x4(%eax),%eax
c00208de:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Executing '%s':\n", task);
c00208e1:	83 ec 08             	sub    $0x8,%esp
c00208e4:	ff 75 f4             	push   -0xc(%ebp)
c00208e7:	8d 83 26 72 ff ff    	lea    -0x8dda(%ebx),%eax
c00208ed:	50                   	push   %eax
c00208ee:	e8 f2 85 00 00       	call   c0028ee5 <printf>
c00208f3:	83 c4 10             	add    $0x10,%esp
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c00208f6:	83 ec 0c             	sub    $0xc,%esp
c00208f9:	ff 75 f4             	push   -0xc(%ebp)
c00208fc:	e8 85 d8 00 00       	call   c002e186 <run_test>
c0020901:	83 c4 10             	add    $0x10,%esp
#endif
  printf ("Execution of '%s' complete.\n", task);
c0020904:	83 ec 08             	sub    $0x8,%esp
c0020907:	ff 75 f4             	push   -0xc(%ebp)
c002090a:	8d 83 37 72 ff ff    	lea    -0x8dc9(%ebx),%eax
c0020910:	50                   	push   %eax
c0020911:	e8 cf 85 00 00       	call   c0028ee5 <printf>
c0020916:	83 c4 10             	add    $0x10,%esp
}
c0020919:	90                   	nop
c002091a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002091d:	c9                   	leave  
c002091e:	c3                   	ret    

c002091f <hello_action>:
static void hello_action(char **argv) {
c002091f:	55                   	push   %ebp
c0020920:	89 e5                	mov    %esp,%ebp
c0020922:	53                   	push   %ebx
c0020923:	83 ec 04             	sub    $0x4,%esp
c0020926:	e8 fd 0a 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002092b:	05 4d 9a 01 00       	add    $0x19a4d,%eax
    /* Add your "hello" task implementation here */
    printf("Hayirli Ramazanlar <3\n");
c0020930:	83 ec 0c             	sub    $0xc,%esp
c0020933:	8d 90 54 72 ff ff    	lea    -0x8dac(%eax),%edx
c0020939:	52                   	push   %edx
c002093a:	89 c3                	mov    %eax,%ebx
c002093c:	e8 ab d6 00 00       	call   c002dfec <puts>
c0020941:	83 c4 10             	add    $0x10,%esp
}
c0020944:	90                   	nop
c0020945:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020948:	c9                   	leave  
c0020949:	c3                   	ret    

c002094a <run_actions>:
/* Executes all of the actions specified in ARGV[]
   up to the null pointer sentinel. */
static void
run_actions (char **argv) 
{
c002094a:	55                   	push   %ebp
c002094b:	89 e5                	mov    %esp,%ebp
c002094d:	53                   	push   %ebx
c002094e:	83 ec 14             	sub    $0x14,%esp
c0020951:	e8 d6 0a 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0020956:	81 c3 22 9a 01 00    	add    $0x19a22,%ebx

  if (*argv == NULL) {
c002095c:	8b 45 08             	mov    0x8(%ebp),%eax
c002095f:	8b 00                	mov    (%eax),%eax
c0020961:	85 c0                	test   %eax,%eax
c0020963:	0f 85 eb 00 00 00    	jne    c0020a54 <run_actions+0x10a>
        // No arguments passed, execute the "hello" action
        hello_action(argv);
c0020969:	83 ec 0c             	sub    $0xc,%esp
c002096c:	ff 75 08             	push   0x8(%ebp)
c002096f:	e8 ab ff ff ff       	call   c002091f <hello_action>
c0020974:	83 c4 10             	add    $0x10,%esp
        return;
c0020977:	e9 e5 00 00 00       	jmp    c0020a61 <run_actions+0x117>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c002097c:	8d 83 28 00 00 00    	lea    0x28(%ebx),%eax
c0020982:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (a->name == NULL)
c0020985:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020988:	8b 00                	mov    (%eax),%eax
c002098a:	85 c0                	test   %eax,%eax
c002098c:	75 28                	jne    c00209b6 <run_actions+0x6c>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c002098e:	8b 45 08             	mov    0x8(%ebp),%eax
c0020991:	8b 00                	mov    (%eax),%eax
c0020993:	83 ec 0c             	sub    $0xc,%esp
c0020996:	50                   	push   %eax
c0020997:	8d 83 6c 72 ff ff    	lea    -0x8d94(%ebx),%eax
c002099d:	50                   	push   %eax
c002099e:	8d 83 e4 74 ff ff    	lea    -0x8b1c(%ebx),%eax
c00209a4:	50                   	push   %eax
c00209a5:	68 54 01 00 00       	push   $0x154
c00209aa:	8d 83 b4 71 ff ff    	lea    -0x8e4c(%ebx),%eax
c00209b0:	50                   	push   %eax
c00209b1:	e8 ae ad 00 00       	call   c002b764 <debug_panic>
        else if (!strcmp (*argv, a->name))
c00209b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00209b9:	8b 10                	mov    (%eax),%edx
c00209bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00209be:	8b 00                	mov    (%eax),%eax
c00209c0:	83 ec 08             	sub    $0x8,%esp
c00209c3:	52                   	push   %edx
c00209c4:	50                   	push   %eax
c00209c5:	e8 7c 9b 00 00       	call   c002a546 <strcmp>
c00209ca:	83 c4 10             	add    $0x10,%esp
c00209cd:	85 c0                	test   %eax,%eax
c00209cf:	74 06                	je     c00209d7 <run_actions+0x8d>
      for (a = actions; ; a++)
c00209d1:	83 45 f4 0c          	addl   $0xc,-0xc(%ebp)
        if (a->name == NULL)
c00209d5:	eb ae                	jmp    c0020985 <run_actions+0x3b>
          break;
c00209d7:	90                   	nop

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c00209d8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c00209df:	eb 4b                	jmp    c0020a2c <run_actions+0xe2>
        if (argv[i] == NULL)
c00209e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00209e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00209eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00209ee:	01 d0                	add    %edx,%eax
c00209f0:	8b 00                	mov    (%eax),%eax
c00209f2:	85 c0                	test   %eax,%eax
c00209f4:	75 32                	jne    c0020a28 <run_actions+0xde>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c00209f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00209f9:	8b 40 04             	mov    0x4(%eax),%eax
c00209fc:	8d 50 ff             	lea    -0x1(%eax),%edx
c00209ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0020a02:	8b 00                	mov    (%eax),%eax
c0020a04:	83 ec 08             	sub    $0x8,%esp
c0020a07:	52                   	push   %edx
c0020a08:	50                   	push   %eax
c0020a09:	8d 83 94 72 ff ff    	lea    -0x8d6c(%ebx),%eax
c0020a0f:	50                   	push   %eax
c0020a10:	8d 83 e4 74 ff ff    	lea    -0x8b1c(%ebx),%eax
c0020a16:	50                   	push   %eax
c0020a17:	68 5b 01 00 00       	push   $0x15b
c0020a1c:	8d 83 b4 71 ff ff    	lea    -0x8e4c(%ebx),%eax
c0020a22:	50                   	push   %eax
c0020a23:	e8 3c ad 00 00       	call   c002b764 <debug_panic>
      for (i = 1; i < a->argc; i++)
c0020a28:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0020a2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020a2f:	8b 40 04             	mov    0x4(%eax),%eax
c0020a32:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0020a35:	7c aa                	jl     c00209e1 <run_actions+0x97>

      /* Invoke action and advance. */
      a->function (argv);
c0020a37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020a3a:	8b 40 08             	mov    0x8(%eax),%eax
c0020a3d:	83 ec 0c             	sub    $0xc,%esp
c0020a40:	ff 75 08             	push   0x8(%ebp)
c0020a43:	ff d0                	call   *%eax
c0020a45:	83 c4 10             	add    $0x10,%esp
      argv += a->argc;
c0020a48:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020a4b:	8b 40 04             	mov    0x4(%eax),%eax
c0020a4e:	c1 e0 02             	shl    $0x2,%eax
c0020a51:	01 45 08             	add    %eax,0x8(%ebp)
  while (*argv != NULL)
c0020a54:	8b 45 08             	mov    0x8(%ebp),%eax
c0020a57:	8b 00                	mov    (%eax),%eax
c0020a59:	85 c0                	test   %eax,%eax
c0020a5b:	0f 85 1b ff ff ff    	jne    c002097c <run_actions+0x32>
    }
}
c0020a61:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020a64:	c9                   	leave  
c0020a65:	c3                   	ret    

c0020a66 <usage>:

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
c0020a66:	55                   	push   %ebp
c0020a67:	89 e5                	mov    %esp,%ebp
c0020a69:	53                   	push   %ebx
c0020a6a:	83 ec 04             	sub    $0x4,%esp
c0020a6d:	e8 ba 09 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0020a72:	81 c3 06 99 01 00    	add    $0x19906,%ebx
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020a78:	83 ec 0c             	sub    $0xc,%esp
c0020a7b:	8d 83 b8 72 ff ff    	lea    -0x8d48(%ebx),%eax
c0020a81:	50                   	push   %eax
c0020a82:	e8 65 d5 00 00       	call   c002dfec <puts>
c0020a87:	83 c4 10             	add    $0x10,%esp
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c0020a8a:	e8 3e 7e 00 00       	call   c00288cd <shutdown_power_off>

c0020a8f <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c0020a8f:	55                   	push   %ebp
c0020a90:	89 e5                	mov    %esp,%ebp
c0020a92:	e8 91 09 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020a97:	05 e1 98 01 00       	add    $0x198e1,%eax
  return (void *) ((uintptr_t) va & ~PGMASK);
c0020a9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0020a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c0020aa4:	5d                   	pop    %ebp
c0020aa5:	c3                   	ret    

c0020aa6 <tofxpt>:
int mulfx(int a, int b);
int divin(int a, int b);
int divfx(int a, int b);

int tofxpt(int a)
{
c0020aa6:	55                   	push   %ebp
c0020aa7:	89 e5                	mov    %esp,%ebp
c0020aa9:	e8 7a 09 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020aae:	05 ca 98 01 00       	add    $0x198ca,%eax
	return a * F;
c0020ab3:	8b 45 08             	mov    0x8(%ebp),%eax
c0020ab6:	c1 e0 0e             	shl    $0xe,%eax
}
c0020ab9:	5d                   	pop    %ebp
c0020aba:	c3                   	ret    

c0020abb <tointfloor>:

int tointfloor(int a)
{
c0020abb:	55                   	push   %ebp
c0020abc:	89 e5                	mov    %esp,%ebp
c0020abe:	e8 65 09 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020ac3:	05 b5 98 01 00       	add    $0x198b5,%eax
	return a / F;
c0020ac8:	8b 45 08             	mov    0x8(%ebp),%eax
c0020acb:	8d 90 ff 3f 00 00    	lea    0x3fff(%eax),%edx
c0020ad1:	85 c0                	test   %eax,%eax
c0020ad3:	0f 48 c2             	cmovs  %edx,%eax
c0020ad6:	c1 f8 0e             	sar    $0xe,%eax
}
c0020ad9:	5d                   	pop    %ebp
c0020ada:	c3                   	ret    

c0020adb <tointround>:

int tointround(int a)
{
c0020adb:	55                   	push   %ebp
c0020adc:	89 e5                	mov    %esp,%ebp
c0020ade:	e8 45 09 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020ae3:	05 95 98 01 00       	add    $0x19895,%eax
	if (a>=0)
c0020ae8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020aec:	78 18                	js     c0020b06 <tointround+0x2b>
		return (a + F/2) / F;
c0020aee:	8b 45 08             	mov    0x8(%ebp),%eax
c0020af1:	05 00 20 00 00       	add    $0x2000,%eax
c0020af6:	8d 90 ff 3f 00 00    	lea    0x3fff(%eax),%edx
c0020afc:	85 c0                	test   %eax,%eax
c0020afe:	0f 48 c2             	cmovs  %edx,%eax
c0020b01:	c1 f8 0e             	sar    $0xe,%eax
c0020b04:	eb 16                	jmp    c0020b1c <tointround+0x41>
	else
		return (a - F/2) / F;
c0020b06:	8b 45 08             	mov    0x8(%ebp),%eax
c0020b09:	2d 00 20 00 00       	sub    $0x2000,%eax
c0020b0e:	8d 90 ff 3f 00 00    	lea    0x3fff(%eax),%edx
c0020b14:	85 c0                	test   %eax,%eax
c0020b16:	0f 48 c2             	cmovs  %edx,%eax
c0020b19:	c1 f8 0e             	sar    $0xe,%eax
}
c0020b1c:	5d                   	pop    %ebp
c0020b1d:	c3                   	ret    

c0020b1e <addin>:

int addin(int a, int b)
{
c0020b1e:	55                   	push   %ebp
c0020b1f:	89 e5                	mov    %esp,%ebp
c0020b21:	e8 02 09 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020b26:	05 52 98 01 00       	add    $0x19852,%eax
	return a + (b * F);
c0020b2b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0020b2e:	c1 e0 0e             	shl    $0xe,%eax
c0020b31:	89 c2                	mov    %eax,%edx
c0020b33:	8b 45 08             	mov    0x8(%ebp),%eax
c0020b36:	01 d0                	add    %edx,%eax
}
c0020b38:	5d                   	pop    %ebp
c0020b39:	c3                   	ret    

c0020b3a <addfx>:

int addfx(int a, int b)
{
c0020b3a:	55                   	push   %ebp
c0020b3b:	89 e5                	mov    %esp,%ebp
c0020b3d:	e8 e6 08 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020b42:	05 36 98 01 00       	add    $0x19836,%eax
	return a + b;
c0020b47:	8b 55 08             	mov    0x8(%ebp),%edx
c0020b4a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0020b4d:	01 d0                	add    %edx,%eax
}
c0020b4f:	5d                   	pop    %ebp
c0020b50:	c3                   	ret    

c0020b51 <subin>:

int subin(int a, int b)
{
c0020b51:	55                   	push   %ebp
c0020b52:	89 e5                	mov    %esp,%ebp
c0020b54:	e8 cf 08 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020b59:	05 1f 98 01 00       	add    $0x1981f,%eax
	return a - (b * F);
c0020b5e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0020b61:	c1 e0 0e             	shl    $0xe,%eax
c0020b64:	89 c2                	mov    %eax,%edx
c0020b66:	8b 45 08             	mov    0x8(%ebp),%eax
c0020b69:	29 d0                	sub    %edx,%eax
}
c0020b6b:	5d                   	pop    %ebp
c0020b6c:	c3                   	ret    

c0020b6d <subfx>:

int subfx(int a, int b)
{
c0020b6d:	55                   	push   %ebp
c0020b6e:	89 e5                	mov    %esp,%ebp
c0020b70:	e8 b3 08 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020b75:	05 03 98 01 00       	add    $0x19803,%eax
	return a - b;
c0020b7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0020b7d:	2b 45 0c             	sub    0xc(%ebp),%eax
}
c0020b80:	5d                   	pop    %ebp
c0020b81:	c3                   	ret    

c0020b82 <mulin>:

int mulin(int a, int b)
{
c0020b82:	55                   	push   %ebp
c0020b83:	89 e5                	mov    %esp,%ebp
c0020b85:	e8 9e 08 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020b8a:	05 ee 97 01 00       	add    $0x197ee,%eax
	return a * b;
c0020b8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020b92:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
c0020b96:	5d                   	pop    %ebp
c0020b97:	c3                   	ret    

c0020b98 <mulfx>:

int mulfx(int a, int b)
{
c0020b98:	55                   	push   %ebp
c0020b99:	89 e5                	mov    %esp,%ebp
c0020b9b:	57                   	push   %edi
c0020b9c:	56                   	push   %esi
c0020b9d:	53                   	push   %ebx
c0020b9e:	83 ec 0c             	sub    $0xc,%esp
c0020ba1:	e8 82 08 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020ba6:	05 d2 97 01 00       	add    $0x197d2,%eax
	return ((int64_t) a) * b / F;
c0020bab:	8b 45 08             	mov    0x8(%ebp),%eax
c0020bae:	89 c1                	mov    %eax,%ecx
c0020bb0:	89 c3                	mov    %eax,%ebx
c0020bb2:	c1 fb 1f             	sar    $0x1f,%ebx
c0020bb5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0020bb8:	99                   	cltd   
c0020bb9:	89 df                	mov    %ebx,%edi
c0020bbb:	0f af f8             	imul   %eax,%edi
c0020bbe:	89 d6                	mov    %edx,%esi
c0020bc0:	0f af f1             	imul   %ecx,%esi
c0020bc3:	01 f7                	add    %esi,%edi
c0020bc5:	f7 e1                	mul    %ecx
c0020bc7:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
c0020bca:	89 ca                	mov    %ecx,%edx
c0020bcc:	89 d1                	mov    %edx,%ecx
c0020bce:	c1 f9 1f             	sar    $0x1f,%ecx
c0020bd1:	89 cb                	mov    %ecx,%ebx
c0020bd3:	c1 fb 1f             	sar    $0x1f,%ebx
c0020bd6:	89 ce                	mov    %ecx,%esi
c0020bd8:	81 e6 ff 3f 00 00    	and    $0x3fff,%esi
c0020bde:	89 75 e8             	mov    %esi,-0x18(%ebp)
c0020be1:	83 e3 00             	and    $0x0,%ebx
c0020be4:	89 5d ec             	mov    %ebx,-0x14(%ebp)
c0020be7:	03 45 e8             	add    -0x18(%ebp),%eax
c0020bea:	13 55 ec             	adc    -0x14(%ebp),%edx
c0020bed:	0f ac d0 0e          	shrd   $0xe,%edx,%eax
c0020bf1:	c1 fa 0e             	sar    $0xe,%edx
}
c0020bf4:	83 c4 0c             	add    $0xc,%esp
c0020bf7:	5b                   	pop    %ebx
c0020bf8:	5e                   	pop    %esi
c0020bf9:	5f                   	pop    %edi
c0020bfa:	5d                   	pop    %ebp
c0020bfb:	c3                   	ret    

c0020bfc <divin>:

int divin(int a, int b)
{
c0020bfc:	55                   	push   %ebp
c0020bfd:	89 e5                	mov    %esp,%ebp
c0020bff:	e8 24 08 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0020c04:	05 74 97 01 00       	add    $0x19774,%eax
	return a / b;
c0020c09:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c0c:	99                   	cltd   
c0020c0d:	f7 7d 0c             	idivl  0xc(%ebp)
}
c0020c10:	5d                   	pop    %ebp
c0020c11:	c3                   	ret    

c0020c12 <divfx>:

int divfx(int a, int b)
{
c0020c12:	55                   	push   %ebp
c0020c13:	89 e5                	mov    %esp,%ebp
c0020c15:	56                   	push   %esi
c0020c16:	53                   	push   %ebx
c0020c17:	e8 14 08 01 00       	call   c0031430 <__x86.get_pc_thunk.si>
c0020c1c:	81 c6 5c 97 01 00    	add    $0x1975c,%esi
	return ((int64_t) a) * F / b;
c0020c22:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c25:	99                   	cltd   
c0020c26:	0f a4 c2 0e          	shld   $0xe,%eax,%edx
c0020c2a:	c1 e0 0e             	shl    $0xe,%eax
c0020c2d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0020c30:	89 cb                	mov    %ecx,%ebx
c0020c32:	c1 fb 1f             	sar    $0x1f,%ebx
c0020c35:	53                   	push   %ebx
c0020c36:	51                   	push   %ecx
c0020c37:	52                   	push   %edx
c0020c38:	50                   	push   %eax
c0020c39:	89 f3                	mov    %esi,%ebx
c0020c3b:	e8 5e a4 00 00       	call   c002b09e <__divdi3>
c0020c40:	83 c4 10             	add    $0x10,%esp
c0020c43:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0020c46:	5b                   	pop    %ebx
c0020c47:	5e                   	pop    %esi
c0020c48:	5d                   	pop    %ebp
c0020c49:	c3                   	ret    

c0020c4a <thread_init>:

   It is not safe to call thread_current() until this function
   finishes. */
void
thread_init (void) 
{
c0020c4a:	55                   	push   %ebp
c0020c4b:	89 e5                	mov    %esp,%ebp
c0020c4d:	53                   	push   %ebx
c0020c4e:	83 ec 04             	sub    $0x4,%esp
c0020c51:	e8 d6 07 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0020c56:	81 c3 22 97 01 00    	add    $0x19722,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0020c5c:	e8 ec 11 00 00       	call   c0021e4d <intr_get_level>
c0020c61:	85 c0                	test   %eax,%eax
c0020c63:	74 26                	je     c0020c8b <thread_init+0x41>
c0020c65:	83 ec 0c             	sub    $0xc,%esp
c0020c68:	8d 83 f0 74 ff ff    	lea    -0x8b10(%ebx),%eax
c0020c6e:	50                   	push   %eax
c0020c6f:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0020c75:	50                   	push   %eax
c0020c76:	8d 83 b0 76 ff ff    	lea    -0x8950(%ebx),%eax
c0020c7c:	50                   	push   %eax
c0020c7d:	6a 5e                	push   $0x5e
c0020c7f:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0020c85:	50                   	push   %eax
c0020c86:	e8 d9 aa 00 00       	call   c002b764 <debug_panic>

  lock_init (&tid_lock);
c0020c8b:	83 ec 0c             	sub    $0xc,%esp
c0020c8e:	8d 83 80 08 00 00    	lea    0x880(%ebx),%eax
c0020c94:	50                   	push   %eax
c0020c95:	e8 38 2b 00 00       	call   c00237d2 <lock_init>
c0020c9a:	83 c4 10             	add    $0x10,%esp
  list_init (&ready_list);
c0020c9d:	83 ec 0c             	sub    $0xc,%esp
c0020ca0:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c0020ca6:	50                   	push   %eax
c0020ca7:	e8 98 ad 00 00       	call   c002ba44 <list_init>
c0020cac:	83 c4 10             	add    $0x10,%esp
  list_init (&all_list);
c0020caf:	83 ec 0c             	sub    $0xc,%esp
c0020cb2:	8d 83 68 08 00 00    	lea    0x868(%ebx),%eax
c0020cb8:	50                   	push   %eax
c0020cb9:	e8 86 ad 00 00       	call   c002ba44 <list_init>
c0020cbe:	83 c4 10             	add    $0x10,%esp

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
c0020cc1:	e8 83 0b 00 00       	call   c0021849 <running_thread>
c0020cc6:	89 83 7c 08 00 00    	mov    %eax,0x87c(%ebx)
  init_thread (initial_thread, "main", PRI_DEFAULT);
c0020ccc:	8b 83 7c 08 00 00    	mov    0x87c(%ebx),%eax
c0020cd2:	83 ec 04             	sub    $0x4,%esp
c0020cd5:	6a 1f                	push   $0x1f
c0020cd7:	8d 93 3c 75 ff ff    	lea    -0x8ac4(%ebx),%edx
c0020cdd:	52                   	push   %edx
c0020cde:	50                   	push   %eax
c0020cdf:	e8 b8 0b 00 00       	call   c002189c <init_thread>
c0020ce4:	83 c4 10             	add    $0x10,%esp
  initial_thread->status = THREAD_RUNNING;
c0020ce7:	8b 83 7c 08 00 00    	mov    0x87c(%ebx),%eax
c0020ced:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  initial_thread->tid = allocate_tid ();
c0020cf4:	8b 9b 7c 08 00 00    	mov    0x87c(%ebx),%ebx
c0020cfa:	e8 17 10 00 00       	call   c0021d16 <allocate_tid>
c0020cff:	89 03                	mov    %eax,(%ebx)
}
c0020d01:	90                   	nop
c0020d02:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020d05:	c9                   	leave  
c0020d06:	c3                   	ret    

c0020d07 <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) 
{
c0020d07:	55                   	push   %ebp
c0020d08:	89 e5                	mov    %esp,%ebp
c0020d0a:	53                   	push   %ebx
c0020d0b:	83 ec 24             	sub    $0x24,%esp
c0020d0e:	e8 19 07 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0020d13:	81 c3 65 96 01 00    	add    $0x19665,%ebx
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init (&idle_started, 0);
c0020d19:	83 ec 08             	sub    $0x8,%esp
c0020d1c:	6a 00                	push   $0x0
c0020d1e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020d21:	50                   	push   %eax
c0020d22:	e8 47 27 00 00       	call   c002346e <sema_init>
c0020d27:	83 c4 10             	add    $0x10,%esp
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c0020d2a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020d2d:	50                   	push   %eax
c0020d2e:	8d 83 36 74 fe ff    	lea    -0x18bca(%ebx),%eax
c0020d34:	50                   	push   %eax
c0020d35:	6a 00                	push   $0x0
c0020d37:	8d 83 41 75 ff ff    	lea    -0x8abf(%ebx),%eax
c0020d3d:	50                   	push   %eax
c0020d3e:	e8 61 03 00 00       	call   c00210a4 <thread_create>
c0020d43:	83 c4 10             	add    $0x10,%esp

  /* Start preemptive thread scheduling. */
  intr_enable ();
c0020d46:	e8 46 11 00 00       	call   c0021e91 <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down (&idle_started);
c0020d4b:	83 ec 0c             	sub    $0xc,%esp
c0020d4e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020d51:	50                   	push   %eax
c0020d52:	e8 78 27 00 00       	call   c00234cf <sema_down>
c0020d57:	83 c4 10             	add    $0x10,%esp
}
c0020d5a:	90                   	nop
c0020d5b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020d5e:	c9                   	leave  
c0020d5f:	c3                   	ret    

c0020d60 <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) 
{
c0020d60:	55                   	push   %ebp
c0020d61:	89 e5                	mov    %esp,%ebp
c0020d63:	56                   	push   %esi
c0020d64:	53                   	push   %ebx
c0020d65:	83 ec 20             	sub    $0x20,%esp
c0020d68:	e8 bf 06 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0020d6d:	81 c3 0b 96 01 00    	add    $0x1960b,%ebx
  struct thread *t = thread_current ();
c0020d73:	e8 09 06 00 00       	call   c0021381 <thread_current>
c0020d78:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Update statistics. */
  if (t == idle_thread)
c0020d7b:	8b 83 78 08 00 00    	mov    0x878(%ebx),%eax
c0020d81:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0020d84:	75 20                	jne    c0020da6 <thread_tick+0x46>
    idle_ticks++;
c0020d86:	8b 83 98 08 00 00    	mov    0x898(%ebx),%eax
c0020d8c:	8b 93 9c 08 00 00    	mov    0x89c(%ebx),%edx
c0020d92:	83 c0 01             	add    $0x1,%eax
c0020d95:	83 d2 00             	adc    $0x0,%edx
c0020d98:	89 83 98 08 00 00    	mov    %eax,0x898(%ebx)
c0020d9e:	89 93 9c 08 00 00    	mov    %edx,0x89c(%ebx)
c0020da4:	eb 1e                	jmp    c0020dc4 <thread_tick+0x64>
#ifdef USERPROG
  else if (t->pagedir != NULL)
    user_ticks++;
#endif
  else
    kernel_ticks++;
c0020da6:	8b 83 a0 08 00 00    	mov    0x8a0(%ebx),%eax
c0020dac:	8b 93 a4 08 00 00    	mov    0x8a4(%ebx),%edx
c0020db2:	83 c0 01             	add    $0x1,%eax
c0020db5:	83 d2 00             	adc    $0x0,%edx
c0020db8:	89 83 a0 08 00 00    	mov    %eax,0x8a0(%ebx)
c0020dbe:	89 93 a4 08 00 00    	mov    %edx,0x8a4(%ebx)

  if(thread_mlfqs)
c0020dc4:	0f b6 83 50 08 00 00 	movzbl 0x850(%ebx),%eax
c0020dcb:	84 c0                	test   %al,%al
c0020dcd:	0f 84 46 02 00 00    	je     c0021019 <thread_tick+0x2b9>
  {
    if(strcmp(t->name,"idle")!=0)
c0020dd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020dd6:	8d 50 08             	lea    0x8(%eax),%edx
c0020dd9:	83 ec 08             	sub    $0x8,%esp
c0020ddc:	8d 83 41 75 ff ff    	lea    -0x8abf(%ebx),%eax
c0020de2:	50                   	push   %eax
c0020de3:	52                   	push   %edx
c0020de4:	e8 5d 97 00 00       	call   c002a546 <strcmp>
c0020de9:	83 c4 10             	add    $0x10,%esp
c0020dec:	85 c0                	test   %eax,%eax
c0020dee:	74 1a                	je     c0020e0a <thread_tick+0xaa>
    {
      t->recent_cpu = addin(t->recent_cpu, 1);
c0020df0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020df3:	8b 40 60             	mov    0x60(%eax),%eax
c0020df6:	83 ec 08             	sub    $0x8,%esp
c0020df9:	6a 01                	push   $0x1
c0020dfb:	50                   	push   %eax
c0020dfc:	e8 1d fd ff ff       	call   c0020b1e <addin>
c0020e01:	83 c4 10             	add    $0x10,%esp
c0020e04:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0020e07:	89 42 60             	mov    %eax,0x60(%edx)
    }

    if(timer_ticks() % 100 == 0)
c0020e0a:	e8 80 42 00 00       	call   c002508f <timer_ticks>
c0020e0f:	89 c1                	mov    %eax,%ecx
c0020e11:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0020e16:	89 c8                	mov    %ecx,%eax
c0020e18:	f7 ea                	imul   %edx
c0020e1a:	89 d0                	mov    %edx,%eax
c0020e1c:	c1 f8 05             	sar    $0x5,%eax
c0020e1f:	89 ca                	mov    %ecx,%edx
c0020e21:	c1 fa 1f             	sar    $0x1f,%edx
c0020e24:	29 d0                	sub    %edx,%eax
c0020e26:	6b d0 64             	imul   $0x64,%eax,%edx
c0020e29:	89 c8                	mov    %ecx,%eax
c0020e2b:	29 d0                	sub    %edx,%eax
c0020e2d:	85 c0                	test   %eax,%eax
c0020e2f:	0f 85 52 01 00 00    	jne    c0020f87 <thread_tick+0x227>
    {
      struct list_elem *e;
      int temp, i=0;
c0020e35:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

      load_avg = addfx(divin(mulin(load_avg, 59), 60), divin(tofxpt(list_size(&ready_list) + (strcmp(running_thread()->name,"idle")==0?0:1)), 60));
c0020e3c:	83 ec 0c             	sub    $0xc,%esp
c0020e3f:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c0020e45:	50                   	push   %eax
c0020e46:	e8 bd b2 00 00       	call   c002c108 <list_size>
c0020e4b:	83 c4 10             	add    $0x10,%esp
c0020e4e:	89 c6                	mov    %eax,%esi
c0020e50:	e8 f4 09 00 00       	call   c0021849 <running_thread>
c0020e55:	8d 50 08             	lea    0x8(%eax),%edx
c0020e58:	83 ec 08             	sub    $0x8,%esp
c0020e5b:	8d 83 41 75 ff ff    	lea    -0x8abf(%ebx),%eax
c0020e61:	50                   	push   %eax
c0020e62:	52                   	push   %edx
c0020e63:	e8 de 96 00 00       	call   c002a546 <strcmp>
c0020e68:	83 c4 10             	add    $0x10,%esp
c0020e6b:	85 c0                	test   %eax,%eax
c0020e6d:	0f 95 c0             	setne  %al
c0020e70:	0f b6 c0             	movzbl %al,%eax
c0020e73:	01 f0                	add    %esi,%eax
c0020e75:	83 ec 0c             	sub    $0xc,%esp
c0020e78:	50                   	push   %eax
c0020e79:	e8 28 fc ff ff       	call   c0020aa6 <tofxpt>
c0020e7e:	83 c4 10             	add    $0x10,%esp
c0020e81:	83 ec 08             	sub    $0x8,%esp
c0020e84:	6a 3c                	push   $0x3c
c0020e86:	50                   	push   %eax
c0020e87:	e8 70 fd ff ff       	call   c0020bfc <divin>
c0020e8c:	83 c4 10             	add    $0x10,%esp
c0020e8f:	89 c6                	mov    %eax,%esi
c0020e91:	8b 83 54 08 00 00    	mov    0x854(%ebx),%eax
c0020e97:	83 ec 08             	sub    $0x8,%esp
c0020e9a:	6a 3b                	push   $0x3b
c0020e9c:	50                   	push   %eax
c0020e9d:	e8 e0 fc ff ff       	call   c0020b82 <mulin>
c0020ea2:	83 c4 10             	add    $0x10,%esp
c0020ea5:	83 ec 08             	sub    $0x8,%esp
c0020ea8:	6a 3c                	push   $0x3c
c0020eaa:	50                   	push   %eax
c0020eab:	e8 4c fd ff ff       	call   c0020bfc <divin>
c0020eb0:	83 c4 10             	add    $0x10,%esp
c0020eb3:	83 ec 08             	sub    $0x8,%esp
c0020eb6:	56                   	push   %esi
c0020eb7:	50                   	push   %eax
c0020eb8:	e8 7d fc ff ff       	call   c0020b3a <addfx>
c0020ebd:	83 c4 10             	add    $0x10,%esp
c0020ec0:	89 83 54 08 00 00    	mov    %eax,0x854(%ebx)

      temp = divfx(mulin(load_avg, 2),addin(mulin(load_avg, 2), 1));
c0020ec6:	8b 83 54 08 00 00    	mov    0x854(%ebx),%eax
c0020ecc:	83 ec 08             	sub    $0x8,%esp
c0020ecf:	6a 02                	push   $0x2
c0020ed1:	50                   	push   %eax
c0020ed2:	e8 ab fc ff ff       	call   c0020b82 <mulin>
c0020ed7:	83 c4 10             	add    $0x10,%esp
c0020eda:	83 ec 08             	sub    $0x8,%esp
c0020edd:	6a 01                	push   $0x1
c0020edf:	50                   	push   %eax
c0020ee0:	e8 39 fc ff ff       	call   c0020b1e <addin>
c0020ee5:	83 c4 10             	add    $0x10,%esp
c0020ee8:	89 c6                	mov    %eax,%esi
c0020eea:	8b 83 54 08 00 00    	mov    0x854(%ebx),%eax
c0020ef0:	83 ec 08             	sub    $0x8,%esp
c0020ef3:	6a 02                	push   $0x2
c0020ef5:	50                   	push   %eax
c0020ef6:	e8 87 fc ff ff       	call   c0020b82 <mulin>
c0020efb:	83 c4 10             	add    $0x10,%esp
c0020efe:	83 ec 08             	sub    $0x8,%esp
c0020f01:	56                   	push   %esi
c0020f02:	50                   	push   %eax
c0020f03:	e8 0a fd ff ff       	call   c0020c12 <divfx>
c0020f08:	83 c4 10             	add    $0x10,%esp
c0020f0b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      for (e = list_begin (&all_list); e != list_end (&all_list);
c0020f0e:	83 ec 0c             	sub    $0xc,%esp
c0020f11:	8d 83 68 08 00 00    	lea    0x868(%ebx),%eax
c0020f17:	50                   	push   %eax
c0020f18:	e8 94 ab 00 00       	call   c002bab1 <list_begin>
c0020f1d:	83 c4 10             	add    $0x10,%esp
c0020f20:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020f23:	eb 4b                	jmp    c0020f70 <thread_tick+0x210>
         e = list_next (e))
      {
        struct thread *f = list_entry (e, struct thread, allelem);
c0020f25:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020f28:	83 c0 04             	add    $0x4,%eax
c0020f2b:	83 e8 24             	sub    $0x24,%eax
c0020f2e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        f->recent_cpu = addin(mulfx(temp, f->recent_cpu),f->nice);
c0020f31:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020f34:	8b 70 5c             	mov    0x5c(%eax),%esi
c0020f37:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020f3a:	8b 40 60             	mov    0x60(%eax),%eax
c0020f3d:	83 ec 08             	sub    $0x8,%esp
c0020f40:	50                   	push   %eax
c0020f41:	ff 75 e4             	push   -0x1c(%ebp)
c0020f44:	e8 4f fc ff ff       	call   c0020b98 <mulfx>
c0020f49:	83 c4 10             	add    $0x10,%esp
c0020f4c:	83 ec 08             	sub    $0x8,%esp
c0020f4f:	56                   	push   %esi
c0020f50:	50                   	push   %eax
c0020f51:	e8 c8 fb ff ff       	call   c0020b1e <addin>
c0020f56:	83 c4 10             	add    $0x10,%esp
c0020f59:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0020f5c:	89 42 60             	mov    %eax,0x60(%edx)
         e = list_next (e))
c0020f5f:	83 ec 0c             	sub    $0xc,%esp
c0020f62:	ff 75 f4             	push   -0xc(%ebp)
c0020f65:	e8 91 ab 00 00       	call   c002bafb <list_next>
c0020f6a:	83 c4 10             	add    $0x10,%esp
c0020f6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_begin (&all_list); e != list_end (&all_list);
c0020f70:	83 ec 0c             	sub    $0xc,%esp
c0020f73:	8d 83 68 08 00 00    	lea    0x868(%ebx),%eax
c0020f79:	50                   	push   %eax
c0020f7a:	e8 dd ab 00 00       	call   c002bb5c <list_end>
c0020f7f:	83 c4 10             	add    $0x10,%esp
c0020f82:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020f85:	75 9e                	jne    c0020f25 <thread_tick+0x1c5>
      }
    }

    if(timer_ticks() % 4 == 0)
c0020f87:	e8 03 41 00 00       	call   c002508f <timer_ticks>
c0020f8c:	83 e0 03             	and    $0x3,%eax
c0020f8f:	85 c0                	test   %eax,%eax
c0020f91:	0f 85 82 00 00 00    	jne    c0021019 <thread_tick+0x2b9>
    {
      struct list_elem *e;
      for (e = list_begin (&all_list); e != list_end (&all_list);
c0020f97:	83 ec 0c             	sub    $0xc,%esp
c0020f9a:	8d 83 68 08 00 00    	lea    0x868(%ebx),%eax
c0020fa0:	50                   	push   %eax
c0020fa1:	e8 0b ab 00 00       	call   c002bab1 <list_begin>
c0020fa6:	83 c4 10             	add    $0x10,%esp
c0020fa9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0020fac:	eb 54                	jmp    c0021002 <thread_tick+0x2a2>
         e = list_next (e))
      {
        struct thread *f = list_entry (e, struct thread, allelem);
c0020fae:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020fb1:	83 c0 04             	add    $0x4,%eax
c0020fb4:	83 e8 24             	sub    $0x24,%eax
c0020fb7:	89 45 dc             	mov    %eax,-0x24(%ebp)
        f->priority = PRI_MAX - tointround(divin(f->recent_cpu,4)) - (f->nice * 2);
c0020fba:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0020fbd:	8b 40 60             	mov    0x60(%eax),%eax
c0020fc0:	83 ec 08             	sub    $0x8,%esp
c0020fc3:	6a 04                	push   $0x4
c0020fc5:	50                   	push   %eax
c0020fc6:	e8 31 fc ff ff       	call   c0020bfc <divin>
c0020fcb:	83 c4 10             	add    $0x10,%esp
c0020fce:	83 ec 0c             	sub    $0xc,%esp
c0020fd1:	50                   	push   %eax
c0020fd2:	e8 04 fb ff ff       	call   c0020adb <tointround>
c0020fd7:	83 c4 10             	add    $0x10,%esp
c0020fda:	ba 3f 00 00 00       	mov    $0x3f,%edx
c0020fdf:	29 c2                	sub    %eax,%edx
c0020fe1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0020fe4:	8b 40 5c             	mov    0x5c(%eax),%eax
c0020fe7:	01 c0                	add    %eax,%eax
c0020fe9:	29 c2                	sub    %eax,%edx
c0020feb:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0020fee:	89 50 1c             	mov    %edx,0x1c(%eax)
         e = list_next (e))
c0020ff1:	83 ec 0c             	sub    $0xc,%esp
c0020ff4:	ff 75 f0             	push   -0x10(%ebp)
c0020ff7:	e8 ff aa 00 00       	call   c002bafb <list_next>
c0020ffc:	83 c4 10             	add    $0x10,%esp
c0020fff:	89 45 f0             	mov    %eax,-0x10(%ebp)
      for (e = list_begin (&all_list); e != list_end (&all_list);
c0021002:	83 ec 0c             	sub    $0xc,%esp
c0021005:	8d 83 68 08 00 00    	lea    0x868(%ebx),%eax
c002100b:	50                   	push   %eax
c002100c:	e8 4b ab 00 00       	call   c002bb5c <list_end>
c0021011:	83 c4 10             	add    $0x10,%esp
c0021014:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0021017:	75 95                	jne    c0020fae <thread_tick+0x24e>
      }
    }
  }

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c0021019:	8b 83 b0 08 00 00    	mov    0x8b0(%ebx),%eax
c002101f:	83 c0 01             	add    $0x1,%eax
c0021022:	89 83 b0 08 00 00    	mov    %eax,0x8b0(%ebx)
c0021028:	8b 83 b0 08 00 00    	mov    0x8b0(%ebx),%eax
c002102e:	83 f8 03             	cmp    $0x3,%eax
c0021031:	76 05                	jbe    c0021038 <thread_tick+0x2d8>
    intr_yield_on_return ();
c0021033:	e8 22 12 00 00       	call   c002225a <intr_yield_on_return>
}
c0021038:	90                   	nop
c0021039:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002103c:	5b                   	pop    %ebx
c002103d:	5e                   	pop    %esi
c002103e:	5d                   	pop    %ebp
c002103f:	c3                   	ret    

c0021040 <thread_print_stats>:

/* Prints thread statistics. */
void
thread_print_stats (void) 
{
c0021040:	55                   	push   %ebp
c0021041:	89 e5                	mov    %esp,%ebp
c0021043:	57                   	push   %edi
c0021044:	56                   	push   %esi
c0021045:	53                   	push   %ebx
c0021046:	83 ec 1c             	sub    $0x1c,%esp
c0021049:	e8 da 03 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002104e:	05 2a 93 01 00       	add    $0x1932a,%eax
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0021053:	8b 98 a8 08 00 00    	mov    0x8a8(%eax),%ebx
c0021059:	8b b0 ac 08 00 00    	mov    0x8ac(%eax),%esi
c002105f:	89 5d e0             	mov    %ebx,-0x20(%ebp)
c0021062:	89 75 e4             	mov    %esi,-0x1c(%ebp)
c0021065:	8b b0 a0 08 00 00    	mov    0x8a0(%eax),%esi
c002106b:	8b b8 a4 08 00 00    	mov    0x8a4(%eax),%edi
c0021071:	8b 88 98 08 00 00    	mov    0x898(%eax),%ecx
c0021077:	8b 98 9c 08 00 00    	mov    0x89c(%eax),%ebx
c002107d:	83 ec 04             	sub    $0x4,%esp
c0021080:	ff 75 e4             	push   -0x1c(%ebp)
c0021083:	ff 75 e0             	push   -0x20(%ebp)
c0021086:	57                   	push   %edi
c0021087:	56                   	push   %esi
c0021088:	53                   	push   %ebx
c0021089:	51                   	push   %ecx
c002108a:	8d 90 48 75 ff ff    	lea    -0x8ab8(%eax),%edx
c0021090:	52                   	push   %edx
c0021091:	89 c3                	mov    %eax,%ebx
c0021093:	e8 4d 7e 00 00       	call   c0028ee5 <printf>
c0021098:	83 c4 20             	add    $0x20,%esp
          idle_ticks, kernel_ticks, user_ticks);
}
c002109b:	90                   	nop
c002109c:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002109f:	5b                   	pop    %ebx
c00210a0:	5e                   	pop    %esi
c00210a1:	5f                   	pop    %edi
c00210a2:	5d                   	pop    %ebp
c00210a3:	c3                   	ret    

c00210a4 <thread_create>:
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux) 
{
c00210a4:	55                   	push   %ebp
c00210a5:	89 e5                	mov    %esp,%ebp
c00210a7:	56                   	push   %esi
c00210a8:	53                   	push   %ebx
c00210a9:	83 ec 20             	sub    $0x20,%esp
c00210ac:	e8 7b 03 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00210b1:	81 c3 c7 92 01 00    	add    $0x192c7,%ebx
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;
  enum intr_level old_level;

  ASSERT (function != NULL);
c00210b7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00210bb:	75 29                	jne    c00210e6 <thread_create+0x42>
c00210bd:	83 ec 0c             	sub    $0xc,%esp
c00210c0:	8d 83 85 75 ff ff    	lea    -0x8a7b(%ebx),%eax
c00210c6:	50                   	push   %eax
c00210c7:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c00210cd:	50                   	push   %eax
c00210ce:	8d 83 bc 76 ff ff    	lea    -0x8944(%ebx),%eax
c00210d4:	50                   	push   %eax
c00210d5:	68 d8 00 00 00       	push   $0xd8
c00210da:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c00210e0:	50                   	push   %eax
c00210e1:	e8 7e a6 00 00       	call   c002b764 <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
c00210e6:	83 ec 0c             	sub    $0xc,%esp
c00210e9:	6a 02                	push   $0x2
c00210eb:	e8 4c 32 00 00       	call   c002433c <palloc_get_page>
c00210f0:	83 c4 10             	add    $0x10,%esp
c00210f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (t == NULL)
c00210f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00210fa:	75 0a                	jne    c0021106 <thread_create+0x62>
    return TID_ERROR;
c00210fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0021101:	e9 ef 00 00 00       	jmp    c00211f5 <thread_create+0x151>

  /* Initialize thread. */
  init_thread (t, name, priority);
c0021106:	83 ec 04             	sub    $0x4,%esp
c0021109:	ff 75 0c             	push   0xc(%ebp)
c002110c:	ff 75 08             	push   0x8(%ebp)
c002110f:	ff 75 f4             	push   -0xc(%ebp)
c0021112:	e8 85 07 00 00       	call   c002189c <init_thread>
c0021117:	83 c4 10             	add    $0x10,%esp
  tid = t->tid = allocate_tid ();
c002111a:	e8 f7 0b 00 00       	call   c0021d16 <allocate_tid>
c002111f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0021122:	89 02                	mov    %eax,(%edx)
c0021124:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021127:	8b 00                	mov    (%eax),%eax
c0021129:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Prepare thread for first run by initializing its stack.
     Do this atomically so intermediate values for the 'stack' 
     member cannot be observed. */
  old_level = intr_disable ();
c002112c:	e8 b5 0d 00 00       	call   c0021ee6 <intr_disable>
c0021131:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
c0021134:	83 ec 08             	sub    $0x8,%esp
c0021137:	6a 0c                	push   $0xc
c0021139:	ff 75 f4             	push   -0xc(%ebp)
c002113c:	e8 33 09 00 00       	call   c0021a74 <alloc_frame>
c0021141:	83 c4 10             	add    $0x10,%esp
c0021144:	89 45 e8             	mov    %eax,-0x18(%ebp)
  kf->eip = NULL;
c0021147:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002114a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0021150:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0021153:	8b 55 10             	mov    0x10(%ebp),%edx
c0021156:	89 50 04             	mov    %edx,0x4(%eax)
  kf->aux = aux;
c0021159:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002115c:	8b 55 14             	mov    0x14(%ebp),%edx
c002115f:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
c0021162:	83 ec 08             	sub    $0x8,%esp
c0021165:	6a 04                	push   $0x4
c0021167:	ff 75 f4             	push   -0xc(%ebp)
c002116a:	e8 05 09 00 00       	call   c0021a74 <alloc_frame>
c002116f:	83 c4 10             	add    $0x10,%esp
c0021172:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ef->eip = (void (*) (void)) kernel_thread;
c0021175:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0021178:	8d 93 75 74 fe ff    	lea    -0x18b8b(%ebx),%edx
c002117e:	89 10                	mov    %edx,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
c0021180:	83 ec 08             	sub    $0x8,%esp
c0021183:	6a 1c                	push   $0x1c
c0021185:	ff 75 f4             	push   -0xc(%ebp)
c0021188:	e8 e7 08 00 00       	call   c0021a74 <alloc_frame>
c002118d:	83 c4 10             	add    $0x10,%esp
c0021190:	89 45 e0             	mov    %eax,-0x20(%ebp)
  sf->eip = switch_entry;
c0021193:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0021196:	c7 c2 15 1e 02 c0    	mov    $0xc0021e15,%edx
c002119c:	89 50 10             	mov    %edx,0x10(%eax)
  sf->ebp = 0;
c002119f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00211a2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  intr_set_level (old_level);
c00211a9:	83 ec 0c             	sub    $0xc,%esp
c00211ac:	ff 75 ec             	push   -0x14(%ebp)
c00211af:	e8 b9 0c 00 00       	call   c0021e6d <intr_set_level>
c00211b4:	83 c4 10             	add    $0x10,%esp

  /* Add to run queue. */
  thread_unblock (t);
c00211b7:	83 ec 0c             	sub    $0xc,%esp
c00211ba:	ff 75 f4             	push   -0xc(%ebp)
c00211bd:	e8 ca 00 00 00       	call   c002128c <thread_unblock>
c00211c2:	83 c4 10             	add    $0x10,%esp

  old_level = intr_disable ();
c00211c5:	e8 1c 0d 00 00       	call   c0021ee6 <intr_disable>
c00211ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(t->priority > thread_current()->priority)
c00211cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00211d0:	8b 70 1c             	mov    0x1c(%eax),%esi
c00211d3:	e8 a9 01 00 00       	call   c0021381 <thread_current>
c00211d8:	8b 40 1c             	mov    0x1c(%eax),%eax
c00211db:	39 c6                	cmp    %eax,%esi
c00211dd:	7e 05                	jle    c00211e4 <thread_create+0x140>
    thread_yield();
c00211df:	e8 d6 02 00 00       	call   c00214ba <thread_yield>

  intr_set_level (old_level);
c00211e4:	83 ec 0c             	sub    $0xc,%esp
c00211e7:	ff 75 ec             	push   -0x14(%ebp)
c00211ea:	e8 7e 0c 00 00       	call   c0021e6d <intr_set_level>
c00211ef:	83 c4 10             	add    $0x10,%esp

  return tid;
c00211f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00211f5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00211f8:	5b                   	pop    %ebx
c00211f9:	5e                   	pop    %esi
c00211fa:	5d                   	pop    %ebp
c00211fb:	c3                   	ret    

c00211fc <thread_block>:
   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void
thread_block (void) 
{
c00211fc:	55                   	push   %ebp
c00211fd:	89 e5                	mov    %esp,%ebp
c00211ff:	53                   	push   %ebx
c0021200:	83 ec 04             	sub    $0x4,%esp
c0021203:	e8 24 02 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021208:	81 c3 70 91 01 00    	add    $0x19170,%ebx
  ASSERT (!intr_context ());
c002120e:	e8 31 10 00 00       	call   c0022244 <intr_context>
c0021213:	83 f0 01             	xor    $0x1,%eax
c0021216:	84 c0                	test   %al,%al
c0021218:	75 29                	jne    c0021243 <thread_block+0x47>
c002121a:	83 ec 0c             	sub    $0xc,%esp
c002121d:	8d 83 96 75 ff ff    	lea    -0x8a6a(%ebx),%eax
c0021223:	50                   	push   %eax
c0021224:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c002122a:	50                   	push   %eax
c002122b:	8d 83 cc 76 ff ff    	lea    -0x8934(%ebx),%eax
c0021231:	50                   	push   %eax
c0021232:	68 0e 01 00 00       	push   $0x10e
c0021237:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c002123d:	50                   	push   %eax
c002123e:	e8 21 a5 00 00       	call   c002b764 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0021243:	e8 05 0c 00 00       	call   c0021e4d <intr_get_level>
c0021248:	85 c0                	test   %eax,%eax
c002124a:	74 29                	je     c0021275 <thread_block+0x79>
c002124c:	83 ec 0c             	sub    $0xc,%esp
c002124f:	8d 83 f0 74 ff ff    	lea    -0x8b10(%ebx),%eax
c0021255:	50                   	push   %eax
c0021256:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c002125c:	50                   	push   %eax
c002125d:	8d 83 cc 76 ff ff    	lea    -0x8934(%ebx),%eax
c0021263:	50                   	push   %eax
c0021264:	68 0f 01 00 00       	push   $0x10f
c0021269:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c002126f:	50                   	push   %eax
c0021270:	e8 ef a4 00 00       	call   c002b764 <debug_panic>

  thread_current ()->status = THREAD_BLOCKED;
c0021275:	e8 07 01 00 00       	call   c0021381 <thread_current>
c002127a:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0021281:	e8 97 09 00 00       	call   c0021c1d <schedule>
}
c0021286:	90                   	nop
c0021287:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002128a:	c9                   	leave  
c002128b:	c3                   	ret    

c002128c <thread_unblock>:
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void
thread_unblock (struct thread *t) 
{
c002128c:	55                   	push   %ebp
c002128d:	89 e5                	mov    %esp,%ebp
c002128f:	53                   	push   %ebx
c0021290:	83 ec 14             	sub    $0x14,%esp
c0021293:	e8 94 01 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021298:	81 c3 e0 90 01 00    	add    $0x190e0,%ebx
  enum intr_level old_level;

  ASSERT (is_thread (t));
c002129e:	83 ec 0c             	sub    $0xc,%esp
c00212a1:	ff 75 08             	push   0x8(%ebp)
c00212a4:	e8 c2 05 00 00       	call   c002186b <is_thread>
c00212a9:	83 c4 10             	add    $0x10,%esp
c00212ac:	84 c0                	test   %al,%al
c00212ae:	75 29                	jne    c00212d9 <thread_unblock+0x4d>
c00212b0:	83 ec 0c             	sub    $0xc,%esp
c00212b3:	8d 83 a7 75 ff ff    	lea    -0x8a59(%ebx),%eax
c00212b9:	50                   	push   %eax
c00212ba:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c00212c0:	50                   	push   %eax
c00212c1:	8d 83 dc 76 ff ff    	lea    -0x8924(%ebx),%eax
c00212c7:	50                   	push   %eax
c00212c8:	68 22 01 00 00       	push   $0x122
c00212cd:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c00212d3:	50                   	push   %eax
c00212d4:	e8 8b a4 00 00       	call   c002b764 <debug_panic>

  old_level = intr_disable ();
c00212d9:	e8 08 0c 00 00       	call   c0021ee6 <intr_disable>
c00212de:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (t->status == THREAD_BLOCKED);
c00212e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00212e4:	8b 40 04             	mov    0x4(%eax),%eax
c00212e7:	83 f8 02             	cmp    $0x2,%eax
c00212ea:	74 29                	je     c0021315 <thread_unblock+0x89>
c00212ec:	83 ec 0c             	sub    $0xc,%esp
c00212ef:	8d 83 b5 75 ff ff    	lea    -0x8a4b(%ebx),%eax
c00212f5:	50                   	push   %eax
c00212f6:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c00212fc:	50                   	push   %eax
c00212fd:	8d 83 dc 76 ff ff    	lea    -0x8924(%ebx),%eax
c0021303:	50                   	push   %eax
c0021304:	68 25 01 00 00       	push   $0x125
c0021309:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c002130f:	50                   	push   %eax
c0021310:	e8 4f a4 00 00       	call   c002b764 <debug_panic>
  list_push_back (&ready_list, &t->elem);
c0021315:	8b 45 08             	mov    0x8(%ebp),%eax
c0021318:	83 c0 28             	add    $0x28,%eax
c002131b:	83 ec 08             	sub    $0x8,%esp
c002131e:	50                   	push   %eax
c002131f:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c0021325:	50                   	push   %eax
c0021326:	e8 1f ac 00 00       	call   c002bf4a <list_push_back>
c002132b:	83 c4 10             	add    $0x10,%esp
  list_sort (&ready_list, cmp_priority, NULL);
c002132e:	83 ec 04             	sub    $0x4,%esp
c0021331:	6a 00                	push   $0x0
c0021333:	8d 83 45 7a fe ff    	lea    -0x185bb(%ebx),%eax
c0021339:	50                   	push   %eax
c002133a:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c0021340:	50                   	push   %eax
c0021341:	e8 6d b2 00 00       	call   c002c5b3 <list_sort>
c0021346:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_READY;
c0021349:	8b 45 08             	mov    0x8(%ebp),%eax
c002134c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)

  intr_set_level (old_level);
c0021353:	83 ec 0c             	sub    $0xc,%esp
c0021356:	ff 75 f4             	push   -0xc(%ebp)
c0021359:	e8 0f 0b 00 00       	call   c0021e6d <intr_set_level>
c002135e:	83 c4 10             	add    $0x10,%esp
}
c0021361:	90                   	nop
c0021362:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021365:	c9                   	leave  
c0021366:	c3                   	ret    

c0021367 <thread_name>:

/* Returns the name of the running thread. */
const char *
thread_name (void) 
{
c0021367:	55                   	push   %ebp
c0021368:	89 e5                	mov    %esp,%ebp
c002136a:	83 ec 08             	sub    $0x8,%esp
c002136d:	e8 b6 00 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021372:	05 06 90 01 00       	add    $0x19006,%eax
  return thread_current ()->name;
c0021377:	e8 05 00 00 00       	call   c0021381 <thread_current>
c002137c:	83 c0 08             	add    $0x8,%eax
}
c002137f:	c9                   	leave  
c0021380:	c3                   	ret    

c0021381 <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current (void) 
{
c0021381:	55                   	push   %ebp
c0021382:	89 e5                	mov    %esp,%ebp
c0021384:	53                   	push   %ebx
c0021385:	83 ec 14             	sub    $0x14,%esp
c0021388:	e8 9f 00 01 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002138d:	81 c3 eb 8f 01 00    	add    $0x18feb,%ebx
  struct thread *t = running_thread ();
c0021393:	e8 b1 04 00 00       	call   c0021849 <running_thread>
c0021398:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
c002139b:	83 ec 0c             	sub    $0xc,%esp
c002139e:	ff 75 f4             	push   -0xc(%ebp)
c00213a1:	e8 c5 04 00 00       	call   c002186b <is_thread>
c00213a6:	83 c4 10             	add    $0x10,%esp
c00213a9:	84 c0                	test   %al,%al
c00213ab:	75 29                	jne    c00213d6 <thread_current+0x55>
c00213ad:	83 ec 0c             	sub    $0xc,%esp
c00213b0:	8d 83 a7 75 ff ff    	lea    -0x8a59(%ebx),%eax
c00213b6:	50                   	push   %eax
c00213b7:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c00213bd:	50                   	push   %eax
c00213be:	8d 83 ec 76 ff ff    	lea    -0x8914(%ebx),%eax
c00213c4:	50                   	push   %eax
c00213c5:	68 41 01 00 00       	push   $0x141
c00213ca:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c00213d0:	50                   	push   %eax
c00213d1:	e8 8e a3 00 00       	call   c002b764 <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c00213d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00213d9:	8b 40 04             	mov    0x4(%eax),%eax
c00213dc:	85 c0                	test   %eax,%eax
c00213de:	74 29                	je     c0021409 <thread_current+0x88>
c00213e0:	83 ec 0c             	sub    $0xc,%esp
c00213e3:	8d 83 d1 75 ff ff    	lea    -0x8a2f(%ebx),%eax
c00213e9:	50                   	push   %eax
c00213ea:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c00213f0:	50                   	push   %eax
c00213f1:	8d 83 ec 76 ff ff    	lea    -0x8914(%ebx),%eax
c00213f7:	50                   	push   %eax
c00213f8:	68 42 01 00 00       	push   $0x142
c00213fd:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0021403:	50                   	push   %eax
c0021404:	e8 5b a3 00 00       	call   c002b764 <debug_panic>

  return t;
c0021409:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002140c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002140f:	c9                   	leave  
c0021410:	c3                   	ret    

c0021411 <thread_tid>:

/* Returns the running thread's tid. */
tid_t
thread_tid (void) 
{
c0021411:	55                   	push   %ebp
c0021412:	89 e5                	mov    %esp,%ebp
c0021414:	83 ec 08             	sub    $0x8,%esp
c0021417:	e8 0c 00 01 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002141c:	05 5c 8f 01 00       	add    $0x18f5c,%eax
  return thread_current ()->tid;
c0021421:	e8 5b ff ff ff       	call   c0021381 <thread_current>
c0021426:	8b 00                	mov    (%eax),%eax
}
c0021428:	c9                   	leave  
c0021429:	c3                   	ret    

c002142a <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void
thread_exit (void) 
{
c002142a:	55                   	push   %ebp
c002142b:	89 e5                	mov    %esp,%ebp
c002142d:	53                   	push   %ebx
c002142e:	83 ec 04             	sub    $0x4,%esp
c0021431:	e8 f6 ff 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021436:	81 c3 42 8f 01 00    	add    $0x18f42,%ebx
  ASSERT (!intr_context ());
c002143c:	e8 03 0e 00 00       	call   c0022244 <intr_context>
c0021441:	83 f0 01             	xor    $0x1,%eax
c0021444:	84 c0                	test   %al,%al
c0021446:	75 29                	jne    c0021471 <thread_exit+0x47>
c0021448:	83 ec 0c             	sub    $0xc,%esp
c002144b:	8d 83 96 75 ff ff    	lea    -0x8a6a(%ebx),%eax
c0021451:	50                   	push   %eax
c0021452:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0021458:	50                   	push   %eax
c0021459:	8d 83 fc 76 ff ff    	lea    -0x8904(%ebx),%eax
c002145f:	50                   	push   %eax
c0021460:	68 53 01 00 00       	push   $0x153
c0021465:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c002146b:	50                   	push   %eax
c002146c:	e8 f3 a2 00 00       	call   c002b764 <debug_panic>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable ();
c0021471:	e8 70 0a 00 00       	call   c0021ee6 <intr_disable>

  list_remove (&thread_current()->allelem);
c0021476:	e8 06 ff ff ff       	call   c0021381 <thread_current>
c002147b:	83 c0 20             	add    $0x20,%eax
c002147e:	83 ec 0c             	sub    $0xc,%esp
c0021481:	50                   	push   %eax
c0021482:	e8 f3 aa 00 00       	call   c002bf7a <list_remove>
c0021487:	83 c4 10             	add    $0x10,%esp
  thread_current ()->status = THREAD_DYING;
c002148a:	e8 f2 fe ff ff       	call   c0021381 <thread_current>
c002148f:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c0021496:	e8 82 07 00 00       	call   c0021c1d <schedule>
  NOT_REACHED ();
c002149b:	8d 83 f0 75 ff ff    	lea    -0x8a10(%ebx),%eax
c00214a1:	50                   	push   %eax
c00214a2:	8d 83 fc 76 ff ff    	lea    -0x8904(%ebx),%eax
c00214a8:	50                   	push   %eax
c00214a9:	68 61 01 00 00       	push   $0x161
c00214ae:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c00214b4:	50                   	push   %eax
c00214b5:	e8 aa a2 00 00       	call   c002b764 <debug_panic>

c00214ba <thread_yield>:

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void
thread_yield (void) 
{
c00214ba:	55                   	push   %ebp
c00214bb:	89 e5                	mov    %esp,%ebp
c00214bd:	53                   	push   %ebx
c00214be:	83 ec 14             	sub    $0x14,%esp
c00214c1:	e8 66 ff 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00214c6:	81 c3 b2 8e 01 00    	add    $0x18eb2,%ebx

  struct thread *cur = thread_current ();
c00214cc:	e8 b0 fe ff ff       	call   c0021381 <thread_current>
c00214d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  enum intr_level old_level;
  
  ASSERT (!intr_context ());
c00214d4:	e8 6b 0d 00 00       	call   c0022244 <intr_context>
c00214d9:	83 f0 01             	xor    $0x1,%eax
c00214dc:	84 c0                	test   %al,%al
c00214de:	75 29                	jne    c0021509 <thread_yield+0x4f>
c00214e0:	83 ec 0c             	sub    $0xc,%esp
c00214e3:	8d 83 96 75 ff ff    	lea    -0x8a6a(%ebx),%eax
c00214e9:	50                   	push   %eax
c00214ea:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c00214f0:	50                   	push   %eax
c00214f1:	8d 83 08 77 ff ff    	lea    -0x88f8(%ebx),%eax
c00214f7:	50                   	push   %eax
c00214f8:	68 6d 01 00 00       	push   $0x16d
c00214fd:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0021503:	50                   	push   %eax
c0021504:	e8 5b a2 00 00       	call   c002b764 <debug_panic>

  old_level = intr_disable ();
c0021509:	e8 d8 09 00 00       	call   c0021ee6 <intr_disable>
c002150e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (cur != idle_thread)
c0021511:	8b 83 78 08 00 00    	mov    0x878(%ebx),%eax
c0021517:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002151a:	74 34                	je     c0021550 <thread_yield+0x96>
  {
    list_push_back (&ready_list, &cur->elem);
c002151c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002151f:	83 c0 28             	add    $0x28,%eax
c0021522:	83 ec 08             	sub    $0x8,%esp
c0021525:	50                   	push   %eax
c0021526:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c002152c:	50                   	push   %eax
c002152d:	e8 18 aa 00 00       	call   c002bf4a <list_push_back>
c0021532:	83 c4 10             	add    $0x10,%esp
    list_sort (&ready_list, cmp_priority, NULL);
c0021535:	83 ec 04             	sub    $0x4,%esp
c0021538:	6a 00                	push   $0x0
c002153a:	8d 83 45 7a fe ff    	lea    -0x185bb(%ebx),%eax
c0021540:	50                   	push   %eax
c0021541:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c0021547:	50                   	push   %eax
c0021548:	e8 66 b0 00 00       	call   c002c5b3 <list_sort>
c002154d:	83 c4 10             	add    $0x10,%esp
  }
  cur->status = THREAD_READY;
c0021550:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021553:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  schedule ();
c002155a:	e8 be 06 00 00       	call   c0021c1d <schedule>
  intr_set_level (old_level);
c002155f:	83 ec 0c             	sub    $0xc,%esp
c0021562:	ff 75 f0             	push   -0x10(%ebp)
c0021565:	e8 03 09 00 00       	call   c0021e6d <intr_set_level>
c002156a:	83 c4 10             	add    $0x10,%esp
}
c002156d:	90                   	nop
c002156e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021571:	c9                   	leave  
c0021572:	c3                   	ret    

c0021573 <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void
thread_foreach (thread_action_func *func, void *aux)
{
c0021573:	55                   	push   %ebp
c0021574:	89 e5                	mov    %esp,%ebp
c0021576:	53                   	push   %ebx
c0021577:	83 ec 14             	sub    $0x14,%esp
c002157a:	e8 ad fe 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002157f:	81 c3 f9 8d 01 00    	add    $0x18df9,%ebx
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);
c0021585:	e8 c3 08 00 00       	call   c0021e4d <intr_get_level>
c002158a:	85 c0                	test   %eax,%eax
c002158c:	74 29                	je     c00215b7 <thread_foreach+0x44>
c002158e:	83 ec 0c             	sub    $0xc,%esp
c0021591:	8d 83 f0 74 ff ff    	lea    -0x8b10(%ebx),%eax
c0021597:	50                   	push   %eax
c0021598:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c002159e:	50                   	push   %eax
c002159f:	8d 83 18 77 ff ff    	lea    -0x88e8(%ebx),%eax
c00215a5:	50                   	push   %eax
c00215a6:	68 81 01 00 00       	push   $0x181
c00215ab:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c00215b1:	50                   	push   %eax
c00215b2:	e8 ad a1 00 00       	call   c002b764 <debug_panic>

  for (e = list_begin (&all_list); e != list_end (&all_list);
c00215b7:	83 ec 0c             	sub    $0xc,%esp
c00215ba:	8d 83 68 08 00 00    	lea    0x868(%ebx),%eax
c00215c0:	50                   	push   %eax
c00215c1:	e8 eb a4 00 00       	call   c002bab1 <list_begin>
c00215c6:	83 c4 10             	add    $0x10,%esp
c00215c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00215cc:	eb 2e                	jmp    c00215fc <thread_foreach+0x89>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
c00215ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00215d1:	83 c0 04             	add    $0x4,%eax
c00215d4:	83 e8 24             	sub    $0x24,%eax
c00215d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      func (t, aux);
c00215da:	83 ec 08             	sub    $0x8,%esp
c00215dd:	ff 75 0c             	push   0xc(%ebp)
c00215e0:	ff 75 f0             	push   -0x10(%ebp)
c00215e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00215e6:	ff d0                	call   *%eax
c00215e8:	83 c4 10             	add    $0x10,%esp
       e = list_next (e))
c00215eb:	83 ec 0c             	sub    $0xc,%esp
c00215ee:	ff 75 f4             	push   -0xc(%ebp)
c00215f1:	e8 05 a5 00 00       	call   c002bafb <list_next>
c00215f6:	83 c4 10             	add    $0x10,%esp
c00215f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_list); e != list_end (&all_list);
c00215fc:	83 ec 0c             	sub    $0xc,%esp
c00215ff:	8d 83 68 08 00 00    	lea    0x868(%ebx),%eax
c0021605:	50                   	push   %eax
c0021606:	e8 51 a5 00 00       	call   c002bb5c <list_end>
c002160b:	83 c4 10             	add    $0x10,%esp
c002160e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0021611:	75 bb                	jne    c00215ce <thread_foreach+0x5b>
    }
}
c0021613:	90                   	nop
c0021614:	90                   	nop
c0021615:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021618:	c9                   	leave  
c0021619:	c3                   	ret    

c002161a <thread_set_priority>:

/* Sets the current thread's priority to NEW_PRIORITY. */
void
thread_set_priority (int new_priority) 
{
c002161a:	55                   	push   %ebp
c002161b:	89 e5                	mov    %esp,%ebp
c002161d:	56                   	push   %esi
c002161e:	53                   	push   %ebx
c002161f:	83 ec 10             	sub    $0x10,%esp
c0021622:	e8 05 fe 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021627:	81 c3 51 8d 01 00    	add    $0x18d51,%ebx
  enum intr_level old_level;

  old_level = intr_disable ();
c002162d:	e8 b4 08 00 00       	call   c0021ee6 <intr_disable>
c0021632:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(list_empty(&thread_current()->pot_donors))
c0021635:	e8 47 fd ff ff       	call   c0021381 <thread_current>
c002163a:	83 c0 48             	add    $0x48,%eax
c002163d:	83 ec 0c             	sub    $0xc,%esp
c0021640:	50                   	push   %eax
c0021641:	e8 19 ab 00 00       	call   c002c15f <list_empty>
c0021646:	83 c4 10             	add    $0x10,%esp
c0021649:	84 c0                	test   %al,%al
c002164b:	74 18                	je     c0021665 <thread_set_priority+0x4b>
  {
    thread_current()->priority = new_priority; 
c002164d:	e8 2f fd ff ff       	call   c0021381 <thread_current>
c0021652:	8b 55 08             	mov    0x8(%ebp),%edx
c0021655:	89 50 1c             	mov    %edx,0x1c(%eax)
    thread_current()->basepriority = new_priority;
c0021658:	e8 24 fd ff ff       	call   c0021381 <thread_current>
c002165d:	8b 55 08             	mov    0x8(%ebp),%edx
c0021660:	89 50 40             	mov    %edx,0x40(%eax)
c0021663:	eb 30                	jmp    c0021695 <thread_set_priority+0x7b>
  }
  else if(new_priority > thread_current()->priority)
c0021665:	e8 17 fd ff ff       	call   c0021381 <thread_current>
c002166a:	8b 40 1c             	mov    0x1c(%eax),%eax
c002166d:	39 45 08             	cmp    %eax,0x8(%ebp)
c0021670:	7e 18                	jle    c002168a <thread_set_priority+0x70>
  {
    thread_current()->priority = new_priority;
c0021672:	e8 0a fd ff ff       	call   c0021381 <thread_current>
c0021677:	8b 55 08             	mov    0x8(%ebp),%edx
c002167a:	89 50 1c             	mov    %edx,0x1c(%eax)
    thread_current()->basepriority = new_priority;
c002167d:	e8 ff fc ff ff       	call   c0021381 <thread_current>
c0021682:	8b 55 08             	mov    0x8(%ebp),%edx
c0021685:	89 50 40             	mov    %edx,0x40(%eax)
c0021688:	eb 0b                	jmp    c0021695 <thread_set_priority+0x7b>
  }
  else
    thread_current()->basepriority = new_priority;
c002168a:	e8 f2 fc ff ff       	call   c0021381 <thread_current>
c002168f:	8b 55 08             	mov    0x8(%ebp),%edx
c0021692:	89 50 40             	mov    %edx,0x40(%eax)

  if(!list_empty(&ready_list))
c0021695:	83 ec 0c             	sub    $0xc,%esp
c0021698:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c002169e:	50                   	push   %eax
c002169f:	e8 bb aa 00 00       	call   c002c15f <list_empty>
c00216a4:	83 c4 10             	add    $0x10,%esp
c00216a7:	83 f0 01             	xor    $0x1,%eax
c00216aa:	84 c0                	test   %al,%al
c00216ac:	74 38                	je     c00216e6 <thread_set_priority+0xcc>
  {
    struct list_elem *front = list_front(&ready_list);
c00216ae:	83 ec 0c             	sub    $0xc,%esp
c00216b1:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c00216b7:	50                   	push   %eax
c00216b8:	e8 95 a9 00 00       	call   c002c052 <list_front>
c00216bd:	83 c4 10             	add    $0x10,%esp
c00216c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct thread *fthread = list_entry (front, struct thread, elem);
c00216c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00216c6:	83 c0 04             	add    $0x4,%eax
c00216c9:	83 e8 2c             	sub    $0x2c,%eax
c00216cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(fthread->priority > thread_current ()->priority)
c00216cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00216d2:	8b 70 1c             	mov    0x1c(%eax),%esi
c00216d5:	e8 a7 fc ff ff       	call   c0021381 <thread_current>
c00216da:	8b 40 1c             	mov    0x1c(%eax),%eax
c00216dd:	39 c6                	cmp    %eax,%esi
c00216df:	7e 05                	jle    c00216e6 <thread_set_priority+0xcc>
      thread_yield();
c00216e1:	e8 d4 fd ff ff       	call   c00214ba <thread_yield>
  }
  intr_set_level (old_level);
c00216e6:	83 ec 0c             	sub    $0xc,%esp
c00216e9:	ff 75 f4             	push   -0xc(%ebp)
c00216ec:	e8 7c 07 00 00       	call   c0021e6d <intr_set_level>
c00216f1:	83 c4 10             	add    $0x10,%esp
}
c00216f4:	90                   	nop
c00216f5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00216f8:	5b                   	pop    %ebx
c00216f9:	5e                   	pop    %esi
c00216fa:	5d                   	pop    %ebp
c00216fb:	c3                   	ret    

c00216fc <thread_get_priority>:

/* Returns the current thread's priority. */
int
thread_get_priority (void) 
{
c00216fc:	55                   	push   %ebp
c00216fd:	89 e5                	mov    %esp,%ebp
c00216ff:	83 ec 08             	sub    $0x8,%esp
c0021702:	e8 21 fd 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021707:	05 71 8c 01 00       	add    $0x18c71,%eax
  return thread_current ()->priority;
c002170c:	e8 70 fc ff ff       	call   c0021381 <thread_current>
c0021711:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0021714:	c9                   	leave  
c0021715:	c3                   	ret    

c0021716 <thread_set_nice>:

/* Sets the current thread's nice value to NICE. */
void
thread_set_nice (int nice UNUSED) 
{
c0021716:	55                   	push   %ebp
c0021717:	89 e5                	mov    %esp,%ebp
c0021719:	83 ec 08             	sub    $0x8,%esp
c002171c:	e8 07 fd 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021721:	05 57 8c 01 00       	add    $0x18c57,%eax
  thread_current()->nice = nice-7;
c0021726:	e8 56 fc ff ff       	call   c0021381 <thread_current>
c002172b:	8b 55 08             	mov    0x8(%ebp),%edx
c002172e:	83 ea 07             	sub    $0x7,%edx
c0021731:	89 50 5c             	mov    %edx,0x5c(%eax)
  
}
c0021734:	90                   	nop
c0021735:	c9                   	leave  
c0021736:	c3                   	ret    

c0021737 <thread_get_nice>:

/* Returns the current thread's nice value. */
int
thread_get_nice (void) 
{
c0021737:	55                   	push   %ebp
c0021738:	89 e5                	mov    %esp,%ebp
c002173a:	83 ec 08             	sub    $0x8,%esp
c002173d:	e8 e6 fc 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021742:	05 36 8c 01 00       	add    $0x18c36,%eax
  /* Not yet implemented. */
  return thread_current()->nice;
c0021747:	e8 35 fc ff ff       	call   c0021381 <thread_current>
c002174c:	8b 40 5c             	mov    0x5c(%eax),%eax
}
c002174f:	c9                   	leave  
c0021750:	c3                   	ret    

c0021751 <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int
thread_get_load_avg (void) 
{
c0021751:	55                   	push   %ebp
c0021752:	89 e5                	mov    %esp,%ebp
c0021754:	e8 cf fc 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021759:	05 1f 8c 01 00       	add    $0x18c1f,%eax
  /* Not yet implemented. */
  return tointround(mulin(load_avg,100));
c002175e:	8b 80 54 08 00 00    	mov    0x854(%eax),%eax
c0021764:	6a 64                	push   $0x64
c0021766:	50                   	push   %eax
c0021767:	e8 16 f4 ff ff       	call   c0020b82 <mulin>
c002176c:	83 c4 08             	add    $0x8,%esp
c002176f:	50                   	push   %eax
c0021770:	e8 66 f3 ff ff       	call   c0020adb <tointround>
c0021775:	83 c4 04             	add    $0x4,%esp
}
c0021778:	c9                   	leave  
c0021779:	c3                   	ret    

c002177a <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int
thread_get_recent_cpu (void) 
{
c002177a:	55                   	push   %ebp
c002177b:	89 e5                	mov    %esp,%ebp
c002177d:	83 ec 08             	sub    $0x8,%esp
c0021780:	e8 a3 fc 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021785:	05 f3 8b 01 00       	add    $0x18bf3,%eax
  /* Not yet implemented. */
  return tointround(mulin(thread_current()->recent_cpu,100)) ;
c002178a:	e8 f2 fb ff ff       	call   c0021381 <thread_current>
c002178f:	8b 40 60             	mov    0x60(%eax),%eax
c0021792:	83 ec 08             	sub    $0x8,%esp
c0021795:	6a 64                	push   $0x64
c0021797:	50                   	push   %eax
c0021798:	e8 e5 f3 ff ff       	call   c0020b82 <mulin>
c002179d:	83 c4 10             	add    $0x10,%esp
c00217a0:	83 ec 0c             	sub    $0xc,%esp
c00217a3:	50                   	push   %eax
c00217a4:	e8 32 f3 ff ff       	call   c0020adb <tointround>
c00217a9:	83 c4 10             	add    $0x10,%esp
}
c00217ac:	c9                   	leave  
c00217ad:	c3                   	ret    

c00217ae <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle (void *idle_started_ UNUSED) 
{
c00217ae:	55                   	push   %ebp
c00217af:	89 e5                	mov    %esp,%ebp
c00217b1:	53                   	push   %ebx
c00217b2:	83 ec 14             	sub    $0x14,%esp
c00217b5:	e8 72 fc 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00217ba:	81 c3 be 8b 01 00    	add    $0x18bbe,%ebx
  struct semaphore *idle_started = idle_started_;
c00217c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00217c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  idle_thread = thread_current ();
c00217c6:	e8 b6 fb ff ff       	call   c0021381 <thread_current>
c00217cb:	89 83 78 08 00 00    	mov    %eax,0x878(%ebx)
  sema_up (idle_started);
c00217d1:	83 ec 0c             	sub    $0xc,%esp
c00217d4:	ff 75 f4             	push   -0xc(%ebp)
c00217d7:	e8 34 1e 00 00       	call   c0023610 <sema_up>
c00217dc:	83 c4 10             	add    $0x10,%esp

  for (;;) 
    {
      /* Let someone else run. */
      intr_disable ();
c00217df:	e8 02 07 00 00       	call   c0021ee6 <intr_disable>
      thread_block ();
c00217e4:	e8 13 fa ff ff       	call   c00211fc <thread_block>
         one to occur, wasting as much as one clock tick worth of
         time.

         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
         7.11.1 "HLT Instruction". */
      asm volatile ("sti; hlt" : : : "memory");
c00217e9:	fb                   	sti    
c00217ea:	f4                   	hlt    
      intr_disable ();
c00217eb:	eb f2                	jmp    c00217df <idle+0x31>

c00217ed <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread (thread_func *function, void *aux) 
{
c00217ed:	55                   	push   %ebp
c00217ee:	89 e5                	mov    %esp,%ebp
c00217f0:	53                   	push   %ebx
c00217f1:	83 ec 04             	sub    $0x4,%esp
c00217f4:	e8 2f fc 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00217f9:	05 7f 8b 01 00       	add    $0x18b7f,%eax
  ASSERT (function != NULL);
c00217fe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021802:	75 2b                	jne    c002182f <kernel_thread+0x42>
c0021804:	83 ec 0c             	sub    $0xc,%esp
c0021807:	8d 90 85 75 ff ff    	lea    -0x8a7b(%eax),%edx
c002180d:	52                   	push   %edx
c002180e:	8d 90 0e 75 ff ff    	lea    -0x8af2(%eax),%edx
c0021814:	52                   	push   %edx
c0021815:	8d 90 28 77 ff ff    	lea    -0x88d8(%eax),%edx
c002181b:	52                   	push   %edx
c002181c:	68 fb 01 00 00       	push   $0x1fb
c0021821:	8d 90 25 75 ff ff    	lea    -0x8adb(%eax),%edx
c0021827:	52                   	push   %edx
c0021828:	89 c3                	mov    %eax,%ebx
c002182a:	e8 35 9f 00 00       	call   c002b764 <debug_panic>

  intr_enable ();       /* The scheduler runs with interrupts off. */
c002182f:	89 c3                	mov    %eax,%ebx
c0021831:	e8 5b 06 00 00       	call   c0021e91 <intr_enable>
  function (aux);       /* Execute the thread function. */
c0021836:	83 ec 0c             	sub    $0xc,%esp
c0021839:	ff 75 0c             	push   0xc(%ebp)
c002183c:	8b 45 08             	mov    0x8(%ebp),%eax
c002183f:	ff d0                	call   *%eax
c0021841:	83 c4 10             	add    $0x10,%esp
  thread_exit ();       /* If function() returns, kill the thread. */
c0021844:	e8 e1 fb ff ff       	call   c002142a <thread_exit>

c0021849 <running_thread>:
}

/* Returns the running thread. */
struct thread *
running_thread (void) 
{
c0021849:	55                   	push   %ebp
c002184a:	89 e5                	mov    %esp,%ebp
c002184c:	83 ec 10             	sub    $0x10,%esp
c002184f:	e8 d4 fb 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021854:	05 24 8b 01 00       	add    $0x18b24,%eax

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c0021859:	89 e0                	mov    %esp,%eax
c002185b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return pg_round_down (esp);
c002185e:	ff 75 fc             	push   -0x4(%ebp)
c0021861:	e8 29 f2 ff ff       	call   c0020a8f <pg_round_down>
c0021866:	83 c4 04             	add    $0x4,%esp
}
c0021869:	c9                   	leave  
c002186a:	c3                   	ret    

c002186b <is_thread>:

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
c002186b:	55                   	push   %ebp
c002186c:	89 e5                	mov    %esp,%ebp
c002186e:	e8 b5 fb 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021873:	05 05 8b 01 00       	add    $0x18b05,%eax
  return t != NULL && t->magic == THREAD_MAGIC;
c0021878:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002187c:	74 14                	je     c0021892 <is_thread+0x27>
c002187e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021881:	8b 40 64             	mov    0x64(%eax),%eax
c0021884:	3d 4b bf 6a cd       	cmp    $0xcd6abf4b,%eax
c0021889:	75 07                	jne    c0021892 <is_thread+0x27>
c002188b:	b8 01 00 00 00       	mov    $0x1,%eax
c0021890:	eb 05                	jmp    c0021897 <is_thread+0x2c>
c0021892:	b8 00 00 00 00       	mov    $0x0,%eax
c0021897:	83 e0 01             	and    $0x1,%eax
}
c002189a:	5d                   	pop    %ebp
c002189b:	c3                   	ret    

c002189c <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c002189c:	55                   	push   %ebp
c002189d:	89 e5                	mov    %esp,%ebp
c002189f:	53                   	push   %ebx
c00218a0:	83 ec 04             	sub    $0x4,%esp
c00218a3:	e8 84 fb 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00218a8:	81 c3 d0 8a 01 00    	add    $0x18ad0,%ebx
  ASSERT (t != NULL);
c00218ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00218b2:	75 29                	jne    c00218dd <init_thread+0x41>
c00218b4:	83 ec 0c             	sub    $0xc,%esp
c00218b7:	8d 83 12 76 ff ff    	lea    -0x89ee(%ebx),%eax
c00218bd:	50                   	push   %eax
c00218be:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c00218c4:	50                   	push   %eax
c00218c5:	8d 83 38 77 ff ff    	lea    -0x88c8(%ebx),%eax
c00218cb:	50                   	push   %eax
c00218cc:	68 1c 02 00 00       	push   $0x21c
c00218d1:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c00218d7:	50                   	push   %eax
c00218d8:	e8 87 9e 00 00       	call   c002b764 <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c00218dd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00218e1:	78 06                	js     c00218e9 <init_thread+0x4d>
c00218e3:	83 7d 10 3f          	cmpl   $0x3f,0x10(%ebp)
c00218e7:	7e 29                	jle    c0021912 <init_thread+0x76>
c00218e9:	83 ec 0c             	sub    $0xc,%esp
c00218ec:	8d 83 1c 76 ff ff    	lea    -0x89e4(%ebx),%eax
c00218f2:	50                   	push   %eax
c00218f3:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c00218f9:	50                   	push   %eax
c00218fa:	8d 83 38 77 ff ff    	lea    -0x88c8(%ebx),%eax
c0021900:	50                   	push   %eax
c0021901:	68 1d 02 00 00       	push   $0x21d
c0021906:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c002190c:	50                   	push   %eax
c002190d:	e8 52 9e 00 00       	call   c002b764 <debug_panic>
  ASSERT (name != NULL);
c0021912:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0021916:	75 29                	jne    c0021941 <init_thread+0xa5>
c0021918:	83 ec 0c             	sub    $0xc,%esp
c002191b:	8d 83 47 76 ff ff    	lea    -0x89b9(%ebx),%eax
c0021921:	50                   	push   %eax
c0021922:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0021928:	50                   	push   %eax
c0021929:	8d 83 38 77 ff ff    	lea    -0x88c8(%ebx),%eax
c002192f:	50                   	push   %eax
c0021930:	68 1e 02 00 00       	push   $0x21e
c0021935:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c002193b:	50                   	push   %eax
c002193c:	e8 23 9e 00 00       	call   c002b764 <debug_panic>

  memset (t, 0, sizeof *t);
c0021941:	83 ec 04             	sub    $0x4,%esp
c0021944:	6a 68                	push   $0x68
c0021946:	6a 00                	push   $0x0
c0021948:	ff 75 08             	push   0x8(%ebp)
c002194b:	e8 a4 90 00 00       	call   c002a9f4 <memset>
c0021950:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_BLOCKED;
c0021953:	8b 45 08             	mov    0x8(%ebp),%eax
c0021956:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  strlcpy (t->name, name, sizeof t->name);
c002195d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021960:	83 c0 08             	add    $0x8,%eax
c0021963:	83 ec 04             	sub    $0x4,%esp
c0021966:	6a 10                	push   $0x10
c0021968:	ff 75 0c             	push   0xc(%ebp)
c002196b:	50                   	push   %eax
c002196c:	e8 92 91 00 00       	call   c002ab03 <strlcpy>
c0021971:	83 c4 10             	add    $0x10,%esp
  t->stack = (uint8_t *) t + PGSIZE;
c0021974:	8b 45 08             	mov    0x8(%ebp),%eax
c0021977:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c002197d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021980:	89 50 18             	mov    %edx,0x18(%eax)
  t->nice = 0;
c0021983:	8b 45 08             	mov    0x8(%ebp),%eax
c0021986:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  if(thread_mlfqs)
c002198d:	0f b6 83 50 08 00 00 	movzbl 0x850(%ebx),%eax
c0021994:	84 c0                	test   %al,%al
c0021996:	74 7b                	je     c0021a13 <init_thread+0x177>
  {
    if(strcmp(t->name,"main")==0)
c0021998:	8b 45 08             	mov    0x8(%ebp),%eax
c002199b:	8d 50 08             	lea    0x8(%eax),%edx
c002199e:	83 ec 08             	sub    $0x8,%esp
c00219a1:	8d 83 3c 75 ff ff    	lea    -0x8ac4(%ebx),%eax
c00219a7:	50                   	push   %eax
c00219a8:	52                   	push   %edx
c00219a9:	e8 98 8b 00 00       	call   c002a546 <strcmp>
c00219ae:	83 c4 10             	add    $0x10,%esp
c00219b1:	85 c0                	test   %eax,%eax
c00219b3:	75 0c                	jne    c00219c1 <init_thread+0x125>
      t->recent_cpu = 0;
c00219b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00219b8:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
c00219bf:	eb 19                	jmp    c00219da <init_thread+0x13e>
    else
      t->recent_cpu = divin(thread_get_recent_cpu(),100);
c00219c1:	e8 b4 fd ff ff       	call   c002177a <thread_get_recent_cpu>
c00219c6:	83 ec 08             	sub    $0x8,%esp
c00219c9:	6a 64                	push   $0x64
c00219cb:	50                   	push   %eax
c00219cc:	e8 2b f2 ff ff       	call   c0020bfc <divin>
c00219d1:	83 c4 10             	add    $0x10,%esp
c00219d4:	8b 55 08             	mov    0x8(%ebp),%edx
c00219d7:	89 42 60             	mov    %eax,0x60(%edx)

    priority = PRI_MAX - tointround(divin(t->recent_cpu,4)) - (t->nice * 2);
c00219da:	8b 45 08             	mov    0x8(%ebp),%eax
c00219dd:	8b 40 60             	mov    0x60(%eax),%eax
c00219e0:	83 ec 08             	sub    $0x8,%esp
c00219e3:	6a 04                	push   $0x4
c00219e5:	50                   	push   %eax
c00219e6:	e8 11 f2 ff ff       	call   c0020bfc <divin>
c00219eb:	83 c4 10             	add    $0x10,%esp
c00219ee:	83 ec 0c             	sub    $0xc,%esp
c00219f1:	50                   	push   %eax
c00219f2:	e8 e4 f0 ff ff       	call   c0020adb <tointround>
c00219f7:	83 c4 10             	add    $0x10,%esp
c00219fa:	ba 3f 00 00 00       	mov    $0x3f,%edx
c00219ff:	29 c2                	sub    %eax,%edx
c0021a01:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a04:	8b 40 5c             	mov    0x5c(%eax),%eax
c0021a07:	8d 0c 00             	lea    (%eax,%eax,1),%ecx
c0021a0a:	89 d0                	mov    %edx,%eax
c0021a0c:	29 c8                	sub    %ecx,%eax
c0021a0e:	89 45 10             	mov    %eax,0x10(%ebp)
c0021a11:	eb 09                	jmp    c0021a1c <init_thread+0x180>
      
  }
  else
    t->priority = priority;
c0021a13:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a16:	8b 55 10             	mov    0x10(%ebp),%edx
c0021a19:	89 50 1c             	mov    %edx,0x1c(%eax)
  t->magic = THREAD_MAGIC;
c0021a1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a1f:	c7 40 64 4b bf 6a cd 	movl   $0xcd6abf4b,0x64(%eax)
  t->basepriority = priority;
c0021a26:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a29:	8b 55 10             	mov    0x10(%ebp),%edx
c0021a2c:	89 50 40             	mov    %edx,0x40(%eax)
  t->locker = NULL;
c0021a2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a32:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  t->blocked = NULL;
c0021a39:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a3c:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  list_init (&t->pot_donors);
c0021a43:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a46:	83 c0 48             	add    $0x48,%eax
c0021a49:	83 ec 0c             	sub    $0xc,%esp
c0021a4c:	50                   	push   %eax
c0021a4d:	e8 f2 9f 00 00       	call   c002ba44 <list_init>
c0021a52:	83 c4 10             	add    $0x10,%esp
  list_push_back (&all_list, &t->allelem);
c0021a55:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a58:	83 c0 20             	add    $0x20,%eax
c0021a5b:	83 ec 08             	sub    $0x8,%esp
c0021a5e:	50                   	push   %eax
c0021a5f:	8d 83 68 08 00 00    	lea    0x868(%ebx),%eax
c0021a65:	50                   	push   %eax
c0021a66:	e8 df a4 00 00       	call   c002bf4a <list_push_back>
c0021a6b:	83 c4 10             	add    $0x10,%esp
}
c0021a6e:	90                   	nop
c0021a6f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021a72:	c9                   	leave  
c0021a73:	c3                   	ret    

c0021a74 <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c0021a74:	55                   	push   %ebp
c0021a75:	89 e5                	mov    %esp,%ebp
c0021a77:	53                   	push   %ebx
c0021a78:	83 ec 04             	sub    $0x4,%esp
c0021a7b:	e8 ac f9 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021a80:	81 c3 f8 88 01 00    	add    $0x188f8,%ebx
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c0021a86:	ff 75 08             	push   0x8(%ebp)
c0021a89:	e8 dd fd ff ff       	call   c002186b <is_thread>
c0021a8e:	83 c4 04             	add    $0x4,%esp
c0021a91:	84 c0                	test   %al,%al
c0021a93:	75 29                	jne    c0021abe <alloc_frame+0x4a>
c0021a95:	83 ec 0c             	sub    $0xc,%esp
c0021a98:	8d 83 a7 75 ff ff    	lea    -0x8a59(%ebx),%eax
c0021a9e:	50                   	push   %eax
c0021a9f:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0021aa5:	50                   	push   %eax
c0021aa6:	8d 83 44 77 ff ff    	lea    -0x88bc(%ebx),%eax
c0021aac:	50                   	push   %eax
c0021aad:	68 3f 02 00 00       	push   $0x23f
c0021ab2:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0021ab8:	50                   	push   %eax
c0021ab9:	e8 a6 9c 00 00       	call   c002b764 <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c0021abe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021ac1:	83 e0 03             	and    $0x3,%eax
c0021ac4:	85 c0                	test   %eax,%eax
c0021ac6:	74 29                	je     c0021af1 <alloc_frame+0x7d>
c0021ac8:	83 ec 0c             	sub    $0xc,%esp
c0021acb:	8d 83 54 76 ff ff    	lea    -0x89ac(%ebx),%eax
c0021ad1:	50                   	push   %eax
c0021ad2:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0021ad8:	50                   	push   %eax
c0021ad9:	8d 83 44 77 ff ff    	lea    -0x88bc(%ebx),%eax
c0021adf:	50                   	push   %eax
c0021ae0:	68 40 02 00 00       	push   $0x240
c0021ae5:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0021aeb:	50                   	push   %eax
c0021aec:	e8 73 9c 00 00       	call   c002b764 <debug_panic>

  t->stack -= size;
c0021af1:	8b 45 08             	mov    0x8(%ebp),%eax
c0021af4:	8b 50 18             	mov    0x18(%eax),%edx
c0021af7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021afa:	f7 d8                	neg    %eax
c0021afc:	01 c2                	add    %eax,%edx
c0021afe:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b01:	89 50 18             	mov    %edx,0x18(%eax)
  return t->stack;
c0021b04:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b07:	8b 40 18             	mov    0x18(%eax),%eax
}
c0021b0a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021b0d:	c9                   	leave  
c0021b0e:	c3                   	ret    

c0021b0f <next_thread_to_run>:
   empty.  (If the running thread can continue running, then it
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
c0021b0f:	55                   	push   %ebp
c0021b10:	89 e5                	mov    %esp,%ebp
c0021b12:	53                   	push   %ebx
c0021b13:	83 ec 04             	sub    $0x4,%esp
c0021b16:	e8 11 f9 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021b1b:	81 c3 5d 88 01 00    	add    $0x1885d,%ebx
  if (list_empty (&ready_list))
c0021b21:	83 ec 0c             	sub    $0xc,%esp
c0021b24:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c0021b2a:	50                   	push   %eax
c0021b2b:	e8 2f a6 00 00       	call   c002c15f <list_empty>
c0021b30:	83 c4 10             	add    $0x10,%esp
c0021b33:	84 c0                	test   %al,%al
c0021b35:	74 08                	je     c0021b3f <next_thread_to_run+0x30>
    return idle_thread;
c0021b37:	8b 83 78 08 00 00    	mov    0x878(%ebx),%eax
c0021b3d:	eb 18                	jmp    c0021b57 <next_thread_to_run+0x48>
  else
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c0021b3f:	83 ec 0c             	sub    $0xc,%esp
c0021b42:	8d 83 58 08 00 00    	lea    0x858(%ebx),%eax
c0021b48:	50                   	push   %eax
c0021b49:	e8 9c a4 00 00       	call   c002bfea <list_pop_front>
c0021b4e:	83 c4 10             	add    $0x10,%esp
c0021b51:	83 c0 04             	add    $0x4,%eax
c0021b54:	83 e8 2c             	sub    $0x2c,%eax
}
c0021b57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021b5a:	c9                   	leave  
c0021b5b:	c3                   	ret    

c0021b5c <thread_schedule_tail>:

   After this function and its caller returns, the thread switch
   is complete. */
void
thread_schedule_tail (struct thread *prev)
{
c0021b5c:	55                   	push   %ebp
c0021b5d:	89 e5                	mov    %esp,%ebp
c0021b5f:	53                   	push   %ebx
c0021b60:	83 ec 14             	sub    $0x14,%esp
c0021b63:	e8 c4 f8 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021b68:	81 c3 10 88 01 00    	add    $0x18810,%ebx
  struct thread *cur = running_thread ();
c0021b6e:	e8 d6 fc ff ff       	call   c0021849 <running_thread>
c0021b73:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (intr_get_level () == INTR_OFF);
c0021b76:	e8 d2 02 00 00       	call   c0021e4d <intr_get_level>
c0021b7b:	85 c0                	test   %eax,%eax
c0021b7d:	74 29                	je     c0021ba8 <thread_schedule_tail+0x4c>
c0021b7f:	83 ec 0c             	sub    $0xc,%esp
c0021b82:	8d 83 f0 74 ff ff    	lea    -0x8b10(%ebx),%eax
c0021b88:	50                   	push   %eax
c0021b89:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0021b8f:	50                   	push   %eax
c0021b90:	8d 83 50 77 ff ff    	lea    -0x88b0(%ebx),%eax
c0021b96:	50                   	push   %eax
c0021b97:	68 69 02 00 00       	push   $0x269
c0021b9c:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0021ba2:	50                   	push   %eax
c0021ba3:	e8 bc 9b 00 00       	call   c002b764 <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c0021ba8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021bab:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

  /* Start new time slice. */
  thread_ticks = 0;
c0021bb2:	c7 83 b0 08 00 00 00 	movl   $0x0,0x8b0(%ebx)
c0021bb9:	00 00 00 
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0021bbc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021bc0:	74 55                	je     c0021c17 <thread_schedule_tail+0xbb>
c0021bc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bc5:	8b 40 04             	mov    0x4(%eax),%eax
c0021bc8:	83 f8 03             	cmp    $0x3,%eax
c0021bcb:	75 4a                	jne    c0021c17 <thread_schedule_tail+0xbb>
c0021bcd:	8b 83 7c 08 00 00    	mov    0x87c(%ebx),%eax
c0021bd3:	39 45 08             	cmp    %eax,0x8(%ebp)
c0021bd6:	74 3f                	je     c0021c17 <thread_schedule_tail+0xbb>
    {
      ASSERT (prev != cur);
c0021bd8:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bdb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0021bde:	75 29                	jne    c0021c09 <thread_schedule_tail+0xad>
c0021be0:	83 ec 0c             	sub    $0xc,%esp
c0021be3:	8d 83 72 76 ff ff    	lea    -0x898e(%ebx),%eax
c0021be9:	50                   	push   %eax
c0021bea:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0021bf0:	50                   	push   %eax
c0021bf1:	8d 83 50 77 ff ff    	lea    -0x88b0(%ebx),%eax
c0021bf7:	50                   	push   %eax
c0021bf8:	68 7d 02 00 00       	push   $0x27d
c0021bfd:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0021c03:	50                   	push   %eax
c0021c04:	e8 5b 9b 00 00       	call   c002b764 <debug_panic>
      palloc_free_page (prev);
c0021c09:	83 ec 0c             	sub    $0xc,%esp
c0021c0c:	ff 75 08             	push   0x8(%ebp)
c0021c0f:	e8 b8 28 00 00       	call   c00244cc <palloc_free_page>
c0021c14:	83 c4 10             	add    $0x10,%esp
    }
}
c0021c17:	90                   	nop
c0021c18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021c1b:	c9                   	leave  
c0021c1c:	c3                   	ret    

c0021c1d <schedule>:

   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule (void) 
{
c0021c1d:	55                   	push   %ebp
c0021c1e:	89 e5                	mov    %esp,%ebp
c0021c20:	53                   	push   %ebx
c0021c21:	83 ec 14             	sub    $0x14,%esp
c0021c24:	e8 03 f8 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021c29:	81 c3 4f 87 01 00    	add    $0x1874f,%ebx
  struct thread *cur = running_thread ();
c0021c2f:	e8 15 fc ff ff       	call   c0021849 <running_thread>
c0021c34:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread *next = next_thread_to_run ();
c0021c37:	e8 d3 fe ff ff       	call   c0021b0f <next_thread_to_run>
c0021c3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread *prev = NULL;
c0021c3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0021c46:	e8 02 02 00 00       	call   c0021e4d <intr_get_level>
c0021c4b:	85 c0                	test   %eax,%eax
c0021c4d:	74 29                	je     c0021c78 <schedule+0x5b>
c0021c4f:	83 ec 0c             	sub    $0xc,%esp
c0021c52:	8d 83 f0 74 ff ff    	lea    -0x8b10(%ebx),%eax
c0021c58:	50                   	push   %eax
c0021c59:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0021c5f:	50                   	push   %eax
c0021c60:	8d 83 68 77 ff ff    	lea    -0x8898(%ebx),%eax
c0021c66:	50                   	push   %eax
c0021c67:	68 90 02 00 00       	push   $0x290
c0021c6c:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0021c72:	50                   	push   %eax
c0021c73:	e8 ec 9a 00 00       	call   c002b764 <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c0021c78:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021c7b:	8b 40 04             	mov    0x4(%eax),%eax
c0021c7e:	85 c0                	test   %eax,%eax
c0021c80:	75 29                	jne    c0021cab <schedule+0x8e>
c0021c82:	83 ec 0c             	sub    $0xc,%esp
c0021c85:	8d 83 7e 76 ff ff    	lea    -0x8982(%ebx),%eax
c0021c8b:	50                   	push   %eax
c0021c8c:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0021c92:	50                   	push   %eax
c0021c93:	8d 83 68 77 ff ff    	lea    -0x8898(%ebx),%eax
c0021c99:	50                   	push   %eax
c0021c9a:	68 91 02 00 00       	push   $0x291
c0021c9f:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0021ca5:	50                   	push   %eax
c0021ca6:	e8 b9 9a 00 00       	call   c002b764 <debug_panic>
  ASSERT (is_thread (next));
c0021cab:	83 ec 0c             	sub    $0xc,%esp
c0021cae:	ff 75 ec             	push   -0x14(%ebp)
c0021cb1:	e8 b5 fb ff ff       	call   c002186b <is_thread>
c0021cb6:	83 c4 10             	add    $0x10,%esp
c0021cb9:	84 c0                	test   %al,%al
c0021cbb:	75 29                	jne    c0021ce6 <schedule+0xc9>
c0021cbd:	83 ec 0c             	sub    $0xc,%esp
c0021cc0:	8d 83 9c 76 ff ff    	lea    -0x8964(%ebx),%eax
c0021cc6:	50                   	push   %eax
c0021cc7:	8d 83 0e 75 ff ff    	lea    -0x8af2(%ebx),%eax
c0021ccd:	50                   	push   %eax
c0021cce:	8d 83 68 77 ff ff    	lea    -0x8898(%ebx),%eax
c0021cd4:	50                   	push   %eax
c0021cd5:	68 92 02 00 00       	push   $0x292
c0021cda:	8d 83 25 75 ff ff    	lea    -0x8adb(%ebx),%eax
c0021ce0:	50                   	push   %eax
c0021ce1:	e8 7e 9a 00 00       	call   c002b764 <debug_panic>

  if (cur != next)
c0021ce6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021ce9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0021cec:	74 14                	je     c0021d02 <schedule+0xe5>
    prev = switch_threads (cur, next);
c0021cee:	83 ec 08             	sub    $0x8,%esp
c0021cf1:	ff 75 ec             	push   -0x14(%ebp)
c0021cf4:	ff 75 f0             	push   -0x10(%ebp)
c0021cf7:	e8 fc 00 00 00       	call   c0021df8 <switch_threads>
c0021cfc:	83 c4 10             	add    $0x10,%esp
c0021cff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread_schedule_tail (prev);
c0021d02:	83 ec 0c             	sub    $0xc,%esp
c0021d05:	ff 75 f4             	push   -0xc(%ebp)
c0021d08:	e8 4f fe ff ff       	call   c0021b5c <thread_schedule_tail>
c0021d0d:	83 c4 10             	add    $0x10,%esp
}
c0021d10:	90                   	nop
c0021d11:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021d14:	c9                   	leave  
c0021d15:	c3                   	ret    

c0021d16 <allocate_tid>:

/* Returns a tid to use for a new thread. */
static tid_t
allocate_tid (void) 
{
c0021d16:	55                   	push   %ebp
c0021d17:	89 e5                	mov    %esp,%ebp
c0021d19:	53                   	push   %ebx
c0021d1a:	83 ec 14             	sub    $0x14,%esp
c0021d1d:	e8 0a f7 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021d22:	81 c3 56 86 01 00    	add    $0x18656,%ebx
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c0021d28:	83 ec 0c             	sub    $0xc,%esp
c0021d2b:	8d 83 80 08 00 00    	lea    0x880(%ebx),%eax
c0021d31:	50                   	push   %eax
c0021d32:	e8 00 1b 00 00       	call   c0023837 <lock_acquire>
c0021d37:	83 c4 10             	add    $0x10,%esp
  tid = next_tid++;
c0021d3a:	8b 83 f8 fb ff ff    	mov    -0x408(%ebx),%eax
c0021d40:	8d 50 01             	lea    0x1(%eax),%edx
c0021d43:	89 93 f8 fb ff ff    	mov    %edx,-0x408(%ebx)
c0021d49:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lock_release (&tid_lock);
c0021d4c:	83 ec 0c             	sub    $0xc,%esp
c0021d4f:	8d 83 80 08 00 00    	lea    0x880(%ebx),%eax
c0021d55:	50                   	push   %eax
c0021d56:	e8 8a 1d 00 00       	call   c0023ae5 <lock_release>
c0021d5b:	83 c4 10             	add    $0x10,%esp

  return tid;
c0021d5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0021d61:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021d64:	c9                   	leave  
c0021d65:	c3                   	ret    

c0021d66 <cmp_waketick>:
/* Offset of `stack' member within `struct thread'.
   Used by switch.S, which can't figure it out on its own. */
uint32_t thread_stack_ofs = offsetof (struct thread, stack);

bool cmp_waketick(struct list_elem *first, struct list_elem *second, void *aux)
{
c0021d66:	55                   	push   %ebp
c0021d67:	89 e5                	mov    %esp,%ebp
c0021d69:	56                   	push   %esi
c0021d6a:	53                   	push   %ebx
c0021d6b:	83 ec 10             	sub    $0x10,%esp
c0021d6e:	e8 b5 f6 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021d73:	05 05 86 01 00       	add    $0x18605,%eax
  struct thread *fthread = list_entry (first, struct thread, elem);
c0021d78:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d7b:	83 c0 04             	add    $0x4,%eax
c0021d7e:	83 e8 2c             	sub    $0x2c,%eax
c0021d81:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct thread *sthread = list_entry (second, struct thread, elem);
c0021d84:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021d87:	83 c0 04             	add    $0x4,%eax
c0021d8a:	83 e8 2c             	sub    $0x2c,%eax
c0021d8d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  return fthread->waketick < sthread->waketick;
c0021d90:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021d93:	8b 50 3c             	mov    0x3c(%eax),%edx
c0021d96:	8b 40 38             	mov    0x38(%eax),%eax
c0021d99:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c0021d9c:	8b 59 3c             	mov    0x3c(%ecx),%ebx
c0021d9f:	8b 49 38             	mov    0x38(%ecx),%ecx
c0021da2:	be 01 00 00 00       	mov    $0x1,%esi
c0021da7:	39 c8                	cmp    %ecx,%eax
c0021da9:	89 d0                	mov    %edx,%eax
c0021dab:	19 d8                	sbb    %ebx,%eax
c0021dad:	7c 05                	jl     c0021db4 <cmp_waketick+0x4e>
c0021daf:	be 00 00 00 00       	mov    $0x0,%esi
c0021db4:	89 f0                	mov    %esi,%eax

}
c0021db6:	83 c4 10             	add    $0x10,%esp
c0021db9:	5b                   	pop    %ebx
c0021dba:	5e                   	pop    %esi
c0021dbb:	5d                   	pop    %ebp
c0021dbc:	c3                   	ret    

c0021dbd <cmp_priority>:

bool cmp_priority(struct list_elem *first, struct list_elem *second, void *aux)
{
c0021dbd:	55                   	push   %ebp
c0021dbe:	89 e5                	mov    %esp,%ebp
c0021dc0:	83 ec 10             	sub    $0x10,%esp
c0021dc3:	e8 60 f6 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021dc8:	05 b0 85 01 00       	add    $0x185b0,%eax
  struct thread *fthread = list_entry (first, struct thread, elem);
c0021dcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0021dd0:	83 c0 04             	add    $0x4,%eax
c0021dd3:	83 e8 2c             	sub    $0x2c,%eax
c0021dd6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  struct thread *sthread = list_entry (second, struct thread, elem);
c0021dd9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021ddc:	83 c0 04             	add    $0x4,%eax
c0021ddf:	83 e8 2c             	sub    $0x2c,%eax
c0021de2:	89 45 f8             	mov    %eax,-0x8(%ebp)

  return fthread->priority > sthread->priority;
c0021de5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0021de8:	8b 50 1c             	mov    0x1c(%eax),%edx
c0021deb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0021dee:	8b 40 1c             	mov    0x1c(%eax),%eax
c0021df1:	39 c2                	cmp    %eax,%edx
c0021df3:	0f 9f c0             	setg   %al

c0021df6:	c9                   	leave  
c0021df7:	c3                   	ret    

c0021df8 <switch_threads>:
c0021df8:	53                   	push   %ebx
c0021df9:	55                   	push   %ebp
c0021dfa:	56                   	push   %esi
c0021dfb:	57                   	push   %edi
c0021dfc:	8b 15 6c 9f 03 c0    	mov    0xc0039f6c,%edx
c0021e02:	8b 44 24 14          	mov    0x14(%esp),%eax
c0021e06:	89 24 10             	mov    %esp,(%eax,%edx,1)
c0021e09:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c0021e0d:	8b 24 11             	mov    (%ecx,%edx,1),%esp
c0021e10:	5f                   	pop    %edi
c0021e11:	5e                   	pop    %esi
c0021e12:	5d                   	pop    %ebp
c0021e13:	5b                   	pop    %ebx
c0021e14:	c3                   	ret    

c0021e15 <switch_entry>:
c0021e15:	83 c4 08             	add    $0x8,%esp
c0021e18:	50                   	push   %eax
c0021e19:	e8 3e fd ff ff       	call   c0021b5c <thread_schedule_tail>
c0021e1e:	83 c4 04             	add    $0x4,%esp
c0021e21:	c3                   	ret    

c0021e22 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0021e22:	55                   	push   %ebp
c0021e23:	89 e5                	mov    %esp,%ebp
c0021e25:	83 ec 08             	sub    $0x8,%esp
c0021e28:	e8 fb f5 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021e2d:	05 4b 85 01 00       	add    $0x1854b,%eax
c0021e32:	8b 45 08             	mov    0x8(%ebp),%eax
c0021e35:	8b 55 0c             	mov    0xc(%ebp),%edx
c0021e38:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0021e3c:	89 d0                	mov    %edx,%eax
c0021e3e:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021e41:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0021e45:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0021e49:	ee                   	out    %al,(%dx)
}
c0021e4a:	90                   	nop
c0021e4b:	c9                   	leave  
c0021e4c:	c3                   	ret    

c0021e4d <intr_get_level>:
static void unexpected_interrupt (const struct intr_frame *);

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
c0021e4d:	55                   	push   %ebp
c0021e4e:	89 e5                	mov    %esp,%ebp
c0021e50:	83 ec 10             	sub    $0x10,%esp
c0021e53:	e8 d0 f5 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021e58:	05 20 85 01 00       	add    $0x18520,%eax

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021e5d:	9c                   	pushf  
c0021e5e:	58                   	pop    %eax
c0021e5f:	89 45 fc             	mov    %eax,-0x4(%ebp)

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021e62:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0021e65:	c1 e8 09             	shr    $0x9,%eax
c0021e68:	83 e0 01             	and    $0x1,%eax
}
c0021e6b:	c9                   	leave  
c0021e6c:	c3                   	ret    

c0021e6d <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c0021e6d:	55                   	push   %ebp
c0021e6e:	89 e5                	mov    %esp,%ebp
c0021e70:	83 ec 08             	sub    $0x8,%esp
c0021e73:	e8 b0 f5 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021e78:	05 00 85 01 00       	add    $0x18500,%eax
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021e7d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0021e81:	75 07                	jne    c0021e8a <intr_set_level+0x1d>
c0021e83:	e8 09 00 00 00       	call   c0021e91 <intr_enable>
c0021e88:	eb 05                	jmp    c0021e8f <intr_set_level+0x22>
c0021e8a:	e8 57 00 00 00       	call   c0021ee6 <intr_disable>
}
c0021e8f:	c9                   	leave  
c0021e90:	c3                   	ret    

c0021e91 <intr_enable>:

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c0021e91:	55                   	push   %ebp
c0021e92:	89 e5                	mov    %esp,%ebp
c0021e94:	53                   	push   %ebx
c0021e95:	83 ec 14             	sub    $0x14,%esp
c0021e98:	e8 8f f5 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021e9d:	81 c3 db 84 01 00    	add    $0x184db,%ebx
  enum intr_level old_level = intr_get_level ();
c0021ea3:	e8 a5 ff ff ff       	call   c0021e4d <intr_get_level>
c0021ea8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (!intr_context ());
c0021eab:	e8 94 03 00 00       	call   c0022244 <intr_context>
c0021eb0:	83 f0 01             	xor    $0x1,%eax
c0021eb3:	84 c0                	test   %al,%al
c0021eb5:	75 26                	jne    c0021edd <intr_enable+0x4c>
c0021eb7:	83 ec 0c             	sub    $0xc,%esp
c0021eba:	8d 83 74 77 ff ff    	lea    -0x888c(%ebx),%eax
c0021ec0:	50                   	push   %eax
c0021ec1:	8d 83 85 77 ff ff    	lea    -0x887b(%ebx),%eax
c0021ec7:	50                   	push   %eax
c0021ec8:	8d 83 84 7b ff ff    	lea    -0x847c(%ebx),%eax
c0021ece:	50                   	push   %eax
c0021ecf:	6a 5b                	push   $0x5b
c0021ed1:	8d 83 9c 77 ff ff    	lea    -0x8864(%ebx),%eax
c0021ed7:	50                   	push   %eax
c0021ed8:	e8 87 98 00 00       	call   c002b764 <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c0021edd:	fb                   	sti    

  return old_level;
c0021ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0021ee1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021ee4:	c9                   	leave  
c0021ee5:	c3                   	ret    

c0021ee6 <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
c0021ee6:	55                   	push   %ebp
c0021ee7:	89 e5                	mov    %esp,%ebp
c0021ee9:	83 ec 10             	sub    $0x10,%esp
c0021eec:	e8 37 f5 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0021ef1:	05 87 84 01 00       	add    $0x18487,%eax
  enum intr_level old_level = intr_get_level ();
c0021ef6:	e8 52 ff ff ff       	call   c0021e4d <intr_get_level>
c0021efb:	89 45 fc             	mov    %eax,-0x4(%ebp)

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c0021efe:	fa                   	cli    

  return old_level;
c0021eff:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0021f02:	c9                   	leave  
c0021f03:	c3                   	ret    

c0021f04 <intr_init>:

/* Initializes the interrupt system. */
void
intr_init (void)
{
c0021f04:	55                   	push   %ebp
c0021f05:	89 e5                	mov    %esp,%ebp
c0021f07:	53                   	push   %ebx
c0021f08:	83 ec 14             	sub    $0x14,%esp
c0021f0b:	e8 1c f5 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0021f10:	81 c3 68 84 01 00    	add    $0x18468,%ebx
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();
c0021f16:	e8 90 03 00 00       	call   c00222ab <pic_init>

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c0021f1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0021f22:	eb 2f                	jmp    c0021f53 <intr_init+0x4f>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c0021f24:	c7 c0 74 9f 03 c0    	mov    $0xc0039f74,%eax
c0021f2a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0021f2d:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0021f30:	83 ec 08             	sub    $0x8,%esp
c0021f33:	6a 00                	push   $0x0
c0021f35:	50                   	push   %eax
c0021f36:	e8 b3 05 00 00       	call   c00224ee <make_intr_gate>
c0021f3b:	83 c4 10             	add    $0x10,%esp
c0021f3e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0021f41:	89 84 cb c8 08 00 00 	mov    %eax,0x8c8(%ebx,%ecx,8)
c0021f48:	89 94 cb cc 08 00 00 	mov    %edx,0x8cc(%ebx,%ecx,8)
  for (i = 0; i < INTR_CNT; i++)
c0021f4f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0021f53:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c0021f5a:	7e c8                	jle    c0021f24 <intr_init+0x20>

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c0021f5c:	83 ec 08             	sub    $0x8,%esp
c0021f5f:	8d 83 c8 08 00 00    	lea    0x8c8(%ebx),%eax
c0021f65:	50                   	push   %eax
c0021f66:	68 ff 07 00 00       	push   $0x7ff
c0021f6b:	e8 c8 05 00 00       	call   c0022538 <make_idtr_operand>
c0021f70:	83 c4 10             	add    $0x10,%esp
c0021f73:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0021f76:	89 55 ec             	mov    %edx,-0x14(%ebp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021f79:	0f 01 5d e8          	lidtl  -0x18(%ebp)

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c0021f7d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0021f84:	eb 14                	jmp    c0021f9a <intr_init+0x96>
    intr_names[i] = "unknown";
c0021f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021f89:	8d 93 b6 77 ff ff    	lea    -0x884a(%ebx),%edx
c0021f8f:	89 94 83 c8 14 00 00 	mov    %edx,0x14c8(%ebx,%eax,4)
  for (i = 0; i < INTR_CNT; i++)
c0021f96:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0021f9a:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c0021fa1:	7e e3                	jle    c0021f86 <intr_init+0x82>
  intr_names[0] = "#DE Divide Error";
c0021fa3:	8d 83 be 77 ff ff    	lea    -0x8842(%ebx),%eax
c0021fa9:	89 83 c8 14 00 00    	mov    %eax,0x14c8(%ebx)
  intr_names[1] = "#DB Debug Exception";
c0021faf:	8d 83 cf 77 ff ff    	lea    -0x8831(%ebx),%eax
c0021fb5:	89 83 cc 14 00 00    	mov    %eax,0x14cc(%ebx)
  intr_names[2] = "NMI Interrupt";
c0021fbb:	8d 83 e3 77 ff ff    	lea    -0x881d(%ebx),%eax
c0021fc1:	89 83 d0 14 00 00    	mov    %eax,0x14d0(%ebx)
  intr_names[3] = "#BP Breakpoint Exception";
c0021fc7:	8d 83 f1 77 ff ff    	lea    -0x880f(%ebx),%eax
c0021fcd:	89 83 d4 14 00 00    	mov    %eax,0x14d4(%ebx)
  intr_names[4] = "#OF Overflow Exception";
c0021fd3:	8d 83 0a 78 ff ff    	lea    -0x87f6(%ebx),%eax
c0021fd9:	89 83 d8 14 00 00    	mov    %eax,0x14d8(%ebx)
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021fdf:	8d 83 24 78 ff ff    	lea    -0x87dc(%ebx),%eax
c0021fe5:	89 83 dc 14 00 00    	mov    %eax,0x14dc(%ebx)
  intr_names[6] = "#UD Invalid Opcode Exception";
c0021feb:	8d 83 47 78 ff ff    	lea    -0x87b9(%ebx),%eax
c0021ff1:	89 83 e0 14 00 00    	mov    %eax,0x14e0(%ebx)
  intr_names[7] = "#NM Device Not Available Exception";
c0021ff7:	8d 83 64 78 ff ff    	lea    -0x879c(%ebx),%eax
c0021ffd:	89 83 e4 14 00 00    	mov    %eax,0x14e4(%ebx)
  intr_names[8] = "#DF Double Fault Exception";
c0022003:	8d 83 87 78 ff ff    	lea    -0x8779(%ebx),%eax
c0022009:	89 83 e8 14 00 00    	mov    %eax,0x14e8(%ebx)
  intr_names[9] = "Coprocessor Segment Overrun";
c002200f:	8d 83 a2 78 ff ff    	lea    -0x875e(%ebx),%eax
c0022015:	89 83 ec 14 00 00    	mov    %eax,0x14ec(%ebx)
  intr_names[10] = "#TS Invalid TSS Exception";
c002201b:	8d 83 be 78 ff ff    	lea    -0x8742(%ebx),%eax
c0022021:	89 83 f0 14 00 00    	mov    %eax,0x14f0(%ebx)
  intr_names[11] = "#NP Segment Not Present";
c0022027:	8d 83 d8 78 ff ff    	lea    -0x8728(%ebx),%eax
c002202d:	89 83 f4 14 00 00    	mov    %eax,0x14f4(%ebx)
  intr_names[12] = "#SS Stack Fault Exception";
c0022033:	8d 83 f0 78 ff ff    	lea    -0x8710(%ebx),%eax
c0022039:	89 83 f8 14 00 00    	mov    %eax,0x14f8(%ebx)
  intr_names[13] = "#GP General Protection Exception";
c002203f:	8d 83 0c 79 ff ff    	lea    -0x86f4(%ebx),%eax
c0022045:	89 83 fc 14 00 00    	mov    %eax,0x14fc(%ebx)
  intr_names[14] = "#PF Page-Fault Exception";
c002204b:	8d 83 2d 79 ff ff    	lea    -0x86d3(%ebx),%eax
c0022051:	89 83 00 15 00 00    	mov    %eax,0x1500(%ebx)
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0022057:	8d 83 48 79 ff ff    	lea    -0x86b8(%ebx),%eax
c002205d:	89 83 08 15 00 00    	mov    %eax,0x1508(%ebx)
  intr_names[17] = "#AC Alignment Check Exception";
c0022063:	8d 83 69 79 ff ff    	lea    -0x8697(%ebx),%eax
c0022069:	89 83 0c 15 00 00    	mov    %eax,0x150c(%ebx)
  intr_names[18] = "#MC Machine-Check Exception";
c002206f:	8d 83 87 79 ff ff    	lea    -0x8679(%ebx),%eax
c0022075:	89 83 10 15 00 00    	mov    %eax,0x1510(%ebx)
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c002207b:	8d 83 a4 79 ff ff    	lea    -0x865c(%ebx),%eax
c0022081:	89 83 14 15 00 00    	mov    %eax,0x1514(%ebx)
}
c0022087:	90                   	nop
c0022088:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002208b:	c9                   	leave  
c002208c:	c3                   	ret    

c002208d <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c002208d:	55                   	push   %ebp
c002208e:	89 e5                	mov    %esp,%ebp
c0022090:	56                   	push   %esi
c0022091:	53                   	push   %ebx
c0022092:	83 ec 10             	sub    $0x10,%esp
c0022095:	e8 92 f3 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002209a:	81 c3 de 82 01 00    	add    $0x182de,%ebx
c00220a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00220a3:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_handlers[vec_no] == NULL);
c00220a6:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00220aa:	8b 84 83 c8 10 00 00 	mov    0x10c8(%ebx,%eax,4),%eax
c00220b1:	85 c0                	test   %eax,%eax
c00220b3:	74 29                	je     c00220de <register_handler+0x51>
c00220b5:	83 ec 0c             	sub    $0xc,%esp
c00220b8:	8d 83 c6 79 ff ff    	lea    -0x863a(%ebx),%eax
c00220be:	50                   	push   %eax
c00220bf:	8d 83 85 77 ff ff    	lea    -0x887b(%ebx),%eax
c00220c5:	50                   	push   %eax
c00220c6:	8d 83 90 7b ff ff    	lea    -0x8470(%ebx),%eax
c00220cc:	50                   	push   %eax
c00220cd:	68 a8 00 00 00       	push   $0xa8
c00220d2:	8d 83 9c 77 ff ff    	lea    -0x8864(%ebx),%eax
c00220d8:	50                   	push   %eax
c00220d9:	e8 86 96 00 00       	call   c002b764 <debug_panic>
  if (level == INTR_ON)
c00220de:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c00220e2:	75 30                	jne    c0022114 <register_handler+0x87>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c00220e4:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c00220e8:	c7 c0 74 9f 03 c0    	mov    $0xc0039f74,%eax
c00220ee:	8b 04 90             	mov    (%eax,%edx,4),%eax
c00220f1:	0f b6 75 f4          	movzbl -0xc(%ebp),%esi
c00220f5:	83 ec 08             	sub    $0x8,%esp
c00220f8:	ff 75 0c             	push   0xc(%ebp)
c00220fb:	50                   	push   %eax
c00220fc:	e8 12 04 00 00       	call   c0022513 <make_trap_gate>
c0022101:	83 c4 10             	add    $0x10,%esp
c0022104:	89 84 f3 c8 08 00 00 	mov    %eax,0x8c8(%ebx,%esi,8)
c002210b:	89 94 f3 cc 08 00 00 	mov    %edx,0x8cc(%ebx,%esi,8)
c0022112:	eb 2e                	jmp    c0022142 <register_handler+0xb5>
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0022114:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0022118:	c7 c0 74 9f 03 c0    	mov    $0xc0039f74,%eax
c002211e:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0022121:	0f b6 75 f4          	movzbl -0xc(%ebp),%esi
c0022125:	83 ec 08             	sub    $0x8,%esp
c0022128:	ff 75 0c             	push   0xc(%ebp)
c002212b:	50                   	push   %eax
c002212c:	e8 bd 03 00 00       	call   c00224ee <make_intr_gate>
c0022131:	83 c4 10             	add    $0x10,%esp
c0022134:	89 84 f3 c8 08 00 00 	mov    %eax,0x8c8(%ebx,%esi,8)
c002213b:	89 94 f3 cc 08 00 00 	mov    %edx,0x8cc(%ebx,%esi,8)
  intr_handlers[vec_no] = handler;
c0022142:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0022146:	8b 55 14             	mov    0x14(%ebp),%edx
c0022149:	89 94 83 c8 10 00 00 	mov    %edx,0x10c8(%ebx,%eax,4)
  intr_names[vec_no] = name;
c0022150:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0022154:	8b 55 18             	mov    0x18(%ebp),%edx
c0022157:	89 94 83 c8 14 00 00 	mov    %edx,0x14c8(%ebx,%eax,4)
}
c002215e:	90                   	nop
c002215f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0022162:	5b                   	pop    %ebx
c0022163:	5e                   	pop    %esi
c0022164:	5d                   	pop    %ebp
c0022165:	c3                   	ret    

c0022166 <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c0022166:	55                   	push   %ebp
c0022167:	89 e5                	mov    %esp,%ebp
c0022169:	53                   	push   %ebx
c002216a:	83 ec 14             	sub    $0x14,%esp
c002216d:	e8 b6 f2 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0022172:	05 06 82 01 00       	add    $0x18206,%eax
c0022177:	8b 55 08             	mov    0x8(%ebp),%edx
c002217a:	88 55 f4             	mov    %dl,-0xc(%ebp)
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c002217d:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0022181:	76 06                	jbe    c0022189 <intr_register_ext+0x23>
c0022183:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0022187:	76 2b                	jbe    c00221b4 <intr_register_ext+0x4e>
c0022189:	83 ec 0c             	sub    $0xc,%esp
c002218c:	8d 90 e4 79 ff ff    	lea    -0x861c(%eax),%edx
c0022192:	52                   	push   %edx
c0022193:	8d 90 85 77 ff ff    	lea    -0x887b(%eax),%edx
c0022199:	52                   	push   %edx
c002219a:	8d 90 a4 7b ff ff    	lea    -0x845c(%eax),%edx
c00221a0:	52                   	push   %edx
c00221a1:	68 b8 00 00 00       	push   $0xb8
c00221a6:	8d 90 9c 77 ff ff    	lea    -0x8864(%eax),%edx
c00221ac:	52                   	push   %edx
c00221ad:	89 c3                	mov    %eax,%ebx
c00221af:	e8 b0 95 00 00       	call   c002b764 <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c00221b4:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00221b8:	83 ec 0c             	sub    $0xc,%esp
c00221bb:	ff 75 10             	push   0x10(%ebp)
c00221be:	ff 75 0c             	push   0xc(%ebp)
c00221c1:	6a 00                	push   $0x0
c00221c3:	6a 00                	push   $0x0
c00221c5:	50                   	push   %eax
c00221c6:	e8 c2 fe ff ff       	call   c002208d <register_handler>
c00221cb:	83 c4 20             	add    $0x20,%esp
}
c00221ce:	90                   	nop
c00221cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00221d2:	c9                   	leave  
c00221d3:	c3                   	ret    

c00221d4 <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c00221d4:	55                   	push   %ebp
c00221d5:	89 e5                	mov    %esp,%ebp
c00221d7:	53                   	push   %ebx
c00221d8:	83 ec 14             	sub    $0x14,%esp
c00221db:	e8 48 f2 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00221e0:	05 98 81 01 00       	add    $0x18198,%eax
c00221e5:	8b 55 08             	mov    0x8(%ebp),%edx
c00221e8:	88 55 f4             	mov    %dl,-0xc(%ebp)
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c00221eb:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c00221ef:	76 31                	jbe    c0022222 <intr_register_int+0x4e>
c00221f1:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c00221f5:	77 2b                	ja     c0022222 <intr_register_int+0x4e>
c00221f7:	83 ec 0c             	sub    $0xc,%esp
c00221fa:	8d 90 08 7a ff ff    	lea    -0x85f8(%eax),%edx
c0022200:	52                   	push   %edx
c0022201:	8d 90 85 77 ff ff    	lea    -0x887b(%eax),%edx
c0022207:	52                   	push   %edx
c0022208:	8d 90 b8 7b ff ff    	lea    -0x8448(%eax),%edx
c002220e:	52                   	push   %edx
c002220f:	68 cd 00 00 00       	push   $0xcd
c0022214:	8d 90 9c 77 ff ff    	lea    -0x8864(%eax),%edx
c002221a:	52                   	push   %edx
c002221b:	89 c3                	mov    %eax,%ebx
c002221d:	e8 42 95 00 00       	call   c002b764 <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c0022222:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0022226:	83 ec 0c             	sub    $0xc,%esp
c0022229:	ff 75 18             	push   0x18(%ebp)
c002222c:	ff 75 14             	push   0x14(%ebp)
c002222f:	ff 75 10             	push   0x10(%ebp)
c0022232:	ff 75 0c             	push   0xc(%ebp)
c0022235:	50                   	push   %eax
c0022236:	e8 52 fe ff ff       	call   c002208d <register_handler>
c002223b:	83 c4 20             	add    $0x20,%esp
}
c002223e:	90                   	nop
c002223f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0022242:	c9                   	leave  
c0022243:	c3                   	ret    

c0022244 <intr_context>:

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
c0022244:	55                   	push   %ebp
c0022245:	89 e5                	mov    %esp,%ebp
c0022247:	e8 dc f1 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002224c:	05 2c 81 01 00       	add    $0x1812c,%eax
  return in_external_intr;
c0022251:	0f b6 80 c8 1c 00 00 	movzbl 0x1cc8(%eax),%eax
}
c0022258:	5d                   	pop    %ebp
c0022259:	c3                   	ret    

c002225a <intr_yield_on_return>:
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c002225a:	55                   	push   %ebp
c002225b:	89 e5                	mov    %esp,%ebp
c002225d:	53                   	push   %ebx
c002225e:	83 ec 04             	sub    $0x4,%esp
c0022261:	e8 c6 f1 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0022266:	81 c3 12 81 01 00    	add    $0x18112,%ebx
  ASSERT (intr_context ());
c002226c:	e8 d3 ff ff ff       	call   c0022244 <intr_context>
c0022271:	84 c0                	test   %al,%al
c0022273:	75 29                	jne    c002229e <intr_yield_on_return+0x44>
c0022275:	83 ec 0c             	sub    $0xc,%esp
c0022278:	8d 83 27 7a ff ff    	lea    -0x85d9(%ebx),%eax
c002227e:	50                   	push   %eax
c002227f:	8d 83 85 77 ff ff    	lea    -0x887b(%ebx),%eax
c0022285:	50                   	push   %eax
c0022286:	8d 83 cc 7b ff ff    	lea    -0x8434(%ebx),%eax
c002228c:	50                   	push   %eax
c002228d:	68 e0 00 00 00       	push   $0xe0
c0022292:	8d 83 9c 77 ff ff    	lea    -0x8864(%ebx),%eax
c0022298:	50                   	push   %eax
c0022299:	e8 c6 94 00 00       	call   c002b764 <debug_panic>
  yield_on_return = true;
c002229e:	c6 83 c9 1c 00 00 01 	movb   $0x1,0x1cc9(%ebx)
}
c00222a5:	90                   	nop
c00222a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00222a9:	c9                   	leave  
c00222aa:	c3                   	ret    

c00222ab <pic_init>:
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
c00222ab:	55                   	push   %ebp
c00222ac:	89 e5                	mov    %esp,%ebp
c00222ae:	e8 75 f1 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00222b3:	05 c5 80 01 00       	add    $0x180c5,%eax
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
c00222b8:	68 ff 00 00 00       	push   $0xff
c00222bd:	6a 21                	push   $0x21
c00222bf:	e8 5e fb ff ff       	call   c0021e22 <outb>
c00222c4:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0xff);
c00222c7:	68 ff 00 00 00       	push   $0xff
c00222cc:	68 a1 00 00 00       	push   $0xa1
c00222d1:	e8 4c fb ff ff       	call   c0021e22 <outb>
c00222d6:	83 c4 08             	add    $0x8,%esp

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c00222d9:	6a 11                	push   $0x11
c00222db:	6a 20                	push   $0x20
c00222dd:	e8 40 fb ff ff       	call   c0021e22 <outb>
c00222e2:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
c00222e5:	6a 20                	push   $0x20
c00222e7:	6a 21                	push   $0x21
c00222e9:	e8 34 fb ff ff       	call   c0021e22 <outb>
c00222ee:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
c00222f1:	6a 04                	push   $0x4
c00222f3:	6a 21                	push   $0x21
c00222f5:	e8 28 fb ff ff       	call   c0021e22 <outb>
c00222fa:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c00222fd:	6a 01                	push   $0x1
c00222ff:	6a 21                	push   $0x21
c0022301:	e8 1c fb ff ff       	call   c0021e22 <outb>
c0022306:	83 c4 08             	add    $0x8,%esp

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0022309:	6a 11                	push   $0x11
c002230b:	68 a0 00 00 00       	push   $0xa0
c0022310:	e8 0d fb ff ff       	call   c0021e22 <outb>
c0022315:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
c0022318:	6a 28                	push   $0x28
c002231a:	68 a1 00 00 00       	push   $0xa1
c002231f:	e8 fe fa ff ff       	call   c0021e22 <outb>
c0022324:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
c0022327:	6a 02                	push   $0x2
c0022329:	68 a1 00 00 00       	push   $0xa1
c002232e:	e8 ef fa ff ff       	call   c0021e22 <outb>
c0022333:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0022336:	6a 01                	push   $0x1
c0022338:	68 a1 00 00 00       	push   $0xa1
c002233d:	e8 e0 fa ff ff       	call   c0021e22 <outb>
c0022342:	83 c4 08             	add    $0x8,%esp

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
c0022345:	6a 00                	push   $0x0
c0022347:	6a 21                	push   $0x21
c0022349:	e8 d4 fa ff ff       	call   c0021e22 <outb>
c002234e:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x00);
c0022351:	6a 00                	push   $0x0
c0022353:	68 a1 00 00 00       	push   $0xa1
c0022358:	e8 c5 fa ff ff       	call   c0021e22 <outb>
c002235d:	83 c4 08             	add    $0x8,%esp
}
c0022360:	90                   	nop
c0022361:	c9                   	leave  
c0022362:	c3                   	ret    

c0022363 <pic_end_of_interrupt>:
/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
c0022363:	55                   	push   %ebp
c0022364:	89 e5                	mov    %esp,%ebp
c0022366:	53                   	push   %ebx
c0022367:	83 ec 04             	sub    $0x4,%esp
c002236a:	e8 b9 f0 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002236f:	05 09 80 01 00       	add    $0x18009,%eax
  ASSERT (irq >= 0x20 && irq < 0x30);
c0022374:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0022378:	7e 06                	jle    c0022380 <pic_end_of_interrupt+0x1d>
c002237a:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c002237e:	7e 2b                	jle    c00223ab <pic_end_of_interrupt+0x48>
c0022380:	83 ec 0c             	sub    $0xc,%esp
c0022383:	8d 90 37 7a ff ff    	lea    -0x85c9(%eax),%edx
c0022389:	52                   	push   %edx
c002238a:	8d 90 85 77 ff ff    	lea    -0x887b(%eax),%edx
c0022390:	52                   	push   %edx
c0022391:	8d 90 e4 7b ff ff    	lea    -0x841c(%eax),%edx
c0022397:	52                   	push   %edx
c0022398:	68 0b 01 00 00       	push   $0x10b
c002239d:	8d 90 9c 77 ff ff    	lea    -0x8864(%eax),%edx
c00223a3:	52                   	push   %edx
c00223a4:	89 c3                	mov    %eax,%ebx
c00223a6:	e8 b9 93 00 00       	call   c002b764 <debug_panic>

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);
c00223ab:	83 ec 08             	sub    $0x8,%esp
c00223ae:	6a 20                	push   $0x20
c00223b0:	6a 20                	push   $0x20
c00223b2:	e8 6b fa ff ff       	call   c0021e22 <outb>
c00223b7:	83 c4 10             	add    $0x10,%esp

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c00223ba:	83 7d 08 27          	cmpl   $0x27,0x8(%ebp)
c00223be:	7e 12                	jle    c00223d2 <pic_end_of_interrupt+0x6f>
    outb (0xa0, 0x20);
c00223c0:	83 ec 08             	sub    $0x8,%esp
c00223c3:	6a 20                	push   $0x20
c00223c5:	68 a0 00 00 00       	push   $0xa0
c00223ca:	e8 53 fa ff ff       	call   c0021e22 <outb>
c00223cf:	83 c4 10             	add    $0x10,%esp
}
c00223d2:	90                   	nop
c00223d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00223d6:	c9                   	leave  
c00223d7:	c3                   	ret    

c00223d8 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c00223d8:	55                   	push   %ebp
c00223d9:	89 e5                	mov    %esp,%ebp
c00223db:	57                   	push   %edi
c00223dc:	56                   	push   %esi
c00223dd:	53                   	push   %ebx
c00223de:	83 ec 2c             	sub    $0x2c,%esp
c00223e1:	e8 42 f0 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00223e6:	05 92 7f 01 00       	add    $0x17f92,%eax
  uint32_t e0, e1;

  ASSERT (function != NULL);
c00223eb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00223ef:	75 2b                	jne    c002241c <make_gate+0x44>
c00223f1:	83 ec 0c             	sub    $0xc,%esp
c00223f4:	8d 90 51 7a ff ff    	lea    -0x85af(%eax),%edx
c00223fa:	52                   	push   %edx
c00223fb:	8d 90 85 77 ff ff    	lea    -0x887b(%eax),%edx
c0022401:	52                   	push   %edx
c0022402:	8d 90 fc 7b ff ff    	lea    -0x8404(%eax),%edx
c0022408:	52                   	push   %edx
c0022409:	68 2a 01 00 00       	push   $0x12a
c002240e:	8d 90 9c 77 ff ff    	lea    -0x8864(%eax),%edx
c0022414:	52                   	push   %edx
c0022415:	89 c3                	mov    %eax,%ebx
c0022417:	e8 48 93 00 00       	call   c002b764 <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c002241c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022420:	78 06                	js     c0022428 <make_gate+0x50>
c0022422:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0022426:	7e 2b                	jle    c0022453 <make_gate+0x7b>
c0022428:	83 ec 0c             	sub    $0xc,%esp
c002242b:	8d 90 62 7a ff ff    	lea    -0x859e(%eax),%edx
c0022431:	52                   	push   %edx
c0022432:	8d 90 85 77 ff ff    	lea    -0x887b(%eax),%edx
c0022438:	52                   	push   %edx
c0022439:	8d 90 fc 7b ff ff    	lea    -0x8404(%eax),%edx
c002243f:	52                   	push   %edx
c0022440:	68 2b 01 00 00       	push   $0x12b
c0022445:	8d 90 9c 77 ff ff    	lea    -0x8864(%eax),%edx
c002244b:	52                   	push   %edx
c002244c:	89 c3                	mov    %eax,%ebx
c002244e:	e8 11 93 00 00       	call   c002b764 <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0022453:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0022457:	78 06                	js     c002245f <make_gate+0x87>
c0022459:	83 7d 10 0f          	cmpl   $0xf,0x10(%ebp)
c002245d:	7e 2b                	jle    c002248a <make_gate+0xb2>
c002245f:	83 ec 0c             	sub    $0xc,%esp
c0022462:	8d 90 77 7a ff ff    	lea    -0x8589(%eax),%edx
c0022468:	52                   	push   %edx
c0022469:	8d 90 85 77 ff ff    	lea    -0x887b(%eax),%edx
c002246f:	52                   	push   %edx
c0022470:	8d 90 fc 7b ff ff    	lea    -0x8404(%eax),%edx
c0022476:	52                   	push   %edx
c0022477:	68 2c 01 00 00       	push   $0x12c
c002247c:	8d 90 9c 77 ff ff    	lea    -0x8864(%eax),%edx
c0022482:	52                   	push   %edx
c0022483:	89 c3                	mov    %eax,%ebx
c0022485:	e8 da 92 00 00       	call   c002b764 <debug_panic>

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c002248a:	8b 45 08             	mov    0x8(%ebp),%eax
c002248d:	0f b7 c0             	movzwl %ax,%eax
c0022490:	0d 00 00 08 00       	or     $0x80000,%eax
c0022495:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0022498:	8b 45 08             	mov    0x8(%ebp),%eax
c002249b:	66 b8 00 00          	mov    $0x0,%ax
c002249f:	89 c2                	mov    %eax,%edx
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c00224a1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00224a4:	c1 e0 0d             	shl    $0xd,%eax
c00224a7:	09 c2                	or     %eax,%edx
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c00224a9:	8b 45 10             	mov    0x10(%ebp),%eax
c00224ac:	c1 e0 08             	shl    $0x8,%eax
c00224af:	09 d0                	or     %edx,%eax
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00224b1:	80 cc 80             	or     $0x80,%ah
c00224b4:	89 45 e0             	mov    %eax,-0x20(%ebp)

  return e0 | ((uint64_t) e1 << 32);
c00224b7:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c00224ba:	bf 00 00 00 00       	mov    $0x0,%edi
c00224bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00224c2:	ba 00 00 00 00       	mov    $0x0,%edx
c00224c7:	89 c2                	mov    %eax,%edx
c00224c9:	b8 00 00 00 00       	mov    $0x0,%eax
c00224ce:	89 45 d0             	mov    %eax,-0x30(%ebp)
c00224d1:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c00224d4:	89 f0                	mov    %esi,%eax
c00224d6:	0b 45 d0             	or     -0x30(%ebp),%eax
c00224d9:	89 c1                	mov    %eax,%ecx
c00224db:	89 f8                	mov    %edi,%eax
c00224dd:	0b 45 d4             	or     -0x2c(%ebp),%eax
c00224e0:	89 c3                	mov    %eax,%ebx
c00224e2:	89 c8                	mov    %ecx,%eax
c00224e4:	89 da                	mov    %ebx,%edx
}
c00224e6:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00224e9:	5b                   	pop    %ebx
c00224ea:	5e                   	pop    %esi
c00224eb:	5f                   	pop    %edi
c00224ec:	5d                   	pop    %ebp
c00224ed:	c3                   	ret    

c00224ee <make_intr_gate>:

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
c00224ee:	55                   	push   %ebp
c00224ef:	89 e5                	mov    %esp,%ebp
c00224f1:	83 ec 08             	sub    $0x8,%esp
c00224f4:	e8 2f ef 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00224f9:	05 7f 7e 01 00       	add    $0x17e7f,%eax
  return make_gate (function, dpl, 14);
c00224fe:	83 ec 04             	sub    $0x4,%esp
c0022501:	6a 0e                	push   $0xe
c0022503:	ff 75 0c             	push   0xc(%ebp)
c0022506:	ff 75 08             	push   0x8(%ebp)
c0022509:	e8 ca fe ff ff       	call   c00223d8 <make_gate>
c002250e:	83 c4 10             	add    $0x10,%esp
}
c0022511:	c9                   	leave  
c0022512:	c3                   	ret    

c0022513 <make_trap_gate>:

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
c0022513:	55                   	push   %ebp
c0022514:	89 e5                	mov    %esp,%ebp
c0022516:	83 ec 08             	sub    $0x8,%esp
c0022519:	e8 0a ef 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002251e:	05 5a 7e 01 00       	add    $0x17e5a,%eax
  return make_gate (function, dpl, 15);
c0022523:	83 ec 04             	sub    $0x4,%esp
c0022526:	6a 0f                	push   $0xf
c0022528:	ff 75 0c             	push   0xc(%ebp)
c002252b:	ff 75 08             	push   0x8(%ebp)
c002252e:	e8 a5 fe ff ff       	call   c00223d8 <make_gate>
c0022533:	83 c4 10             	add    $0x10,%esp
}
c0022536:	c9                   	leave  
c0022537:	c3                   	ret    

c0022538 <make_idtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
c0022538:	55                   	push   %ebp
c0022539:	89 e5                	mov    %esp,%ebp
c002253b:	57                   	push   %edi
c002253c:	56                   	push   %esi
c002253d:	53                   	push   %ebx
c002253e:	83 ec 14             	sub    $0x14,%esp
c0022541:	e8 ee ee 00 00       	call   c0031434 <__x86.get_pc_thunk.cx>
c0022546:	81 c1 32 7e 01 00    	add    $0x17e32,%ecx
c002254c:	8b 4d 08             	mov    0x8(%ebp),%ecx
c002254f:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c0022553:	0f b7 4d ec          	movzwl -0x14(%ebp),%ecx
c0022557:	89 ce                	mov    %ecx,%esi
c0022559:	bf 00 00 00 00       	mov    $0x0,%edi
c002255e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0022561:	bb 00 00 00 00       	mov    $0x0,%ebx
c0022566:	0f a4 cb 10          	shld   $0x10,%ecx,%ebx
c002256a:	c1 e1 10             	shl    $0x10,%ecx
c002256d:	89 f0                	mov    %esi,%eax
c002256f:	09 c8                	or     %ecx,%eax
c0022571:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0022574:	89 f8                	mov    %edi,%eax
c0022576:	09 d8                	or     %ebx,%eax
c0022578:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c002257b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002257e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}
c0022581:	83 c4 14             	add    $0x14,%esp
c0022584:	5b                   	pop    %ebx
c0022585:	5e                   	pop    %esi
c0022586:	5f                   	pop    %edi
c0022587:	5d                   	pop    %ebp
c0022588:	c3                   	ret    

c0022589 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0022589:	55                   	push   %ebp
c002258a:	89 e5                	mov    %esp,%ebp
c002258c:	53                   	push   %ebx
c002258d:	83 ec 14             	sub    $0x14,%esp
c0022590:	e8 97 ee 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0022595:	81 c3 e3 7d 01 00    	add    $0x17de3,%ebx

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c002259b:	8b 45 08             	mov    0x8(%ebp),%eax
c002259e:	8b 40 30             	mov    0x30(%eax),%eax
c00225a1:	83 f8 1f             	cmp    $0x1f,%eax
c00225a4:	76 12                	jbe    c00225b8 <intr_handler+0x2f>
c00225a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00225a9:	8b 40 30             	mov    0x30(%eax),%eax
c00225ac:	83 f8 2f             	cmp    $0x2f,%eax
c00225af:	77 07                	ja     c00225b8 <intr_handler+0x2f>
c00225b1:	b8 01 00 00 00       	mov    $0x1,%eax
c00225b6:	eb 05                	jmp    c00225bd <intr_handler+0x34>
c00225b8:	b8 00 00 00 00       	mov    $0x0,%eax
c00225bd:	88 45 f7             	mov    %al,-0x9(%ebp)
c00225c0:	80 65 f7 01          	andb   $0x1,-0x9(%ebp)
  if (external) 
c00225c4:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c00225c8:	74 75                	je     c002263f <intr_handler+0xb6>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c00225ca:	e8 7e f8 ff ff       	call   c0021e4d <intr_get_level>
c00225cf:	85 c0                	test   %eax,%eax
c00225d1:	74 29                	je     c00225fc <intr_handler+0x73>
c00225d3:	83 ec 0c             	sub    $0xc,%esp
c00225d6:	8d 83 8f 7a ff ff    	lea    -0x8571(%ebx),%eax
c00225dc:	50                   	push   %eax
c00225dd:	8d 83 85 77 ff ff    	lea    -0x887b(%ebx),%eax
c00225e3:	50                   	push   %eax
c00225e4:	8d 83 08 7c ff ff    	lea    -0x83f8(%ebx),%eax
c00225ea:	50                   	push   %eax
c00225eb:	68 65 01 00 00       	push   $0x165
c00225f0:	8d 83 9c 77 ff ff    	lea    -0x8864(%ebx),%eax
c00225f6:	50                   	push   %eax
c00225f7:	e8 68 91 00 00       	call   c002b764 <debug_panic>
      ASSERT (!intr_context ());
c00225fc:	e8 43 fc ff ff       	call   c0022244 <intr_context>
c0022601:	83 f0 01             	xor    $0x1,%eax
c0022604:	84 c0                	test   %al,%al
c0022606:	75 29                	jne    c0022631 <intr_handler+0xa8>
c0022608:	83 ec 0c             	sub    $0xc,%esp
c002260b:	8d 83 74 77 ff ff    	lea    -0x888c(%ebx),%eax
c0022611:	50                   	push   %eax
c0022612:	8d 83 85 77 ff ff    	lea    -0x887b(%ebx),%eax
c0022618:	50                   	push   %eax
c0022619:	8d 83 08 7c ff ff    	lea    -0x83f8(%ebx),%eax
c002261f:	50                   	push   %eax
c0022620:	68 66 01 00 00       	push   $0x166
c0022625:	8d 83 9c 77 ff ff    	lea    -0x8864(%ebx),%eax
c002262b:	50                   	push   %eax
c002262c:	e8 33 91 00 00       	call   c002b764 <debug_panic>

      in_external_intr = true;
c0022631:	c6 83 c8 1c 00 00 01 	movb   $0x1,0x1cc8(%ebx)
      yield_on_return = false;
c0022638:	c6 83 c9 1c 00 00 00 	movb   $0x0,0x1cc9(%ebx)
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c002263f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022642:	8b 40 30             	mov    0x30(%eax),%eax
c0022645:	8b 84 83 c8 10 00 00 	mov    0x10c8(%ebx,%eax,4),%eax
c002264c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (handler != NULL)
c002264f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0022653:	74 10                	je     c0022665 <intr_handler+0xdc>
    handler (frame);
c0022655:	83 ec 0c             	sub    $0xc,%esp
c0022658:	ff 75 08             	push   0x8(%ebp)
c002265b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002265e:	ff d0                	call   *%eax
c0022660:	83 c4 10             	add    $0x10,%esp
c0022663:	eb 24                	jmp    c0022689 <intr_handler+0x100>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0022665:	8b 45 08             	mov    0x8(%ebp),%eax
c0022668:	8b 40 30             	mov    0x30(%eax),%eax
c002266b:	83 f8 27             	cmp    $0x27,%eax
c002266e:	74 19                	je     c0022689 <intr_handler+0x100>
c0022670:	8b 45 08             	mov    0x8(%ebp),%eax
c0022673:	8b 40 30             	mov    0x30(%eax),%eax
c0022676:	83 f8 2f             	cmp    $0x2f,%eax
c0022679:	74 0e                	je     c0022689 <intr_handler+0x100>
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);
c002267b:	83 ec 0c             	sub    $0xc,%esp
c002267e:	ff 75 08             	push   0x8(%ebp)
c0022681:	e8 a0 00 00 00       	call   c0022726 <unexpected_interrupt>
c0022686:	83 c4 10             	add    $0x10,%esp

  /* Complete the processing of an external interrupt. */
  if (external) 
c0022689:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c002268d:	0f 84 8d 00 00 00    	je     c0022720 <intr_handler+0x197>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0022693:	e8 b5 f7 ff ff       	call   c0021e4d <intr_get_level>
c0022698:	85 c0                	test   %eax,%eax
c002269a:	74 29                	je     c00226c5 <intr_handler+0x13c>
c002269c:	83 ec 0c             	sub    $0xc,%esp
c002269f:	8d 83 8f 7a ff ff    	lea    -0x8571(%ebx),%eax
c00226a5:	50                   	push   %eax
c00226a6:	8d 83 85 77 ff ff    	lea    -0x887b(%ebx),%eax
c00226ac:	50                   	push   %eax
c00226ad:	8d 83 08 7c ff ff    	lea    -0x83f8(%ebx),%eax
c00226b3:	50                   	push   %eax
c00226b4:	68 7c 01 00 00       	push   $0x17c
c00226b9:	8d 83 9c 77 ff ff    	lea    -0x8864(%ebx),%eax
c00226bf:	50                   	push   %eax
c00226c0:	e8 9f 90 00 00       	call   c002b764 <debug_panic>
      ASSERT (intr_context ());
c00226c5:	e8 7a fb ff ff       	call   c0022244 <intr_context>
c00226ca:	84 c0                	test   %al,%al
c00226cc:	75 29                	jne    c00226f7 <intr_handler+0x16e>
c00226ce:	83 ec 0c             	sub    $0xc,%esp
c00226d1:	8d 83 27 7a ff ff    	lea    -0x85d9(%ebx),%eax
c00226d7:	50                   	push   %eax
c00226d8:	8d 83 85 77 ff ff    	lea    -0x887b(%ebx),%eax
c00226de:	50                   	push   %eax
c00226df:	8d 83 08 7c ff ff    	lea    -0x83f8(%ebx),%eax
c00226e5:	50                   	push   %eax
c00226e6:	68 7d 01 00 00       	push   $0x17d
c00226eb:	8d 83 9c 77 ff ff    	lea    -0x8864(%ebx),%eax
c00226f1:	50                   	push   %eax
c00226f2:	e8 6d 90 00 00       	call   c002b764 <debug_panic>

      in_external_intr = false;
c00226f7:	c6 83 c8 1c 00 00 00 	movb   $0x0,0x1cc8(%ebx)
      pic_end_of_interrupt (frame->vec_no); 
c00226fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0022701:	8b 40 30             	mov    0x30(%eax),%eax
c0022704:	83 ec 0c             	sub    $0xc,%esp
c0022707:	50                   	push   %eax
c0022708:	e8 56 fc ff ff       	call   c0022363 <pic_end_of_interrupt>
c002270d:	83 c4 10             	add    $0x10,%esp

      if (yield_on_return) 
c0022710:	0f b6 83 c9 1c 00 00 	movzbl 0x1cc9(%ebx),%eax
c0022717:	84 c0                	test   %al,%al
c0022719:	74 05                	je     c0022720 <intr_handler+0x197>
        thread_yield (); 
c002271b:	e8 9a ed ff ff       	call   c00214ba <thread_yield>
    }
}
c0022720:	90                   	nop
c0022721:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0022724:	c9                   	leave  
c0022725:	c3                   	ret    

c0022726 <unexpected_interrupt>:

/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
c0022726:	55                   	push   %ebp
c0022727:	89 e5                	mov    %esp,%ebp
c0022729:	53                   	push   %ebx
c002272a:	83 ec 14             	sub    $0x14,%esp
c002272d:	e8 f6 ec 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0022732:	05 46 7c 01 00       	add    $0x17c46,%eax
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0022737:	8b 55 08             	mov    0x8(%ebp),%edx
c002273a:	8b 52 30             	mov    0x30(%edx),%edx
c002273d:	8b 8c 90 c8 18 00 00 	mov    0x18c8(%eax,%edx,4),%ecx
c0022744:	83 c1 01             	add    $0x1,%ecx
c0022747:	89 8c 90 c8 18 00 00 	mov    %ecx,0x18c8(%eax,%edx,4)
c002274e:	8b 94 90 c8 18 00 00 	mov    0x18c8(%eax,%edx,4),%edx
c0022755:	89 55 f4             	mov    %edx,-0xc(%ebp)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0022758:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002275b:	83 ea 01             	sub    $0x1,%edx
c002275e:	23 55 f4             	and    -0xc(%ebp),%edx
c0022761:	85 d2                	test   %edx,%edx
c0022763:	75 29                	jne    c002278e <unexpected_interrupt+0x68>
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
c0022765:	8b 55 08             	mov    0x8(%ebp),%edx
c0022768:	8b 52 30             	mov    0x30(%edx),%edx
    printf ("Unexpected interrupt %#04x (%s)\n",
c002276b:	8b 8c 90 c8 14 00 00 	mov    0x14c8(%eax,%edx,4),%ecx
    f->vec_no, intr_names[f->vec_no]);
c0022772:	8b 55 08             	mov    0x8(%ebp),%edx
c0022775:	8b 52 30             	mov    0x30(%edx),%edx
    printf ("Unexpected interrupt %#04x (%s)\n",
c0022778:	83 ec 04             	sub    $0x4,%esp
c002277b:	51                   	push   %ecx
c002277c:	52                   	push   %edx
c002277d:	8d 90 b0 7a ff ff    	lea    -0x8550(%eax),%edx
c0022783:	52                   	push   %edx
c0022784:	89 c3                	mov    %eax,%ebx
c0022786:	e8 5a 67 00 00       	call   c0028ee5 <printf>
c002278b:	83 c4 10             	add    $0x10,%esp
}
c002278e:	90                   	nop
c002278f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0022792:	c9                   	leave  
c0022793:	c3                   	ret    

c0022794 <intr_dump_frame>:

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0022794:	55                   	push   %ebp
c0022795:	89 e5                	mov    %esp,%ebp
c0022797:	56                   	push   %esi
c0022798:	53                   	push   %ebx
c0022799:	83 ec 10             	sub    $0x10,%esp
c002279c:	e8 8b ec 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00227a1:	81 c3 d7 7b 01 00    	add    $0x17bd7,%ebx
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c00227a7:	0f 20 d0             	mov    %cr2,%eax
c00227aa:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
c00227ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00227b0:	8b 48 3c             	mov    0x3c(%eax),%ecx
c00227b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00227b6:	8b 40 30             	mov    0x30(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c00227b9:	8b 94 83 c8 14 00 00 	mov    0x14c8(%ebx,%eax,4),%edx
          f->vec_no, intr_names[f->vec_no], f->eip);
c00227c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00227c3:	8b 40 30             	mov    0x30(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c00227c6:	51                   	push   %ecx
c00227c7:	52                   	push   %edx
c00227c8:	50                   	push   %eax
c00227c9:	8d 83 d4 7a ff ff    	lea    -0x852c(%ebx),%eax
c00227cf:	50                   	push   %eax
c00227d0:	e8 10 67 00 00       	call   c0028ee5 <printf>
c00227d5:	83 c4 10             	add    $0x10,%esp
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c00227d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00227db:	8b 40 34             	mov    0x34(%eax),%eax
c00227de:	83 ec 04             	sub    $0x4,%esp
c00227e1:	50                   	push   %eax
c00227e2:	ff 75 f4             	push   -0xc(%ebp)
c00227e5:	8d 83 f4 7a ff ff    	lea    -0x850c(%ebx),%eax
c00227eb:	50                   	push   %eax
c00227ec:	e8 f4 66 00 00       	call   c0028ee5 <printf>
c00227f1:	83 c4 10             	add    $0x10,%esp
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
c00227f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00227f7:	8b 70 14             	mov    0x14(%eax),%esi
c00227fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00227fd:	8b 48 18             	mov    0x18(%eax),%ecx
c0022800:	8b 45 08             	mov    0x8(%ebp),%eax
c0022803:	8b 50 10             	mov    0x10(%eax),%edx
c0022806:	8b 45 08             	mov    0x8(%ebp),%eax
c0022809:	8b 40 1c             	mov    0x1c(%eax),%eax
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c002280c:	83 ec 0c             	sub    $0xc,%esp
c002280f:	56                   	push   %esi
c0022810:	51                   	push   %ecx
c0022811:	52                   	push   %edx
c0022812:	50                   	push   %eax
c0022813:	8d 83 0c 7b ff ff    	lea    -0x84f4(%ebx),%eax
c0022819:	50                   	push   %eax
c002281a:	e8 c6 66 00 00       	call   c0028ee5 <printf>
c002281f:	83 c4 20             	add    $0x20,%esp
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c0022822:	8b 45 08             	mov    0x8(%ebp),%eax
c0022825:	8b 48 08             	mov    0x8(%eax),%ecx
c0022828:	8b 45 08             	mov    0x8(%ebp),%eax
c002282b:	8b 40 48             	mov    0x48(%eax),%eax
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c002282e:	89 c6                	mov    %eax,%esi
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c0022830:	8b 45 08             	mov    0x8(%ebp),%eax
c0022833:	8b 10                	mov    (%eax),%edx
c0022835:	8b 45 08             	mov    0x8(%ebp),%eax
c0022838:	8b 40 04             	mov    0x4(%eax),%eax
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c002283b:	83 ec 0c             	sub    $0xc,%esp
c002283e:	51                   	push   %ecx
c002283f:	56                   	push   %esi
c0022840:	52                   	push   %edx
c0022841:	50                   	push   %eax
c0022842:	8d 83 34 7b ff ff    	lea    -0x84cc(%ebx),%eax
c0022848:	50                   	push   %eax
c0022849:	e8 97 66 00 00       	call   c0028ee5 <printf>
c002284e:	83 c4 20             	add    $0x20,%esp
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
c0022851:	8b 45 08             	mov    0x8(%ebp),%eax
c0022854:	0f b7 40 4c          	movzwl 0x4c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022858:	0f b7 f0             	movzwl %ax,%esi
          f->cs, f->ds, f->es, f->ss);
c002285b:	8b 45 08             	mov    0x8(%ebp),%eax
c002285e:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022862:	0f b7 c8             	movzwl %ax,%ecx
          f->cs, f->ds, f->es, f->ss);
c0022865:	8b 45 08             	mov    0x8(%ebp),%eax
c0022868:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c002286c:	0f b7 d0             	movzwl %ax,%edx
          f->cs, f->ds, f->es, f->ss);
c002286f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022872:	0f b7 40 40          	movzwl 0x40(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022876:	0f b7 c0             	movzwl %ax,%eax
c0022879:	83 ec 0c             	sub    $0xc,%esp
c002287c:	56                   	push   %esi
c002287d:	51                   	push   %ecx
c002287e:	52                   	push   %edx
c002287f:	50                   	push   %eax
c0022880:	8d 83 5c 7b ff ff    	lea    -0x84a4(%ebx),%eax
c0022886:	50                   	push   %eax
c0022887:	e8 59 66 00 00       	call   c0028ee5 <printf>
c002288c:	83 c4 20             	add    $0x20,%esp
}
c002288f:	90                   	nop
c0022890:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0022893:	5b                   	pop    %ebx
c0022894:	5e                   	pop    %esi
c0022895:	5d                   	pop    %ebp
c0022896:	c3                   	ret    

c0022897 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c0022897:	55                   	push   %ebp
c0022898:	89 e5                	mov    %esp,%ebp
c002289a:	83 ec 04             	sub    $0x4,%esp
c002289d:	e8 86 eb 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00228a2:	05 d6 7a 01 00       	add    $0x17ad6,%eax
c00228a7:	8b 55 08             	mov    0x8(%ebp),%edx
c00228aa:	88 55 fc             	mov    %dl,-0x4(%ebp)
  return intr_names[vec];
c00228ad:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c00228b1:	8b 84 90 c8 14 00 00 	mov    0x14c8(%eax,%edx,4),%eax
}
c00228b8:	c9                   	leave  
c00228b9:	c3                   	ret    

c00228ba <intr_entry>:
c00228ba:	1e                   	push   %ds
c00228bb:	06                   	push   %es
c00228bc:	0f a0                	push   %fs
c00228be:	0f a8                	push   %gs
c00228c0:	60                   	pusha  
c00228c1:	fc                   	cld    
c00228c2:	b8 10 00 00 00       	mov    $0x10,%eax
c00228c7:	8e d8                	mov    %eax,%ds
c00228c9:	8e c0                	mov    %eax,%es
c00228cb:	8d 6c 24 38          	lea    0x38(%esp),%ebp
c00228cf:	54                   	push   %esp
c00228d0:	e8 b4 fc ff ff       	call   c0022589 <intr_handler>
c00228d5:	83 c4 04             	add    $0x4,%esp

c00228d8 <intr_exit>:
c00228d8:	61                   	popa   
c00228d9:	0f a9                	pop    %gs
c00228db:	0f a1                	pop    %fs
c00228dd:	07                   	pop    %es
c00228de:	1f                   	pop    %ds
c00228df:	83 c4 0c             	add    $0xc,%esp
c00228e2:	cf                   	iret   

c00228e3 <intr00_stub>:
c00228e3:	55                   	push   %ebp
c00228e4:	6a 00                	push   $0x0
c00228e6:	6a 00                	push   $0x0
c00228e8:	eb d0                	jmp    c00228ba <intr_entry>

c00228ea <intr01_stub>:
c00228ea:	55                   	push   %ebp
c00228eb:	6a 00                	push   $0x0
c00228ed:	6a 01                	push   $0x1
c00228ef:	eb c9                	jmp    c00228ba <intr_entry>

c00228f1 <intr02_stub>:
c00228f1:	55                   	push   %ebp
c00228f2:	6a 00                	push   $0x0
c00228f4:	6a 02                	push   $0x2
c00228f6:	eb c2                	jmp    c00228ba <intr_entry>

c00228f8 <intr03_stub>:
c00228f8:	55                   	push   %ebp
c00228f9:	6a 00                	push   $0x0
c00228fb:	6a 03                	push   $0x3
c00228fd:	eb bb                	jmp    c00228ba <intr_entry>

c00228ff <intr04_stub>:
c00228ff:	55                   	push   %ebp
c0022900:	6a 00                	push   $0x0
c0022902:	6a 04                	push   $0x4
c0022904:	eb b4                	jmp    c00228ba <intr_entry>

c0022906 <intr05_stub>:
c0022906:	55                   	push   %ebp
c0022907:	6a 00                	push   $0x0
c0022909:	6a 05                	push   $0x5
c002290b:	eb ad                	jmp    c00228ba <intr_entry>

c002290d <intr06_stub>:
c002290d:	55                   	push   %ebp
c002290e:	6a 00                	push   $0x0
c0022910:	6a 06                	push   $0x6
c0022912:	eb a6                	jmp    c00228ba <intr_entry>

c0022914 <intr07_stub>:
c0022914:	55                   	push   %ebp
c0022915:	6a 00                	push   $0x0
c0022917:	6a 07                	push   $0x7
c0022919:	eb 9f                	jmp    c00228ba <intr_entry>

c002291b <intr08_stub>:
c002291b:	ff 34 24             	push   (%esp)
c002291e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022922:	6a 08                	push   $0x8
c0022924:	eb 94                	jmp    c00228ba <intr_entry>

c0022926 <intr09_stub>:
c0022926:	55                   	push   %ebp
c0022927:	6a 00                	push   $0x0
c0022929:	6a 09                	push   $0x9
c002292b:	eb 8d                	jmp    c00228ba <intr_entry>

c002292d <intr0a_stub>:
c002292d:	ff 34 24             	push   (%esp)
c0022930:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022934:	6a 0a                	push   $0xa
c0022936:	eb 82                	jmp    c00228ba <intr_entry>

c0022938 <intr0b_stub>:
c0022938:	ff 34 24             	push   (%esp)
c002293b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002293f:	6a 0b                	push   $0xb
c0022941:	e9 74 ff ff ff       	jmp    c00228ba <intr_entry>

c0022946 <intr0c_stub>:
c0022946:	55                   	push   %ebp
c0022947:	6a 00                	push   $0x0
c0022949:	6a 0c                	push   $0xc
c002294b:	e9 6a ff ff ff       	jmp    c00228ba <intr_entry>

c0022950 <intr0d_stub>:
c0022950:	ff 34 24             	push   (%esp)
c0022953:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022957:	6a 0d                	push   $0xd
c0022959:	e9 5c ff ff ff       	jmp    c00228ba <intr_entry>

c002295e <intr0e_stub>:
c002295e:	ff 34 24             	push   (%esp)
c0022961:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022965:	6a 0e                	push   $0xe
c0022967:	e9 4e ff ff ff       	jmp    c00228ba <intr_entry>

c002296c <intr0f_stub>:
c002296c:	55                   	push   %ebp
c002296d:	6a 00                	push   $0x0
c002296f:	6a 0f                	push   $0xf
c0022971:	e9 44 ff ff ff       	jmp    c00228ba <intr_entry>

c0022976 <intr10_stub>:
c0022976:	55                   	push   %ebp
c0022977:	6a 00                	push   $0x0
c0022979:	6a 10                	push   $0x10
c002297b:	e9 3a ff ff ff       	jmp    c00228ba <intr_entry>

c0022980 <intr11_stub>:
c0022980:	ff 34 24             	push   (%esp)
c0022983:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022987:	6a 11                	push   $0x11
c0022989:	e9 2c ff ff ff       	jmp    c00228ba <intr_entry>

c002298e <intr12_stub>:
c002298e:	55                   	push   %ebp
c002298f:	6a 00                	push   $0x0
c0022991:	6a 12                	push   $0x12
c0022993:	e9 22 ff ff ff       	jmp    c00228ba <intr_entry>

c0022998 <intr13_stub>:
c0022998:	55                   	push   %ebp
c0022999:	6a 00                	push   $0x0
c002299b:	6a 13                	push   $0x13
c002299d:	e9 18 ff ff ff       	jmp    c00228ba <intr_entry>

c00229a2 <intr14_stub>:
c00229a2:	55                   	push   %ebp
c00229a3:	6a 00                	push   $0x0
c00229a5:	6a 14                	push   $0x14
c00229a7:	e9 0e ff ff ff       	jmp    c00228ba <intr_entry>

c00229ac <intr15_stub>:
c00229ac:	55                   	push   %ebp
c00229ad:	6a 00                	push   $0x0
c00229af:	6a 15                	push   $0x15
c00229b1:	e9 04 ff ff ff       	jmp    c00228ba <intr_entry>

c00229b6 <intr16_stub>:
c00229b6:	55                   	push   %ebp
c00229b7:	6a 00                	push   $0x0
c00229b9:	6a 16                	push   $0x16
c00229bb:	e9 fa fe ff ff       	jmp    c00228ba <intr_entry>

c00229c0 <intr17_stub>:
c00229c0:	55                   	push   %ebp
c00229c1:	6a 00                	push   $0x0
c00229c3:	6a 17                	push   $0x17
c00229c5:	e9 f0 fe ff ff       	jmp    c00228ba <intr_entry>

c00229ca <intr18_stub>:
c00229ca:	ff 34 24             	push   (%esp)
c00229cd:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00229d1:	6a 18                	push   $0x18
c00229d3:	e9 e2 fe ff ff       	jmp    c00228ba <intr_entry>

c00229d8 <intr19_stub>:
c00229d8:	55                   	push   %ebp
c00229d9:	6a 00                	push   $0x0
c00229db:	6a 19                	push   $0x19
c00229dd:	e9 d8 fe ff ff       	jmp    c00228ba <intr_entry>

c00229e2 <intr1a_stub>:
c00229e2:	ff 34 24             	push   (%esp)
c00229e5:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00229e9:	6a 1a                	push   $0x1a
c00229eb:	e9 ca fe ff ff       	jmp    c00228ba <intr_entry>

c00229f0 <intr1b_stub>:
c00229f0:	ff 34 24             	push   (%esp)
c00229f3:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00229f7:	6a 1b                	push   $0x1b
c00229f9:	e9 bc fe ff ff       	jmp    c00228ba <intr_entry>

c00229fe <intr1c_stub>:
c00229fe:	55                   	push   %ebp
c00229ff:	6a 00                	push   $0x0
c0022a01:	6a 1c                	push   $0x1c
c0022a03:	e9 b2 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a08 <intr1d_stub>:
c0022a08:	ff 34 24             	push   (%esp)
c0022a0b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022a0f:	6a 1d                	push   $0x1d
c0022a11:	e9 a4 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a16 <intr1e_stub>:
c0022a16:	ff 34 24             	push   (%esp)
c0022a19:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022a1d:	6a 1e                	push   $0x1e
c0022a1f:	e9 96 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a24 <intr1f_stub>:
c0022a24:	55                   	push   %ebp
c0022a25:	6a 00                	push   $0x0
c0022a27:	6a 1f                	push   $0x1f
c0022a29:	e9 8c fe ff ff       	jmp    c00228ba <intr_entry>

c0022a2e <intr20_stub>:
c0022a2e:	55                   	push   %ebp
c0022a2f:	6a 00                	push   $0x0
c0022a31:	6a 20                	push   $0x20
c0022a33:	e9 82 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a38 <intr21_stub>:
c0022a38:	55                   	push   %ebp
c0022a39:	6a 00                	push   $0x0
c0022a3b:	6a 21                	push   $0x21
c0022a3d:	e9 78 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a42 <intr22_stub>:
c0022a42:	55                   	push   %ebp
c0022a43:	6a 00                	push   $0x0
c0022a45:	6a 22                	push   $0x22
c0022a47:	e9 6e fe ff ff       	jmp    c00228ba <intr_entry>

c0022a4c <intr23_stub>:
c0022a4c:	55                   	push   %ebp
c0022a4d:	6a 00                	push   $0x0
c0022a4f:	6a 23                	push   $0x23
c0022a51:	e9 64 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a56 <intr24_stub>:
c0022a56:	55                   	push   %ebp
c0022a57:	6a 00                	push   $0x0
c0022a59:	6a 24                	push   $0x24
c0022a5b:	e9 5a fe ff ff       	jmp    c00228ba <intr_entry>

c0022a60 <intr25_stub>:
c0022a60:	55                   	push   %ebp
c0022a61:	6a 00                	push   $0x0
c0022a63:	6a 25                	push   $0x25
c0022a65:	e9 50 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a6a <intr26_stub>:
c0022a6a:	55                   	push   %ebp
c0022a6b:	6a 00                	push   $0x0
c0022a6d:	6a 26                	push   $0x26
c0022a6f:	e9 46 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a74 <intr27_stub>:
c0022a74:	55                   	push   %ebp
c0022a75:	6a 00                	push   $0x0
c0022a77:	6a 27                	push   $0x27
c0022a79:	e9 3c fe ff ff       	jmp    c00228ba <intr_entry>

c0022a7e <intr28_stub>:
c0022a7e:	55                   	push   %ebp
c0022a7f:	6a 00                	push   $0x0
c0022a81:	6a 28                	push   $0x28
c0022a83:	e9 32 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a88 <intr29_stub>:
c0022a88:	55                   	push   %ebp
c0022a89:	6a 00                	push   $0x0
c0022a8b:	6a 29                	push   $0x29
c0022a8d:	e9 28 fe ff ff       	jmp    c00228ba <intr_entry>

c0022a92 <intr2a_stub>:
c0022a92:	55                   	push   %ebp
c0022a93:	6a 00                	push   $0x0
c0022a95:	6a 2a                	push   $0x2a
c0022a97:	e9 1e fe ff ff       	jmp    c00228ba <intr_entry>

c0022a9c <intr2b_stub>:
c0022a9c:	55                   	push   %ebp
c0022a9d:	6a 00                	push   $0x0
c0022a9f:	6a 2b                	push   $0x2b
c0022aa1:	e9 14 fe ff ff       	jmp    c00228ba <intr_entry>

c0022aa6 <intr2c_stub>:
c0022aa6:	55                   	push   %ebp
c0022aa7:	6a 00                	push   $0x0
c0022aa9:	6a 2c                	push   $0x2c
c0022aab:	e9 0a fe ff ff       	jmp    c00228ba <intr_entry>

c0022ab0 <intr2d_stub>:
c0022ab0:	55                   	push   %ebp
c0022ab1:	6a 00                	push   $0x0
c0022ab3:	6a 2d                	push   $0x2d
c0022ab5:	e9 00 fe ff ff       	jmp    c00228ba <intr_entry>

c0022aba <intr2e_stub>:
c0022aba:	55                   	push   %ebp
c0022abb:	6a 00                	push   $0x0
c0022abd:	6a 2e                	push   $0x2e
c0022abf:	e9 f6 fd ff ff       	jmp    c00228ba <intr_entry>

c0022ac4 <intr2f_stub>:
c0022ac4:	55                   	push   %ebp
c0022ac5:	6a 00                	push   $0x0
c0022ac7:	6a 2f                	push   $0x2f
c0022ac9:	e9 ec fd ff ff       	jmp    c00228ba <intr_entry>

c0022ace <intr30_stub>:
c0022ace:	55                   	push   %ebp
c0022acf:	6a 00                	push   $0x0
c0022ad1:	6a 30                	push   $0x30
c0022ad3:	e9 e2 fd ff ff       	jmp    c00228ba <intr_entry>

c0022ad8 <intr31_stub>:
c0022ad8:	55                   	push   %ebp
c0022ad9:	6a 00                	push   $0x0
c0022adb:	6a 31                	push   $0x31
c0022add:	e9 d8 fd ff ff       	jmp    c00228ba <intr_entry>

c0022ae2 <intr32_stub>:
c0022ae2:	55                   	push   %ebp
c0022ae3:	6a 00                	push   $0x0
c0022ae5:	6a 32                	push   $0x32
c0022ae7:	e9 ce fd ff ff       	jmp    c00228ba <intr_entry>

c0022aec <intr33_stub>:
c0022aec:	55                   	push   %ebp
c0022aed:	6a 00                	push   $0x0
c0022aef:	6a 33                	push   $0x33
c0022af1:	e9 c4 fd ff ff       	jmp    c00228ba <intr_entry>

c0022af6 <intr34_stub>:
c0022af6:	55                   	push   %ebp
c0022af7:	6a 00                	push   $0x0
c0022af9:	6a 34                	push   $0x34
c0022afb:	e9 ba fd ff ff       	jmp    c00228ba <intr_entry>

c0022b00 <intr35_stub>:
c0022b00:	55                   	push   %ebp
c0022b01:	6a 00                	push   $0x0
c0022b03:	6a 35                	push   $0x35
c0022b05:	e9 b0 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b0a <intr36_stub>:
c0022b0a:	55                   	push   %ebp
c0022b0b:	6a 00                	push   $0x0
c0022b0d:	6a 36                	push   $0x36
c0022b0f:	e9 a6 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b14 <intr37_stub>:
c0022b14:	55                   	push   %ebp
c0022b15:	6a 00                	push   $0x0
c0022b17:	6a 37                	push   $0x37
c0022b19:	e9 9c fd ff ff       	jmp    c00228ba <intr_entry>

c0022b1e <intr38_stub>:
c0022b1e:	55                   	push   %ebp
c0022b1f:	6a 00                	push   $0x0
c0022b21:	6a 38                	push   $0x38
c0022b23:	e9 92 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b28 <intr39_stub>:
c0022b28:	55                   	push   %ebp
c0022b29:	6a 00                	push   $0x0
c0022b2b:	6a 39                	push   $0x39
c0022b2d:	e9 88 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b32 <intr3a_stub>:
c0022b32:	55                   	push   %ebp
c0022b33:	6a 00                	push   $0x0
c0022b35:	6a 3a                	push   $0x3a
c0022b37:	e9 7e fd ff ff       	jmp    c00228ba <intr_entry>

c0022b3c <intr3b_stub>:
c0022b3c:	55                   	push   %ebp
c0022b3d:	6a 00                	push   $0x0
c0022b3f:	6a 3b                	push   $0x3b
c0022b41:	e9 74 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b46 <intr3c_stub>:
c0022b46:	55                   	push   %ebp
c0022b47:	6a 00                	push   $0x0
c0022b49:	6a 3c                	push   $0x3c
c0022b4b:	e9 6a fd ff ff       	jmp    c00228ba <intr_entry>

c0022b50 <intr3d_stub>:
c0022b50:	55                   	push   %ebp
c0022b51:	6a 00                	push   $0x0
c0022b53:	6a 3d                	push   $0x3d
c0022b55:	e9 60 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b5a <intr3e_stub>:
c0022b5a:	55                   	push   %ebp
c0022b5b:	6a 00                	push   $0x0
c0022b5d:	6a 3e                	push   $0x3e
c0022b5f:	e9 56 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b64 <intr3f_stub>:
c0022b64:	55                   	push   %ebp
c0022b65:	6a 00                	push   $0x0
c0022b67:	6a 3f                	push   $0x3f
c0022b69:	e9 4c fd ff ff       	jmp    c00228ba <intr_entry>

c0022b6e <intr40_stub>:
c0022b6e:	55                   	push   %ebp
c0022b6f:	6a 00                	push   $0x0
c0022b71:	6a 40                	push   $0x40
c0022b73:	e9 42 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b78 <intr41_stub>:
c0022b78:	55                   	push   %ebp
c0022b79:	6a 00                	push   $0x0
c0022b7b:	6a 41                	push   $0x41
c0022b7d:	e9 38 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b82 <intr42_stub>:
c0022b82:	55                   	push   %ebp
c0022b83:	6a 00                	push   $0x0
c0022b85:	6a 42                	push   $0x42
c0022b87:	e9 2e fd ff ff       	jmp    c00228ba <intr_entry>

c0022b8c <intr43_stub>:
c0022b8c:	55                   	push   %ebp
c0022b8d:	6a 00                	push   $0x0
c0022b8f:	6a 43                	push   $0x43
c0022b91:	e9 24 fd ff ff       	jmp    c00228ba <intr_entry>

c0022b96 <intr44_stub>:
c0022b96:	55                   	push   %ebp
c0022b97:	6a 00                	push   $0x0
c0022b99:	6a 44                	push   $0x44
c0022b9b:	e9 1a fd ff ff       	jmp    c00228ba <intr_entry>

c0022ba0 <intr45_stub>:
c0022ba0:	55                   	push   %ebp
c0022ba1:	6a 00                	push   $0x0
c0022ba3:	6a 45                	push   $0x45
c0022ba5:	e9 10 fd ff ff       	jmp    c00228ba <intr_entry>

c0022baa <intr46_stub>:
c0022baa:	55                   	push   %ebp
c0022bab:	6a 00                	push   $0x0
c0022bad:	6a 46                	push   $0x46
c0022baf:	e9 06 fd ff ff       	jmp    c00228ba <intr_entry>

c0022bb4 <intr47_stub>:
c0022bb4:	55                   	push   %ebp
c0022bb5:	6a 00                	push   $0x0
c0022bb7:	6a 47                	push   $0x47
c0022bb9:	e9 fc fc ff ff       	jmp    c00228ba <intr_entry>

c0022bbe <intr48_stub>:
c0022bbe:	55                   	push   %ebp
c0022bbf:	6a 00                	push   $0x0
c0022bc1:	6a 48                	push   $0x48
c0022bc3:	e9 f2 fc ff ff       	jmp    c00228ba <intr_entry>

c0022bc8 <intr49_stub>:
c0022bc8:	55                   	push   %ebp
c0022bc9:	6a 00                	push   $0x0
c0022bcb:	6a 49                	push   $0x49
c0022bcd:	e9 e8 fc ff ff       	jmp    c00228ba <intr_entry>

c0022bd2 <intr4a_stub>:
c0022bd2:	55                   	push   %ebp
c0022bd3:	6a 00                	push   $0x0
c0022bd5:	6a 4a                	push   $0x4a
c0022bd7:	e9 de fc ff ff       	jmp    c00228ba <intr_entry>

c0022bdc <intr4b_stub>:
c0022bdc:	55                   	push   %ebp
c0022bdd:	6a 00                	push   $0x0
c0022bdf:	6a 4b                	push   $0x4b
c0022be1:	e9 d4 fc ff ff       	jmp    c00228ba <intr_entry>

c0022be6 <intr4c_stub>:
c0022be6:	55                   	push   %ebp
c0022be7:	6a 00                	push   $0x0
c0022be9:	6a 4c                	push   $0x4c
c0022beb:	e9 ca fc ff ff       	jmp    c00228ba <intr_entry>

c0022bf0 <intr4d_stub>:
c0022bf0:	55                   	push   %ebp
c0022bf1:	6a 00                	push   $0x0
c0022bf3:	6a 4d                	push   $0x4d
c0022bf5:	e9 c0 fc ff ff       	jmp    c00228ba <intr_entry>

c0022bfa <intr4e_stub>:
c0022bfa:	55                   	push   %ebp
c0022bfb:	6a 00                	push   $0x0
c0022bfd:	6a 4e                	push   $0x4e
c0022bff:	e9 b6 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c04 <intr4f_stub>:
c0022c04:	55                   	push   %ebp
c0022c05:	6a 00                	push   $0x0
c0022c07:	6a 4f                	push   $0x4f
c0022c09:	e9 ac fc ff ff       	jmp    c00228ba <intr_entry>

c0022c0e <intr50_stub>:
c0022c0e:	55                   	push   %ebp
c0022c0f:	6a 00                	push   $0x0
c0022c11:	6a 50                	push   $0x50
c0022c13:	e9 a2 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c18 <intr51_stub>:
c0022c18:	55                   	push   %ebp
c0022c19:	6a 00                	push   $0x0
c0022c1b:	6a 51                	push   $0x51
c0022c1d:	e9 98 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c22 <intr52_stub>:
c0022c22:	55                   	push   %ebp
c0022c23:	6a 00                	push   $0x0
c0022c25:	6a 52                	push   $0x52
c0022c27:	e9 8e fc ff ff       	jmp    c00228ba <intr_entry>

c0022c2c <intr53_stub>:
c0022c2c:	55                   	push   %ebp
c0022c2d:	6a 00                	push   $0x0
c0022c2f:	6a 53                	push   $0x53
c0022c31:	e9 84 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c36 <intr54_stub>:
c0022c36:	55                   	push   %ebp
c0022c37:	6a 00                	push   $0x0
c0022c39:	6a 54                	push   $0x54
c0022c3b:	e9 7a fc ff ff       	jmp    c00228ba <intr_entry>

c0022c40 <intr55_stub>:
c0022c40:	55                   	push   %ebp
c0022c41:	6a 00                	push   $0x0
c0022c43:	6a 55                	push   $0x55
c0022c45:	e9 70 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c4a <intr56_stub>:
c0022c4a:	55                   	push   %ebp
c0022c4b:	6a 00                	push   $0x0
c0022c4d:	6a 56                	push   $0x56
c0022c4f:	e9 66 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c54 <intr57_stub>:
c0022c54:	55                   	push   %ebp
c0022c55:	6a 00                	push   $0x0
c0022c57:	6a 57                	push   $0x57
c0022c59:	e9 5c fc ff ff       	jmp    c00228ba <intr_entry>

c0022c5e <intr58_stub>:
c0022c5e:	55                   	push   %ebp
c0022c5f:	6a 00                	push   $0x0
c0022c61:	6a 58                	push   $0x58
c0022c63:	e9 52 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c68 <intr59_stub>:
c0022c68:	55                   	push   %ebp
c0022c69:	6a 00                	push   $0x0
c0022c6b:	6a 59                	push   $0x59
c0022c6d:	e9 48 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c72 <intr5a_stub>:
c0022c72:	55                   	push   %ebp
c0022c73:	6a 00                	push   $0x0
c0022c75:	6a 5a                	push   $0x5a
c0022c77:	e9 3e fc ff ff       	jmp    c00228ba <intr_entry>

c0022c7c <intr5b_stub>:
c0022c7c:	55                   	push   %ebp
c0022c7d:	6a 00                	push   $0x0
c0022c7f:	6a 5b                	push   $0x5b
c0022c81:	e9 34 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c86 <intr5c_stub>:
c0022c86:	55                   	push   %ebp
c0022c87:	6a 00                	push   $0x0
c0022c89:	6a 5c                	push   $0x5c
c0022c8b:	e9 2a fc ff ff       	jmp    c00228ba <intr_entry>

c0022c90 <intr5d_stub>:
c0022c90:	55                   	push   %ebp
c0022c91:	6a 00                	push   $0x0
c0022c93:	6a 5d                	push   $0x5d
c0022c95:	e9 20 fc ff ff       	jmp    c00228ba <intr_entry>

c0022c9a <intr5e_stub>:
c0022c9a:	55                   	push   %ebp
c0022c9b:	6a 00                	push   $0x0
c0022c9d:	6a 5e                	push   $0x5e
c0022c9f:	e9 16 fc ff ff       	jmp    c00228ba <intr_entry>

c0022ca4 <intr5f_stub>:
c0022ca4:	55                   	push   %ebp
c0022ca5:	6a 00                	push   $0x0
c0022ca7:	6a 5f                	push   $0x5f
c0022ca9:	e9 0c fc ff ff       	jmp    c00228ba <intr_entry>

c0022cae <intr60_stub>:
c0022cae:	55                   	push   %ebp
c0022caf:	6a 00                	push   $0x0
c0022cb1:	6a 60                	push   $0x60
c0022cb3:	e9 02 fc ff ff       	jmp    c00228ba <intr_entry>

c0022cb8 <intr61_stub>:
c0022cb8:	55                   	push   %ebp
c0022cb9:	6a 00                	push   $0x0
c0022cbb:	6a 61                	push   $0x61
c0022cbd:	e9 f8 fb ff ff       	jmp    c00228ba <intr_entry>

c0022cc2 <intr62_stub>:
c0022cc2:	55                   	push   %ebp
c0022cc3:	6a 00                	push   $0x0
c0022cc5:	6a 62                	push   $0x62
c0022cc7:	e9 ee fb ff ff       	jmp    c00228ba <intr_entry>

c0022ccc <intr63_stub>:
c0022ccc:	55                   	push   %ebp
c0022ccd:	6a 00                	push   $0x0
c0022ccf:	6a 63                	push   $0x63
c0022cd1:	e9 e4 fb ff ff       	jmp    c00228ba <intr_entry>

c0022cd6 <intr64_stub>:
c0022cd6:	55                   	push   %ebp
c0022cd7:	6a 00                	push   $0x0
c0022cd9:	6a 64                	push   $0x64
c0022cdb:	e9 da fb ff ff       	jmp    c00228ba <intr_entry>

c0022ce0 <intr65_stub>:
c0022ce0:	55                   	push   %ebp
c0022ce1:	6a 00                	push   $0x0
c0022ce3:	6a 65                	push   $0x65
c0022ce5:	e9 d0 fb ff ff       	jmp    c00228ba <intr_entry>

c0022cea <intr66_stub>:
c0022cea:	55                   	push   %ebp
c0022ceb:	6a 00                	push   $0x0
c0022ced:	6a 66                	push   $0x66
c0022cef:	e9 c6 fb ff ff       	jmp    c00228ba <intr_entry>

c0022cf4 <intr67_stub>:
c0022cf4:	55                   	push   %ebp
c0022cf5:	6a 00                	push   $0x0
c0022cf7:	6a 67                	push   $0x67
c0022cf9:	e9 bc fb ff ff       	jmp    c00228ba <intr_entry>

c0022cfe <intr68_stub>:
c0022cfe:	55                   	push   %ebp
c0022cff:	6a 00                	push   $0x0
c0022d01:	6a 68                	push   $0x68
c0022d03:	e9 b2 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d08 <intr69_stub>:
c0022d08:	55                   	push   %ebp
c0022d09:	6a 00                	push   $0x0
c0022d0b:	6a 69                	push   $0x69
c0022d0d:	e9 a8 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d12 <intr6a_stub>:
c0022d12:	55                   	push   %ebp
c0022d13:	6a 00                	push   $0x0
c0022d15:	6a 6a                	push   $0x6a
c0022d17:	e9 9e fb ff ff       	jmp    c00228ba <intr_entry>

c0022d1c <intr6b_stub>:
c0022d1c:	55                   	push   %ebp
c0022d1d:	6a 00                	push   $0x0
c0022d1f:	6a 6b                	push   $0x6b
c0022d21:	e9 94 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d26 <intr6c_stub>:
c0022d26:	55                   	push   %ebp
c0022d27:	6a 00                	push   $0x0
c0022d29:	6a 6c                	push   $0x6c
c0022d2b:	e9 8a fb ff ff       	jmp    c00228ba <intr_entry>

c0022d30 <intr6d_stub>:
c0022d30:	55                   	push   %ebp
c0022d31:	6a 00                	push   $0x0
c0022d33:	6a 6d                	push   $0x6d
c0022d35:	e9 80 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d3a <intr6e_stub>:
c0022d3a:	55                   	push   %ebp
c0022d3b:	6a 00                	push   $0x0
c0022d3d:	6a 6e                	push   $0x6e
c0022d3f:	e9 76 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d44 <intr6f_stub>:
c0022d44:	55                   	push   %ebp
c0022d45:	6a 00                	push   $0x0
c0022d47:	6a 6f                	push   $0x6f
c0022d49:	e9 6c fb ff ff       	jmp    c00228ba <intr_entry>

c0022d4e <intr70_stub>:
c0022d4e:	55                   	push   %ebp
c0022d4f:	6a 00                	push   $0x0
c0022d51:	6a 70                	push   $0x70
c0022d53:	e9 62 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d58 <intr71_stub>:
c0022d58:	55                   	push   %ebp
c0022d59:	6a 00                	push   $0x0
c0022d5b:	6a 71                	push   $0x71
c0022d5d:	e9 58 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d62 <intr72_stub>:
c0022d62:	55                   	push   %ebp
c0022d63:	6a 00                	push   $0x0
c0022d65:	6a 72                	push   $0x72
c0022d67:	e9 4e fb ff ff       	jmp    c00228ba <intr_entry>

c0022d6c <intr73_stub>:
c0022d6c:	55                   	push   %ebp
c0022d6d:	6a 00                	push   $0x0
c0022d6f:	6a 73                	push   $0x73
c0022d71:	e9 44 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d76 <intr74_stub>:
c0022d76:	55                   	push   %ebp
c0022d77:	6a 00                	push   $0x0
c0022d79:	6a 74                	push   $0x74
c0022d7b:	e9 3a fb ff ff       	jmp    c00228ba <intr_entry>

c0022d80 <intr75_stub>:
c0022d80:	55                   	push   %ebp
c0022d81:	6a 00                	push   $0x0
c0022d83:	6a 75                	push   $0x75
c0022d85:	e9 30 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d8a <intr76_stub>:
c0022d8a:	55                   	push   %ebp
c0022d8b:	6a 00                	push   $0x0
c0022d8d:	6a 76                	push   $0x76
c0022d8f:	e9 26 fb ff ff       	jmp    c00228ba <intr_entry>

c0022d94 <intr77_stub>:
c0022d94:	55                   	push   %ebp
c0022d95:	6a 00                	push   $0x0
c0022d97:	6a 77                	push   $0x77
c0022d99:	e9 1c fb ff ff       	jmp    c00228ba <intr_entry>

c0022d9e <intr78_stub>:
c0022d9e:	55                   	push   %ebp
c0022d9f:	6a 00                	push   $0x0
c0022da1:	6a 78                	push   $0x78
c0022da3:	e9 12 fb ff ff       	jmp    c00228ba <intr_entry>

c0022da8 <intr79_stub>:
c0022da8:	55                   	push   %ebp
c0022da9:	6a 00                	push   $0x0
c0022dab:	6a 79                	push   $0x79
c0022dad:	e9 08 fb ff ff       	jmp    c00228ba <intr_entry>

c0022db2 <intr7a_stub>:
c0022db2:	55                   	push   %ebp
c0022db3:	6a 00                	push   $0x0
c0022db5:	6a 7a                	push   $0x7a
c0022db7:	e9 fe fa ff ff       	jmp    c00228ba <intr_entry>

c0022dbc <intr7b_stub>:
c0022dbc:	55                   	push   %ebp
c0022dbd:	6a 00                	push   $0x0
c0022dbf:	6a 7b                	push   $0x7b
c0022dc1:	e9 f4 fa ff ff       	jmp    c00228ba <intr_entry>

c0022dc6 <intr7c_stub>:
c0022dc6:	55                   	push   %ebp
c0022dc7:	6a 00                	push   $0x0
c0022dc9:	6a 7c                	push   $0x7c
c0022dcb:	e9 ea fa ff ff       	jmp    c00228ba <intr_entry>

c0022dd0 <intr7d_stub>:
c0022dd0:	55                   	push   %ebp
c0022dd1:	6a 00                	push   $0x0
c0022dd3:	6a 7d                	push   $0x7d
c0022dd5:	e9 e0 fa ff ff       	jmp    c00228ba <intr_entry>

c0022dda <intr7e_stub>:
c0022dda:	55                   	push   %ebp
c0022ddb:	6a 00                	push   $0x0
c0022ddd:	6a 7e                	push   $0x7e
c0022ddf:	e9 d6 fa ff ff       	jmp    c00228ba <intr_entry>

c0022de4 <intr7f_stub>:
c0022de4:	55                   	push   %ebp
c0022de5:	6a 00                	push   $0x0
c0022de7:	6a 7f                	push   $0x7f
c0022de9:	e9 cc fa ff ff       	jmp    c00228ba <intr_entry>

c0022dee <intr80_stub>:
c0022dee:	55                   	push   %ebp
c0022def:	6a 00                	push   $0x0
c0022df1:	68 80 00 00 00       	push   $0x80
c0022df6:	e9 bf fa ff ff       	jmp    c00228ba <intr_entry>

c0022dfb <intr81_stub>:
c0022dfb:	55                   	push   %ebp
c0022dfc:	6a 00                	push   $0x0
c0022dfe:	68 81 00 00 00       	push   $0x81
c0022e03:	e9 b2 fa ff ff       	jmp    c00228ba <intr_entry>

c0022e08 <intr82_stub>:
c0022e08:	55                   	push   %ebp
c0022e09:	6a 00                	push   $0x0
c0022e0b:	68 82 00 00 00       	push   $0x82
c0022e10:	e9 a5 fa ff ff       	jmp    c00228ba <intr_entry>

c0022e15 <intr83_stub>:
c0022e15:	55                   	push   %ebp
c0022e16:	6a 00                	push   $0x0
c0022e18:	68 83 00 00 00       	push   $0x83
c0022e1d:	e9 98 fa ff ff       	jmp    c00228ba <intr_entry>

c0022e22 <intr84_stub>:
c0022e22:	55                   	push   %ebp
c0022e23:	6a 00                	push   $0x0
c0022e25:	68 84 00 00 00       	push   $0x84
c0022e2a:	e9 8b fa ff ff       	jmp    c00228ba <intr_entry>

c0022e2f <intr85_stub>:
c0022e2f:	55                   	push   %ebp
c0022e30:	6a 00                	push   $0x0
c0022e32:	68 85 00 00 00       	push   $0x85
c0022e37:	e9 7e fa ff ff       	jmp    c00228ba <intr_entry>

c0022e3c <intr86_stub>:
c0022e3c:	55                   	push   %ebp
c0022e3d:	6a 00                	push   $0x0
c0022e3f:	68 86 00 00 00       	push   $0x86
c0022e44:	e9 71 fa ff ff       	jmp    c00228ba <intr_entry>

c0022e49 <intr87_stub>:
c0022e49:	55                   	push   %ebp
c0022e4a:	6a 00                	push   $0x0
c0022e4c:	68 87 00 00 00       	push   $0x87
c0022e51:	e9 64 fa ff ff       	jmp    c00228ba <intr_entry>

c0022e56 <intr88_stub>:
c0022e56:	55                   	push   %ebp
c0022e57:	6a 00                	push   $0x0
c0022e59:	68 88 00 00 00       	push   $0x88
c0022e5e:	e9 57 fa ff ff       	jmp    c00228ba <intr_entry>

c0022e63 <intr89_stub>:
c0022e63:	55                   	push   %ebp
c0022e64:	6a 00                	push   $0x0
c0022e66:	68 89 00 00 00       	push   $0x89
c0022e6b:	e9 4a fa ff ff       	jmp    c00228ba <intr_entry>

c0022e70 <intr8a_stub>:
c0022e70:	55                   	push   %ebp
c0022e71:	6a 00                	push   $0x0
c0022e73:	68 8a 00 00 00       	push   $0x8a
c0022e78:	e9 3d fa ff ff       	jmp    c00228ba <intr_entry>

c0022e7d <intr8b_stub>:
c0022e7d:	55                   	push   %ebp
c0022e7e:	6a 00                	push   $0x0
c0022e80:	68 8b 00 00 00       	push   $0x8b
c0022e85:	e9 30 fa ff ff       	jmp    c00228ba <intr_entry>

c0022e8a <intr8c_stub>:
c0022e8a:	55                   	push   %ebp
c0022e8b:	6a 00                	push   $0x0
c0022e8d:	68 8c 00 00 00       	push   $0x8c
c0022e92:	e9 23 fa ff ff       	jmp    c00228ba <intr_entry>

c0022e97 <intr8d_stub>:
c0022e97:	55                   	push   %ebp
c0022e98:	6a 00                	push   $0x0
c0022e9a:	68 8d 00 00 00       	push   $0x8d
c0022e9f:	e9 16 fa ff ff       	jmp    c00228ba <intr_entry>

c0022ea4 <intr8e_stub>:
c0022ea4:	55                   	push   %ebp
c0022ea5:	6a 00                	push   $0x0
c0022ea7:	68 8e 00 00 00       	push   $0x8e
c0022eac:	e9 09 fa ff ff       	jmp    c00228ba <intr_entry>

c0022eb1 <intr8f_stub>:
c0022eb1:	55                   	push   %ebp
c0022eb2:	6a 00                	push   $0x0
c0022eb4:	68 8f 00 00 00       	push   $0x8f
c0022eb9:	e9 fc f9 ff ff       	jmp    c00228ba <intr_entry>

c0022ebe <intr90_stub>:
c0022ebe:	55                   	push   %ebp
c0022ebf:	6a 00                	push   $0x0
c0022ec1:	68 90 00 00 00       	push   $0x90
c0022ec6:	e9 ef f9 ff ff       	jmp    c00228ba <intr_entry>

c0022ecb <intr91_stub>:
c0022ecb:	55                   	push   %ebp
c0022ecc:	6a 00                	push   $0x0
c0022ece:	68 91 00 00 00       	push   $0x91
c0022ed3:	e9 e2 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022ed8 <intr92_stub>:
c0022ed8:	55                   	push   %ebp
c0022ed9:	6a 00                	push   $0x0
c0022edb:	68 92 00 00 00       	push   $0x92
c0022ee0:	e9 d5 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022ee5 <intr93_stub>:
c0022ee5:	55                   	push   %ebp
c0022ee6:	6a 00                	push   $0x0
c0022ee8:	68 93 00 00 00       	push   $0x93
c0022eed:	e9 c8 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022ef2 <intr94_stub>:
c0022ef2:	55                   	push   %ebp
c0022ef3:	6a 00                	push   $0x0
c0022ef5:	68 94 00 00 00       	push   $0x94
c0022efa:	e9 bb f9 ff ff       	jmp    c00228ba <intr_entry>

c0022eff <intr95_stub>:
c0022eff:	55                   	push   %ebp
c0022f00:	6a 00                	push   $0x0
c0022f02:	68 95 00 00 00       	push   $0x95
c0022f07:	e9 ae f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f0c <intr96_stub>:
c0022f0c:	55                   	push   %ebp
c0022f0d:	6a 00                	push   $0x0
c0022f0f:	68 96 00 00 00       	push   $0x96
c0022f14:	e9 a1 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f19 <intr97_stub>:
c0022f19:	55                   	push   %ebp
c0022f1a:	6a 00                	push   $0x0
c0022f1c:	68 97 00 00 00       	push   $0x97
c0022f21:	e9 94 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f26 <intr98_stub>:
c0022f26:	55                   	push   %ebp
c0022f27:	6a 00                	push   $0x0
c0022f29:	68 98 00 00 00       	push   $0x98
c0022f2e:	e9 87 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f33 <intr99_stub>:
c0022f33:	55                   	push   %ebp
c0022f34:	6a 00                	push   $0x0
c0022f36:	68 99 00 00 00       	push   $0x99
c0022f3b:	e9 7a f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f40 <intr9a_stub>:
c0022f40:	55                   	push   %ebp
c0022f41:	6a 00                	push   $0x0
c0022f43:	68 9a 00 00 00       	push   $0x9a
c0022f48:	e9 6d f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f4d <intr9b_stub>:
c0022f4d:	55                   	push   %ebp
c0022f4e:	6a 00                	push   $0x0
c0022f50:	68 9b 00 00 00       	push   $0x9b
c0022f55:	e9 60 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f5a <intr9c_stub>:
c0022f5a:	55                   	push   %ebp
c0022f5b:	6a 00                	push   $0x0
c0022f5d:	68 9c 00 00 00       	push   $0x9c
c0022f62:	e9 53 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f67 <intr9d_stub>:
c0022f67:	55                   	push   %ebp
c0022f68:	6a 00                	push   $0x0
c0022f6a:	68 9d 00 00 00       	push   $0x9d
c0022f6f:	e9 46 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f74 <intr9e_stub>:
c0022f74:	55                   	push   %ebp
c0022f75:	6a 00                	push   $0x0
c0022f77:	68 9e 00 00 00       	push   $0x9e
c0022f7c:	e9 39 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f81 <intr9f_stub>:
c0022f81:	55                   	push   %ebp
c0022f82:	6a 00                	push   $0x0
c0022f84:	68 9f 00 00 00       	push   $0x9f
c0022f89:	e9 2c f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f8e <intra0_stub>:
c0022f8e:	55                   	push   %ebp
c0022f8f:	6a 00                	push   $0x0
c0022f91:	68 a0 00 00 00       	push   $0xa0
c0022f96:	e9 1f f9 ff ff       	jmp    c00228ba <intr_entry>

c0022f9b <intra1_stub>:
c0022f9b:	55                   	push   %ebp
c0022f9c:	6a 00                	push   $0x0
c0022f9e:	68 a1 00 00 00       	push   $0xa1
c0022fa3:	e9 12 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022fa8 <intra2_stub>:
c0022fa8:	55                   	push   %ebp
c0022fa9:	6a 00                	push   $0x0
c0022fab:	68 a2 00 00 00       	push   $0xa2
c0022fb0:	e9 05 f9 ff ff       	jmp    c00228ba <intr_entry>

c0022fb5 <intra3_stub>:
c0022fb5:	55                   	push   %ebp
c0022fb6:	6a 00                	push   $0x0
c0022fb8:	68 a3 00 00 00       	push   $0xa3
c0022fbd:	e9 f8 f8 ff ff       	jmp    c00228ba <intr_entry>

c0022fc2 <intra4_stub>:
c0022fc2:	55                   	push   %ebp
c0022fc3:	6a 00                	push   $0x0
c0022fc5:	68 a4 00 00 00       	push   $0xa4
c0022fca:	e9 eb f8 ff ff       	jmp    c00228ba <intr_entry>

c0022fcf <intra5_stub>:
c0022fcf:	55                   	push   %ebp
c0022fd0:	6a 00                	push   $0x0
c0022fd2:	68 a5 00 00 00       	push   $0xa5
c0022fd7:	e9 de f8 ff ff       	jmp    c00228ba <intr_entry>

c0022fdc <intra6_stub>:
c0022fdc:	55                   	push   %ebp
c0022fdd:	6a 00                	push   $0x0
c0022fdf:	68 a6 00 00 00       	push   $0xa6
c0022fe4:	e9 d1 f8 ff ff       	jmp    c00228ba <intr_entry>

c0022fe9 <intra7_stub>:
c0022fe9:	55                   	push   %ebp
c0022fea:	6a 00                	push   $0x0
c0022fec:	68 a7 00 00 00       	push   $0xa7
c0022ff1:	e9 c4 f8 ff ff       	jmp    c00228ba <intr_entry>

c0022ff6 <intra8_stub>:
c0022ff6:	55                   	push   %ebp
c0022ff7:	6a 00                	push   $0x0
c0022ff9:	68 a8 00 00 00       	push   $0xa8
c0022ffe:	e9 b7 f8 ff ff       	jmp    c00228ba <intr_entry>

c0023003 <intra9_stub>:
c0023003:	55                   	push   %ebp
c0023004:	6a 00                	push   $0x0
c0023006:	68 a9 00 00 00       	push   $0xa9
c002300b:	e9 aa f8 ff ff       	jmp    c00228ba <intr_entry>

c0023010 <intraa_stub>:
c0023010:	55                   	push   %ebp
c0023011:	6a 00                	push   $0x0
c0023013:	68 aa 00 00 00       	push   $0xaa
c0023018:	e9 9d f8 ff ff       	jmp    c00228ba <intr_entry>

c002301d <intrab_stub>:
c002301d:	55                   	push   %ebp
c002301e:	6a 00                	push   $0x0
c0023020:	68 ab 00 00 00       	push   $0xab
c0023025:	e9 90 f8 ff ff       	jmp    c00228ba <intr_entry>

c002302a <intrac_stub>:
c002302a:	55                   	push   %ebp
c002302b:	6a 00                	push   $0x0
c002302d:	68 ac 00 00 00       	push   $0xac
c0023032:	e9 83 f8 ff ff       	jmp    c00228ba <intr_entry>

c0023037 <intrad_stub>:
c0023037:	55                   	push   %ebp
c0023038:	6a 00                	push   $0x0
c002303a:	68 ad 00 00 00       	push   $0xad
c002303f:	e9 76 f8 ff ff       	jmp    c00228ba <intr_entry>

c0023044 <intrae_stub>:
c0023044:	55                   	push   %ebp
c0023045:	6a 00                	push   $0x0
c0023047:	68 ae 00 00 00       	push   $0xae
c002304c:	e9 69 f8 ff ff       	jmp    c00228ba <intr_entry>

c0023051 <intraf_stub>:
c0023051:	55                   	push   %ebp
c0023052:	6a 00                	push   $0x0
c0023054:	68 af 00 00 00       	push   $0xaf
c0023059:	e9 5c f8 ff ff       	jmp    c00228ba <intr_entry>

c002305e <intrb0_stub>:
c002305e:	55                   	push   %ebp
c002305f:	6a 00                	push   $0x0
c0023061:	68 b0 00 00 00       	push   $0xb0
c0023066:	e9 4f f8 ff ff       	jmp    c00228ba <intr_entry>

c002306b <intrb1_stub>:
c002306b:	55                   	push   %ebp
c002306c:	6a 00                	push   $0x0
c002306e:	68 b1 00 00 00       	push   $0xb1
c0023073:	e9 42 f8 ff ff       	jmp    c00228ba <intr_entry>

c0023078 <intrb2_stub>:
c0023078:	55                   	push   %ebp
c0023079:	6a 00                	push   $0x0
c002307b:	68 b2 00 00 00       	push   $0xb2
c0023080:	e9 35 f8 ff ff       	jmp    c00228ba <intr_entry>

c0023085 <intrb3_stub>:
c0023085:	55                   	push   %ebp
c0023086:	6a 00                	push   $0x0
c0023088:	68 b3 00 00 00       	push   $0xb3
c002308d:	e9 28 f8 ff ff       	jmp    c00228ba <intr_entry>

c0023092 <intrb4_stub>:
c0023092:	55                   	push   %ebp
c0023093:	6a 00                	push   $0x0
c0023095:	68 b4 00 00 00       	push   $0xb4
c002309a:	e9 1b f8 ff ff       	jmp    c00228ba <intr_entry>

c002309f <intrb5_stub>:
c002309f:	55                   	push   %ebp
c00230a0:	6a 00                	push   $0x0
c00230a2:	68 b5 00 00 00       	push   $0xb5
c00230a7:	e9 0e f8 ff ff       	jmp    c00228ba <intr_entry>

c00230ac <intrb6_stub>:
c00230ac:	55                   	push   %ebp
c00230ad:	6a 00                	push   $0x0
c00230af:	68 b6 00 00 00       	push   $0xb6
c00230b4:	e9 01 f8 ff ff       	jmp    c00228ba <intr_entry>

c00230b9 <intrb7_stub>:
c00230b9:	55                   	push   %ebp
c00230ba:	6a 00                	push   $0x0
c00230bc:	68 b7 00 00 00       	push   $0xb7
c00230c1:	e9 f4 f7 ff ff       	jmp    c00228ba <intr_entry>

c00230c6 <intrb8_stub>:
c00230c6:	55                   	push   %ebp
c00230c7:	6a 00                	push   $0x0
c00230c9:	68 b8 00 00 00       	push   $0xb8
c00230ce:	e9 e7 f7 ff ff       	jmp    c00228ba <intr_entry>

c00230d3 <intrb9_stub>:
c00230d3:	55                   	push   %ebp
c00230d4:	6a 00                	push   $0x0
c00230d6:	68 b9 00 00 00       	push   $0xb9
c00230db:	e9 da f7 ff ff       	jmp    c00228ba <intr_entry>

c00230e0 <intrba_stub>:
c00230e0:	55                   	push   %ebp
c00230e1:	6a 00                	push   $0x0
c00230e3:	68 ba 00 00 00       	push   $0xba
c00230e8:	e9 cd f7 ff ff       	jmp    c00228ba <intr_entry>

c00230ed <intrbb_stub>:
c00230ed:	55                   	push   %ebp
c00230ee:	6a 00                	push   $0x0
c00230f0:	68 bb 00 00 00       	push   $0xbb
c00230f5:	e9 c0 f7 ff ff       	jmp    c00228ba <intr_entry>

c00230fa <intrbc_stub>:
c00230fa:	55                   	push   %ebp
c00230fb:	6a 00                	push   $0x0
c00230fd:	68 bc 00 00 00       	push   $0xbc
c0023102:	e9 b3 f7 ff ff       	jmp    c00228ba <intr_entry>

c0023107 <intrbd_stub>:
c0023107:	55                   	push   %ebp
c0023108:	6a 00                	push   $0x0
c002310a:	68 bd 00 00 00       	push   $0xbd
c002310f:	e9 a6 f7 ff ff       	jmp    c00228ba <intr_entry>

c0023114 <intrbe_stub>:
c0023114:	55                   	push   %ebp
c0023115:	6a 00                	push   $0x0
c0023117:	68 be 00 00 00       	push   $0xbe
c002311c:	e9 99 f7 ff ff       	jmp    c00228ba <intr_entry>

c0023121 <intrbf_stub>:
c0023121:	55                   	push   %ebp
c0023122:	6a 00                	push   $0x0
c0023124:	68 bf 00 00 00       	push   $0xbf
c0023129:	e9 8c f7 ff ff       	jmp    c00228ba <intr_entry>

c002312e <intrc0_stub>:
c002312e:	55                   	push   %ebp
c002312f:	6a 00                	push   $0x0
c0023131:	68 c0 00 00 00       	push   $0xc0
c0023136:	e9 7f f7 ff ff       	jmp    c00228ba <intr_entry>

c002313b <intrc1_stub>:
c002313b:	55                   	push   %ebp
c002313c:	6a 00                	push   $0x0
c002313e:	68 c1 00 00 00       	push   $0xc1
c0023143:	e9 72 f7 ff ff       	jmp    c00228ba <intr_entry>

c0023148 <intrc2_stub>:
c0023148:	55                   	push   %ebp
c0023149:	6a 00                	push   $0x0
c002314b:	68 c2 00 00 00       	push   $0xc2
c0023150:	e9 65 f7 ff ff       	jmp    c00228ba <intr_entry>

c0023155 <intrc3_stub>:
c0023155:	55                   	push   %ebp
c0023156:	6a 00                	push   $0x0
c0023158:	68 c3 00 00 00       	push   $0xc3
c002315d:	e9 58 f7 ff ff       	jmp    c00228ba <intr_entry>

c0023162 <intrc4_stub>:
c0023162:	55                   	push   %ebp
c0023163:	6a 00                	push   $0x0
c0023165:	68 c4 00 00 00       	push   $0xc4
c002316a:	e9 4b f7 ff ff       	jmp    c00228ba <intr_entry>

c002316f <intrc5_stub>:
c002316f:	55                   	push   %ebp
c0023170:	6a 00                	push   $0x0
c0023172:	68 c5 00 00 00       	push   $0xc5
c0023177:	e9 3e f7 ff ff       	jmp    c00228ba <intr_entry>

c002317c <intrc6_stub>:
c002317c:	55                   	push   %ebp
c002317d:	6a 00                	push   $0x0
c002317f:	68 c6 00 00 00       	push   $0xc6
c0023184:	e9 31 f7 ff ff       	jmp    c00228ba <intr_entry>

c0023189 <intrc7_stub>:
c0023189:	55                   	push   %ebp
c002318a:	6a 00                	push   $0x0
c002318c:	68 c7 00 00 00       	push   $0xc7
c0023191:	e9 24 f7 ff ff       	jmp    c00228ba <intr_entry>

c0023196 <intrc8_stub>:
c0023196:	55                   	push   %ebp
c0023197:	6a 00                	push   $0x0
c0023199:	68 c8 00 00 00       	push   $0xc8
c002319e:	e9 17 f7 ff ff       	jmp    c00228ba <intr_entry>

c00231a3 <intrc9_stub>:
c00231a3:	55                   	push   %ebp
c00231a4:	6a 00                	push   $0x0
c00231a6:	68 c9 00 00 00       	push   $0xc9
c00231ab:	e9 0a f7 ff ff       	jmp    c00228ba <intr_entry>

c00231b0 <intrca_stub>:
c00231b0:	55                   	push   %ebp
c00231b1:	6a 00                	push   $0x0
c00231b3:	68 ca 00 00 00       	push   $0xca
c00231b8:	e9 fd f6 ff ff       	jmp    c00228ba <intr_entry>

c00231bd <intrcb_stub>:
c00231bd:	55                   	push   %ebp
c00231be:	6a 00                	push   $0x0
c00231c0:	68 cb 00 00 00       	push   $0xcb
c00231c5:	e9 f0 f6 ff ff       	jmp    c00228ba <intr_entry>

c00231ca <intrcc_stub>:
c00231ca:	55                   	push   %ebp
c00231cb:	6a 00                	push   $0x0
c00231cd:	68 cc 00 00 00       	push   $0xcc
c00231d2:	e9 e3 f6 ff ff       	jmp    c00228ba <intr_entry>

c00231d7 <intrcd_stub>:
c00231d7:	55                   	push   %ebp
c00231d8:	6a 00                	push   $0x0
c00231da:	68 cd 00 00 00       	push   $0xcd
c00231df:	e9 d6 f6 ff ff       	jmp    c00228ba <intr_entry>

c00231e4 <intrce_stub>:
c00231e4:	55                   	push   %ebp
c00231e5:	6a 00                	push   $0x0
c00231e7:	68 ce 00 00 00       	push   $0xce
c00231ec:	e9 c9 f6 ff ff       	jmp    c00228ba <intr_entry>

c00231f1 <intrcf_stub>:
c00231f1:	55                   	push   %ebp
c00231f2:	6a 00                	push   $0x0
c00231f4:	68 cf 00 00 00       	push   $0xcf
c00231f9:	e9 bc f6 ff ff       	jmp    c00228ba <intr_entry>

c00231fe <intrd0_stub>:
c00231fe:	55                   	push   %ebp
c00231ff:	6a 00                	push   $0x0
c0023201:	68 d0 00 00 00       	push   $0xd0
c0023206:	e9 af f6 ff ff       	jmp    c00228ba <intr_entry>

c002320b <intrd1_stub>:
c002320b:	55                   	push   %ebp
c002320c:	6a 00                	push   $0x0
c002320e:	68 d1 00 00 00       	push   $0xd1
c0023213:	e9 a2 f6 ff ff       	jmp    c00228ba <intr_entry>

c0023218 <intrd2_stub>:
c0023218:	55                   	push   %ebp
c0023219:	6a 00                	push   $0x0
c002321b:	68 d2 00 00 00       	push   $0xd2
c0023220:	e9 95 f6 ff ff       	jmp    c00228ba <intr_entry>

c0023225 <intrd3_stub>:
c0023225:	55                   	push   %ebp
c0023226:	6a 00                	push   $0x0
c0023228:	68 d3 00 00 00       	push   $0xd3
c002322d:	e9 88 f6 ff ff       	jmp    c00228ba <intr_entry>

c0023232 <intrd4_stub>:
c0023232:	55                   	push   %ebp
c0023233:	6a 00                	push   $0x0
c0023235:	68 d4 00 00 00       	push   $0xd4
c002323a:	e9 7b f6 ff ff       	jmp    c00228ba <intr_entry>

c002323f <intrd5_stub>:
c002323f:	55                   	push   %ebp
c0023240:	6a 00                	push   $0x0
c0023242:	68 d5 00 00 00       	push   $0xd5
c0023247:	e9 6e f6 ff ff       	jmp    c00228ba <intr_entry>

c002324c <intrd6_stub>:
c002324c:	55                   	push   %ebp
c002324d:	6a 00                	push   $0x0
c002324f:	68 d6 00 00 00       	push   $0xd6
c0023254:	e9 61 f6 ff ff       	jmp    c00228ba <intr_entry>

c0023259 <intrd7_stub>:
c0023259:	55                   	push   %ebp
c002325a:	6a 00                	push   $0x0
c002325c:	68 d7 00 00 00       	push   $0xd7
c0023261:	e9 54 f6 ff ff       	jmp    c00228ba <intr_entry>

c0023266 <intrd8_stub>:
c0023266:	55                   	push   %ebp
c0023267:	6a 00                	push   $0x0
c0023269:	68 d8 00 00 00       	push   $0xd8
c002326e:	e9 47 f6 ff ff       	jmp    c00228ba <intr_entry>

c0023273 <intrd9_stub>:
c0023273:	55                   	push   %ebp
c0023274:	6a 00                	push   $0x0
c0023276:	68 d9 00 00 00       	push   $0xd9
c002327b:	e9 3a f6 ff ff       	jmp    c00228ba <intr_entry>

c0023280 <intrda_stub>:
c0023280:	55                   	push   %ebp
c0023281:	6a 00                	push   $0x0
c0023283:	68 da 00 00 00       	push   $0xda
c0023288:	e9 2d f6 ff ff       	jmp    c00228ba <intr_entry>

c002328d <intrdb_stub>:
c002328d:	55                   	push   %ebp
c002328e:	6a 00                	push   $0x0
c0023290:	68 db 00 00 00       	push   $0xdb
c0023295:	e9 20 f6 ff ff       	jmp    c00228ba <intr_entry>

c002329a <intrdc_stub>:
c002329a:	55                   	push   %ebp
c002329b:	6a 00                	push   $0x0
c002329d:	68 dc 00 00 00       	push   $0xdc
c00232a2:	e9 13 f6 ff ff       	jmp    c00228ba <intr_entry>

c00232a7 <intrdd_stub>:
c00232a7:	55                   	push   %ebp
c00232a8:	6a 00                	push   $0x0
c00232aa:	68 dd 00 00 00       	push   $0xdd
c00232af:	e9 06 f6 ff ff       	jmp    c00228ba <intr_entry>

c00232b4 <intrde_stub>:
c00232b4:	55                   	push   %ebp
c00232b5:	6a 00                	push   $0x0
c00232b7:	68 de 00 00 00       	push   $0xde
c00232bc:	e9 f9 f5 ff ff       	jmp    c00228ba <intr_entry>

c00232c1 <intrdf_stub>:
c00232c1:	55                   	push   %ebp
c00232c2:	6a 00                	push   $0x0
c00232c4:	68 df 00 00 00       	push   $0xdf
c00232c9:	e9 ec f5 ff ff       	jmp    c00228ba <intr_entry>

c00232ce <intre0_stub>:
c00232ce:	55                   	push   %ebp
c00232cf:	6a 00                	push   $0x0
c00232d1:	68 e0 00 00 00       	push   $0xe0
c00232d6:	e9 df f5 ff ff       	jmp    c00228ba <intr_entry>

c00232db <intre1_stub>:
c00232db:	55                   	push   %ebp
c00232dc:	6a 00                	push   $0x0
c00232de:	68 e1 00 00 00       	push   $0xe1
c00232e3:	e9 d2 f5 ff ff       	jmp    c00228ba <intr_entry>

c00232e8 <intre2_stub>:
c00232e8:	55                   	push   %ebp
c00232e9:	6a 00                	push   $0x0
c00232eb:	68 e2 00 00 00       	push   $0xe2
c00232f0:	e9 c5 f5 ff ff       	jmp    c00228ba <intr_entry>

c00232f5 <intre3_stub>:
c00232f5:	55                   	push   %ebp
c00232f6:	6a 00                	push   $0x0
c00232f8:	68 e3 00 00 00       	push   $0xe3
c00232fd:	e9 b8 f5 ff ff       	jmp    c00228ba <intr_entry>

c0023302 <intre4_stub>:
c0023302:	55                   	push   %ebp
c0023303:	6a 00                	push   $0x0
c0023305:	68 e4 00 00 00       	push   $0xe4
c002330a:	e9 ab f5 ff ff       	jmp    c00228ba <intr_entry>

c002330f <intre5_stub>:
c002330f:	55                   	push   %ebp
c0023310:	6a 00                	push   $0x0
c0023312:	68 e5 00 00 00       	push   $0xe5
c0023317:	e9 9e f5 ff ff       	jmp    c00228ba <intr_entry>

c002331c <intre6_stub>:
c002331c:	55                   	push   %ebp
c002331d:	6a 00                	push   $0x0
c002331f:	68 e6 00 00 00       	push   $0xe6
c0023324:	e9 91 f5 ff ff       	jmp    c00228ba <intr_entry>

c0023329 <intre7_stub>:
c0023329:	55                   	push   %ebp
c002332a:	6a 00                	push   $0x0
c002332c:	68 e7 00 00 00       	push   $0xe7
c0023331:	e9 84 f5 ff ff       	jmp    c00228ba <intr_entry>

c0023336 <intre8_stub>:
c0023336:	55                   	push   %ebp
c0023337:	6a 00                	push   $0x0
c0023339:	68 e8 00 00 00       	push   $0xe8
c002333e:	e9 77 f5 ff ff       	jmp    c00228ba <intr_entry>

c0023343 <intre9_stub>:
c0023343:	55                   	push   %ebp
c0023344:	6a 00                	push   $0x0
c0023346:	68 e9 00 00 00       	push   $0xe9
c002334b:	e9 6a f5 ff ff       	jmp    c00228ba <intr_entry>

c0023350 <intrea_stub>:
c0023350:	55                   	push   %ebp
c0023351:	6a 00                	push   $0x0
c0023353:	68 ea 00 00 00       	push   $0xea
c0023358:	e9 5d f5 ff ff       	jmp    c00228ba <intr_entry>

c002335d <intreb_stub>:
c002335d:	55                   	push   %ebp
c002335e:	6a 00                	push   $0x0
c0023360:	68 eb 00 00 00       	push   $0xeb
c0023365:	e9 50 f5 ff ff       	jmp    c00228ba <intr_entry>

c002336a <intrec_stub>:
c002336a:	55                   	push   %ebp
c002336b:	6a 00                	push   $0x0
c002336d:	68 ec 00 00 00       	push   $0xec
c0023372:	e9 43 f5 ff ff       	jmp    c00228ba <intr_entry>

c0023377 <intred_stub>:
c0023377:	55                   	push   %ebp
c0023378:	6a 00                	push   $0x0
c002337a:	68 ed 00 00 00       	push   $0xed
c002337f:	e9 36 f5 ff ff       	jmp    c00228ba <intr_entry>

c0023384 <intree_stub>:
c0023384:	55                   	push   %ebp
c0023385:	6a 00                	push   $0x0
c0023387:	68 ee 00 00 00       	push   $0xee
c002338c:	e9 29 f5 ff ff       	jmp    c00228ba <intr_entry>

c0023391 <intref_stub>:
c0023391:	55                   	push   %ebp
c0023392:	6a 00                	push   $0x0
c0023394:	68 ef 00 00 00       	push   $0xef
c0023399:	e9 1c f5 ff ff       	jmp    c00228ba <intr_entry>

c002339e <intrf0_stub>:
c002339e:	55                   	push   %ebp
c002339f:	6a 00                	push   $0x0
c00233a1:	68 f0 00 00 00       	push   $0xf0
c00233a6:	e9 0f f5 ff ff       	jmp    c00228ba <intr_entry>

c00233ab <intrf1_stub>:
c00233ab:	55                   	push   %ebp
c00233ac:	6a 00                	push   $0x0
c00233ae:	68 f1 00 00 00       	push   $0xf1
c00233b3:	e9 02 f5 ff ff       	jmp    c00228ba <intr_entry>

c00233b8 <intrf2_stub>:
c00233b8:	55                   	push   %ebp
c00233b9:	6a 00                	push   $0x0
c00233bb:	68 f2 00 00 00       	push   $0xf2
c00233c0:	e9 f5 f4 ff ff       	jmp    c00228ba <intr_entry>

c00233c5 <intrf3_stub>:
c00233c5:	55                   	push   %ebp
c00233c6:	6a 00                	push   $0x0
c00233c8:	68 f3 00 00 00       	push   $0xf3
c00233cd:	e9 e8 f4 ff ff       	jmp    c00228ba <intr_entry>

c00233d2 <intrf4_stub>:
c00233d2:	55                   	push   %ebp
c00233d3:	6a 00                	push   $0x0
c00233d5:	68 f4 00 00 00       	push   $0xf4
c00233da:	e9 db f4 ff ff       	jmp    c00228ba <intr_entry>

c00233df <intrf5_stub>:
c00233df:	55                   	push   %ebp
c00233e0:	6a 00                	push   $0x0
c00233e2:	68 f5 00 00 00       	push   $0xf5
c00233e7:	e9 ce f4 ff ff       	jmp    c00228ba <intr_entry>

c00233ec <intrf6_stub>:
c00233ec:	55                   	push   %ebp
c00233ed:	6a 00                	push   $0x0
c00233ef:	68 f6 00 00 00       	push   $0xf6
c00233f4:	e9 c1 f4 ff ff       	jmp    c00228ba <intr_entry>

c00233f9 <intrf7_stub>:
c00233f9:	55                   	push   %ebp
c00233fa:	6a 00                	push   $0x0
c00233fc:	68 f7 00 00 00       	push   $0xf7
c0023401:	e9 b4 f4 ff ff       	jmp    c00228ba <intr_entry>

c0023406 <intrf8_stub>:
c0023406:	55                   	push   %ebp
c0023407:	6a 00                	push   $0x0
c0023409:	68 f8 00 00 00       	push   $0xf8
c002340e:	e9 a7 f4 ff ff       	jmp    c00228ba <intr_entry>

c0023413 <intrf9_stub>:
c0023413:	55                   	push   %ebp
c0023414:	6a 00                	push   $0x0
c0023416:	68 f9 00 00 00       	push   $0xf9
c002341b:	e9 9a f4 ff ff       	jmp    c00228ba <intr_entry>

c0023420 <intrfa_stub>:
c0023420:	55                   	push   %ebp
c0023421:	6a 00                	push   $0x0
c0023423:	68 fa 00 00 00       	push   $0xfa
c0023428:	e9 8d f4 ff ff       	jmp    c00228ba <intr_entry>

c002342d <intrfb_stub>:
c002342d:	55                   	push   %ebp
c002342e:	6a 00                	push   $0x0
c0023430:	68 fb 00 00 00       	push   $0xfb
c0023435:	e9 80 f4 ff ff       	jmp    c00228ba <intr_entry>

c002343a <intrfc_stub>:
c002343a:	55                   	push   %ebp
c002343b:	6a 00                	push   $0x0
c002343d:	68 fc 00 00 00       	push   $0xfc
c0023442:	e9 73 f4 ff ff       	jmp    c00228ba <intr_entry>

c0023447 <intrfd_stub>:
c0023447:	55                   	push   %ebp
c0023448:	6a 00                	push   $0x0
c002344a:	68 fd 00 00 00       	push   $0xfd
c002344f:	e9 66 f4 ff ff       	jmp    c00228ba <intr_entry>

c0023454 <intrfe_stub>:
c0023454:	55                   	push   %ebp
c0023455:	6a 00                	push   $0x0
c0023457:	68 fe 00 00 00       	push   $0xfe
c002345c:	e9 59 f4 ff ff       	jmp    c00228ba <intr_entry>

c0023461 <intrff_stub>:
c0023461:	55                   	push   %ebp
c0023462:	6a 00                	push   $0x0
c0023464:	68 ff 00 00 00       	push   $0xff
c0023469:	e9 4c f4 ff ff       	jmp    c00228ba <intr_entry>

c002346e <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c002346e:	55                   	push   %ebp
c002346f:	89 e5                	mov    %esp,%ebp
c0023471:	53                   	push   %ebx
c0023472:	83 ec 04             	sub    $0x4,%esp
c0023475:	e8 ae df 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002347a:	05 fe 6e 01 00       	add    $0x16efe,%eax
  ASSERT (sema != NULL);
c002347f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023483:	75 28                	jne    c00234ad <sema_init+0x3f>
c0023485:	83 ec 0c             	sub    $0xc,%esp
c0023488:	8d 90 18 7c ff ff    	lea    -0x83e8(%eax),%edx
c002348e:	52                   	push   %edx
c002348f:	8d 90 25 7c ff ff    	lea    -0x83db(%eax),%edx
c0023495:	52                   	push   %edx
c0023496:	8d 90 ec 7c ff ff    	lea    -0x8314(%eax),%edx
c002349c:	52                   	push   %edx
c002349d:	6a 2f                	push   $0x2f
c002349f:	8d 90 3c 7c ff ff    	lea    -0x83c4(%eax),%edx
c00234a5:	52                   	push   %edx
c00234a6:	89 c3                	mov    %eax,%ebx
c00234a8:	e8 b7 82 00 00       	call   c002b764 <debug_panic>

  sema->value = value;
c00234ad:	8b 55 08             	mov    0x8(%ebp),%edx
c00234b0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00234b3:	89 0a                	mov    %ecx,(%edx)
  list_init (&sema->waiters);
c00234b5:	8b 55 08             	mov    0x8(%ebp),%edx
c00234b8:	83 c2 04             	add    $0x4,%edx
c00234bb:	83 ec 0c             	sub    $0xc,%esp
c00234be:	52                   	push   %edx
c00234bf:	89 c3                	mov    %eax,%ebx
c00234c1:	e8 7e 85 00 00       	call   c002ba44 <list_init>
c00234c6:	83 c4 10             	add    $0x10,%esp
}
c00234c9:	90                   	nop
c00234ca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00234cd:	c9                   	leave  
c00234ce:	c3                   	ret    

c00234cf <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c00234cf:	55                   	push   %ebp
c00234d0:	89 e5                	mov    %esp,%ebp
c00234d2:	53                   	push   %ebx
c00234d3:	83 ec 14             	sub    $0x14,%esp
c00234d6:	e8 51 df 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00234db:	81 c3 9d 6e 01 00    	add    $0x16e9d,%ebx
  enum intr_level old_level;

  ASSERT (sema != NULL);
c00234e1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00234e5:	75 26                	jne    c002350d <sema_down+0x3e>
c00234e7:	83 ec 0c             	sub    $0xc,%esp
c00234ea:	8d 83 18 7c ff ff    	lea    -0x83e8(%ebx),%eax
c00234f0:	50                   	push   %eax
c00234f1:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c00234f7:	50                   	push   %eax
c00234f8:	8d 83 f8 7c ff ff    	lea    -0x8308(%ebx),%eax
c00234fe:	50                   	push   %eax
c00234ff:	6a 41                	push   $0x41
c0023501:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023507:	50                   	push   %eax
c0023508:	e8 57 82 00 00       	call   c002b764 <debug_panic>
  ASSERT (!intr_context ());
c002350d:	e8 32 ed ff ff       	call   c0022244 <intr_context>
c0023512:	83 f0 01             	xor    $0x1,%eax
c0023515:	84 c0                	test   %al,%al
c0023517:	75 26                	jne    c002353f <sema_down+0x70>
c0023519:	83 ec 0c             	sub    $0xc,%esp
c002351c:	8d 83 52 7c ff ff    	lea    -0x83ae(%ebx),%eax
c0023522:	50                   	push   %eax
c0023523:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023529:	50                   	push   %eax
c002352a:	8d 83 f8 7c ff ff    	lea    -0x8308(%ebx),%eax
c0023530:	50                   	push   %eax
c0023531:	6a 42                	push   $0x42
c0023533:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023539:	50                   	push   %eax
c002353a:	e8 25 82 00 00       	call   c002b764 <debug_panic>

  old_level = intr_disable ();
c002353f:	e8 a2 e9 ff ff       	call   c0021ee6 <intr_disable>
c0023544:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (sema->value == 0) 
c0023547:	eb 20                	jmp    c0023569 <sema_down+0x9a>
    {

      list_push_back (&sema->waiters, &thread_current ()->elem);
c0023549:	e8 33 de ff ff       	call   c0021381 <thread_current>
c002354e:	8d 50 28             	lea    0x28(%eax),%edx
c0023551:	8b 45 08             	mov    0x8(%ebp),%eax
c0023554:	83 c0 04             	add    $0x4,%eax
c0023557:	83 ec 08             	sub    $0x8,%esp
c002355a:	52                   	push   %edx
c002355b:	50                   	push   %eax
c002355c:	e8 e9 89 00 00       	call   c002bf4a <list_push_back>
c0023561:	83 c4 10             	add    $0x10,%esp
      thread_block ();
c0023564:	e8 93 dc ff ff       	call   c00211fc <thread_block>
  while (sema->value == 0) 
c0023569:	8b 45 08             	mov    0x8(%ebp),%eax
c002356c:	8b 00                	mov    (%eax),%eax
c002356e:	85 c0                	test   %eax,%eax
c0023570:	74 d7                	je     c0023549 <sema_down+0x7a>
    }
  sema->value--;
c0023572:	8b 45 08             	mov    0x8(%ebp),%eax
c0023575:	8b 00                	mov    (%eax),%eax
c0023577:	8d 50 ff             	lea    -0x1(%eax),%edx
c002357a:	8b 45 08             	mov    0x8(%ebp),%eax
c002357d:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c002357f:	83 ec 0c             	sub    $0xc,%esp
c0023582:	ff 75 f4             	push   -0xc(%ebp)
c0023585:	e8 e3 e8 ff ff       	call   c0021e6d <intr_set_level>
c002358a:	83 c4 10             	add    $0x10,%esp
}
c002358d:	90                   	nop
c002358e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023591:	c9                   	leave  
c0023592:	c3                   	ret    

c0023593 <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0023593:	55                   	push   %ebp
c0023594:	89 e5                	mov    %esp,%ebp
c0023596:	53                   	push   %ebx
c0023597:	83 ec 14             	sub    $0x14,%esp
c002359a:	e8 8d de 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002359f:	81 c3 d9 6d 01 00    	add    $0x16dd9,%ebx
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c00235a5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00235a9:	75 26                	jne    c00235d1 <sema_try_down+0x3e>
c00235ab:	83 ec 0c             	sub    $0xc,%esp
c00235ae:	8d 83 18 7c ff ff    	lea    -0x83e8(%ebx),%eax
c00235b4:	50                   	push   %eax
c00235b5:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c00235bb:	50                   	push   %eax
c00235bc:	8d 83 04 7d ff ff    	lea    -0x82fc(%ebx),%eax
c00235c2:	50                   	push   %eax
c00235c3:	6a 5a                	push   $0x5a
c00235c5:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c00235cb:	50                   	push   %eax
c00235cc:	e8 93 81 00 00       	call   c002b764 <debug_panic>

  old_level = intr_disable ();
c00235d1:	e8 10 e9 ff ff       	call   c0021ee6 <intr_disable>
c00235d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (sema->value > 0) 
c00235d9:	8b 45 08             	mov    0x8(%ebp),%eax
c00235dc:	8b 00                	mov    (%eax),%eax
c00235de:	85 c0                	test   %eax,%eax
c00235e0:	74 13                	je     c00235f5 <sema_try_down+0x62>
    {
      sema->value--;
c00235e2:	8b 45 08             	mov    0x8(%ebp),%eax
c00235e5:	8b 00                	mov    (%eax),%eax
c00235e7:	8d 50 ff             	lea    -0x1(%eax),%edx
c00235ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00235ed:	89 10                	mov    %edx,(%eax)
      success = true; 
c00235ef:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
c00235f3:	eb 04                	jmp    c00235f9 <sema_try_down+0x66>
    }
  else
    success = false;
c00235f5:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  intr_set_level (old_level);
c00235f9:	83 ec 0c             	sub    $0xc,%esp
c00235fc:	ff 75 f0             	push   -0x10(%ebp)
c00235ff:	e8 69 e8 ff ff       	call   c0021e6d <intr_set_level>
c0023604:	83 c4 10             	add    $0x10,%esp

  return success;
c0023607:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c002360b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002360e:	c9                   	leave  
c002360f:	c3                   	ret    

c0023610 <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c0023610:	55                   	push   %ebp
c0023611:	89 e5                	mov    %esp,%ebp
c0023613:	53                   	push   %ebx
c0023614:	83 ec 14             	sub    $0x14,%esp
c0023617:	e8 10 de 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002361c:	81 c3 5c 6d 01 00    	add    $0x16d5c,%ebx
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0023622:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023626:	75 26                	jne    c002364e <sema_up+0x3e>
c0023628:	83 ec 0c             	sub    $0xc,%esp
c002362b:	8d 83 18 7c ff ff    	lea    -0x83e8(%ebx),%eax
c0023631:	50                   	push   %eax
c0023632:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023638:	50                   	push   %eax
c0023639:	8d 83 14 7d ff ff    	lea    -0x82ec(%ebx),%eax
c002363f:	50                   	push   %eax
c0023640:	6a 72                	push   $0x72
c0023642:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023648:	50                   	push   %eax
c0023649:	e8 16 81 00 00       	call   c002b764 <debug_panic>

  old_level = intr_disable ();
c002364e:	e8 93 e8 ff ff       	call   c0021ee6 <intr_disable>
c0023653:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!list_empty (&sema->waiters))
c0023656:	8b 45 08             	mov    0x8(%ebp),%eax
c0023659:	83 c0 04             	add    $0x4,%eax
c002365c:	83 ec 0c             	sub    $0xc,%esp
c002365f:	50                   	push   %eax
c0023660:	e8 fa 8a 00 00       	call   c002c15f <list_empty>
c0023665:	83 c4 10             	add    $0x10,%esp
c0023668:	83 f0 01             	xor    $0x1,%eax
c002366b:	84 c0                	test   %al,%al
c002366d:	74 3f                	je     c00236ae <sema_up+0x9e>
  {
    list_sort (&sema->waiters, cmp_priority, NULL);
c002366f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023672:	83 c0 04             	add    $0x4,%eax
c0023675:	83 ec 04             	sub    $0x4,%esp
c0023678:	6a 00                	push   $0x0
c002367a:	c7 c2 bd 1d 02 c0    	mov    $0xc0021dbd,%edx
c0023680:	52                   	push   %edx
c0023681:	50                   	push   %eax
c0023682:	e8 2c 8f 00 00       	call   c002c5b3 <list_sort>
c0023687:	83 c4 10             	add    $0x10,%esp
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c002368a:	8b 45 08             	mov    0x8(%ebp),%eax
c002368d:	83 c0 04             	add    $0x4,%eax
c0023690:	83 ec 0c             	sub    $0xc,%esp
c0023693:	50                   	push   %eax
c0023694:	e8 51 89 00 00       	call   c002bfea <list_pop_front>
c0023699:	83 c4 10             	add    $0x10,%esp
c002369c:	83 c0 04             	add    $0x4,%eax
c002369f:	83 e8 2c             	sub    $0x2c,%eax
c00236a2:	83 ec 0c             	sub    $0xc,%esp
c00236a5:	50                   	push   %eax
c00236a6:	e8 e1 db ff ff       	call   c002128c <thread_unblock>
c00236ab:	83 c4 10             	add    $0x10,%esp
                                struct thread, elem));
  }
  sema->value++;
c00236ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00236b1:	8b 00                	mov    (%eax),%eax
c00236b3:	8d 50 01             	lea    0x1(%eax),%edx
c00236b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00236b9:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c00236bb:	83 ec 0c             	sub    $0xc,%esp
c00236be:	ff 75 f4             	push   -0xc(%ebp)
c00236c1:	e8 a7 e7 ff ff       	call   c0021e6d <intr_set_level>
c00236c6:	83 c4 10             	add    $0x10,%esp

  thread_yield();
c00236c9:	e8 ec dd ff ff       	call   c00214ba <thread_yield>
}
c00236ce:	90                   	nop
c00236cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00236d2:	c9                   	leave  
c00236d3:	c3                   	ret    

c00236d4 <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c00236d4:	55                   	push   %ebp
c00236d5:	89 e5                	mov    %esp,%ebp
c00236d7:	53                   	push   %ebx
c00236d8:	83 ec 34             	sub    $0x34,%esp
c00236db:	e8 4c dd 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00236e0:	81 c3 98 6c 01 00    	add    $0x16c98,%ebx
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c00236e6:	83 ec 0c             	sub    $0xc,%esp
c00236e9:	8d 83 63 7c ff ff    	lea    -0x839d(%ebx),%eax
c00236ef:	50                   	push   %eax
c00236f0:	e8 f0 57 00 00       	call   c0028ee5 <printf>
c00236f5:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[0], 0);
c00236f8:	83 ec 08             	sub    $0x8,%esp
c00236fb:	6a 00                	push   $0x0
c00236fd:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0023700:	50                   	push   %eax
c0023701:	e8 68 fd ff ff       	call   c002346e <sema_init>
c0023706:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[1], 0);
c0023709:	83 ec 08             	sub    $0x8,%esp
c002370c:	6a 00                	push   $0x0
c002370e:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0023711:	83 c0 14             	add    $0x14,%eax
c0023714:	50                   	push   %eax
c0023715:	e8 54 fd ff ff       	call   c002346e <sema_init>
c002371a:	83 c4 10             	add    $0x10,%esp
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c002371d:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0023720:	50                   	push   %eax
c0023721:	8d 83 0d 94 fe ff    	lea    -0x16bf3(%ebx),%eax
c0023727:	50                   	push   %eax
c0023728:	6a 1f                	push   $0x1f
c002372a:	8d 83 79 7c ff ff    	lea    -0x8387(%ebx),%eax
c0023730:	50                   	push   %eax
c0023731:	e8 6e d9 ff ff       	call   c00210a4 <thread_create>
c0023736:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0023739:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023740:	eb 25                	jmp    c0023767 <sema_self_test+0x93>
    {
      sema_up (&sema[0]);
c0023742:	83 ec 0c             	sub    $0xc,%esp
c0023745:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0023748:	50                   	push   %eax
c0023749:	e8 c2 fe ff ff       	call   c0023610 <sema_up>
c002374e:	83 c4 10             	add    $0x10,%esp
      sema_down (&sema[1]);
c0023751:	83 ec 0c             	sub    $0xc,%esp
c0023754:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0023757:	83 c0 14             	add    $0x14,%eax
c002375a:	50                   	push   %eax
c002375b:	e8 6f fd ff ff       	call   c00234cf <sema_down>
c0023760:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0023763:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0023767:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002376b:	7e d5                	jle    c0023742 <sema_self_test+0x6e>
    }
  printf ("done.\n");
c002376d:	83 ec 0c             	sub    $0xc,%esp
c0023770:	8d 83 83 7c ff ff    	lea    -0x837d(%ebx),%eax
c0023776:	50                   	push   %eax
c0023777:	e8 70 a8 00 00       	call   c002dfec <puts>
c002377c:	83 c4 10             	add    $0x10,%esp
}
c002377f:	90                   	nop
c0023780:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023783:	c9                   	leave  
c0023784:	c3                   	ret    

c0023785 <sema_test_helper>:

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0023785:	55                   	push   %ebp
c0023786:	89 e5                	mov    %esp,%ebp
c0023788:	83 ec 18             	sub    $0x18,%esp
c002378b:	e8 98 dc 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0023790:	05 e8 6b 01 00       	add    $0x16be8,%eax
  struct semaphore *sema = sema_;
c0023795:	8b 45 08             	mov    0x8(%ebp),%eax
c0023798:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  for (i = 0; i < 10; i++) 
c002379b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00237a2:	eb 24                	jmp    c00237c8 <sema_test_helper+0x43>
    {
      sema_down (&sema[0]);
c00237a4:	83 ec 0c             	sub    $0xc,%esp
c00237a7:	ff 75 f0             	push   -0x10(%ebp)
c00237aa:	e8 20 fd ff ff       	call   c00234cf <sema_down>
c00237af:	83 c4 10             	add    $0x10,%esp
      sema_up (&sema[1]);
c00237b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00237b5:	83 c0 14             	add    $0x14,%eax
c00237b8:	83 ec 0c             	sub    $0xc,%esp
c00237bb:	50                   	push   %eax
c00237bc:	e8 4f fe ff ff       	call   c0023610 <sema_up>
c00237c1:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c00237c4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00237c8:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c00237cc:	7e d6                	jle    c00237a4 <sema_test_helper+0x1f>
    }
}
c00237ce:	90                   	nop
c00237cf:	90                   	nop
c00237d0:	c9                   	leave  
c00237d1:	c3                   	ret    

c00237d2 <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c00237d2:	55                   	push   %ebp
c00237d3:	89 e5                	mov    %esp,%ebp
c00237d5:	53                   	push   %ebx
c00237d6:	83 ec 04             	sub    $0x4,%esp
c00237d9:	e8 4a dc 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00237de:	05 9a 6b 01 00       	add    $0x16b9a,%eax
  ASSERT (lock != NULL);
c00237e3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00237e7:	75 2b                	jne    c0023814 <lock_init+0x42>
c00237e9:	83 ec 0c             	sub    $0xc,%esp
c00237ec:	8d 90 89 7c ff ff    	lea    -0x8377(%eax),%edx
c00237f2:	52                   	push   %edx
c00237f3:	8d 90 25 7c ff ff    	lea    -0x83db(%eax),%edx
c00237f9:	52                   	push   %edx
c00237fa:	8d 90 1c 7d ff ff    	lea    -0x82e4(%eax),%edx
c0023800:	52                   	push   %edx
c0023801:	68 b8 00 00 00       	push   $0xb8
c0023806:	8d 90 3c 7c ff ff    	lea    -0x83c4(%eax),%edx
c002380c:	52                   	push   %edx
c002380d:	89 c3                	mov    %eax,%ebx
c002380f:	e8 50 7f 00 00       	call   c002b764 <debug_panic>

  lock->holder = NULL;
c0023814:	8b 45 08             	mov    0x8(%ebp),%eax
c0023817:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c002381d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023820:	83 c0 04             	add    $0x4,%eax
c0023823:	83 ec 08             	sub    $0x8,%esp
c0023826:	6a 01                	push   $0x1
c0023828:	50                   	push   %eax
c0023829:	e8 40 fc ff ff       	call   c002346e <sema_init>
c002382e:	83 c4 10             	add    $0x10,%esp
}
c0023831:	90                   	nop
c0023832:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023835:	c9                   	leave  
c0023836:	c3                   	ret    

c0023837 <lock_acquire>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
lock_acquire (struct lock *lock)
{
c0023837:	55                   	push   %ebp
c0023838:	89 e5                	mov    %esp,%ebp
c002383a:	53                   	push   %ebx
c002383b:	83 ec 14             	sub    $0x14,%esp
c002383e:	e8 e9 db 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0023843:	81 c3 35 6b 01 00    	add    $0x16b35,%ebx
  ASSERT (lock != NULL);
c0023849:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002384d:	75 29                	jne    c0023878 <lock_acquire+0x41>
c002384f:	83 ec 0c             	sub    $0xc,%esp
c0023852:	8d 83 89 7c ff ff    	lea    -0x8377(%ebx),%eax
c0023858:	50                   	push   %eax
c0023859:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c002385f:	50                   	push   %eax
c0023860:	8d 83 28 7d ff ff    	lea    -0x82d8(%ebx),%eax
c0023866:	50                   	push   %eax
c0023867:	68 c9 00 00 00       	push   $0xc9
c002386c:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023872:	50                   	push   %eax
c0023873:	e8 ec 7e 00 00       	call   c002b764 <debug_panic>
  ASSERT (!intr_context ());
c0023878:	e8 c7 e9 ff ff       	call   c0022244 <intr_context>
c002387d:	83 f0 01             	xor    $0x1,%eax
c0023880:	84 c0                	test   %al,%al
c0023882:	75 29                	jne    c00238ad <lock_acquire+0x76>
c0023884:	83 ec 0c             	sub    $0xc,%esp
c0023887:	8d 83 52 7c ff ff    	lea    -0x83ae(%ebx),%eax
c002388d:	50                   	push   %eax
c002388e:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023894:	50                   	push   %eax
c0023895:	8d 83 28 7d ff ff    	lea    -0x82d8(%ebx),%eax
c002389b:	50                   	push   %eax
c002389c:	68 ca 00 00 00       	push   $0xca
c00238a1:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c00238a7:	50                   	push   %eax
c00238a8:	e8 b7 7e 00 00       	call   c002b764 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c00238ad:	83 ec 0c             	sub    $0xc,%esp
c00238b0:	ff 75 08             	push   0x8(%ebp)
c00238b3:	e8 2f 04 00 00       	call   c0023ce7 <lock_held_by_current_thread>
c00238b8:	83 c4 10             	add    $0x10,%esp
c00238bb:	83 f0 01             	xor    $0x1,%eax
c00238be:	84 c0                	test   %al,%al
c00238c0:	75 29                	jne    c00238eb <lock_acquire+0xb4>
c00238c2:	83 ec 0c             	sub    $0xc,%esp
c00238c5:	8d 83 98 7c ff ff    	lea    -0x8368(%ebx),%eax
c00238cb:	50                   	push   %eax
c00238cc:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c00238d2:	50                   	push   %eax
c00238d3:	8d 83 28 7d ff ff    	lea    -0x82d8(%ebx),%eax
c00238d9:	50                   	push   %eax
c00238da:	68 cb 00 00 00       	push   $0xcb
c00238df:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c00238e5:	50                   	push   %eax
c00238e6:	e8 79 7e 00 00       	call   c002b764 <debug_panic>

  enum intr_level old_level = intr_disable ();
c00238eb:	e8 f6 e5 ff ff       	call   c0021ee6 <intr_disable>
c00238f0:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(!thread_mlfqs)
c00238f3:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c00238f9:	0f b6 00             	movzbl (%eax),%eax
c00238fc:	83 f0 01             	xor    $0x1,%eax
c00238ff:	84 c0                	test   %al,%al
c0023901:	0f 84 8b 00 00 00    	je     c0023992 <lock_acquire+0x15b>
  {
    if(lock->holder)
c0023907:	8b 45 08             	mov    0x8(%ebp),%eax
c002390a:	8b 00                	mov    (%eax),%eax
c002390c:	85 c0                	test   %eax,%eax
c002390e:	74 76                	je     c0023986 <lock_acquire+0x14f>
    {
      thread_current()->locker = lock->holder;
c0023910:	e8 6c da ff ff       	call   c0021381 <thread_current>
c0023915:	8b 55 08             	mov    0x8(%ebp),%edx
c0023918:	8b 12                	mov    (%edx),%edx
c002391a:	89 50 44             	mov    %edx,0x44(%eax)

      list_push_front(&lock->holder->pot_donors,&thread_current()->donorelem);
c002391d:	e8 5f da ff ff       	call   c0021381 <thread_current>
c0023922:	8d 50 30             	lea    0x30(%eax),%edx
c0023925:	8b 45 08             	mov    0x8(%ebp),%eax
c0023928:	8b 00                	mov    (%eax),%eax
c002392a:	83 c0 48             	add    $0x48,%eax
c002392d:	83 ec 08             	sub    $0x8,%esp
c0023930:	52                   	push   %edx
c0023931:	50                   	push   %eax
c0023932:	e8 e3 85 00 00       	call   c002bf1a <list_push_front>
c0023937:	83 c4 10             	add    $0x10,%esp

      thread_current()->blocked = lock;
c002393a:	e8 42 da ff ff       	call   c0021381 <thread_current>
c002393f:	8b 55 08             	mov    0x8(%ebp),%edx
c0023942:	89 50 58             	mov    %edx,0x58(%eax)

      struct thread *temp = thread_current();
c0023945:	e8 37 da ff ff       	call   c0021381 <thread_current>
c002394a:	89 45 f4             	mov    %eax,-0xc(%ebp)


      while(temp->locker!=NULL)
c002394d:	eb 2b                	jmp    c002397a <lock_acquire+0x143>
      {
        if(temp->priority > temp->locker->priority)
c002394f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023952:	8b 50 1c             	mov    0x1c(%eax),%edx
c0023955:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023958:	8b 40 44             	mov    0x44(%eax),%eax
c002395b:	8b 40 1c             	mov    0x1c(%eax),%eax
c002395e:	39 c2                	cmp    %eax,%edx
c0023960:	7e 18                	jle    c002397a <lock_acquire+0x143>
        {
          temp->locker->priority = temp->priority;
c0023962:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023965:	8b 40 44             	mov    0x44(%eax),%eax
c0023968:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002396b:	8b 52 1c             	mov    0x1c(%edx),%edx
c002396e:	89 50 1c             	mov    %edx,0x1c(%eax)
          temp = temp->locker;
c0023971:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023974:	8b 40 44             	mov    0x44(%eax),%eax
c0023977:	89 45 f4             	mov    %eax,-0xc(%ebp)
      while(temp->locker!=NULL)
c002397a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002397d:	8b 40 44             	mov    0x44(%eax),%eax
c0023980:	85 c0                	test   %eax,%eax
c0023982:	75 cb                	jne    c002394f <lock_acquire+0x118>
c0023984:	eb 0c                	jmp    c0023992 <lock_acquire+0x15b>
        }

      }
    }
    else
      thread_current()->locker = NULL;
c0023986:	e8 f6 d9 ff ff       	call   c0021381 <thread_current>
c002398b:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  }

  sema_down (&lock->semaphore);
c0023992:	8b 45 08             	mov    0x8(%ebp),%eax
c0023995:	83 c0 04             	add    $0x4,%eax
c0023998:	83 ec 0c             	sub    $0xc,%esp
c002399b:	50                   	push   %eax
c002399c:	e8 2e fb ff ff       	call   c00234cf <sema_down>
c00239a1:	83 c4 10             	add    $0x10,%esp
  lock->holder = thread_current ();
c00239a4:	e8 d8 d9 ff ff       	call   c0021381 <thread_current>
c00239a9:	8b 55 08             	mov    0x8(%ebp),%edx
c00239ac:	89 02                	mov    %eax,(%edx)

  intr_set_level (old_level);
c00239ae:	83 ec 0c             	sub    $0xc,%esp
c00239b1:	ff 75 f0             	push   -0x10(%ebp)
c00239b4:	e8 b4 e4 ff ff       	call   c0021e6d <intr_set_level>
c00239b9:	83 c4 10             	add    $0x10,%esp
}
c00239bc:	90                   	nop
c00239bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00239c0:	c9                   	leave  
c00239c1:	c3                   	ret    

c00239c2 <lock_try_acquire>:

   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c00239c2:	55                   	push   %ebp
c00239c3:	89 e5                	mov    %esp,%ebp
c00239c5:	53                   	push   %ebx
c00239c6:	83 ec 14             	sub    $0x14,%esp
c00239c9:	e8 5e da 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00239ce:	81 c3 aa 69 01 00    	add    $0x169aa,%ebx
  bool success;

  ASSERT (lock != NULL);
c00239d4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00239d8:	75 29                	jne    c0023a03 <lock_try_acquire+0x41>
c00239da:	83 ec 0c             	sub    $0xc,%esp
c00239dd:	8d 83 89 7c ff ff    	lea    -0x8377(%ebx),%eax
c00239e3:	50                   	push   %eax
c00239e4:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c00239ea:	50                   	push   %eax
c00239eb:	8d 83 38 7d ff ff    	lea    -0x82c8(%ebx),%eax
c00239f1:	50                   	push   %eax
c00239f2:	68 fb 00 00 00       	push   $0xfb
c00239f7:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c00239fd:	50                   	push   %eax
c00239fe:	e8 61 7d 00 00       	call   c002b764 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0023a03:	83 ec 0c             	sub    $0xc,%esp
c0023a06:	ff 75 08             	push   0x8(%ebp)
c0023a09:	e8 d9 02 00 00       	call   c0023ce7 <lock_held_by_current_thread>
c0023a0e:	83 c4 10             	add    $0x10,%esp
c0023a11:	83 f0 01             	xor    $0x1,%eax
c0023a14:	84 c0                	test   %al,%al
c0023a16:	75 29                	jne    c0023a41 <lock_try_acquire+0x7f>
c0023a18:	83 ec 0c             	sub    $0xc,%esp
c0023a1b:	8d 83 98 7c ff ff    	lea    -0x8368(%ebx),%eax
c0023a21:	50                   	push   %eax
c0023a22:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023a28:	50                   	push   %eax
c0023a29:	8d 83 38 7d ff ff    	lea    -0x82c8(%ebx),%eax
c0023a2f:	50                   	push   %eax
c0023a30:	68 fc 00 00 00       	push   $0xfc
c0023a35:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023a3b:	50                   	push   %eax
c0023a3c:	e8 23 7d 00 00       	call   c002b764 <debug_panic>

  success = sema_try_down (&lock->semaphore);
c0023a41:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a44:	83 c0 04             	add    $0x4,%eax
c0023a47:	83 ec 0c             	sub    $0xc,%esp
c0023a4a:	50                   	push   %eax
c0023a4b:	e8 43 fb ff ff       	call   c0023593 <sema_try_down>
c0023a50:	83 c4 10             	add    $0x10,%esp
c0023a53:	88 45 f3             	mov    %al,-0xd(%ebp)
  if (success)
c0023a56:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c0023a5a:	74 0c                	je     c0023a68 <lock_try_acquire+0xa6>
    lock->holder = thread_current ();
c0023a5c:	e8 20 d9 ff ff       	call   c0021381 <thread_current>
c0023a61:	8b 55 08             	mov    0x8(%ebp),%edx
c0023a64:	89 02                	mov    %eax,(%edx)
c0023a66:	eb 74                	jmp    c0023adc <lock_try_acquire+0x11a>
  else
  {
    thread_current()->locker = lock->holder;
c0023a68:	e8 14 d9 ff ff       	call   c0021381 <thread_current>
c0023a6d:	8b 55 08             	mov    0x8(%ebp),%edx
c0023a70:	8b 12                	mov    (%edx),%edx
c0023a72:	89 50 44             	mov    %edx,0x44(%eax)

    list_push_front(&lock->holder->pot_donors,&thread_current()->donorelem);
c0023a75:	e8 07 d9 ff ff       	call   c0021381 <thread_current>
c0023a7a:	8d 50 30             	lea    0x30(%eax),%edx
c0023a7d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a80:	8b 00                	mov    (%eax),%eax
c0023a82:	83 c0 48             	add    $0x48,%eax
c0023a85:	83 ec 08             	sub    $0x8,%esp
c0023a88:	52                   	push   %edx
c0023a89:	50                   	push   %eax
c0023a8a:	e8 8b 84 00 00       	call   c002bf1a <list_push_front>
c0023a8f:	83 c4 10             	add    $0x10,%esp

    thread_current()->blocked = lock;
c0023a92:	e8 ea d8 ff ff       	call   c0021381 <thread_current>
c0023a97:	8b 55 08             	mov    0x8(%ebp),%edx
c0023a9a:	89 50 58             	mov    %edx,0x58(%eax)

    struct thread *temp = thread_current();
c0023a9d:	e8 df d8 ff ff       	call   c0021381 <thread_current>
c0023aa2:	89 45 f4             	mov    %eax,-0xc(%ebp)


    while(temp->locker!=NULL)
c0023aa5:	eb 2b                	jmp    c0023ad2 <lock_try_acquire+0x110>
    {
      if(temp->priority > temp->locker->priority)
c0023aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023aaa:	8b 50 1c             	mov    0x1c(%eax),%edx
c0023aad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023ab0:	8b 40 44             	mov    0x44(%eax),%eax
c0023ab3:	8b 40 1c             	mov    0x1c(%eax),%eax
c0023ab6:	39 c2                	cmp    %eax,%edx
c0023ab8:	7e 18                	jle    c0023ad2 <lock_try_acquire+0x110>
      {
        temp->locker->priority = temp->priority;
c0023aba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023abd:	8b 40 44             	mov    0x44(%eax),%eax
c0023ac0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023ac3:	8b 52 1c             	mov    0x1c(%edx),%edx
c0023ac6:	89 50 1c             	mov    %edx,0x1c(%eax)
        temp = temp->locker;
c0023ac9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023acc:	8b 40 44             	mov    0x44(%eax),%eax
c0023acf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(temp->locker!=NULL)
c0023ad2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023ad5:	8b 40 44             	mov    0x44(%eax),%eax
c0023ad8:	85 c0                	test   %eax,%eax
c0023ada:	75 cb                	jne    c0023aa7 <lock_try_acquire+0xe5>
      }

    }

  }
  return success;
c0023adc:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
}
c0023ae0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023ae3:	c9                   	leave  
c0023ae4:	c3                   	ret    

c0023ae5 <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c0023ae5:	55                   	push   %ebp
c0023ae6:	89 e5                	mov    %esp,%ebp
c0023ae8:	53                   	push   %ebx
c0023ae9:	83 ec 24             	sub    $0x24,%esp
c0023aec:	e8 3b d9 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0023af1:	81 c3 87 68 01 00    	add    $0x16887,%ebx
  ASSERT (lock != NULL);
c0023af7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023afb:	75 29                	jne    c0023b26 <lock_release+0x41>
c0023afd:	83 ec 0c             	sub    $0xc,%esp
c0023b00:	8d 83 89 7c ff ff    	lea    -0x8377(%ebx),%eax
c0023b06:	50                   	push   %eax
c0023b07:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023b0d:	50                   	push   %eax
c0023b0e:	8d 83 4c 7d ff ff    	lea    -0x82b4(%ebx),%eax
c0023b14:	50                   	push   %eax
c0023b15:	68 22 01 00 00       	push   $0x122
c0023b1a:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023b20:	50                   	push   %eax
c0023b21:	e8 3e 7c 00 00       	call   c002b764 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023b26:	83 ec 0c             	sub    $0xc,%esp
c0023b29:	ff 75 08             	push   0x8(%ebp)
c0023b2c:	e8 b6 01 00 00       	call   c0023ce7 <lock_held_by_current_thread>
c0023b31:	83 c4 10             	add    $0x10,%esp
c0023b34:	84 c0                	test   %al,%al
c0023b36:	75 29                	jne    c0023b61 <lock_release+0x7c>
c0023b38:	83 ec 0c             	sub    $0xc,%esp
c0023b3b:	8d 83 bc 7c ff ff    	lea    -0x8344(%ebx),%eax
c0023b41:	50                   	push   %eax
c0023b42:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023b48:	50                   	push   %eax
c0023b49:	8d 83 4c 7d ff ff    	lea    -0x82b4(%ebx),%eax
c0023b4f:	50                   	push   %eax
c0023b50:	68 23 01 00 00       	push   $0x123
c0023b55:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023b5b:	50                   	push   %eax
c0023b5c:	e8 03 7c 00 00       	call   c002b764 <debug_panic>

  enum intr_level old_level = intr_disable ();
c0023b61:	e8 80 e3 ff ff       	call   c0021ee6 <intr_disable>
c0023b66:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lock->holder = NULL;
c0023b69:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

  sema_up (&lock->semaphore);
c0023b72:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b75:	83 c0 04             	add    $0x4,%eax
c0023b78:	83 ec 0c             	sub    $0xc,%esp
c0023b7b:	50                   	push   %eax
c0023b7c:	e8 8f fa ff ff       	call   c0023610 <sema_up>
c0023b81:	83 c4 10             	add    $0x10,%esp
  if(!thread_mlfqs)
c0023b84:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c0023b8a:	0f b6 00             	movzbl (%eax),%eax
c0023b8d:	83 f0 01             	xor    $0x1,%eax
c0023b90:	84 c0                	test   %al,%al
c0023b92:	0f 84 3b 01 00 00    	je     c0023cd3 <lock_release+0x1ee>
  {
    if(list_empty(&thread_current()->pot_donors))
c0023b98:	e8 e4 d7 ff ff       	call   c0021381 <thread_current>
c0023b9d:	83 c0 48             	add    $0x48,%eax
c0023ba0:	83 ec 0c             	sub    $0xc,%esp
c0023ba3:	50                   	push   %eax
c0023ba4:	e8 b6 85 00 00       	call   c002c15f <list_empty>
c0023ba9:	83 c4 10             	add    $0x10,%esp
c0023bac:	84 c0                	test   %al,%al
c0023bae:	74 19                	je     c0023bc9 <lock_release+0xe4>
      thread_set_priority(thread_current()->basepriority);
c0023bb0:	e8 cc d7 ff ff       	call   c0021381 <thread_current>
c0023bb5:	8b 40 40             	mov    0x40(%eax),%eax
c0023bb8:	83 ec 0c             	sub    $0xc,%esp
c0023bbb:	50                   	push   %eax
c0023bbc:	e8 59 da ff ff       	call   c002161a <thread_set_priority>
c0023bc1:	83 c4 10             	add    $0x10,%esp
c0023bc4:	e9 0a 01 00 00       	jmp    c0023cd3 <lock_release+0x1ee>
    else
    {
      struct list_elem *e;

      for (e = list_begin (&thread_current()->pot_donors); e != list_end (&thread_current()->pot_donors);
c0023bc9:	e8 b3 d7 ff ff       	call   c0021381 <thread_current>
c0023bce:	83 c0 48             	add    $0x48,%eax
c0023bd1:	83 ec 0c             	sub    $0xc,%esp
c0023bd4:	50                   	push   %eax
c0023bd5:	e8 d7 7e 00 00       	call   c002bab1 <list_begin>
c0023bda:	83 c4 10             	add    $0x10,%esp
c0023bdd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023be0:	eb 40                	jmp    c0023c22 <lock_release+0x13d>
           e = list_next (e))
      {

        struct thread *f = list_entry (e, struct thread, donorelem);
c0023be2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023be5:	83 c0 04             	add    $0x4,%eax
c0023be8:	83 e8 34             	sub    $0x34,%eax
c0023beb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(f->blocked == lock)
c0023bee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023bf1:	8b 40 58             	mov    0x58(%eax),%eax
c0023bf4:	39 45 08             	cmp    %eax,0x8(%ebp)
c0023bf7:	75 18                	jne    c0023c11 <lock_release+0x12c>
        {
          list_remove(e);
c0023bf9:	83 ec 0c             	sub    $0xc,%esp
c0023bfc:	ff 75 f4             	push   -0xc(%ebp)
c0023bff:	e8 76 83 00 00       	call   c002bf7a <list_remove>
c0023c04:	83 c4 10             	add    $0x10,%esp
          f->blocked = NULL;
c0023c07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023c0a:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
           e = list_next (e))
c0023c11:	83 ec 0c             	sub    $0xc,%esp
c0023c14:	ff 75 f4             	push   -0xc(%ebp)
c0023c17:	e8 df 7e 00 00       	call   c002bafb <list_next>
c0023c1c:	83 c4 10             	add    $0x10,%esp
c0023c1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_begin (&thread_current()->pot_donors); e != list_end (&thread_current()->pot_donors);
c0023c22:	e8 5a d7 ff ff       	call   c0021381 <thread_current>
c0023c27:	83 c0 48             	add    $0x48,%eax
c0023c2a:	83 ec 0c             	sub    $0xc,%esp
c0023c2d:	50                   	push   %eax
c0023c2e:	e8 29 7f 00 00       	call   c002bb5c <list_end>
c0023c33:	83 c4 10             	add    $0x10,%esp
c0023c36:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0023c39:	75 a7                	jne    c0023be2 <lock_release+0xfd>

        }
      }

      if(!list_empty(&thread_current()->pot_donors))
c0023c3b:	e8 41 d7 ff ff       	call   c0021381 <thread_current>
c0023c40:	83 c0 48             	add    $0x48,%eax
c0023c43:	83 ec 0c             	sub    $0xc,%esp
c0023c46:	50                   	push   %eax
c0023c47:	e8 13 85 00 00       	call   c002c15f <list_empty>
c0023c4c:	83 c4 10             	add    $0x10,%esp
c0023c4f:	83 f0 01             	xor    $0x1,%eax
c0023c52:	84 c0                	test   %al,%al
c0023c54:	74 69                	je     c0023cbf <lock_release+0x1da>
      {
        struct list_elem *max_donor = list_max(&thread_current()->pot_donors, cmp_priority, NULL);
c0023c56:	e8 26 d7 ff ff       	call   c0021381 <thread_current>
c0023c5b:	83 c0 48             	add    $0x48,%eax
c0023c5e:	83 ec 04             	sub    $0x4,%esp
c0023c61:	6a 00                	push   $0x0
c0023c63:	c7 c2 bd 1d 02 c0    	mov    $0xc0021dbd,%edx
c0023c69:	52                   	push   %edx
c0023c6a:	50                   	push   %eax
c0023c6b:	e8 0d 8d 00 00       	call   c002c97d <list_max>
c0023c70:	83 c4 10             	add    $0x10,%esp
c0023c73:	89 45 ec             	mov    %eax,-0x14(%ebp)
        struct thread *max_donor_thread = list_entry(max_donor, struct thread, donorelem);
c0023c76:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023c79:	83 c0 04             	add    $0x4,%eax
c0023c7c:	83 e8 34             	sub    $0x34,%eax
c0023c7f:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if(thread_current()->basepriority > max_donor_thread->priority)
c0023c82:	e8 fa d6 ff ff       	call   c0021381 <thread_current>
c0023c87:	8b 50 40             	mov    0x40(%eax),%edx
c0023c8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023c8d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0023c90:	39 c2                	cmp    %eax,%edx
c0023c92:	7e 16                	jle    c0023caa <lock_release+0x1c5>
          thread_set_priority(thread_current()->basepriority);
c0023c94:	e8 e8 d6 ff ff       	call   c0021381 <thread_current>
c0023c99:	8b 40 40             	mov    0x40(%eax),%eax
c0023c9c:	83 ec 0c             	sub    $0xc,%esp
c0023c9f:	50                   	push   %eax
c0023ca0:	e8 75 d9 ff ff       	call   c002161a <thread_set_priority>
c0023ca5:	83 c4 10             	add    $0x10,%esp
c0023ca8:	eb 29                	jmp    c0023cd3 <lock_release+0x1ee>
        else
        {
          thread_current()->priority = max_donor_thread->priority;
c0023caa:	e8 d2 d6 ff ff       	call   c0021381 <thread_current>
c0023caf:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0023cb2:	8b 52 1c             	mov    0x1c(%edx),%edx
c0023cb5:	89 50 1c             	mov    %edx,0x1c(%eax)
          thread_yield();
c0023cb8:	e8 fd d7 ff ff       	call   c00214ba <thread_yield>
c0023cbd:	eb 14                	jmp    c0023cd3 <lock_release+0x1ee>
        }
      }
      else
        thread_set_priority(thread_current()->basepriority);
c0023cbf:	e8 bd d6 ff ff       	call   c0021381 <thread_current>
c0023cc4:	8b 40 40             	mov    0x40(%eax),%eax
c0023cc7:	83 ec 0c             	sub    $0xc,%esp
c0023cca:	50                   	push   %eax
c0023ccb:	e8 4a d9 ff ff       	call   c002161a <thread_set_priority>
c0023cd0:	83 c4 10             	add    $0x10,%esp
    }
  }
  
  intr_set_level (old_level);
c0023cd3:	83 ec 0c             	sub    $0xc,%esp
c0023cd6:	ff 75 f0             	push   -0x10(%ebp)
c0023cd9:	e8 8f e1 ff ff       	call   c0021e6d <intr_set_level>
c0023cde:	83 c4 10             	add    $0x10,%esp
}
c0023ce1:	90                   	nop
c0023ce2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023ce5:	c9                   	leave  
c0023ce6:	c3                   	ret    

c0023ce7 <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0023ce7:	55                   	push   %ebp
c0023ce8:	89 e5                	mov    %esp,%ebp
c0023cea:	56                   	push   %esi
c0023ceb:	53                   	push   %ebx
c0023cec:	e8 37 d7 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0023cf1:	05 87 66 01 00       	add    $0x16687,%eax
  ASSERT (lock != NULL);
c0023cf6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023cfa:	75 2b                	jne    c0023d27 <lock_held_by_current_thread+0x40>
c0023cfc:	83 ec 0c             	sub    $0xc,%esp
c0023cff:	8d 90 89 7c ff ff    	lea    -0x8377(%eax),%edx
c0023d05:	52                   	push   %edx
c0023d06:	8d 90 25 7c ff ff    	lea    -0x83db(%eax),%edx
c0023d0c:	52                   	push   %edx
c0023d0d:	8d 90 5c 7d ff ff    	lea    -0x82a4(%eax),%edx
c0023d13:	52                   	push   %edx
c0023d14:	68 5a 01 00 00       	push   $0x15a
c0023d19:	8d 90 3c 7c ff ff    	lea    -0x83c4(%eax),%edx
c0023d1f:	52                   	push   %edx
c0023d20:	89 c3                	mov    %eax,%ebx
c0023d22:	e8 3d 7a 00 00       	call   c002b764 <debug_panic>

  return lock->holder == thread_current ();
c0023d27:	8b 55 08             	mov    0x8(%ebp),%edx
c0023d2a:	8b 32                	mov    (%edx),%esi
c0023d2c:	89 c3                	mov    %eax,%ebx
c0023d2e:	e8 4e d6 ff ff       	call   c0021381 <thread_current>
c0023d33:	39 c6                	cmp    %eax,%esi
c0023d35:	0f 94 c0             	sete   %al
}
c0023d38:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0023d3b:	5b                   	pop    %ebx
c0023d3c:	5e                   	pop    %esi
c0023d3d:	5d                   	pop    %ebp
c0023d3e:	c3                   	ret    

c0023d3f <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0023d3f:	55                   	push   %ebp
c0023d40:	89 e5                	mov    %esp,%ebp
c0023d42:	53                   	push   %ebx
c0023d43:	83 ec 04             	sub    $0x4,%esp
c0023d46:	e8 dd d6 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0023d4b:	05 2d 66 01 00       	add    $0x1662d,%eax
  ASSERT (cond != NULL);
c0023d50:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023d54:	75 2b                	jne    c0023d81 <cond_init+0x42>
c0023d56:	83 ec 0c             	sub    $0xc,%esp
c0023d59:	8d 90 df 7c ff ff    	lea    -0x8321(%eax),%edx
c0023d5f:	52                   	push   %edx
c0023d60:	8d 90 25 7c ff ff    	lea    -0x83db(%eax),%edx
c0023d66:	52                   	push   %edx
c0023d67:	8d 90 78 7d ff ff    	lea    -0x8288(%eax),%edx
c0023d6d:	52                   	push   %edx
c0023d6e:	68 6c 01 00 00       	push   $0x16c
c0023d73:	8d 90 3c 7c ff ff    	lea    -0x83c4(%eax),%edx
c0023d79:	52                   	push   %edx
c0023d7a:	89 c3                	mov    %eax,%ebx
c0023d7c:	e8 e3 79 00 00       	call   c002b764 <debug_panic>

  list_init (&cond->waiters);
c0023d81:	8b 55 08             	mov    0x8(%ebp),%edx
c0023d84:	83 ec 0c             	sub    $0xc,%esp
c0023d87:	52                   	push   %edx
c0023d88:	89 c3                	mov    %eax,%ebx
c0023d8a:	e8 b5 7c 00 00       	call   c002ba44 <list_init>
c0023d8f:	83 c4 10             	add    $0x10,%esp
}
c0023d92:	90                   	nop
c0023d93:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023d96:	c9                   	leave  
c0023d97:	c3                   	ret    

c0023d98 <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0023d98:	55                   	push   %ebp
c0023d99:	89 e5                	mov    %esp,%ebp
c0023d9b:	53                   	push   %ebx
c0023d9c:	83 ec 24             	sub    $0x24,%esp
c0023d9f:	e8 88 d6 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0023da4:	81 c3 d4 65 01 00    	add    $0x165d4,%ebx
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0023daa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023dae:	75 29                	jne    c0023dd9 <cond_wait+0x41>
c0023db0:	83 ec 0c             	sub    $0xc,%esp
c0023db3:	8d 83 df 7c ff ff    	lea    -0x8321(%ebx),%eax
c0023db9:	50                   	push   %eax
c0023dba:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023dc0:	50                   	push   %eax
c0023dc1:	8d 83 84 7d ff ff    	lea    -0x827c(%ebx),%eax
c0023dc7:	50                   	push   %eax
c0023dc8:	68 8a 01 00 00       	push   $0x18a
c0023dcd:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023dd3:	50                   	push   %eax
c0023dd4:	e8 8b 79 00 00       	call   c002b764 <debug_panic>
  ASSERT (lock != NULL);
c0023dd9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023ddd:	75 29                	jne    c0023e08 <cond_wait+0x70>
c0023ddf:	83 ec 0c             	sub    $0xc,%esp
c0023de2:	8d 83 89 7c ff ff    	lea    -0x8377(%ebx),%eax
c0023de8:	50                   	push   %eax
c0023de9:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023def:	50                   	push   %eax
c0023df0:	8d 83 84 7d ff ff    	lea    -0x827c(%ebx),%eax
c0023df6:	50                   	push   %eax
c0023df7:	68 8b 01 00 00       	push   $0x18b
c0023dfc:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023e02:	50                   	push   %eax
c0023e03:	e8 5c 79 00 00       	call   c002b764 <debug_panic>
  ASSERT (!intr_context ());
c0023e08:	e8 37 e4 ff ff       	call   c0022244 <intr_context>
c0023e0d:	83 f0 01             	xor    $0x1,%eax
c0023e10:	84 c0                	test   %al,%al
c0023e12:	75 29                	jne    c0023e3d <cond_wait+0xa5>
c0023e14:	83 ec 0c             	sub    $0xc,%esp
c0023e17:	8d 83 52 7c ff ff    	lea    -0x83ae(%ebx),%eax
c0023e1d:	50                   	push   %eax
c0023e1e:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023e24:	50                   	push   %eax
c0023e25:	8d 83 84 7d ff ff    	lea    -0x827c(%ebx),%eax
c0023e2b:	50                   	push   %eax
c0023e2c:	68 8c 01 00 00       	push   $0x18c
c0023e31:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023e37:	50                   	push   %eax
c0023e38:	e8 27 79 00 00       	call   c002b764 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023e3d:	83 ec 0c             	sub    $0xc,%esp
c0023e40:	ff 75 0c             	push   0xc(%ebp)
c0023e43:	e8 9f fe ff ff       	call   c0023ce7 <lock_held_by_current_thread>
c0023e48:	83 c4 10             	add    $0x10,%esp
c0023e4b:	84 c0                	test   %al,%al
c0023e4d:	75 29                	jne    c0023e78 <cond_wait+0xe0>
c0023e4f:	83 ec 0c             	sub    $0xc,%esp
c0023e52:	8d 83 bc 7c ff ff    	lea    -0x8344(%ebx),%eax
c0023e58:	50                   	push   %eax
c0023e59:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023e5f:	50                   	push   %eax
c0023e60:	8d 83 84 7d ff ff    	lea    -0x827c(%ebx),%eax
c0023e66:	50                   	push   %eax
c0023e67:	68 8d 01 00 00       	push   $0x18d
c0023e6c:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023e72:	50                   	push   %eax
c0023e73:	e8 ec 78 00 00       	call   c002b764 <debug_panic>
  
  sema_init (&waiter.semaphore, 0);
c0023e78:	83 ec 08             	sub    $0x8,%esp
c0023e7b:	6a 00                	push   $0x0
c0023e7d:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0023e80:	83 c0 08             	add    $0x8,%eax
c0023e83:	50                   	push   %eax
c0023e84:	e8 e5 f5 ff ff       	call   c002346e <sema_init>
c0023e89:	83 c4 10             	add    $0x10,%esp
  list_push_back (&cond->waiters, &waiter.elem);
c0023e8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e8f:	83 ec 08             	sub    $0x8,%esp
c0023e92:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0023e95:	52                   	push   %edx
c0023e96:	50                   	push   %eax
c0023e97:	e8 ae 80 00 00       	call   c002bf4a <list_push_back>
c0023e9c:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c0023e9f:	83 ec 0c             	sub    $0xc,%esp
c0023ea2:	ff 75 0c             	push   0xc(%ebp)
c0023ea5:	e8 3b fc ff ff       	call   c0023ae5 <lock_release>
c0023eaa:	83 c4 10             	add    $0x10,%esp
  sema_down (&waiter.semaphore);
c0023ead:	83 ec 0c             	sub    $0xc,%esp
c0023eb0:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0023eb3:	83 c0 08             	add    $0x8,%eax
c0023eb6:	50                   	push   %eax
c0023eb7:	e8 13 f6 ff ff       	call   c00234cf <sema_down>
c0023ebc:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c0023ebf:	83 ec 0c             	sub    $0xc,%esp
c0023ec2:	ff 75 0c             	push   0xc(%ebp)
c0023ec5:	e8 6d f9 ff ff       	call   c0023837 <lock_acquire>
c0023eca:	83 c4 10             	add    $0x10,%esp
}
c0023ecd:	90                   	nop
c0023ece:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023ed1:	c9                   	leave  
c0023ed2:	c3                   	ret    

c0023ed3 <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c0023ed3:	55                   	push   %ebp
c0023ed4:	89 e5                	mov    %esp,%ebp
c0023ed6:	53                   	push   %ebx
c0023ed7:	83 ec 04             	sub    $0x4,%esp
c0023eda:	e8 4d d5 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0023edf:	81 c3 99 64 01 00    	add    $0x16499,%ebx
  ASSERT (cond != NULL);
c0023ee5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023ee9:	75 29                	jne    c0023f14 <cond_signal+0x41>
c0023eeb:	83 ec 0c             	sub    $0xc,%esp
c0023eee:	8d 83 df 7c ff ff    	lea    -0x8321(%ebx),%eax
c0023ef4:	50                   	push   %eax
c0023ef5:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023efb:	50                   	push   %eax
c0023efc:	8d 83 90 7d ff ff    	lea    -0x8270(%ebx),%eax
c0023f02:	50                   	push   %eax
c0023f03:	68 a0 01 00 00       	push   $0x1a0
c0023f08:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023f0e:	50                   	push   %eax
c0023f0f:	e8 50 78 00 00       	call   c002b764 <debug_panic>
  ASSERT (lock != NULL);
c0023f14:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023f18:	75 29                	jne    c0023f43 <cond_signal+0x70>
c0023f1a:	83 ec 0c             	sub    $0xc,%esp
c0023f1d:	8d 83 89 7c ff ff    	lea    -0x8377(%ebx),%eax
c0023f23:	50                   	push   %eax
c0023f24:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023f2a:	50                   	push   %eax
c0023f2b:	8d 83 90 7d ff ff    	lea    -0x8270(%ebx),%eax
c0023f31:	50                   	push   %eax
c0023f32:	68 a1 01 00 00       	push   $0x1a1
c0023f37:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023f3d:	50                   	push   %eax
c0023f3e:	e8 21 78 00 00       	call   c002b764 <debug_panic>
  ASSERT (!intr_context ());
c0023f43:	e8 fc e2 ff ff       	call   c0022244 <intr_context>
c0023f48:	83 f0 01             	xor    $0x1,%eax
c0023f4b:	84 c0                	test   %al,%al
c0023f4d:	75 29                	jne    c0023f78 <cond_signal+0xa5>
c0023f4f:	83 ec 0c             	sub    $0xc,%esp
c0023f52:	8d 83 52 7c ff ff    	lea    -0x83ae(%ebx),%eax
c0023f58:	50                   	push   %eax
c0023f59:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023f5f:	50                   	push   %eax
c0023f60:	8d 83 90 7d ff ff    	lea    -0x8270(%ebx),%eax
c0023f66:	50                   	push   %eax
c0023f67:	68 a2 01 00 00       	push   $0x1a2
c0023f6c:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023f72:	50                   	push   %eax
c0023f73:	e8 ec 77 00 00       	call   c002b764 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023f78:	83 ec 0c             	sub    $0xc,%esp
c0023f7b:	ff 75 0c             	push   0xc(%ebp)
c0023f7e:	e8 64 fd ff ff       	call   c0023ce7 <lock_held_by_current_thread>
c0023f83:	83 c4 10             	add    $0x10,%esp
c0023f86:	84 c0                	test   %al,%al
c0023f88:	75 29                	jne    c0023fb3 <cond_signal+0xe0>
c0023f8a:	83 ec 0c             	sub    $0xc,%esp
c0023f8d:	8d 83 bc 7c ff ff    	lea    -0x8344(%ebx),%eax
c0023f93:	50                   	push   %eax
c0023f94:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0023f9a:	50                   	push   %eax
c0023f9b:	8d 83 90 7d ff ff    	lea    -0x8270(%ebx),%eax
c0023fa1:	50                   	push   %eax
c0023fa2:	68 a3 01 00 00       	push   $0x1a3
c0023fa7:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0023fad:	50                   	push   %eax
c0023fae:	e8 b1 77 00 00       	call   c002b764 <debug_panic>

  if (!list_empty (&cond->waiters)) 
c0023fb3:	8b 45 08             	mov    0x8(%ebp),%eax
c0023fb6:	83 ec 0c             	sub    $0xc,%esp
c0023fb9:	50                   	push   %eax
c0023fba:	e8 a0 81 00 00       	call   c002c15f <list_empty>
c0023fbf:	83 c4 10             	add    $0x10,%esp
c0023fc2:	83 f0 01             	xor    $0x1,%eax
c0023fc5:	84 c0                	test   %al,%al
c0023fc7:	74 3c                	je     c0024005 <cond_signal+0x132>
  {
    list_sort (&cond->waiters, cmp_cond_priority, NULL);
c0023fc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0023fcc:	83 ec 04             	sub    $0x4,%esp
c0023fcf:	6a 00                	push   $0x0
c0023fd1:	8d 93 31 9d fe ff    	lea    -0x162cf(%ebx),%edx
c0023fd7:	52                   	push   %edx
c0023fd8:	50                   	push   %eax
c0023fd9:	e8 d5 85 00 00       	call   c002c5b3 <list_sort>
c0023fde:	83 c4 10             	add    $0x10,%esp
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c0023fe1:	8b 45 08             	mov    0x8(%ebp),%eax
c0023fe4:	83 ec 0c             	sub    $0xc,%esp
c0023fe7:	50                   	push   %eax
c0023fe8:	e8 fd 7f 00 00       	call   c002bfea <list_pop_front>
c0023fed:	83 c4 10             	add    $0x10,%esp
c0023ff0:	83 c0 04             	add    $0x4,%eax
c0023ff3:	83 e8 04             	sub    $0x4,%eax
c0023ff6:	83 c0 08             	add    $0x8,%eax
c0023ff9:	83 ec 0c             	sub    $0xc,%esp
c0023ffc:	50                   	push   %eax
c0023ffd:	e8 0e f6 ff ff       	call   c0023610 <sema_up>
c0024002:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
  }
}
c0024005:	90                   	nop
c0024006:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024009:	c9                   	leave  
c002400a:	c3                   	ret    

c002400b <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c002400b:	55                   	push   %ebp
c002400c:	89 e5                	mov    %esp,%ebp
c002400e:	53                   	push   %ebx
c002400f:	83 ec 04             	sub    $0x4,%esp
c0024012:	e8 15 d4 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0024017:	81 c3 61 63 01 00    	add    $0x16361,%ebx
  ASSERT (cond != NULL);
c002401d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0024021:	75 29                	jne    c002404c <cond_broadcast+0x41>
c0024023:	83 ec 0c             	sub    $0xc,%esp
c0024026:	8d 83 df 7c ff ff    	lea    -0x8321(%ebx),%eax
c002402c:	50                   	push   %eax
c002402d:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0024033:	50                   	push   %eax
c0024034:	8d 83 9c 7d ff ff    	lea    -0x8264(%ebx),%eax
c002403a:	50                   	push   %eax
c002403b:	68 b6 01 00 00       	push   $0x1b6
c0024040:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0024046:	50                   	push   %eax
c0024047:	e8 18 77 00 00       	call   c002b764 <debug_panic>
  ASSERT (lock != NULL);
c002404c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0024050:	75 3a                	jne    c002408c <cond_broadcast+0x81>
c0024052:	83 ec 0c             	sub    $0xc,%esp
c0024055:	8d 83 89 7c ff ff    	lea    -0x8377(%ebx),%eax
c002405b:	50                   	push   %eax
c002405c:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
c0024062:	50                   	push   %eax
c0024063:	8d 83 9c 7d ff ff    	lea    -0x8264(%ebx),%eax
c0024069:	50                   	push   %eax
c002406a:	68 b7 01 00 00       	push   $0x1b7
c002406f:	8d 83 3c 7c ff ff    	lea    -0x83c4(%ebx),%eax
c0024075:	50                   	push   %eax
c0024076:	e8 e9 76 00 00       	call   c002b764 <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c002407b:	83 ec 08             	sub    $0x8,%esp
c002407e:	ff 75 0c             	push   0xc(%ebp)
c0024081:	ff 75 08             	push   0x8(%ebp)
c0024084:	e8 4a fe ff ff       	call   c0023ed3 <cond_signal>
c0024089:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c002408c:	8b 45 08             	mov    0x8(%ebp),%eax
c002408f:	83 ec 0c             	sub    $0xc,%esp
c0024092:	50                   	push   %eax
c0024093:	e8 c7 80 00 00       	call   c002c15f <list_empty>
c0024098:	83 c4 10             	add    $0x10,%esp
c002409b:	83 f0 01             	xor    $0x1,%eax
c002409e:	84 c0                	test   %al,%al
c00240a0:	75 d9                	jne    c002407b <cond_broadcast+0x70>
}
c00240a2:	90                   	nop
c00240a3:	90                   	nop
c00240a4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00240a7:	c9                   	leave  
c00240a8:	c3                   	ret    

c00240a9 <cmp_cond_priority>:

bool cmp_cond_priority(struct list_elem *first, struct list_elem *second, void *aux)
{
c00240a9:	55                   	push   %ebp
c00240aa:	89 e5                	mov    %esp,%ebp
c00240ac:	56                   	push   %esi
c00240ad:	53                   	push   %ebx
c00240ae:	83 ec 10             	sub    $0x10,%esp
c00240b1:	e8 76 d3 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00240b6:	81 c3 c2 62 01 00    	add    $0x162c2,%ebx
  struct semaphore_elem *fsem = list_entry (first, struct semaphore_elem, elem);
c00240bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00240bf:	83 c0 04             	add    $0x4,%eax
c00240c2:	83 e8 04             	sub    $0x4,%eax
c00240c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct semaphore_elem *ssem = list_entry (second, struct semaphore_elem, elem);
c00240c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00240cb:	83 c0 04             	add    $0x4,%eax
c00240ce:	83 e8 04             	sub    $0x4,%eax
c00240d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
 


  return list_entry(list_front(&fsem->semaphore.waiters), struct thread, elem)->priority > list_entry (list_front(&ssem->semaphore.waiters), struct thread, elem)->priority;
c00240d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00240d7:	83 c0 0c             	add    $0xc,%eax
c00240da:	83 ec 0c             	sub    $0xc,%esp
c00240dd:	50                   	push   %eax
c00240de:	e8 6f 7f 00 00       	call   c002c052 <list_front>
c00240e3:	83 c4 10             	add    $0x10,%esp
c00240e6:	83 c0 04             	add    $0x4,%eax
c00240e9:	83 e8 2c             	sub    $0x2c,%eax
c00240ec:	8b 70 1c             	mov    0x1c(%eax),%esi
c00240ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00240f2:	83 c0 0c             	add    $0xc,%eax
c00240f5:	83 ec 0c             	sub    $0xc,%esp
c00240f8:	50                   	push   %eax
c00240f9:	e8 54 7f 00 00       	call   c002c052 <list_front>
c00240fe:	83 c4 10             	add    $0x10,%esp
c0024101:	83 c0 04             	add    $0x4,%eax
c0024104:	83 e8 2c             	sub    $0x2c,%eax
c0024107:	8b 40 1c             	mov    0x1c(%eax),%eax
c002410a:	39 c6                	cmp    %eax,%esi
c002410c:	0f 9f c0             	setg   %al

c002410f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0024112:	5b                   	pop    %ebx
c0024113:	5e                   	pop    %esi
c0024114:	5d                   	pop    %ebp
c0024115:	c3                   	ret    

c0024116 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c0024116:	55                   	push   %ebp
c0024117:	89 e5                	mov    %esp,%ebp
c0024119:	e8 0a d3 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002411e:	05 5a 62 01 00       	add    $0x1625a,%eax
  return (uintptr_t) va & PGMASK;
c0024123:	8b 45 08             	mov    0x8(%ebp),%eax
c0024126:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002412b:	5d                   	pop    %ebp
c002412c:	c3                   	ret    

c002412d <pg_no>:
static inline uintptr_t pg_no (const void *va) {
c002412d:	55                   	push   %ebp
c002412e:	89 e5                	mov    %esp,%ebp
c0024130:	e8 f3 d2 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0024135:	05 43 62 01 00       	add    $0x16243,%eax
  return (uintptr_t) va >> PGBITS;
c002413a:	8b 45 08             	mov    0x8(%ebp),%eax
c002413d:	c1 e8 0c             	shr    $0xc,%eax
}
c0024140:	5d                   	pop    %ebp
c0024141:	c3                   	ret    

c0024142 <ptov>:
{
c0024142:	55                   	push   %ebp
c0024143:	89 e5                	mov    %esp,%ebp
c0024145:	53                   	push   %ebx
c0024146:	83 ec 04             	sub    $0x4,%esp
c0024149:	e8 da d2 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002414e:	05 2a 62 01 00       	add    $0x1622a,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c0024153:	8b 55 08             	mov    0x8(%ebp),%edx
c0024156:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002415c:	76 28                	jbe    c0024186 <ptov+0x44>
c002415e:	83 ec 0c             	sub    $0xc,%esp
c0024161:	8d 90 ac 7d ff ff    	lea    -0x8254(%eax),%edx
c0024167:	52                   	push   %edx
c0024168:	8d 90 c7 7d ff ff    	lea    -0x8239(%eax),%edx
c002416e:	52                   	push   %edx
c002416f:	8d 90 e4 7e ff ff    	lea    -0x811c(%eax),%edx
c0024175:	52                   	push   %edx
c0024176:	6a 4a                	push   $0x4a
c0024178:	8d 90 de 7d ff ff    	lea    -0x8222(%eax),%edx
c002417e:	52                   	push   %edx
c002417f:	89 c3                	mov    %eax,%ebx
c0024181:	e8 de 75 00 00       	call   c002b764 <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c0024186:	8b 45 08             	mov    0x8(%ebp),%eax
c0024189:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c002418e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024191:	c9                   	leave  
c0024192:	c3                   	ret    

c0024193 <palloc_init>:

/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */
void
palloc_init (size_t user_page_limit)
{
c0024193:	55                   	push   %ebp
c0024194:	89 e5                	mov    %esp,%ebp
c0024196:	53                   	push   %ebx
c0024197:	83 ec 24             	sub    $0x24,%esp
c002419a:	e8 8d d2 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002419f:	81 c3 d9 61 01 00    	add    $0x161d9,%ebx
  /* Free memory starts at 1 MB and runs to the end of RAM. */
  uint8_t *free_start = ptov (1024 * 1024);
c00241a5:	83 ec 0c             	sub    $0xc,%esp
c00241a8:	68 00 00 10 00       	push   $0x100000
c00241ad:	e8 90 ff ff ff       	call   c0024142 <ptov>
c00241b2:	83 c4 10             	add    $0x10,%esp
c00241b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c00241b8:	c7 c0 be 01 02 c0    	mov    $0xc00201be,%eax
c00241be:	8b 00                	mov    (%eax),%eax
c00241c0:	c1 e0 0c             	shl    $0xc,%eax
c00241c3:	83 ec 0c             	sub    $0xc,%esp
c00241c6:	50                   	push   %eax
c00241c7:	e8 76 ff ff ff       	call   c0024142 <ptov>
c00241cc:	83 c4 10             	add    $0x10,%esp
c00241cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t free_pages = (free_end - free_start) / PGSIZE;
c00241d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00241d5:	2b 45 f0             	sub    -0x10(%ebp),%eax
c00241d8:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
c00241de:	85 c0                	test   %eax,%eax
c00241e0:	0f 48 c2             	cmovs  %edx,%eax
c00241e3:	c1 f8 0c             	sar    $0xc,%eax
c00241e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
  size_t user_pages = free_pages / 2;
c00241e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00241ec:	d1 e8                	shr    %eax
c00241ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t kernel_pages;
  if (user_pages > user_page_limit)
c00241f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00241f4:	3b 45 08             	cmp    0x8(%ebp),%eax
c00241f7:	76 06                	jbe    c00241ff <palloc_init+0x6c>
    user_pages = user_page_limit;
c00241f9:	8b 45 08             	mov    0x8(%ebp),%eax
c00241fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  kernel_pages = free_pages - user_pages;
c00241ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024202:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0024205:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Give half of memory to kernel, half to user. */
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c0024208:	8d 83 f4 7d ff ff    	lea    -0x820c(%ebx),%eax
c002420e:	50                   	push   %eax
c002420f:	ff 75 e4             	push   -0x1c(%ebp)
c0024212:	ff 75 f0             	push   -0x10(%ebp)
c0024215:	8d 83 e8 1c 00 00    	lea    0x1ce8(%ebx),%eax
c002421b:	50                   	push   %eax
c002421c:	e8 ce 02 00 00       	call   c00244ef <init_pool>
c0024221:	83 c4 10             	add    $0x10,%esp
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c0024224:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0024227:	c1 e0 0c             	shl    $0xc,%eax
c002422a:	89 c2                	mov    %eax,%edx
c002422c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002422f:	01 c2                	add    %eax,%edx
c0024231:	8d 83 00 7e ff ff    	lea    -0x8200(%ebx),%eax
c0024237:	50                   	push   %eax
c0024238:	ff 75 f4             	push   -0xc(%ebp)
c002423b:	52                   	push   %edx
c002423c:	8d 83 08 1d 00 00    	lea    0x1d08(%ebx),%eax
c0024242:	50                   	push   %eax
c0024243:	e8 a7 02 00 00       	call   c00244ef <init_pool>
c0024248:	83 c4 10             	add    $0x10,%esp
             user_pages, "user pool");
}
c002424b:	90                   	nop
c002424c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002424f:	c9                   	leave  
c0024250:	c3                   	ret    

c0024251 <palloc_get_multiple>:
   then the pages are filled with zeros.  If too few pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
{
c0024251:	55                   	push   %ebp
c0024252:	89 e5                	mov    %esp,%ebp
c0024254:	53                   	push   %ebx
c0024255:	83 ec 14             	sub    $0x14,%esp
c0024258:	e8 cf d1 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002425d:	81 c3 1b 61 01 00    	add    $0x1611b,%ebx
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c0024263:	8b 45 08             	mov    0x8(%ebp),%eax
c0024266:	83 e0 04             	and    $0x4,%eax
c0024269:	85 c0                	test   %eax,%eax
c002426b:	74 08                	je     c0024275 <palloc_get_multiple+0x24>
c002426d:	8d 83 08 1d 00 00    	lea    0x1d08(%ebx),%eax
c0024273:	eb 06                	jmp    c002427b <palloc_get_multiple+0x2a>
c0024275:	8d 83 e8 1c 00 00    	lea    0x1ce8(%ebx),%eax
c002427b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
c002427e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0024282:	75 0a                	jne    c002428e <palloc_get_multiple+0x3d>
    return NULL;
c0024284:	b8 00 00 00 00       	mov    $0x0,%eax
c0024289:	e9 a9 00 00 00       	jmp    c0024337 <palloc_get_multiple+0xe6>

  lock_acquire (&pool->lock);
c002428e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024291:	83 ec 0c             	sub    $0xc,%esp
c0024294:	50                   	push   %eax
c0024295:	e8 9d f5 ff ff       	call   c0023837 <lock_acquire>
c002429a:	83 c4 10             	add    $0x10,%esp
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c002429d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00242a0:	8b 40 18             	mov    0x18(%eax),%eax
c00242a3:	6a 00                	push   $0x0
c00242a5:	ff 75 0c             	push   0xc(%ebp)
c00242a8:	6a 00                	push   $0x0
c00242aa:	50                   	push   %eax
c00242ab:	e8 bb 90 00 00       	call   c002d36b <bitmap_scan_and_flip>
c00242b0:	83 c4 10             	add    $0x10,%esp
c00242b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  lock_release (&pool->lock);
c00242b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00242b9:	83 ec 0c             	sub    $0xc,%esp
c00242bc:	50                   	push   %eax
c00242bd:	e8 23 f8 ff ff       	call   c0023ae5 <lock_release>
c00242c2:	83 c4 10             	add    $0x10,%esp

  if (page_idx != BITMAP_ERROR)
c00242c5:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00242c9:	74 13                	je     c00242de <palloc_get_multiple+0x8d>
    pages = pool->base + PGSIZE * page_idx;
c00242cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00242ce:	8b 50 1c             	mov    0x1c(%eax),%edx
c00242d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00242d4:	c1 e0 0c             	shl    $0xc,%eax
c00242d7:	01 d0                	add    %edx,%eax
c00242d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00242dc:	eb 07                	jmp    c00242e5 <palloc_get_multiple+0x94>
  else
    pages = NULL;
c00242de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (pages != NULL) 
c00242e5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00242e9:	74 23                	je     c002430e <palloc_get_multiple+0xbd>
    {
      if (flags & PAL_ZERO)
c00242eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00242ee:	83 e0 02             	and    $0x2,%eax
c00242f1:	85 c0                	test   %eax,%eax
c00242f3:	74 3f                	je     c0024334 <palloc_get_multiple+0xe3>
        memset (pages, 0, PGSIZE * page_cnt);
c00242f5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00242f8:	c1 e0 0c             	shl    $0xc,%eax
c00242fb:	83 ec 04             	sub    $0x4,%esp
c00242fe:	50                   	push   %eax
c00242ff:	6a 00                	push   $0x0
c0024301:	ff 75 f4             	push   -0xc(%ebp)
c0024304:	e8 eb 66 00 00       	call   c002a9f4 <memset>
c0024309:	83 c4 10             	add    $0x10,%esp
c002430c:	eb 26                	jmp    c0024334 <palloc_get_multiple+0xe3>
    }
  else 
    {
      if (flags & PAL_ASSERT)
c002430e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024311:	83 e0 01             	and    $0x1,%eax
c0024314:	85 c0                	test   %eax,%eax
c0024316:	74 1c                	je     c0024334 <palloc_get_multiple+0xe3>
        PANIC ("palloc_get: out of pages");
c0024318:	8d 83 0a 7e ff ff    	lea    -0x81f6(%ebx),%eax
c002431e:	50                   	push   %eax
c002431f:	8d 83 ec 7e ff ff    	lea    -0x8114(%ebx),%eax
c0024325:	50                   	push   %eax
c0024326:	6a 61                	push   $0x61
c0024328:	8d 83 23 7e ff ff    	lea    -0x81dd(%ebx),%eax
c002432e:	50                   	push   %eax
c002432f:	e8 30 74 00 00       	call   c002b764 <debug_panic>
    }

  return pages;
c0024334:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0024337:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002433a:	c9                   	leave  
c002433b:	c3                   	ret    

c002433c <palloc_get_page>:
   then the page is filled with zeros.  If no pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_page (enum palloc_flags flags) 
{
c002433c:	55                   	push   %ebp
c002433d:	89 e5                	mov    %esp,%ebp
c002433f:	83 ec 08             	sub    $0x8,%esp
c0024342:	e8 e1 d0 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0024347:	05 31 60 01 00       	add    $0x16031,%eax
  return palloc_get_multiple (flags, 1);
c002434c:	83 ec 08             	sub    $0x8,%esp
c002434f:	6a 01                	push   $0x1
c0024351:	ff 75 08             	push   0x8(%ebp)
c0024354:	e8 f8 fe ff ff       	call   c0024251 <palloc_get_multiple>
c0024359:	83 c4 10             	add    $0x10,%esp
}
c002435c:	c9                   	leave  
c002435d:	c3                   	ret    

c002435e <palloc_free_multiple>:

/* Frees the PAGE_CNT pages starting at PAGES. */
void
palloc_free_multiple (void *pages, size_t page_cnt) 
{
c002435e:	55                   	push   %ebp
c002435f:	89 e5                	mov    %esp,%ebp
c0024361:	56                   	push   %esi
c0024362:	53                   	push   %ebx
c0024363:	83 ec 10             	sub    $0x10,%esp
c0024366:	e8 c1 d0 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002436b:	81 c3 0d 60 01 00    	add    $0x1600d,%ebx
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
c0024371:	ff 75 08             	push   0x8(%ebp)
c0024374:	e8 9d fd ff ff       	call   c0024116 <pg_ofs>
c0024379:	83 c4 04             	add    $0x4,%esp
c002437c:	85 c0                	test   %eax,%eax
c002437e:	74 26                	je     c00243a6 <palloc_free_multiple+0x48>
c0024380:	83 ec 0c             	sub    $0xc,%esp
c0024383:	8d 83 3a 7e ff ff    	lea    -0x81c6(%ebx),%eax
c0024389:	50                   	push   %eax
c002438a:	8d 83 c7 7d ff ff    	lea    -0x8239(%ebx),%eax
c0024390:	50                   	push   %eax
c0024391:	8d 83 00 7f ff ff    	lea    -0x8100(%ebx),%eax
c0024397:	50                   	push   %eax
c0024398:	6a 7b                	push   $0x7b
c002439a:	8d 83 23 7e ff ff    	lea    -0x81dd(%ebx),%eax
c00243a0:	50                   	push   %eax
c00243a1:	e8 be 73 00 00       	call   c002b764 <debug_panic>
  if (pages == NULL || page_cnt == 0)
c00243a6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00243aa:	0f 84 14 01 00 00    	je     c00244c4 <palloc_free_multiple+0x166>
c00243b0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00243b4:	0f 84 0a 01 00 00    	je     c00244c4 <palloc_free_multiple+0x166>
    return;

  if (page_from_pool (&kernel_pool, pages))
c00243ba:	83 ec 08             	sub    $0x8,%esp
c00243bd:	ff 75 08             	push   0x8(%ebp)
c00243c0:	8d 83 e8 1c 00 00    	lea    0x1ce8(%ebx),%eax
c00243c6:	50                   	push   %eax
c00243c7:	e8 df 01 00 00       	call   c00245ab <page_from_pool>
c00243cc:	83 c4 10             	add    $0x10,%esp
c00243cf:	84 c0                	test   %al,%al
c00243d1:	74 0b                	je     c00243de <palloc_free_multiple+0x80>
    pool = &kernel_pool;
c00243d3:	8d 83 e8 1c 00 00    	lea    0x1ce8(%ebx),%eax
c00243d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00243dc:	eb 43                	jmp    c0024421 <palloc_free_multiple+0xc3>
  else if (page_from_pool (&user_pool, pages))
c00243de:	83 ec 08             	sub    $0x8,%esp
c00243e1:	ff 75 08             	push   0x8(%ebp)
c00243e4:	8d 83 08 1d 00 00    	lea    0x1d08(%ebx),%eax
c00243ea:	50                   	push   %eax
c00243eb:	e8 bb 01 00 00       	call   c00245ab <page_from_pool>
c00243f0:	83 c4 10             	add    $0x10,%esp
c00243f3:	84 c0                	test   %al,%al
c00243f5:	74 0b                	je     c0024402 <palloc_free_multiple+0xa4>
    pool = &user_pool;
c00243f7:	8d 83 08 1d 00 00    	lea    0x1d08(%ebx),%eax
c00243fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0024400:	eb 1f                	jmp    c0024421 <palloc_free_multiple+0xc3>
  else
    NOT_REACHED ();
c0024402:	8d 83 50 7e ff ff    	lea    -0x81b0(%ebx),%eax
c0024408:	50                   	push   %eax
c0024409:	8d 83 00 7f ff ff    	lea    -0x8100(%ebx),%eax
c002440f:	50                   	push   %eax
c0024410:	68 84 00 00 00       	push   $0x84
c0024415:	8d 83 23 7e ff ff    	lea    -0x81dd(%ebx),%eax
c002441b:	50                   	push   %eax
c002441c:	e8 43 73 00 00       	call   c002b764 <debug_panic>

  page_idx = pg_no (pages) - pg_no (pool->base);
c0024421:	83 ec 0c             	sub    $0xc,%esp
c0024424:	ff 75 08             	push   0x8(%ebp)
c0024427:	e8 01 fd ff ff       	call   c002412d <pg_no>
c002442c:	83 c4 10             	add    $0x10,%esp
c002442f:	89 c6                	mov    %eax,%esi
c0024431:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024434:	8b 40 1c             	mov    0x1c(%eax),%eax
c0024437:	83 ec 0c             	sub    $0xc,%esp
c002443a:	50                   	push   %eax
c002443b:	e8 ed fc ff ff       	call   c002412d <pg_no>
c0024440:	83 c4 10             	add    $0x10,%esp
c0024443:	89 c2                	mov    %eax,%edx
c0024445:	89 f0                	mov    %esi,%eax
c0024447:	29 d0                	sub    %edx,%eax
c0024449:	89 45 f0             	mov    %eax,-0x10(%ebp)

#ifndef NDEBUG
  memset (pages, 0xcc, PGSIZE * page_cnt);
c002444c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002444f:	c1 e0 0c             	shl    $0xc,%eax
c0024452:	83 ec 04             	sub    $0x4,%esp
c0024455:	50                   	push   %eax
c0024456:	68 cc 00 00 00       	push   $0xcc
c002445b:	ff 75 08             	push   0x8(%ebp)
c002445e:	e8 91 65 00 00       	call   c002a9f4 <memset>
c0024463:	83 c4 10             	add    $0x10,%esp
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0024466:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024469:	8b 40 18             	mov    0x18(%eax),%eax
c002446c:	83 ec 04             	sub    $0x4,%esp
c002446f:	ff 75 0c             	push   0xc(%ebp)
c0024472:	ff 75 f0             	push   -0x10(%ebp)
c0024475:	50                   	push   %eax
c0024476:	e8 d7 8d 00 00       	call   c002d252 <bitmap_all>
c002447b:	83 c4 10             	add    $0x10,%esp
c002447e:	84 c0                	test   %al,%al
c0024480:	75 29                	jne    c00244ab <palloc_free_multiple+0x14d>
c0024482:	83 ec 0c             	sub    $0xc,%esp
c0024485:	8d 83 74 7e ff ff    	lea    -0x818c(%ebx),%eax
c002448b:	50                   	push   %eax
c002448c:	8d 83 c7 7d ff ff    	lea    -0x8239(%ebx),%eax
c0024492:	50                   	push   %eax
c0024493:	8d 83 00 7f ff ff    	lea    -0x8100(%ebx),%eax
c0024499:	50                   	push   %eax
c002449a:	68 8c 00 00 00       	push   $0x8c
c002449f:	8d 83 23 7e ff ff    	lea    -0x81dd(%ebx),%eax
c00244a5:	50                   	push   %eax
c00244a6:	e8 b9 72 00 00       	call   c002b764 <debug_panic>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c00244ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00244ae:	8b 40 18             	mov    0x18(%eax),%eax
c00244b1:	6a 00                	push   $0x0
c00244b3:	ff 75 0c             	push   0xc(%ebp)
c00244b6:	ff 75 f0             	push   -0x10(%ebp)
c00244b9:	50                   	push   %eax
c00244ba:	e8 4f 8a 00 00       	call   c002cf0e <bitmap_set_multiple>
c00244bf:	83 c4 10             	add    $0x10,%esp
c00244c2:	eb 01                	jmp    c00244c5 <palloc_free_multiple+0x167>
    return;
c00244c4:	90                   	nop
}
c00244c5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00244c8:	5b                   	pop    %ebx
c00244c9:	5e                   	pop    %esi
c00244ca:	5d                   	pop    %ebp
c00244cb:	c3                   	ret    

c00244cc <palloc_free_page>:

/* Frees the page at PAGE. */
void
palloc_free_page (void *page) 
{
c00244cc:	55                   	push   %ebp
c00244cd:	89 e5                	mov    %esp,%ebp
c00244cf:	83 ec 08             	sub    $0x8,%esp
c00244d2:	e8 51 cf 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00244d7:	05 a1 5e 01 00       	add    $0x15ea1,%eax
  palloc_free_multiple (page, 1);
c00244dc:	83 ec 08             	sub    $0x8,%esp
c00244df:	6a 01                	push   $0x1
c00244e1:	ff 75 08             	push   0x8(%ebp)
c00244e4:	e8 75 fe ff ff       	call   c002435e <palloc_free_multiple>
c00244e9:	83 c4 10             	add    $0x10,%esp
}
c00244ec:	90                   	nop
c00244ed:	c9                   	leave  
c00244ee:	c3                   	ret    

c00244ef <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c00244ef:	55                   	push   %ebp
c00244f0:	89 e5                	mov    %esp,%ebp
c00244f2:	53                   	push   %ebx
c00244f3:	83 ec 14             	sub    $0x14,%esp
c00244f6:	e8 31 cf 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00244fb:	81 c3 7d 5e 01 00    	add    $0x15e7d,%ebx
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c0024501:	83 ec 0c             	sub    $0xc,%esp
c0024504:	ff 75 10             	push   0x10(%ebp)
c0024507:	e8 03 87 00 00       	call   c002cc0f <bitmap_buf_size>
c002450c:	83 c4 10             	add    $0x10,%esp
c002450f:	05 ff 0f 00 00       	add    $0xfff,%eax
c0024514:	c1 e8 0c             	shr    $0xc,%eax
c0024517:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (bm_pages > page_cnt)
c002451a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002451d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0024520:	76 25                	jbe    c0024547 <init_pool+0x58>
    PANIC ("Not enough memory in %s for bitmap.", name);
c0024522:	83 ec 0c             	sub    $0xc,%esp
c0024525:	ff 75 14             	push   0x14(%ebp)
c0024528:	8d 83 a4 7e ff ff    	lea    -0x815c(%ebx),%eax
c002452e:	50                   	push   %eax
c002452f:	8d 83 18 7f ff ff    	lea    -0x80e8(%ebx),%eax
c0024535:	50                   	push   %eax
c0024536:	68 a1 00 00 00       	push   $0xa1
c002453b:	8d 83 23 7e ff ff    	lea    -0x81dd(%ebx),%eax
c0024541:	50                   	push   %eax
c0024542:	e8 1d 72 00 00       	call   c002b764 <debug_panic>
  page_cnt -= bm_pages;
c0024547:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002454a:	29 45 10             	sub    %eax,0x10(%ebp)

  printf ("%zu pages available in %s.\n", page_cnt, name);
c002454d:	83 ec 04             	sub    $0x4,%esp
c0024550:	ff 75 14             	push   0x14(%ebp)
c0024553:	ff 75 10             	push   0x10(%ebp)
c0024556:	8d 83 c8 7e ff ff    	lea    -0x8138(%ebx),%eax
c002455c:	50                   	push   %eax
c002455d:	e8 83 49 00 00       	call   c0028ee5 <printf>
c0024562:	83 c4 10             	add    $0x10,%esp

  /* Initialize the pool. */
  lock_init (&p->lock);
c0024565:	8b 45 08             	mov    0x8(%ebp),%eax
c0024568:	83 ec 0c             	sub    $0xc,%esp
c002456b:	50                   	push   %eax
c002456c:	e8 61 f2 ff ff       	call   c00237d2 <lock_init>
c0024571:	83 c4 10             	add    $0x10,%esp
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c0024574:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024577:	c1 e0 0c             	shl    $0xc,%eax
c002457a:	83 ec 04             	sub    $0x4,%esp
c002457d:	50                   	push   %eax
c002457e:	ff 75 0c             	push   0xc(%ebp)
c0024581:	ff 75 10             	push   0x10(%ebp)
c0024584:	e8 09 86 00 00       	call   c002cb92 <bitmap_create_in_buf>
c0024589:	83 c4 10             	add    $0x10,%esp
c002458c:	8b 55 08             	mov    0x8(%ebp),%edx
c002458f:	89 42 18             	mov    %eax,0x18(%edx)
  p->base = base + bm_pages * PGSIZE;
c0024592:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024595:	c1 e0 0c             	shl    $0xc,%eax
c0024598:	89 c2                	mov    %eax,%edx
c002459a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002459d:	01 c2                	add    %eax,%edx
c002459f:	8b 45 08             	mov    0x8(%ebp),%eax
c00245a2:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c00245a5:	90                   	nop
c00245a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00245a9:	c9                   	leave  
c00245aa:	c3                   	ret    

c00245ab <page_from_pool>:

/* Returns true if PAGE was allocated from POOL,
   false otherwise. */
static bool
page_from_pool (const struct pool *pool, void *page) 
{
c00245ab:	55                   	push   %ebp
c00245ac:	89 e5                	mov    %esp,%ebp
c00245ae:	53                   	push   %ebx
c00245af:	83 ec 14             	sub    $0x14,%esp
c00245b2:	e8 75 ce 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00245b7:	81 c3 c1 5d 01 00    	add    $0x15dc1,%ebx
  size_t page_no = pg_no (page);
c00245bd:	ff 75 0c             	push   0xc(%ebp)
c00245c0:	e8 68 fb ff ff       	call   c002412d <pg_no>
c00245c5:	83 c4 04             	add    $0x4,%esp
c00245c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t start_page = pg_no (pool->base);
c00245cb:	8b 45 08             	mov    0x8(%ebp),%eax
c00245ce:	8b 40 1c             	mov    0x1c(%eax),%eax
c00245d1:	50                   	push   %eax
c00245d2:	e8 56 fb ff ff       	call   c002412d <pg_no>
c00245d7:	83 c4 04             	add    $0x4,%esp
c00245da:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t end_page = start_page + bitmap_size (pool->used_map);
c00245dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00245e0:	8b 40 18             	mov    0x18(%eax),%eax
c00245e3:	83 ec 0c             	sub    $0xc,%esp
c00245e6:	50                   	push   %eax
c00245e7:	e8 7e 86 00 00       	call   c002cc6a <bitmap_size>
c00245ec:	83 c4 10             	add    $0x10,%esp
c00245ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00245f2:	01 d0                	add    %edx,%eax
c00245f4:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return page_no >= start_page && page_no < end_page;
c00245f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00245fa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00245fd:	72 0f                	jb     c002460e <page_from_pool+0x63>
c00245ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024602:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0024605:	73 07                	jae    c002460e <page_from_pool+0x63>
c0024607:	b8 01 00 00 00       	mov    $0x1,%eax
c002460c:	eb 05                	jmp    c0024613 <page_from_pool+0x68>
c002460e:	b8 00 00 00 00       	mov    $0x0,%eax
c0024613:	83 e0 01             	and    $0x1,%eax
}
c0024616:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024619:	c9                   	leave  
c002461a:	c3                   	ret    

c002461b <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c002461b:	55                   	push   %ebp
c002461c:	89 e5                	mov    %esp,%ebp
c002461e:	e8 05 ce 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0024623:	05 55 5d 01 00       	add    $0x15d55,%eax
  return (uintptr_t) va & PGMASK;
c0024628:	8b 45 08             	mov    0x8(%ebp),%eax
c002462b:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c0024630:	5d                   	pop    %ebp
c0024631:	c3                   	ret    

c0024632 <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c0024632:	55                   	push   %ebp
c0024633:	89 e5                	mov    %esp,%ebp
c0024635:	e8 ee cd 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002463a:	05 3e 5d 01 00       	add    $0x15d3e,%eax
  return (void *) ((uintptr_t) va & ~PGMASK);
c002463f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024642:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c0024647:	5d                   	pop    %ebp
c0024648:	c3                   	ret    

c0024649 <malloc_init>:
static struct block *arena_to_block (struct arena *, size_t idx);

/* Initializes the malloc() descriptors. */
void
malloc_init (void) 
{
c0024649:	55                   	push   %ebp
c002464a:	89 e5                	mov    %esp,%ebp
c002464c:	53                   	push   %ebx
c002464d:	83 ec 14             	sub    $0x14,%esp
c0024650:	e8 d7 cd 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0024655:	81 c3 23 5d 01 00    	add    $0x15d23,%ebx
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c002465b:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c0024662:	e9 98 00 00 00       	jmp    c00246ff <malloc_init+0xb6>
    {
      struct desc *d = &descs[desc_cnt++];
c0024667:	8b 93 08 1f 00 00    	mov    0x1f08(%ebx),%edx
c002466d:	8d 42 01             	lea    0x1(%edx),%eax
c0024670:	89 83 08 1f 00 00    	mov    %eax,0x1f08(%ebx)
c0024676:	89 d0                	mov    %edx,%eax
c0024678:	01 c0                	add    %eax,%eax
c002467a:	01 d0                	add    %edx,%eax
c002467c:	c1 e0 04             	shl    $0x4,%eax
c002467f:	8d 93 28 1d 00 00    	lea    0x1d28(%ebx),%edx
c0024685:	01 d0                	add    %edx,%eax
c0024687:	89 45 f0             	mov    %eax,-0x10(%ebp)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c002468a:	8b 83 08 1f 00 00    	mov    0x1f08(%ebx),%eax
c0024690:	83 f8 0a             	cmp    $0xa,%eax
c0024693:	76 26                	jbe    c00246bb <malloc_init+0x72>
c0024695:	83 ec 0c             	sub    $0xc,%esp
c0024698:	8d 83 24 7f ff ff    	lea    -0x80dc(%ebx),%eax
c002469e:	50                   	push   %eax
c002469f:	8d 83 4d 7f ff ff    	lea    -0x80b3(%ebx),%eax
c00246a5:	50                   	push   %eax
c00246a6:	8d 83 58 80 ff ff    	lea    -0x7fa8(%ebx),%eax
c00246ac:	50                   	push   %eax
c00246ad:	6a 4f                	push   $0x4f
c00246af:	8d 83 64 7f ff ff    	lea    -0x809c(%ebx),%eax
c00246b5:	50                   	push   %eax
c00246b6:	e8 a9 70 00 00       	call   c002b764 <debug_panic>
      d->block_size = block_size;
c00246bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00246be:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00246c1:	89 10                	mov    %edx,(%eax)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c00246c3:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c00246c8:	ba 00 00 00 00       	mov    $0x0,%edx
c00246cd:	f7 75 f4             	divl   -0xc(%ebp)
c00246d0:	89 c2                	mov    %eax,%edx
c00246d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00246d5:	89 50 04             	mov    %edx,0x4(%eax)
      list_init (&d->free_list);
c00246d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00246db:	83 c0 08             	add    $0x8,%eax
c00246de:	83 ec 0c             	sub    $0xc,%esp
c00246e1:	50                   	push   %eax
c00246e2:	e8 5d 73 00 00       	call   c002ba44 <list_init>
c00246e7:	83 c4 10             	add    $0x10,%esp
      lock_init (&d->lock);
c00246ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00246ed:	83 c0 18             	add    $0x18,%eax
c00246f0:	83 ec 0c             	sub    $0xc,%esp
c00246f3:	50                   	push   %eax
c00246f4:	e8 d9 f0 ff ff       	call   c00237d2 <lock_init>
c00246f9:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c00246fc:	d1 65 f4             	shll   -0xc(%ebp)
c00246ff:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c0024706:	0f 86 5b ff ff ff    	jbe    c0024667 <malloc_init+0x1e>
    }
}
c002470c:	90                   	nop
c002470d:	90                   	nop
c002470e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024711:	c9                   	leave  
c0024712:	c3                   	ret    

c0024713 <malloc>:

/* Obtains and returns a new block of at least SIZE bytes.
   Returns a null pointer if memory is not available. */
void *
malloc (size_t size) 
{
c0024713:	55                   	push   %ebp
c0024714:	89 e5                	mov    %esp,%ebp
c0024716:	53                   	push   %ebx
c0024717:	83 ec 24             	sub    $0x24,%esp
c002471a:	e8 0d cd 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002471f:	81 c3 59 5c 01 00    	add    $0x15c59,%ebx
  struct desc *d;
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
c0024725:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0024729:	75 0a                	jne    c0024735 <malloc+0x22>
    return NULL;
c002472b:	b8 00 00 00 00       	mov    $0x0,%eax
c0024730:	e9 be 01 00 00       	jmp    c00248f3 <malloc+0x1e0>

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c0024735:	8d 83 28 1d 00 00    	lea    0x1d28(%ebx),%eax
c002473b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002473e:	eb 0e                	jmp    c002474e <malloc+0x3b>
    if (d->block_size >= size)
c0024740:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024743:	8b 00                	mov    (%eax),%eax
c0024745:	39 45 08             	cmp    %eax,0x8(%ebp)
c0024748:	76 24                	jbe    c002476e <malloc+0x5b>
  for (d = descs; d < descs + desc_cnt; d++)
c002474a:	83 45 f4 30          	addl   $0x30,-0xc(%ebp)
c002474e:	8b 93 08 1f 00 00    	mov    0x1f08(%ebx),%edx
c0024754:	89 d0                	mov    %edx,%eax
c0024756:	01 c0                	add    %eax,%eax
c0024758:	01 d0                	add    %edx,%eax
c002475a:	c1 e0 04             	shl    $0x4,%eax
c002475d:	89 c2                	mov    %eax,%edx
c002475f:	8d 83 28 1d 00 00    	lea    0x1d28(%ebx),%eax
c0024765:	01 d0                	add    %edx,%eax
c0024767:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002476a:	72 d4                	jb     c0024740 <malloc+0x2d>
c002476c:	eb 01                	jmp    c002476f <malloc+0x5c>
      break;
c002476e:	90                   	nop
  if (d == descs + desc_cnt) 
c002476f:	8b 93 08 1f 00 00    	mov    0x1f08(%ebx),%edx
c0024775:	89 d0                	mov    %edx,%eax
c0024777:	01 c0                	add    %eax,%eax
c0024779:	01 d0                	add    %edx,%eax
c002477b:	c1 e0 04             	shl    $0x4,%eax
c002477e:	89 c2                	mov    %eax,%edx
c0024780:	8d 83 28 1d 00 00    	lea    0x1d28(%ebx),%eax
c0024786:	01 d0                	add    %edx,%eax
c0024788:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002478b:	75 58                	jne    c00247e5 <malloc+0xd2>
    {
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c002478d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024790:	05 0b 10 00 00       	add    $0x100b,%eax
c0024795:	c1 e8 0c             	shr    $0xc,%eax
c0024798:	89 45 e0             	mov    %eax,-0x20(%ebp)
      a = palloc_get_multiple (0, page_cnt);
c002479b:	83 ec 08             	sub    $0x8,%esp
c002479e:	ff 75 e0             	push   -0x20(%ebp)
c00247a1:	6a 00                	push   $0x0
c00247a3:	e8 a9 fa ff ff       	call   c0024251 <palloc_get_multiple>
c00247a8:	83 c4 10             	add    $0x10,%esp
c00247ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if (a == NULL)
c00247ae:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00247b2:	75 0a                	jne    c00247be <malloc+0xab>
        return NULL;
c00247b4:	b8 00 00 00 00       	mov    $0x0,%eax
c00247b9:	e9 35 01 00 00       	jmp    c00248f3 <malloc+0x1e0>

      /* Initialize the arena to indicate a big block of PAGE_CNT
         pages, and return it. */
      a->magic = ARENA_MAGIC;
c00247be:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00247c1:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c00247c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00247ca:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c00247d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00247d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00247d7:	89 50 08             	mov    %edx,0x8(%eax)
      return a + 1;
c00247da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00247dd:	83 c0 0c             	add    $0xc,%eax
c00247e0:	e9 0e 01 00 00       	jmp    c00248f3 <malloc+0x1e0>
    }

  lock_acquire (&d->lock);
c00247e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00247e8:	83 c0 18             	add    $0x18,%eax
c00247eb:	83 ec 0c             	sub    $0xc,%esp
c00247ee:	50                   	push   %eax
c00247ef:	e8 43 f0 ff ff       	call   c0023837 <lock_acquire>
c00247f4:	83 c4 10             	add    $0x10,%esp

  /* If the free list is empty, create a new arena. */
  if (list_empty (&d->free_list))
c00247f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00247fa:	83 c0 08             	add    $0x8,%eax
c00247fd:	83 ec 0c             	sub    $0xc,%esp
c0024800:	50                   	push   %eax
c0024801:	e8 59 79 00 00       	call   c002c15f <list_empty>
c0024806:	83 c4 10             	add    $0x10,%esp
c0024809:	84 c0                	test   %al,%al
c002480b:	0f 84 92 00 00 00    	je     c00248a3 <malloc+0x190>
    {
      size_t i;

      /* Allocate a page. */
      a = palloc_get_page (0);
c0024811:	83 ec 0c             	sub    $0xc,%esp
c0024814:	6a 00                	push   $0x0
c0024816:	e8 21 fb ff ff       	call   c002433c <palloc_get_page>
c002481b:	83 c4 10             	add    $0x10,%esp
c002481e:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if (a == NULL) 
c0024821:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0024825:	75 1c                	jne    c0024843 <malloc+0x130>
        {
          lock_release (&d->lock);
c0024827:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002482a:	83 c0 18             	add    $0x18,%eax
c002482d:	83 ec 0c             	sub    $0xc,%esp
c0024830:	50                   	push   %eax
c0024831:	e8 af f2 ff ff       	call   c0023ae5 <lock_release>
c0024836:	83 c4 10             	add    $0x10,%esp
          return NULL; 
c0024839:	b8 00 00 00 00       	mov    $0x0,%eax
c002483e:	e9 b0 00 00 00       	jmp    c00248f3 <malloc+0x1e0>
        }

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
c0024843:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024846:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c002484c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002484f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0024852:	89 50 04             	mov    %edx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c0024855:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024858:	8b 50 04             	mov    0x4(%eax),%edx
c002485b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002485e:	89 50 08             	mov    %edx,0x8(%eax)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0024861:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0024868:	eb 2e                	jmp    c0024898 <malloc+0x185>
        {
          struct block *b = arena_to_block (a, i);
c002486a:	83 ec 08             	sub    $0x8,%esp
c002486d:	ff 75 f0             	push   -0x10(%ebp)
c0024870:	ff 75 ec             	push   -0x14(%ebp)
c0024873:	e8 62 04 00 00       	call   c0024cda <arena_to_block>
c0024878:	83 c4 10             	add    $0x10,%esp
c002487b:	89 45 e8             	mov    %eax,-0x18(%ebp)
          list_push_back (&d->free_list, &b->free_elem);
c002487e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024881:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0024884:	83 c2 08             	add    $0x8,%edx
c0024887:	83 ec 08             	sub    $0x8,%esp
c002488a:	50                   	push   %eax
c002488b:	52                   	push   %edx
c002488c:	e8 b9 76 00 00       	call   c002bf4a <list_push_back>
c0024891:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < d->blocks_per_arena; i++) 
c0024894:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0024898:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002489b:	8b 40 04             	mov    0x4(%eax),%eax
c002489e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00248a1:	72 c7                	jb     c002486a <malloc+0x157>
        }
    }

  /* Get a block from free list and return it. */
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c00248a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00248a6:	83 c0 08             	add    $0x8,%eax
c00248a9:	83 ec 0c             	sub    $0xc,%esp
c00248ac:	50                   	push   %eax
c00248ad:	e8 38 77 00 00       	call   c002bfea <list_pop_front>
c00248b2:	83 c4 10             	add    $0x10,%esp
c00248b5:	83 c0 04             	add    $0x4,%eax
c00248b8:	83 e8 04             	sub    $0x4,%eax
c00248bb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  a = block_to_arena (b);
c00248be:	83 ec 0c             	sub    $0xc,%esp
c00248c1:	ff 75 e4             	push   -0x1c(%ebp)
c00248c4:	e8 e4 02 00 00       	call   c0024bad <block_to_arena>
c00248c9:	83 c4 10             	add    $0x10,%esp
c00248cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  a->free_cnt--;
c00248cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00248d2:	8b 40 08             	mov    0x8(%eax),%eax
c00248d5:	8d 50 ff             	lea    -0x1(%eax),%edx
c00248d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00248db:	89 50 08             	mov    %edx,0x8(%eax)
  lock_release (&d->lock);
c00248de:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00248e1:	83 c0 18             	add    $0x18,%eax
c00248e4:	83 ec 0c             	sub    $0xc,%esp
c00248e7:	50                   	push   %eax
c00248e8:	e8 f8 f1 ff ff       	call   c0023ae5 <lock_release>
c00248ed:	83 c4 10             	add    $0x10,%esp
  return b;
c00248f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
c00248f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00248f6:	c9                   	leave  
c00248f7:	c3                   	ret    

c00248f8 <calloc>:

/* Allocates and return A times B bytes initialized to zeroes.
   Returns a null pointer if memory is not available. */
void *
calloc (size_t a, size_t b) 
{
c00248f8:	55                   	push   %ebp
c00248f9:	89 e5                	mov    %esp,%ebp
c00248fb:	53                   	push   %ebx
c00248fc:	83 ec 14             	sub    $0x14,%esp
c00248ff:	e8 28 cb 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0024904:	81 c3 74 5a 01 00    	add    $0x15a74,%ebx
  void *p;
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
c002490a:	8b 45 08             	mov    0x8(%ebp),%eax
c002490d:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0024911:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (size < a || size < b)
c0024914:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024917:	3b 45 08             	cmp    0x8(%ebp),%eax
c002491a:	72 08                	jb     c0024924 <calloc+0x2c>
c002491c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002491f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024922:	73 07                	jae    c002492b <calloc+0x33>
    return NULL;
c0024924:	b8 00 00 00 00       	mov    $0x0,%eax
c0024929:	eb 2d                	jmp    c0024958 <calloc+0x60>

  /* Allocate and zero memory. */
  p = malloc (size);
c002492b:	83 ec 0c             	sub    $0xc,%esp
c002492e:	ff 75 f4             	push   -0xc(%ebp)
c0024931:	e8 dd fd ff ff       	call   c0024713 <malloc>
c0024936:	83 c4 10             	add    $0x10,%esp
c0024939:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (p != NULL)
c002493c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0024940:	74 13                	je     c0024955 <calloc+0x5d>
    memset (p, 0, size);
c0024942:	83 ec 04             	sub    $0x4,%esp
c0024945:	ff 75 f4             	push   -0xc(%ebp)
c0024948:	6a 00                	push   $0x0
c002494a:	ff 75 f0             	push   -0x10(%ebp)
c002494d:	e8 a2 60 00 00       	call   c002a9f4 <memset>
c0024952:	83 c4 10             	add    $0x10,%esp

  return p;
c0024955:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0024958:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002495b:	c9                   	leave  
c002495c:	c3                   	ret    

c002495d <block_size>:

/* Returns the number of bytes allocated for BLOCK. */
static size_t
block_size (void *block) 
{
c002495d:	55                   	push   %ebp
c002495e:	89 e5                	mov    %esp,%ebp
c0024960:	53                   	push   %ebx
c0024961:	83 ec 14             	sub    $0x14,%esp
c0024964:	e8 bf ca 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0024969:	05 0f 5a 01 00       	add    $0x15a0f,%eax
  struct block *b = block;
c002496e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024971:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct arena *a = block_to_arena (b);
c0024974:	83 ec 0c             	sub    $0xc,%esp
c0024977:	ff 75 f4             	push   -0xc(%ebp)
c002497a:	e8 2e 02 00 00       	call   c0024bad <block_to_arena>
c002497f:	83 c4 10             	add    $0x10,%esp
c0024982:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct desc *d = a->desc;
c0024985:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024988:	8b 40 04             	mov    0x4(%eax),%eax
c002498b:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c002498e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0024992:	74 07                	je     c002499b <block_size+0x3e>
c0024994:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024997:	8b 00                	mov    (%eax),%eax
c0024999:	eb 1f                	jmp    c00249ba <block_size+0x5d>
c002499b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002499e:	8b 40 08             	mov    0x8(%eax),%eax
c00249a1:	c1 e0 0c             	shl    $0xc,%eax
c00249a4:	89 c3                	mov    %eax,%ebx
c00249a6:	83 ec 0c             	sub    $0xc,%esp
c00249a9:	ff 75 08             	push   0x8(%ebp)
c00249ac:	e8 6a fc ff ff       	call   c002461b <pg_ofs>
c00249b1:	83 c4 10             	add    $0x10,%esp
c00249b4:	89 c2                	mov    %eax,%edx
c00249b6:	89 d8                	mov    %ebx,%eax
c00249b8:	29 d0                	sub    %edx,%eax
}
c00249ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00249bd:	c9                   	leave  
c00249be:	c3                   	ret    

c00249bf <realloc>:
   null pointer.
   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).
   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */
void *
realloc (void *old_block, size_t new_size) 
{
c00249bf:	55                   	push   %ebp
c00249c0:	89 e5                	mov    %esp,%ebp
c00249c2:	53                   	push   %ebx
c00249c3:	83 ec 14             	sub    $0x14,%esp
c00249c6:	e8 61 ca 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00249cb:	81 c3 ad 59 01 00    	add    $0x159ad,%ebx
  if (new_size == 0) 
c00249d1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00249d5:	75 15                	jne    c00249ec <realloc+0x2d>
    {
      free (old_block);
c00249d7:	83 ec 0c             	sub    $0xc,%esp
c00249da:	ff 75 08             	push   0x8(%ebp)
c00249dd:	e8 70 00 00 00       	call   c0024a52 <free>
c00249e2:	83 c4 10             	add    $0x10,%esp
      return NULL;
c00249e5:	b8 00 00 00 00       	mov    $0x0,%eax
c00249ea:	eb 61                	jmp    c0024a4d <realloc+0x8e>
    }
  else 
    {
      void *new_block = malloc (new_size);
c00249ec:	83 ec 0c             	sub    $0xc,%esp
c00249ef:	ff 75 0c             	push   0xc(%ebp)
c00249f2:	e8 1c fd ff ff       	call   c0024713 <malloc>
c00249f7:	83 c4 10             	add    $0x10,%esp
c00249fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (old_block != NULL && new_block != NULL)
c00249fd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0024a01:	74 47                	je     c0024a4a <realloc+0x8b>
c0024a03:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024a07:	74 41                	je     c0024a4a <realloc+0x8b>
        {
          size_t old_size = block_size (old_block);
c0024a09:	83 ec 0c             	sub    $0xc,%esp
c0024a0c:	ff 75 08             	push   0x8(%ebp)
c0024a0f:	e8 49 ff ff ff       	call   c002495d <block_size>
c0024a14:	83 c4 10             	add    $0x10,%esp
c0024a17:	89 45 f0             	mov    %eax,-0x10(%ebp)
          size_t min_size = new_size < old_size ? new_size : old_size;
c0024a1a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0024a1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024a20:	39 c2                	cmp    %eax,%edx
c0024a22:	0f 46 c2             	cmovbe %edx,%eax
c0024a25:	89 45 ec             	mov    %eax,-0x14(%ebp)
          memcpy (new_block, old_block, min_size);
c0024a28:	83 ec 04             	sub    $0x4,%esp
c0024a2b:	ff 75 ec             	push   -0x14(%ebp)
c0024a2e:	ff 75 08             	push   0x8(%ebp)
c0024a31:	ff 75 f4             	push   -0xc(%ebp)
c0024a34:	e8 9f 58 00 00       	call   c002a2d8 <memcpy>
c0024a39:	83 c4 10             	add    $0x10,%esp
          free (old_block);
c0024a3c:	83 ec 0c             	sub    $0xc,%esp
c0024a3f:	ff 75 08             	push   0x8(%ebp)
c0024a42:	e8 0b 00 00 00       	call   c0024a52 <free>
c0024a47:	83 c4 10             	add    $0x10,%esp
        }
      return new_block;
c0024a4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c0024a4d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024a50:	c9                   	leave  
c0024a51:	c3                   	ret    

c0024a52 <free>:

/* Frees block P, which must have been previously allocated with
   malloc(), calloc(), or realloc(). */
void
free (void *p) 
{
c0024a52:	55                   	push   %ebp
c0024a53:	89 e5                	mov    %esp,%ebp
c0024a55:	53                   	push   %ebx
c0024a56:	83 ec 24             	sub    $0x24,%esp
c0024a59:	e8 ce c9 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0024a5e:	81 c3 1a 59 01 00    	add    $0x1591a,%ebx
  if (p != NULL)
c0024a64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0024a68:	0f 84 3a 01 00 00    	je     c0024ba8 <free+0x156>
    {
      struct block *b = p;
c0024a6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a71:	89 45 f0             	mov    %eax,-0x10(%ebp)
      struct arena *a = block_to_arena (b);
c0024a74:	83 ec 0c             	sub    $0xc,%esp
c0024a77:	ff 75 f0             	push   -0x10(%ebp)
c0024a7a:	e8 2e 01 00 00       	call   c0024bad <block_to_arena>
c0024a7f:	83 c4 10             	add    $0x10,%esp
c0024a82:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct desc *d = a->desc;
c0024a85:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024a88:	8b 40 04             	mov    0x4(%eax),%eax
c0024a8b:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      if (d != NULL) 
c0024a8e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0024a92:	0f 84 fa 00 00 00    	je     c0024b92 <free+0x140>
        {
          /* It's a normal block.  We handle it here. */

#ifndef NDEBUG
          /* Clear the block to help detect use-after-free bugs. */
          memset (b, 0xcc, d->block_size);
c0024a98:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024a9b:	8b 00                	mov    (%eax),%eax
c0024a9d:	83 ec 04             	sub    $0x4,%esp
c0024aa0:	50                   	push   %eax
c0024aa1:	68 cc 00 00 00       	push   $0xcc
c0024aa6:	ff 75 f0             	push   -0x10(%ebp)
c0024aa9:	e8 46 5f 00 00       	call   c002a9f4 <memset>
c0024aae:	83 c4 10             	add    $0x10,%esp
#endif
  
          lock_acquire (&d->lock);
c0024ab1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024ab4:	83 c0 18             	add    $0x18,%eax
c0024ab7:	83 ec 0c             	sub    $0xc,%esp
c0024aba:	50                   	push   %eax
c0024abb:	e8 77 ed ff ff       	call   c0023837 <lock_acquire>
c0024ac0:	83 c4 10             	add    $0x10,%esp

          /* Add block to free list. */
          list_push_front (&d->free_list, &b->free_elem);
c0024ac3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024ac6:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0024ac9:	83 c2 08             	add    $0x8,%edx
c0024acc:	83 ec 08             	sub    $0x8,%esp
c0024acf:	50                   	push   %eax
c0024ad0:	52                   	push   %edx
c0024ad1:	e8 44 74 00 00       	call   c002bf1a <list_push_front>
c0024ad6:	83 c4 10             	add    $0x10,%esp

          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
c0024ad9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024adc:	8b 40 08             	mov    0x8(%eax),%eax
c0024adf:	8d 50 01             	lea    0x1(%eax),%edx
c0024ae2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024ae5:	89 50 08             	mov    %edx,0x8(%eax)
c0024ae8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024aeb:	8b 50 08             	mov    0x8(%eax),%edx
c0024aee:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024af1:	8b 40 04             	mov    0x4(%eax),%eax
c0024af4:	39 c2                	cmp    %eax,%edx
c0024af6:	0f 82 82 00 00 00    	jb     c0024b7e <free+0x12c>
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c0024afc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024aff:	8b 50 08             	mov    0x8(%eax),%edx
c0024b02:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024b05:	8b 40 04             	mov    0x4(%eax),%eax
c0024b08:	39 c2                	cmp    %eax,%edx
c0024b0a:	74 29                	je     c0024b35 <free+0xe3>
c0024b0c:	83 ec 0c             	sub    $0xc,%esp
c0024b0f:	8d 83 7c 7f ff ff    	lea    -0x8084(%ebx),%eax
c0024b15:	50                   	push   %eax
c0024b16:	8d 83 4d 7f ff ff    	lea    -0x80b3(%ebx),%eax
c0024b1c:	50                   	push   %eax
c0024b1d:	8d 83 64 80 ff ff    	lea    -0x7f9c(%ebx),%eax
c0024b23:	50                   	push   %eax
c0024b24:	68 f6 00 00 00       	push   $0xf6
c0024b29:	8d 83 64 7f ff ff    	lea    -0x809c(%ebx),%eax
c0024b2f:	50                   	push   %eax
c0024b30:	e8 2f 6c 00 00       	call   c002b764 <debug_panic>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0024b35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0024b3c:	eb 27                	jmp    c0024b65 <free+0x113>
                {
                  struct block *b = arena_to_block (a, i);
c0024b3e:	83 ec 08             	sub    $0x8,%esp
c0024b41:	ff 75 f4             	push   -0xc(%ebp)
c0024b44:	ff 75 ec             	push   -0x14(%ebp)
c0024b47:	e8 8e 01 00 00       	call   c0024cda <arena_to_block>
c0024b4c:	83 c4 10             	add    $0x10,%esp
c0024b4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  list_remove (&b->free_elem);
c0024b52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0024b55:	83 ec 0c             	sub    $0xc,%esp
c0024b58:	50                   	push   %eax
c0024b59:	e8 1c 74 00 00       	call   c002bf7a <list_remove>
c0024b5e:	83 c4 10             	add    $0x10,%esp
              for (i = 0; i < d->blocks_per_arena; i++) 
c0024b61:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0024b65:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024b68:	8b 40 04             	mov    0x4(%eax),%eax
c0024b6b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0024b6e:	72 ce                	jb     c0024b3e <free+0xec>
                }
              palloc_free_page (a);
c0024b70:	83 ec 0c             	sub    $0xc,%esp
c0024b73:	ff 75 ec             	push   -0x14(%ebp)
c0024b76:	e8 51 f9 ff ff       	call   c00244cc <palloc_free_page>
c0024b7b:	83 c4 10             	add    $0x10,%esp
            }

          lock_release (&d->lock);
c0024b7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024b81:	83 c0 18             	add    $0x18,%eax
c0024b84:	83 ec 0c             	sub    $0xc,%esp
c0024b87:	50                   	push   %eax
c0024b88:	e8 58 ef ff ff       	call   c0023ae5 <lock_release>
c0024b8d:	83 c4 10             	add    $0x10,%esp
c0024b90:	eb 16                	jmp    c0024ba8 <free+0x156>
        }
      else
        {
          /* It's a big block.  Free its pages. */
          palloc_free_multiple (a, a->free_cnt);
c0024b92:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024b95:	8b 40 08             	mov    0x8(%eax),%eax
c0024b98:	83 ec 08             	sub    $0x8,%esp
c0024b9b:	50                   	push   %eax
c0024b9c:	ff 75 ec             	push   -0x14(%ebp)
c0024b9f:	e8 ba f7 ff ff       	call   c002435e <palloc_free_multiple>
c0024ba4:	83 c4 10             	add    $0x10,%esp
          return;
c0024ba7:	90                   	nop
        }
    }
}
c0024ba8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024bab:	c9                   	leave  
c0024bac:	c3                   	ret    

c0024bad <block_to_arena>:

/* Returns the arena that block B is inside. */
static struct arena *
block_to_arena (struct block *b)
{
c0024bad:	55                   	push   %ebp
c0024bae:	89 e5                	mov    %esp,%ebp
c0024bb0:	53                   	push   %ebx
c0024bb1:	83 ec 14             	sub    $0x14,%esp
c0024bb4:	e8 73 c8 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0024bb9:	81 c3 bf 57 01 00    	add    $0x157bf,%ebx
  struct arena *a = pg_round_down (b);
c0024bbf:	ff 75 08             	push   0x8(%ebp)
c0024bc2:	e8 6b fa ff ff       	call   c0024632 <pg_round_down>
c0024bc7:	83 c4 04             	add    $0x4,%esp
c0024bca:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Check that the arena is valid. */
  ASSERT (a != NULL);
c0024bcd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024bd1:	75 29                	jne    c0024bfc <block_to_arena+0x4f>
c0024bd3:	83 ec 0c             	sub    $0xc,%esp
c0024bd6:	8d 83 9f 7f ff ff    	lea    -0x8061(%ebx),%eax
c0024bdc:	50                   	push   %eax
c0024bdd:	8d 83 4d 7f ff ff    	lea    -0x80b3(%ebx),%eax
c0024be3:	50                   	push   %eax
c0024be4:	8d 83 6c 80 ff ff    	lea    -0x7f94(%ebx),%eax
c0024bea:	50                   	push   %eax
c0024beb:	68 11 01 00 00       	push   $0x111
c0024bf0:	8d 83 64 7f ff ff    	lea    -0x809c(%ebx),%eax
c0024bf6:	50                   	push   %eax
c0024bf7:	e8 68 6b 00 00       	call   c002b764 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0024bfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024bff:	8b 00                	mov    (%eax),%eax
c0024c01:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0024c06:	74 29                	je     c0024c31 <block_to_arena+0x84>
c0024c08:	83 ec 0c             	sub    $0xc,%esp
c0024c0b:	8d 83 a9 7f ff ff    	lea    -0x8057(%ebx),%eax
c0024c11:	50                   	push   %eax
c0024c12:	8d 83 4d 7f ff ff    	lea    -0x80b3(%ebx),%eax
c0024c18:	50                   	push   %eax
c0024c19:	8d 83 6c 80 ff ff    	lea    -0x7f94(%ebx),%eax
c0024c1f:	50                   	push   %eax
c0024c20:	68 12 01 00 00       	push   $0x112
c0024c25:	8d 83 64 7f ff ff    	lea    -0x809c(%ebx),%eax
c0024c2b:	50                   	push   %eax
c0024c2c:	e8 33 6b 00 00       	call   c002b764 <debug_panic>

  /* Check that the block is properly aligned for the arena. */
  ASSERT (a->desc == NULL
c0024c31:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024c34:	8b 40 04             	mov    0x4(%eax),%eax
c0024c37:	85 c0                	test   %eax,%eax
c0024c39:	74 51                	je     c0024c8c <block_to_arena+0xdf>
c0024c3b:	83 ec 0c             	sub    $0xc,%esp
c0024c3e:	ff 75 08             	push   0x8(%ebp)
c0024c41:	e8 d5 f9 ff ff       	call   c002461b <pg_ofs>
c0024c46:	83 c4 10             	add    $0x10,%esp
c0024c49:	8d 50 f4             	lea    -0xc(%eax),%edx
c0024c4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024c4f:	8b 40 04             	mov    0x4(%eax),%eax
c0024c52:	8b 08                	mov    (%eax),%ecx
c0024c54:	89 d0                	mov    %edx,%eax
c0024c56:	ba 00 00 00 00       	mov    $0x0,%edx
c0024c5b:	f7 f1                	div    %ecx
c0024c5d:	89 d0                	mov    %edx,%eax
c0024c5f:	85 c0                	test   %eax,%eax
c0024c61:	74 29                	je     c0024c8c <block_to_arena+0xdf>
c0024c63:	83 ec 0c             	sub    $0xc,%esp
c0024c66:	8d 83 c4 7f ff ff    	lea    -0x803c(%ebx),%eax
c0024c6c:	50                   	push   %eax
c0024c6d:	8d 83 4d 7f ff ff    	lea    -0x80b3(%ebx),%eax
c0024c73:	50                   	push   %eax
c0024c74:	8d 83 6c 80 ff ff    	lea    -0x7f94(%ebx),%eax
c0024c7a:	50                   	push   %eax
c0024c7b:	68 15 01 00 00       	push   $0x115
c0024c80:	8d 83 64 7f ff ff    	lea    -0x809c(%ebx),%eax
c0024c86:	50                   	push   %eax
c0024c87:	e8 d8 6a 00 00       	call   c002b764 <debug_panic>
          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c0024c8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024c8f:	8b 40 04             	mov    0x4(%eax),%eax
c0024c92:	85 c0                	test   %eax,%eax
c0024c94:	75 3c                	jne    c0024cd2 <block_to_arena+0x125>
c0024c96:	83 ec 0c             	sub    $0xc,%esp
c0024c99:	ff 75 08             	push   0x8(%ebp)
c0024c9c:	e8 7a f9 ff ff       	call   c002461b <pg_ofs>
c0024ca1:	83 c4 10             	add    $0x10,%esp
c0024ca4:	83 f8 0c             	cmp    $0xc,%eax
c0024ca7:	74 29                	je     c0024cd2 <block_to_arena+0x125>
c0024ca9:	83 ec 0c             	sub    $0xc,%esp
c0024cac:	8d 83 0c 80 ff ff    	lea    -0x7ff4(%ebx),%eax
c0024cb2:	50                   	push   %eax
c0024cb3:	8d 83 4d 7f ff ff    	lea    -0x80b3(%ebx),%eax
c0024cb9:	50                   	push   %eax
c0024cba:	8d 83 6c 80 ff ff    	lea    -0x7f94(%ebx),%eax
c0024cc0:	50                   	push   %eax
c0024cc1:	68 17 01 00 00       	push   $0x117
c0024cc6:	8d 83 64 7f ff ff    	lea    -0x809c(%ebx),%eax
c0024ccc:	50                   	push   %eax
c0024ccd:	e8 92 6a 00 00       	call   c002b764 <debug_panic>

  return a;
c0024cd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0024cd5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024cd8:	c9                   	leave  
c0024cd9:	c3                   	ret    

c0024cda <arena_to_block>:

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c0024cda:	55                   	push   %ebp
c0024cdb:	89 e5                	mov    %esp,%ebp
c0024cdd:	53                   	push   %ebx
c0024cde:	83 ec 04             	sub    $0x4,%esp
c0024ce1:	e8 42 c7 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0024ce6:	05 92 56 01 00       	add    $0x15692,%eax
  ASSERT (a != NULL);
c0024ceb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0024cef:	75 2b                	jne    c0024d1c <arena_to_block+0x42>
c0024cf1:	83 ec 0c             	sub    $0xc,%esp
c0024cf4:	8d 90 9f 7f ff ff    	lea    -0x8061(%eax),%edx
c0024cfa:	52                   	push   %edx
c0024cfb:	8d 90 4d 7f ff ff    	lea    -0x80b3(%eax),%edx
c0024d01:	52                   	push   %edx
c0024d02:	8d 90 7c 80 ff ff    	lea    -0x7f84(%eax),%edx
c0024d08:	52                   	push   %edx
c0024d09:	68 20 01 00 00       	push   $0x120
c0024d0e:	8d 90 64 7f ff ff    	lea    -0x809c(%eax),%edx
c0024d14:	52                   	push   %edx
c0024d15:	89 c3                	mov    %eax,%ebx
c0024d17:	e8 48 6a 00 00       	call   c002b764 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0024d1c:	8b 55 08             	mov    0x8(%ebp),%edx
c0024d1f:	8b 12                	mov    (%edx),%edx
c0024d21:	81 fa ed 8e 54 9a    	cmp    $0x9a548eed,%edx
c0024d27:	74 2b                	je     c0024d54 <arena_to_block+0x7a>
c0024d29:	83 ec 0c             	sub    $0xc,%esp
c0024d2c:	8d 90 a9 7f ff ff    	lea    -0x8057(%eax),%edx
c0024d32:	52                   	push   %edx
c0024d33:	8d 90 4d 7f ff ff    	lea    -0x80b3(%eax),%edx
c0024d39:	52                   	push   %edx
c0024d3a:	8d 90 7c 80 ff ff    	lea    -0x7f84(%eax),%edx
c0024d40:	52                   	push   %edx
c0024d41:	68 21 01 00 00       	push   $0x121
c0024d46:	8d 90 64 7f ff ff    	lea    -0x809c(%eax),%edx
c0024d4c:	52                   	push   %edx
c0024d4d:	89 c3                	mov    %eax,%ebx
c0024d4f:	e8 10 6a 00 00       	call   c002b764 <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c0024d54:	8b 55 08             	mov    0x8(%ebp),%edx
c0024d57:	8b 52 04             	mov    0x4(%edx),%edx
c0024d5a:	8b 52 04             	mov    0x4(%edx),%edx
c0024d5d:	39 55 0c             	cmp    %edx,0xc(%ebp)
c0024d60:	72 2b                	jb     c0024d8d <arena_to_block+0xb3>
c0024d62:	83 ec 0c             	sub    $0xc,%esp
c0024d65:	8d 90 38 80 ff ff    	lea    -0x7fc8(%eax),%edx
c0024d6b:	52                   	push   %edx
c0024d6c:	8d 90 4d 7f ff ff    	lea    -0x80b3(%eax),%edx
c0024d72:	52                   	push   %edx
c0024d73:	8d 90 7c 80 ff ff    	lea    -0x7f84(%eax),%edx
c0024d79:	52                   	push   %edx
c0024d7a:	68 22 01 00 00       	push   $0x122
c0024d7f:	8d 90 64 7f ff ff    	lea    -0x809c(%eax),%edx
c0024d85:	52                   	push   %edx
c0024d86:	89 c3                	mov    %eax,%ebx
c0024d88:	e8 d7 69 00 00       	call   c002b764 <debug_panic>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0024d8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024d90:	8b 40 04             	mov    0x4(%eax),%eax
c0024d93:	8b 00                	mov    (%eax),%eax
c0024d95:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0024d99:	8d 50 0c             	lea    0xc(%eax),%edx
  return (struct block *) ((uint8_t *) a
c0024d9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0024d9f:	01 d0                	add    %edx,%eax
}
c0024da1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024da4:	c9                   	leave  
c0024da5:	c3                   	ret    

c0024da6 <outb>:
{
c0024da6:	55                   	push   %ebp
c0024da7:	89 e5                	mov    %esp,%ebp
c0024da9:	83 ec 08             	sub    $0x8,%esp
c0024dac:	e8 77 c6 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0024db1:	05 c7 55 01 00       	add    $0x155c7,%eax
c0024db6:	8b 45 08             	mov    0x8(%ebp),%eax
c0024db9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024dbc:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0024dc0:	89 d0                	mov    %edx,%eax
c0024dc2:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024dc5:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0024dc9:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0024dcd:	ee                   	out    %al,(%dx)
}
c0024dce:	90                   	nop
c0024dcf:	c9                   	leave  
c0024dd0:	c3                   	ret    

c0024dd1 <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0024dd1:	55                   	push   %ebp
c0024dd2:	89 e5                	mov    %esp,%ebp
c0024dd4:	53                   	push   %ebx
c0024dd5:	83 ec 14             	sub    $0x14,%esp
c0024dd8:	e8 4f c6 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0024ddd:	81 c3 9b 55 01 00    	add    $0x1559b,%ebx
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0024de3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0024de7:	74 2c                	je     c0024e15 <pit_configure_channel+0x44>
c0024de9:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0024ded:	74 26                	je     c0024e15 <pit_configure_channel+0x44>
c0024def:	83 ec 0c             	sub    $0xc,%esp
c0024df2:	8d 83 8c 80 ff ff    	lea    -0x7f74(%ebx),%eax
c0024df8:	50                   	push   %eax
c0024df9:	8d 83 a9 80 ff ff    	lea    -0x7f57(%ebx),%eax
c0024dff:	50                   	push   %eax
c0024e00:	8d 83 ec 80 ff ff    	lea    -0x7f14(%ebx),%eax
c0024e06:	50                   	push   %eax
c0024e07:	6a 33                	push   $0x33
c0024e09:	8d 83 c0 80 ff ff    	lea    -0x7f40(%ebx),%eax
c0024e0f:	50                   	push   %eax
c0024e10:	e8 4f 69 00 00       	call   c002b764 <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0024e15:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c0024e19:	74 2c                	je     c0024e47 <pit_configure_channel+0x76>
c0024e1b:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0024e1f:	74 26                	je     c0024e47 <pit_configure_channel+0x76>
c0024e21:	83 ec 0c             	sub    $0xc,%esp
c0024e24:	8d 83 d4 80 ff ff    	lea    -0x7f2c(%ebx),%eax
c0024e2a:	50                   	push   %eax
c0024e2b:	8d 83 a9 80 ff ff    	lea    -0x7f57(%ebx),%eax
c0024e31:	50                   	push   %eax
c0024e32:	8d 83 ec 80 ff ff    	lea    -0x7f14(%ebx),%eax
c0024e38:	50                   	push   %eax
c0024e39:	6a 34                	push   $0x34
c0024e3b:	8d 83 c0 80 ff ff    	lea    -0x7f40(%ebx),%eax
c0024e41:	50                   	push   %eax
c0024e42:	e8 1d 69 00 00       	call   c002b764 <debug_panic>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0024e47:	83 7d 10 12          	cmpl   $0x12,0x10(%ebp)
c0024e4b:	7f 08                	jg     c0024e55 <pit_configure_channel+0x84>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0024e4d:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0024e53:	eb 2a                	jmp    c0024e7f <pit_configure_channel+0xae>
    }
  else if (frequency > PIT_HZ)
c0024e55:	81 7d 10 dc 34 12 00 	cmpl   $0x1234dc,0x10(%ebp)
c0024e5c:	7e 08                	jle    c0024e66 <pit_configure_channel+0x95>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c0024e5e:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
c0024e64:	eb 19                	jmp    c0024e7f <pit_configure_channel+0xae>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0024e66:	8b 45 10             	mov    0x10(%ebp),%eax
c0024e69:	89 c2                	mov    %eax,%edx
c0024e6b:	c1 ea 1f             	shr    $0x1f,%edx
c0024e6e:	01 d0                	add    %edx,%eax
c0024e70:	d1 f8                	sar    %eax
c0024e72:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0024e77:	99                   	cltd   
c0024e78:	f7 7d 10             	idivl  0x10(%ebp)
c0024e7b:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0024e7f:	e8 62 d0 ff ff       	call   c0021ee6 <intr_disable>
c0024e84:	89 45 f0             	mov    %eax,-0x10(%ebp)
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0024e87:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e8a:	c1 e0 06             	shl    $0x6,%eax
c0024e8d:	83 c8 30             	or     $0x30,%eax
c0024e90:	89 c2                	mov    %eax,%edx
c0024e92:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024e95:	01 c0                	add    %eax,%eax
c0024e97:	09 d0                	or     %edx,%eax
c0024e99:	0f b6 c0             	movzbl %al,%eax
c0024e9c:	83 ec 08             	sub    $0x8,%esp
c0024e9f:	50                   	push   %eax
c0024ea0:	6a 43                	push   $0x43
c0024ea2:	e8 ff fe ff ff       	call   c0024da6 <outb>
c0024ea7:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count);
c0024eaa:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0024eae:	0f b6 d0             	movzbl %al,%edx
c0024eb1:	8b 45 08             	mov    0x8(%ebp),%eax
c0024eb4:	83 c0 40             	add    $0x40,%eax
c0024eb7:	0f b7 c0             	movzwl %ax,%eax
c0024eba:	83 ec 08             	sub    $0x8,%esp
c0024ebd:	52                   	push   %edx
c0024ebe:	50                   	push   %eax
c0024ebf:	e8 e2 fe ff ff       	call   c0024da6 <outb>
c0024ec4:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0024ec7:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0024ecb:	66 c1 e8 08          	shr    $0x8,%ax
c0024ecf:	0f b6 d0             	movzbl %al,%edx
c0024ed2:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ed5:	83 c0 40             	add    $0x40,%eax
c0024ed8:	0f b7 c0             	movzwl %ax,%eax
c0024edb:	83 ec 08             	sub    $0x8,%esp
c0024ede:	52                   	push   %edx
c0024edf:	50                   	push   %eax
c0024ee0:	e8 c1 fe ff ff       	call   c0024da6 <outb>
c0024ee5:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0024ee8:	83 ec 0c             	sub    $0xc,%esp
c0024eeb:	ff 75 f0             	push   -0x10(%ebp)
c0024eee:	e8 7a cf ff ff       	call   c0021e6d <intr_set_level>
c0024ef3:	83 c4 10             	add    $0x10,%esp
}
c0024ef6:	90                   	nop
c0024ef7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024efa:	c9                   	leave  
c0024efb:	c3                   	ret    

c0024efc <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c0024efc:	55                   	push   %ebp
c0024efd:	89 e5                	mov    %esp,%ebp
c0024eff:	53                   	push   %ebx
c0024f00:	83 ec 04             	sub    $0x4,%esp
c0024f03:	e8 24 c5 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0024f08:	81 c3 70 54 01 00    	add    $0x15470,%ebx
  pit_configure_channel (0, 2, TIMER_FREQ);
c0024f0e:	83 ec 04             	sub    $0x4,%esp
c0024f11:	6a 64                	push   $0x64
c0024f13:	6a 02                	push   $0x2
c0024f15:	6a 00                	push   $0x0
c0024f17:	e8 b5 fe ff ff       	call   c0024dd1 <pit_configure_channel>
c0024f1c:	83 c4 10             	add    $0x10,%esp
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c0024f1f:	83 ec 04             	sub    $0x4,%esp
c0024f22:	8d 83 04 81 ff ff    	lea    -0x7efc(%ebx),%eax
c0024f28:	50                   	push   %eax
c0024f29:	8d 83 a7 af fe ff    	lea    -0x15059(%ebx),%eax
c0024f2f:	50                   	push   %eax
c0024f30:	6a 20                	push   $0x20
c0024f32:	e8 2f d2 ff ff       	call   c0022166 <intr_register_ext>
c0024f37:	83 c4 10             	add    $0x10,%esp
  list_init (&sleep_list);
c0024f3a:	83 ec 0c             	sub    $0xc,%esp
c0024f3d:	8d 83 10 1f 00 00    	lea    0x1f10(%ebx),%eax
c0024f43:	50                   	push   %eax
c0024f44:	e8 fb 6a 00 00       	call   c002ba44 <list_init>
c0024f49:	83 c4 10             	add    $0x10,%esp
}
c0024f4c:	90                   	nop
c0024f4d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024f50:	c9                   	leave  
c0024f51:	c3                   	ret    

c0024f52 <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c0024f52:	55                   	push   %ebp
c0024f53:	89 e5                	mov    %esp,%ebp
c0024f55:	56                   	push   %esi
c0024f56:	53                   	push   %ebx
c0024f57:	83 ec 10             	sub    $0x10,%esp
c0024f5a:	e8 cd c4 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0024f5f:	81 c3 19 54 01 00    	add    $0x15419,%ebx
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c0024f65:	e8 e3 ce ff ff       	call   c0021e4d <intr_get_level>
c0024f6a:	83 f8 01             	cmp    $0x1,%eax
c0024f6d:	74 26                	je     c0024f95 <timer_calibrate+0x43>
c0024f6f:	83 ec 0c             	sub    $0xc,%esp
c0024f72:	8d 83 0f 81 ff ff    	lea    -0x7ef1(%ebx),%eax
c0024f78:	50                   	push   %eax
c0024f79:	8d 83 2c 81 ff ff    	lea    -0x7ed4(%ebx),%eax
c0024f7f:	50                   	push   %eax
c0024f80:	8d 83 bc 81 ff ff    	lea    -0x7e44(%ebx),%eax
c0024f86:	50                   	push   %eax
c0024f87:	6a 34                	push   $0x34
c0024f89:	8d 83 43 81 ff ff    	lea    -0x7ebd(%ebx),%eax
c0024f8f:	50                   	push   %eax
c0024f90:	e8 cf 67 00 00       	call   c002b764 <debug_panic>
  printf ("Calibrating timer...  ");
c0024f95:	83 ec 0c             	sub    $0xc,%esp
c0024f98:	8d 83 59 81 ff ff    	lea    -0x7ea7(%ebx),%eax
c0024f9e:	50                   	push   %eax
c0024f9f:	e8 41 3f 00 00       	call   c0028ee5 <printf>
c0024fa4:	83 c4 10             	add    $0x10,%esp

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c0024fa7:	c7 83 28 1f 00 00 00 	movl   $0x400,0x1f28(%ebx)
c0024fae:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0024fb1:	eb 3e                	jmp    c0024ff1 <timer_calibrate+0x9f>
    {
      loops_per_tick <<= 1;
c0024fb3:	8b 83 28 1f 00 00    	mov    0x1f28(%ebx),%eax
c0024fb9:	01 c0                	add    %eax,%eax
c0024fbb:	89 83 28 1f 00 00    	mov    %eax,0x1f28(%ebx)
      ASSERT (loops_per_tick != 0);
c0024fc1:	8b 83 28 1f 00 00    	mov    0x1f28(%ebx),%eax
c0024fc7:	85 c0                	test   %eax,%eax
c0024fc9:	75 26                	jne    c0024ff1 <timer_calibrate+0x9f>
c0024fcb:	83 ec 0c             	sub    $0xc,%esp
c0024fce:	8d 83 70 81 ff ff    	lea    -0x7e90(%ebx),%eax
c0024fd4:	50                   	push   %eax
c0024fd5:	8d 83 2c 81 ff ff    	lea    -0x7ed4(%ebx),%eax
c0024fdb:	50                   	push   %eax
c0024fdc:	8d 83 bc 81 ff ff    	lea    -0x7e44(%ebx),%eax
c0024fe2:	50                   	push   %eax
c0024fe3:	6a 3d                	push   $0x3d
c0024fe5:	8d 83 43 81 ff ff    	lea    -0x7ebd(%ebx),%eax
c0024feb:	50                   	push   %eax
c0024fec:	e8 73 67 00 00       	call   c002b764 <debug_panic>
  while (!too_many_loops (loops_per_tick << 1)) 
c0024ff1:	8b 83 28 1f 00 00    	mov    0x1f28(%ebx),%eax
c0024ff7:	01 c0                	add    %eax,%eax
c0024ff9:	83 ec 0c             	sub    $0xc,%esp
c0024ffc:	50                   	push   %eax
c0024ffd:	e8 d5 03 00 00       	call   c00253d7 <too_many_loops>
c0025002:	83 c4 10             	add    $0x10,%esp
c0025005:	83 f0 01             	xor    $0x1,%eax
c0025008:	84 c0                	test   %al,%al
c002500a:	75 a7                	jne    c0024fb3 <timer_calibrate+0x61>
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
c002500c:	8b 83 28 1f 00 00    	mov    0x1f28(%ebx),%eax
c0025012:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0025015:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025018:	d1 e8                	shr    %eax
c002501a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002501d:	eb 2b                	jmp    c002504a <timer_calibrate+0xf8>
    if (!too_many_loops (high_bit | test_bit))
c002501f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025022:	0b 45 f4             	or     -0xc(%ebp),%eax
c0025025:	83 ec 0c             	sub    $0xc,%esp
c0025028:	50                   	push   %eax
c0025029:	e8 a9 03 00 00       	call   c00253d7 <too_many_loops>
c002502e:	83 c4 10             	add    $0x10,%esp
c0025031:	83 f0 01             	xor    $0x1,%eax
c0025034:	84 c0                	test   %al,%al
c0025036:	74 0f                	je     c0025047 <timer_calibrate+0xf5>
      loops_per_tick |= test_bit;
c0025038:	8b 83 28 1f 00 00    	mov    0x1f28(%ebx),%eax
c002503e:	0b 45 f4             	or     -0xc(%ebp),%eax
c0025041:	89 83 28 1f 00 00    	mov    %eax,0x1f28(%ebx)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0025047:	d1 6d f4             	shrl   -0xc(%ebp)
c002504a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002504d:	c1 e8 0a             	shr    $0xa,%eax
c0025050:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0025053:	75 ca                	jne    c002501f <timer_calibrate+0xcd>

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0025055:	8b 83 28 1f 00 00    	mov    0x1f28(%ebx),%eax
c002505b:	ba 00 00 00 00       	mov    $0x0,%edx
c0025060:	6b f2 64             	imul   $0x64,%edx,%esi
c0025063:	6b c8 00             	imul   $0x0,%eax,%ecx
c0025066:	01 f1                	add    %esi,%ecx
c0025068:	be 64 00 00 00       	mov    $0x64,%esi
c002506d:	f7 e6                	mul    %esi
c002506f:	01 d1                	add    %edx,%ecx
c0025071:	89 ca                	mov    %ecx,%edx
c0025073:	83 ec 04             	sub    $0x4,%esp
c0025076:	52                   	push   %edx
c0025077:	50                   	push   %eax
c0025078:	8d 83 84 81 ff ff    	lea    -0x7e7c(%ebx),%eax
c002507e:	50                   	push   %eax
c002507f:	e8 61 3e 00 00       	call   c0028ee5 <printf>
c0025084:	83 c4 10             	add    $0x10,%esp
}
c0025087:	90                   	nop
c0025088:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002508b:	5b                   	pop    %ebx
c002508c:	5e                   	pop    %esi
c002508d:	5d                   	pop    %ebp
c002508e:	c3                   	ret    

c002508f <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c002508f:	55                   	push   %ebp
c0025090:	89 e5                	mov    %esp,%ebp
c0025092:	53                   	push   %ebx
c0025093:	83 ec 14             	sub    $0x14,%esp
c0025096:	e8 91 c3 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002509b:	81 c3 dd 52 01 00    	add    $0x152dd,%ebx
  enum intr_level old_level = intr_disable ();
c00250a1:	e8 40 ce ff ff       	call   c0021ee6 <intr_disable>
c00250a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t t = ticks;
c00250a9:	8b 83 20 1f 00 00    	mov    0x1f20(%ebx),%eax
c00250af:	8b 93 24 1f 00 00    	mov    0x1f24(%ebx),%edx
c00250b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00250b8:	89 55 ec             	mov    %edx,-0x14(%ebp)
  intr_set_level (old_level);
c00250bb:	83 ec 0c             	sub    $0xc,%esp
c00250be:	ff 75 f4             	push   -0xc(%ebp)
c00250c1:	e8 a7 cd ff ff       	call   c0021e6d <intr_set_level>
c00250c6:	83 c4 10             	add    $0x10,%esp
  return t;
c00250c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00250cc:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
c00250cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00250d2:	c9                   	leave  
c00250d3:	c3                   	ret    

c00250d4 <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c00250d4:	55                   	push   %ebp
c00250d5:	89 e5                	mov    %esp,%ebp
c00250d7:	83 ec 18             	sub    $0x18,%esp
c00250da:	e8 49 c3 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00250df:	05 99 52 01 00       	add    $0x15299,%eax
c00250e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00250e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00250ea:	8b 45 0c             	mov    0xc(%ebp),%eax
c00250ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return timer_ticks () - then;
c00250f0:	e8 9a ff ff ff       	call   c002508f <timer_ticks>
c00250f5:	2b 45 f0             	sub    -0x10(%ebp),%eax
c00250f8:	1b 55 f4             	sbb    -0xc(%ebp),%edx
}
c00250fb:	c9                   	leave  
c00250fc:	c3                   	ret    

c00250fd <timer_sleep>:

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{
c00250fd:	55                   	push   %ebp
c00250fe:	89 e5                	mov    %esp,%ebp
c0025100:	57                   	push   %edi
c0025101:	56                   	push   %esi
c0025102:	53                   	push   %ebx
c0025103:	83 ec 2c             	sub    $0x2c,%esp
c0025106:	e8 21 c3 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002510b:	81 c3 6d 52 01 00    	add    $0x1526d,%ebx
c0025111:	8b 45 08             	mov    0x8(%ebp),%eax
c0025114:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0025117:	8b 45 0c             	mov    0xc(%ebp),%eax
c002511a:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	struct thread* curthread;
	enum intr_level curlevel;

  ASSERT (intr_get_level () == INTR_ON);
c002511d:	e8 2b cd ff ff       	call   c0021e4d <intr_get_level>
c0025122:	83 f8 01             	cmp    $0x1,%eax
c0025125:	74 26                	je     c002514d <timer_sleep+0x50>
c0025127:	83 ec 0c             	sub    $0xc,%esp
c002512a:	8d 83 0f 81 ff ff    	lea    -0x7ef1(%ebx),%eax
c0025130:	50                   	push   %eax
c0025131:	8d 83 2c 81 ff ff    	lea    -0x7ed4(%ebx),%eax
c0025137:	50                   	push   %eax
c0025138:	8d 83 cc 81 ff ff    	lea    -0x7e34(%ebx),%eax
c002513e:	50                   	push   %eax
c002513f:	6a 64                	push   $0x64
c0025141:	8d 83 43 81 ff ff    	lea    -0x7ebd(%ebx),%eax
c0025147:	50                   	push   %eax
c0025148:	e8 17 66 00 00       	call   c002b764 <debug_panic>

  curlevel = intr_disable();
c002514d:	e8 94 cd ff ff       	call   c0021ee6 <intr_disable>
c0025152:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  curthread = thread_current();
c0025155:	e8 27 c2 ff ff       	call   c0021381 <thread_current>
c002515a:	89 45 e0             	mov    %eax,-0x20(%ebp)

  curthread->waketick = timer_ticks() + ticks;
c002515d:	e8 2d ff ff ff       	call   c002508f <timer_ticks>
c0025162:	8b 75 d0             	mov    -0x30(%ebp),%esi
c0025165:	8b 7d d4             	mov    -0x2c(%ebp),%edi
c0025168:	01 f0                	add    %esi,%eax
c002516a:	11 fa                	adc    %edi,%edx
c002516c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002516f:	89 41 38             	mov    %eax,0x38(%ecx)
c0025172:	89 51 3c             	mov    %edx,0x3c(%ecx)

  list_insert_ordered (&sleep_list, &curthread->elem, cmp_waketick, NULL);
c0025175:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0025178:	83 c0 28             	add    $0x28,%eax
c002517b:	6a 00                	push   $0x0
c002517d:	c7 c2 66 1d 02 c0    	mov    $0xc0021d66,%edx
c0025183:	52                   	push   %edx
c0025184:	50                   	push   %eax
c0025185:	8d 83 10 1f 00 00    	lea    0x1f10(%ebx),%eax
c002518b:	50                   	push   %eax
c002518c:	e8 b1 75 00 00       	call   c002c742 <list_insert_ordered>
c0025191:	83 c4 10             	add    $0x10,%esp

  thread_block();
c0025194:	e8 63 c0 ff ff       	call   c00211fc <thread_block>

  intr_set_level(curlevel);
c0025199:	83 ec 0c             	sub    $0xc,%esp
c002519c:	ff 75 e4             	push   -0x1c(%ebp)
c002519f:	e8 c9 cc ff ff       	call   c0021e6d <intr_set_level>
c00251a4:	83 c4 10             	add    $0x10,%esp

}
c00251a7:	90                   	nop
c00251a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00251ab:	5b                   	pop    %ebx
c00251ac:	5e                   	pop    %esi
c00251ad:	5f                   	pop    %edi
c00251ae:	5d                   	pop    %ebp
c00251af:	c3                   	ret    

c00251b0 <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c00251b0:	55                   	push   %ebp
c00251b1:	89 e5                	mov    %esp,%ebp
c00251b3:	83 ec 18             	sub    $0x18,%esp
c00251b6:	e8 6d c2 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00251bb:	05 bd 51 01 00       	add    $0x151bd,%eax
c00251c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00251c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00251c6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00251c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ms, 1000);
c00251cc:	83 ec 04             	sub    $0x4,%esp
c00251cf:	68 e8 03 00 00       	push   $0x3e8
c00251d4:	ff 75 f4             	push   -0xc(%ebp)
c00251d7:	ff 75 f0             	push   -0x10(%ebp)
c00251da:	e8 e8 02 00 00       	call   c00254c7 <real_time_sleep>
c00251df:	83 c4 10             	add    $0x10,%esp
}
c00251e2:	90                   	nop
c00251e3:	c9                   	leave  
c00251e4:	c3                   	ret    

c00251e5 <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c00251e5:	55                   	push   %ebp
c00251e6:	89 e5                	mov    %esp,%ebp
c00251e8:	83 ec 18             	sub    $0x18,%esp
c00251eb:	e8 38 c2 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00251f0:	05 88 51 01 00       	add    $0x15188,%eax
c00251f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00251f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00251fb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00251fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (us, 1000 * 1000);
c0025201:	83 ec 04             	sub    $0x4,%esp
c0025204:	68 40 42 0f 00       	push   $0xf4240
c0025209:	ff 75 f4             	push   -0xc(%ebp)
c002520c:	ff 75 f0             	push   -0x10(%ebp)
c002520f:	e8 b3 02 00 00       	call   c00254c7 <real_time_sleep>
c0025214:	83 c4 10             	add    $0x10,%esp
}
c0025217:	90                   	nop
c0025218:	c9                   	leave  
c0025219:	c3                   	ret    

c002521a <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c002521a:	55                   	push   %ebp
c002521b:	89 e5                	mov    %esp,%ebp
c002521d:	83 ec 18             	sub    $0x18,%esp
c0025220:	e8 03 c2 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025225:	05 53 51 01 00       	add    $0x15153,%eax
c002522a:	8b 45 08             	mov    0x8(%ebp),%eax
c002522d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0025230:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025233:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0025236:	83 ec 04             	sub    $0x4,%esp
c0025239:	68 00 ca 9a 3b       	push   $0x3b9aca00
c002523e:	ff 75 f4             	push   -0xc(%ebp)
c0025241:	ff 75 f0             	push   -0x10(%ebp)
c0025244:	e8 7e 02 00 00       	call   c00254c7 <real_time_sleep>
c0025249:	83 c4 10             	add    $0x10,%esp
}
c002524c:	90                   	nop
c002524d:	c9                   	leave  
c002524e:	c3                   	ret    

c002524f <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c002524f:	55                   	push   %ebp
c0025250:	89 e5                	mov    %esp,%ebp
c0025252:	83 ec 18             	sub    $0x18,%esp
c0025255:	e8 ce c1 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002525a:	05 1e 51 01 00       	add    $0x1511e,%eax
c002525f:	8b 45 08             	mov    0x8(%ebp),%eax
c0025262:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0025265:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025268:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ms, 1000);
c002526b:	83 ec 04             	sub    $0x4,%esp
c002526e:	68 e8 03 00 00       	push   $0x3e8
c0025273:	ff 75 f4             	push   -0xc(%ebp)
c0025276:	ff 75 f0             	push   -0x10(%ebp)
c0025279:	e8 15 03 00 00       	call   c0025593 <real_time_delay>
c002527e:	83 c4 10             	add    $0x10,%esp
}
c0025281:	90                   	nop
c0025282:	c9                   	leave  
c0025283:	c3                   	ret    

c0025284 <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c0025284:	55                   	push   %ebp
c0025285:	89 e5                	mov    %esp,%ebp
c0025287:	83 ec 18             	sub    $0x18,%esp
c002528a:	e8 99 c1 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002528f:	05 e9 50 01 00       	add    $0x150e9,%eax
c0025294:	8b 45 08             	mov    0x8(%ebp),%eax
c0025297:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002529a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002529d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (us, 1000 * 1000);
c00252a0:	83 ec 04             	sub    $0x4,%esp
c00252a3:	68 40 42 0f 00       	push   $0xf4240
c00252a8:	ff 75 f4             	push   -0xc(%ebp)
c00252ab:	ff 75 f0             	push   -0x10(%ebp)
c00252ae:	e8 e0 02 00 00       	call   c0025593 <real_time_delay>
c00252b3:	83 c4 10             	add    $0x10,%esp
}
c00252b6:	90                   	nop
c00252b7:	c9                   	leave  
c00252b8:	c3                   	ret    

c00252b9 <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c00252b9:	55                   	push   %ebp
c00252ba:	89 e5                	mov    %esp,%ebp
c00252bc:	83 ec 18             	sub    $0x18,%esp
c00252bf:	e8 64 c1 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00252c4:	05 b4 50 01 00       	add    $0x150b4,%eax
c00252c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00252cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00252cf:	8b 45 0c             	mov    0xc(%ebp),%eax
c00252d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ns, 1000 * 1000 * 1000);
c00252d5:	83 ec 04             	sub    $0x4,%esp
c00252d8:	68 00 ca 9a 3b       	push   $0x3b9aca00
c00252dd:	ff 75 f4             	push   -0xc(%ebp)
c00252e0:	ff 75 f0             	push   -0x10(%ebp)
c00252e3:	e8 ab 02 00 00       	call   c0025593 <real_time_delay>
c00252e8:	83 c4 10             	add    $0x10,%esp
}
c00252eb:	90                   	nop
c00252ec:	c9                   	leave  
c00252ed:	c3                   	ret    

c00252ee <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c00252ee:	55                   	push   %ebp
c00252ef:	89 e5                	mov    %esp,%ebp
c00252f1:	53                   	push   %ebx
c00252f2:	83 ec 04             	sub    $0x4,%esp
c00252f5:	e8 32 c1 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00252fa:	81 c3 7e 50 01 00    	add    $0x1507e,%ebx
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c0025300:	e8 8a fd ff ff       	call   c002508f <timer_ticks>
c0025305:	83 ec 04             	sub    $0x4,%esp
c0025308:	52                   	push   %edx
c0025309:	50                   	push   %eax
c002530a:	8d 83 94 81 ff ff    	lea    -0x7e6c(%ebx),%eax
c0025310:	50                   	push   %eax
c0025311:	e8 cf 3b 00 00       	call   c0028ee5 <printf>
c0025316:	83 c4 10             	add    $0x10,%esp
}
c0025319:	90                   	nop
c002531a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002531d:	c9                   	leave  
c002531e:	c3                   	ret    

c002531f <timer_interrupt>:

/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
c002531f:	55                   	push   %ebp
c0025320:	89 e5                	mov    %esp,%ebp
c0025322:	57                   	push   %edi
c0025323:	56                   	push   %esi
c0025324:	53                   	push   %ebx
c0025325:	83 ec 1c             	sub    $0x1c,%esp
c0025328:	e8 ff c0 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002532d:	81 c3 4b 50 01 00    	add    $0x1504b,%ebx
	struct list_elem *head;
	struct thread *hthread;

  ticks++;
c0025333:	8b 83 20 1f 00 00    	mov    0x1f20(%ebx),%eax
c0025339:	8b 93 24 1f 00 00    	mov    0x1f24(%ebx),%edx
c002533f:	83 c0 01             	add    $0x1,%eax
c0025342:	83 d2 00             	adc    $0x0,%edx
c0025345:	89 83 20 1f 00 00    	mov    %eax,0x1f20(%ebx)
c002534b:	89 93 24 1f 00 00    	mov    %edx,0x1f24(%ebx)
  thread_tick ();
c0025351:	e8 0a ba ff ff       	call   c0020d60 <thread_tick>


	while(!list_empty(&sleep_list))
c0025356:	eb 5a                	jmp    c00253b2 <timer_interrupt+0x93>
	{
		head = list_front(&sleep_list);
c0025358:	83 ec 0c             	sub    $0xc,%esp
c002535b:	8d 83 10 1f 00 00    	lea    0x1f10(%ebx),%eax
c0025361:	50                   	push   %eax
c0025362:	e8 eb 6c 00 00       	call   c002c052 <list_front>
c0025367:	83 c4 10             	add    $0x10,%esp
c002536a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	  hthread = list_entry (head, struct thread, elem);
c002536d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0025370:	83 c0 04             	add    $0x4,%eax
c0025373:	83 e8 2c             	sub    $0x2c,%eax
c0025376:	89 45 e0             	mov    %eax,-0x20(%ebp)

	  	if(hthread->waketick > ticks )
c0025379:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002537c:	8b 70 38             	mov    0x38(%eax),%esi
c002537f:	8b 78 3c             	mov    0x3c(%eax),%edi
c0025382:	8b 83 20 1f 00 00    	mov    0x1f20(%ebx),%eax
c0025388:	8b 93 24 1f 00 00    	mov    0x1f24(%ebx),%edx
c002538e:	39 f0                	cmp    %esi,%eax
c0025390:	89 d0                	mov    %edx,%eax
c0025392:	19 f8                	sbb    %edi,%eax
c0025394:	7c 37                	jl     c00253cd <timer_interrupt+0xae>
	  		break;

	  	list_remove (head);
c0025396:	83 ec 0c             	sub    $0xc,%esp
c0025399:	ff 75 e4             	push   -0x1c(%ebp)
c002539c:	e8 d9 6b 00 00       	call   c002bf7a <list_remove>
c00253a1:	83 c4 10             	add    $0x10,%esp
	  	thread_unblock(hthread);
c00253a4:	83 ec 0c             	sub    $0xc,%esp
c00253a7:	ff 75 e0             	push   -0x20(%ebp)
c00253aa:	e8 dd be ff ff       	call   c002128c <thread_unblock>
c00253af:	83 c4 10             	add    $0x10,%esp
	while(!list_empty(&sleep_list))
c00253b2:	83 ec 0c             	sub    $0xc,%esp
c00253b5:	8d 83 10 1f 00 00    	lea    0x1f10(%ebx),%eax
c00253bb:	50                   	push   %eax
c00253bc:	e8 9e 6d 00 00       	call   c002c15f <list_empty>
c00253c1:	83 c4 10             	add    $0x10,%esp
c00253c4:	83 f0 01             	xor    $0x1,%eax
c00253c7:	84 c0                	test   %al,%al
c00253c9:	75 8d                	jne    c0025358 <timer_interrupt+0x39>
	}
}
c00253cb:	eb 01                	jmp    c00253ce <timer_interrupt+0xaf>
	  		break;
c00253cd:	90                   	nop
}
c00253ce:	90                   	nop
c00253cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00253d2:	5b                   	pop    %ebx
c00253d3:	5e                   	pop    %esi
c00253d4:	5f                   	pop    %edi
c00253d5:	5d                   	pop    %ebp
c00253d6:	c3                   	ret    

c00253d7 <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c00253d7:	55                   	push   %ebp
c00253d8:	89 e5                	mov    %esp,%ebp
c00253da:	57                   	push   %edi
c00253db:	56                   	push   %esi
c00253dc:	53                   	push   %ebx
c00253dd:	83 ec 2c             	sub    $0x2c,%esp
c00253e0:	e8 47 c0 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00253e5:	81 c3 93 4f 01 00    	add    $0x14f93,%ebx
  /* Wait for a timer tick. */
  int64_t start = ticks;
c00253eb:	8b 83 20 1f 00 00    	mov    0x1f20(%ebx),%eax
c00253f1:	8b 93 24 1f 00 00    	mov    0x1f24(%ebx),%edx
c00253f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00253fa:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  while (ticks == start)
c00253fd:	eb 00                	jmp    c00253ff <too_many_loops+0x28>
c00253ff:	8b 83 20 1f 00 00    	mov    0x1f20(%ebx),%eax
c0025405:	8b 93 24 1f 00 00    	mov    0x1f24(%ebx),%edx
c002540b:	89 c1                	mov    %eax,%ecx
c002540d:	33 4d e0             	xor    -0x20(%ebp),%ecx
c0025410:	89 4d d0             	mov    %ecx,-0x30(%ebp)
c0025413:	89 d0                	mov    %edx,%eax
c0025415:	33 45 e4             	xor    -0x1c(%ebp),%eax
c0025418:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c002541b:	8b 55 d0             	mov    -0x30(%ebp),%edx
c002541e:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c0025421:	89 c8                	mov    %ecx,%eax
c0025423:	09 d0                	or     %edx,%eax
c0025425:	85 c0                	test   %eax,%eax
c0025427:	74 d6                	je     c00253ff <too_many_loops+0x28>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
c0025429:	8b 83 20 1f 00 00    	mov    0x1f20(%ebx),%eax
c002542f:	8b 93 24 1f 00 00    	mov    0x1f24(%ebx),%edx
c0025435:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0025438:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  busy_wait (loops);
c002543b:	8b 45 08             	mov    0x8(%ebp),%eax
c002543e:	ba 00 00 00 00       	mov    $0x0,%edx
c0025443:	83 ec 08             	sub    $0x8,%esp
c0025446:	52                   	push   %edx
c0025447:	50                   	push   %eax
c0025448:	e8 2e 00 00 00       	call   c002547b <busy_wait>
c002544d:	83 c4 10             	add    $0x10,%esp

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c0025450:	8b 83 20 1f 00 00    	mov    0x1f20(%ebx),%eax
c0025456:	8b 93 24 1f 00 00    	mov    0x1f24(%ebx),%edx
c002545c:	89 c3                	mov    %eax,%ebx
c002545e:	33 5d e0             	xor    -0x20(%ebp),%ebx
c0025461:	89 de                	mov    %ebx,%esi
c0025463:	89 d0                	mov    %edx,%eax
c0025465:	33 45 e4             	xor    -0x1c(%ebp),%eax
c0025468:	89 c7                	mov    %eax,%edi
c002546a:	89 f0                	mov    %esi,%eax
c002546c:	09 f8                	or     %edi,%eax
c002546e:	85 c0                	test   %eax,%eax
c0025470:	0f 95 c0             	setne  %al
}
c0025473:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0025476:	5b                   	pop    %ebx
c0025477:	5e                   	pop    %esi
c0025478:	5f                   	pop    %edi
c0025479:	5d                   	pop    %ebp
c002547a:	c3                   	ret    

c002547b <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c002547b:	55                   	push   %ebp
c002547c:	89 e5                	mov    %esp,%ebp
c002547e:	53                   	push   %ebx
c002547f:	83 ec 0c             	sub    $0xc,%esp
c0025482:	e8 a1 bf 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025487:	05 f1 4e 01 00       	add    $0x14ef1,%eax
c002548c:	8b 45 08             	mov    0x8(%ebp),%eax
c002548f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0025492:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025495:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (loops-- > 0)
c0025498:	eb 00                	jmp    c002549a <busy_wait+0x1f>
c002549a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002549d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00254a0:	89 c1                	mov    %eax,%ecx
c00254a2:	89 d3                	mov    %edx,%ebx
c00254a4:	83 c1 ff             	add    $0xffffffff,%ecx
c00254a7:	83 d3 ff             	adc    $0xffffffff,%ebx
c00254aa:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c00254ad:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c00254b0:	bb 00 00 00 00       	mov    $0x0,%ebx
c00254b5:	b9 00 00 00 00       	mov    $0x0,%ecx
c00254ba:	39 c3                	cmp    %eax,%ebx
c00254bc:	19 d1                	sbb    %edx,%ecx
c00254be:	7c da                	jl     c002549a <busy_wait+0x1f>
    barrier ();
}
c00254c0:	90                   	nop
c00254c1:	90                   	nop
c00254c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00254c5:	c9                   	leave  
c00254c6:	c3                   	ret    

c00254c7 <real_time_sleep>:

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c00254c7:	55                   	push   %ebp
c00254c8:	89 e5                	mov    %esp,%ebp
c00254ca:	57                   	push   %edi
c00254cb:	56                   	push   %esi
c00254cc:	53                   	push   %ebx
c00254cd:	83 ec 2c             	sub    $0x2c,%esp
c00254d0:	e8 57 bf 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00254d5:	81 c3 a3 4e 01 00    	add    $0x14ea3,%ebx
c00254db:	8b 45 08             	mov    0x8(%ebp),%eax
c00254de:	89 45 d0             	mov    %eax,-0x30(%ebp)
c00254e1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00254e4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c00254e7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00254ea:	6b d0 64             	imul   $0x64,%eax,%edx
c00254ed:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00254f0:	6b c0 00             	imul   $0x0,%eax,%eax
c00254f3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c00254f6:	b8 64 00 00 00       	mov    $0x64,%eax
c00254fb:	f7 65 d0             	mull   -0x30(%ebp)
c00254fe:	01 d1                	add    %edx,%ecx
c0025500:	89 ca                	mov    %ecx,%edx
c0025502:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0025505:	89 ce                	mov    %ecx,%esi
c0025507:	89 cf                	mov    %ecx,%edi
c0025509:	c1 ff 1f             	sar    $0x1f,%edi
c002550c:	57                   	push   %edi
c002550d:	56                   	push   %esi
c002550e:	52                   	push   %edx
c002550f:	50                   	push   %eax
c0025510:	e8 89 5b 00 00       	call   c002b09e <__divdi3>
c0025515:	83 c4 10             	add    $0x10,%esp
c0025518:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002551b:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c002551e:	e8 2a c9 ff ff       	call   c0021e4d <intr_get_level>
c0025523:	83 f8 01             	cmp    $0x1,%eax
c0025526:	74 29                	je     c0025551 <real_time_sleep+0x8a>
c0025528:	83 ec 0c             	sub    $0xc,%esp
c002552b:	8d 83 0f 81 ff ff    	lea    -0x7ef1(%ebx),%eax
c0025531:	50                   	push   %eax
c0025532:	8d 83 2c 81 ff ff    	lea    -0x7ed4(%ebx),%eax
c0025538:	50                   	push   %eax
c0025539:	8d 83 d8 81 ff ff    	lea    -0x7e28(%ebx),%eax
c002553f:	50                   	push   %eax
c0025540:	68 ff 00 00 00       	push   $0xff
c0025545:	8d 83 43 81 ff ff    	lea    -0x7ebd(%ebx),%eax
c002554b:	50                   	push   %eax
c002554c:	e8 13 62 00 00       	call   c002b764 <debug_panic>
  if (ticks > 0)
c0025551:	ba 00 00 00 00       	mov    $0x0,%edx
c0025556:	b8 00 00 00 00       	mov    $0x0,%eax
c002555b:	3b 55 e0             	cmp    -0x20(%ebp),%edx
c002555e:	1b 45 e4             	sbb    -0x1c(%ebp),%eax
c0025561:	7d 13                	jge    c0025576 <real_time_sleep+0xaf>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c0025563:	83 ec 08             	sub    $0x8,%esp
c0025566:	ff 75 e4             	push   -0x1c(%ebp)
c0025569:	ff 75 e0             	push   -0x20(%ebp)
c002556c:	e8 8c fb ff ff       	call   c00250fd <timer_sleep>
c0025571:	83 c4 10             	add    $0x10,%esp
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
    }
}
c0025574:	eb 14                	jmp    c002558a <real_time_sleep+0xc3>
      real_time_delay (num, denom); 
c0025576:	83 ec 04             	sub    $0x4,%esp
c0025579:	ff 75 10             	push   0x10(%ebp)
c002557c:	ff 75 d4             	push   -0x2c(%ebp)
c002557f:	ff 75 d0             	push   -0x30(%ebp)
c0025582:	e8 0c 00 00 00       	call   c0025593 <real_time_delay>
c0025587:	83 c4 10             	add    $0x10,%esp
}
c002558a:	90                   	nop
c002558b:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002558e:	5b                   	pop    %ebx
c002558f:	5e                   	pop    %esi
c0025590:	5f                   	pop    %edi
c0025591:	5d                   	pop    %ebp
c0025592:	c3                   	ret    

c0025593 <real_time_delay>:

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0025593:	55                   	push   %ebp
c0025594:	89 e5                	mov    %esp,%ebp
c0025596:	57                   	push   %edi
c0025597:	56                   	push   %esi
c0025598:	53                   	push   %ebx
c0025599:	83 ec 1c             	sub    $0x1c,%esp
c002559c:	e8 8b be 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00255a1:	81 c3 d7 4d 01 00    	add    $0x14dd7,%ebx
c00255a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00255aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00255ad:	8b 45 0c             	mov    0xc(%ebp),%eax
c00255b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c00255b3:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00255b6:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00255bb:	89 c8                	mov    %ecx,%eax
c00255bd:	f7 ea                	imul   %edx
c00255bf:	89 d0                	mov    %edx,%eax
c00255c1:	c1 f8 06             	sar    $0x6,%eax
c00255c4:	89 ca                	mov    %ecx,%edx
c00255c6:	c1 fa 1f             	sar    $0x1f,%edx
c00255c9:	29 d0                	sub    %edx,%eax
c00255cb:	69 d0 e8 03 00 00    	imul   $0x3e8,%eax,%edx
c00255d1:	89 c8                	mov    %ecx,%eax
c00255d3:	29 d0                	sub    %edx,%eax
c00255d5:	85 c0                	test   %eax,%eax
c00255d7:	74 29                	je     c0025602 <real_time_delay+0x6f>
c00255d9:	83 ec 0c             	sub    $0xc,%esp
c00255dc:	8d 83 a7 81 ff ff    	lea    -0x7e59(%ebx),%eax
c00255e2:	50                   	push   %eax
c00255e3:	8d 83 2c 81 ff ff    	lea    -0x7ed4(%ebx),%eax
c00255e9:	50                   	push   %eax
c00255ea:	8d 83 e8 81 ff ff    	lea    -0x7e18(%ebx),%eax
c00255f0:	50                   	push   %eax
c00255f1:	68 15 01 00 00       	push   $0x115
c00255f6:	8d 83 43 81 ff ff    	lea    -0x7ebd(%ebx),%eax
c00255fc:	50                   	push   %eax
c00255fd:	e8 62 61 00 00       	call   c002b764 <debug_panic>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c0025602:	8b 83 28 1f 00 00    	mov    0x1f28(%ebx),%eax
c0025608:	ba 00 00 00 00       	mov    $0x0,%edx
c002560d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0025610:	89 ce                	mov    %ecx,%esi
c0025612:	0f af f2             	imul   %edx,%esi
c0025615:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0025618:	0f af c8             	imul   %eax,%ecx
c002561b:	01 f1                	add    %esi,%ecx
c002561d:	f7 65 e0             	mull   -0x20(%ebp)
c0025620:	01 d1                	add    %edx,%ecx
c0025622:	89 ca                	mov    %ecx,%edx
c0025624:	6a 00                	push   $0x0
c0025626:	68 e8 03 00 00       	push   $0x3e8
c002562b:	52                   	push   %edx
c002562c:	50                   	push   %eax
c002562d:	e8 6c 5a 00 00       	call   c002b09e <__divdi3>
c0025632:	83 c4 10             	add    $0x10,%esp
c0025635:	6b f2 64             	imul   $0x64,%edx,%esi
c0025638:	6b c8 00             	imul   $0x0,%eax,%ecx
c002563b:	01 f1                	add    %esi,%ecx
c002563d:	be 64 00 00 00       	mov    $0x64,%esi
c0025642:	f7 e6                	mul    %esi
c0025644:	89 c6                	mov    %eax,%esi
c0025646:	89 d7                	mov    %edx,%edi
c0025648:	8d 04 39             	lea    (%ecx,%edi,1),%eax
c002564b:	89 c7                	mov    %eax,%edi
c002564d:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0025650:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c0025655:	89 c8                	mov    %ecx,%eax
c0025657:	f7 ea                	imul   %edx
c0025659:	89 d0                	mov    %edx,%eax
c002565b:	c1 f8 06             	sar    $0x6,%eax
c002565e:	c1 f9 1f             	sar    $0x1f,%ecx
c0025661:	89 ca                	mov    %ecx,%edx
c0025663:	29 d0                	sub    %edx,%eax
c0025665:	99                   	cltd   
c0025666:	52                   	push   %edx
c0025667:	50                   	push   %eax
c0025668:	57                   	push   %edi
c0025669:	56                   	push   %esi
c002566a:	e8 2f 5a 00 00       	call   c002b09e <__divdi3>
c002566f:	83 c4 10             	add    $0x10,%esp
c0025672:	83 ec 08             	sub    $0x8,%esp
c0025675:	52                   	push   %edx
c0025676:	50                   	push   %eax
c0025677:	e8 ff fd ff ff       	call   c002547b <busy_wait>
c002567c:	83 c4 10             	add    $0x10,%esp
c002567f:	90                   	nop
c0025680:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0025683:	5b                   	pop    %ebx
c0025684:	5e                   	pop    %esi
c0025685:	5f                   	pop    %edi
c0025686:	5d                   	pop    %ebp
c0025687:	c3                   	ret    

c0025688 <isupper>:
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c0025688:	55                   	push   %ebp
c0025689:	89 e5                	mov    %esp,%ebp
c002568b:	e8 98 bd 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025690:	05 e8 4c 01 00       	add    $0x14ce8,%eax
c0025695:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0025699:	7e 0d                	jle    c00256a8 <isupper+0x20>
c002569b:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c002569f:	7f 07                	jg     c00256a8 <isupper+0x20>
c00256a1:	b8 01 00 00 00       	mov    $0x1,%eax
c00256a6:	eb 05                	jmp    c00256ad <isupper+0x25>
c00256a8:	b8 00 00 00 00       	mov    $0x0,%eax
c00256ad:	5d                   	pop    %ebp
c00256ae:	c3                   	ret    

c00256af <tolower>:
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c00256af:	55                   	push   %ebp
c00256b0:	89 e5                	mov    %esp,%ebp
c00256b2:	e8 71 bd 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00256b7:	05 c1 4c 01 00       	add    $0x14cc1,%eax
c00256bc:	ff 75 08             	push   0x8(%ebp)
c00256bf:	e8 c4 ff ff ff       	call   c0025688 <isupper>
c00256c4:	83 c4 04             	add    $0x4,%esp
c00256c7:	85 c0                	test   %eax,%eax
c00256c9:	74 08                	je     c00256d3 <tolower+0x24>
c00256cb:	8b 45 08             	mov    0x8(%ebp),%eax
c00256ce:	83 c0 20             	add    $0x20,%eax
c00256d1:	eb 03                	jmp    c00256d6 <tolower+0x27>
c00256d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00256d6:	c9                   	leave  
c00256d7:	c3                   	ret    

c00256d8 <inb>:
{
c00256d8:	55                   	push   %ebp
c00256d9:	89 e5                	mov    %esp,%ebp
c00256db:	83 ec 14             	sub    $0x14,%esp
c00256de:	e8 45 bd 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00256e3:	05 95 4c 01 00       	add    $0x14c95,%eax
c00256e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00256eb:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00256ef:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00256f3:	89 c2                	mov    %eax,%edx
c00256f5:	ec                   	in     (%dx),%al
c00256f6:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00256f9:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c00256fd:	c9                   	leave  
c00256fe:	c3                   	ret    

c00256ff <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c00256ff:	55                   	push   %ebp
c0025700:	89 e5                	mov    %esp,%ebp
c0025702:	53                   	push   %ebx
c0025703:	83 ec 04             	sub    $0x4,%esp
c0025706:	e8 1d bd 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002570b:	05 6d 4c 01 00       	add    $0x14c6d,%eax
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c0025710:	83 ec 04             	sub    $0x4,%esp
c0025713:	8d 90 f8 81 ff ff    	lea    -0x7e08(%eax),%edx
c0025719:	52                   	push   %edx
c002571a:	8d 90 f5 b3 fe ff    	lea    -0x14c0b(%eax),%edx
c0025720:	52                   	push   %edx
c0025721:	6a 21                	push   $0x21
c0025723:	89 c3                	mov    %eax,%ebx
c0025725:	e8 3c ca ff ff       	call   c0022166 <intr_register_ext>
c002572a:	83 c4 10             	add    $0x10,%esp
}
c002572d:	90                   	nop
c002572e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025731:	c9                   	leave  
c0025732:	c3                   	ret    

c0025733 <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c0025733:	55                   	push   %ebp
c0025734:	89 e5                	mov    %esp,%ebp
c0025736:	53                   	push   %ebx
c0025737:	83 ec 04             	sub    $0x4,%esp
c002573a:	e8 f5 bc 00 00       	call   c0031434 <__x86.get_pc_thunk.cx>
c002573f:	81 c1 39 4c 01 00    	add    $0x14c39,%ecx
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c0025745:	8b 81 38 1f 00 00    	mov    0x1f38(%ecx),%eax
c002574b:	8b 91 3c 1f 00 00    	mov    0x1f3c(%ecx),%edx
c0025751:	83 ec 04             	sub    $0x4,%esp
c0025754:	52                   	push   %edx
c0025755:	50                   	push   %eax
c0025756:	8d 81 06 82 ff ff    	lea    -0x7dfa(%ecx),%eax
c002575c:	50                   	push   %eax
c002575d:	89 cb                	mov    %ecx,%ebx
c002575f:	e8 81 37 00 00       	call   c0028ee5 <printf>
c0025764:	83 c4 10             	add    $0x10,%esp
}
c0025767:	90                   	nop
c0025768:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002576b:	c9                   	leave  
c002576c:	c3                   	ret    

c002576d <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c002576d:	55                   	push   %ebp
c002576e:	89 e5                	mov    %esp,%ebp
c0025770:	56                   	push   %esi
c0025771:	53                   	push   %ebx
c0025772:	83 ec 10             	sub    $0x10,%esp
c0025775:	e8 b2 bc 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002577a:	81 c3 fe 4b 01 00    	add    $0x14bfe,%ebx
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c0025780:	0f b6 83 30 1f 00 00 	movzbl 0x1f30(%ebx),%eax
c0025787:	84 c0                	test   %al,%al
c0025789:	75 0b                	jne    c0025796 <keyboard_interrupt+0x29>
c002578b:	0f b6 83 31 1f 00 00 	movzbl 0x1f31(%ebx),%eax
c0025792:	84 c0                	test   %al,%al
c0025794:	74 07                	je     c002579d <keyboard_interrupt+0x30>
c0025796:	b8 01 00 00 00       	mov    $0x1,%eax
c002579b:	eb 05                	jmp    c00257a2 <keyboard_interrupt+0x35>
c002579d:	b8 00 00 00 00       	mov    $0x0,%eax
c00257a2:	88 45 ef             	mov    %al,-0x11(%ebp)
c00257a5:	80 65 ef 01          	andb   $0x1,-0x11(%ebp)
  bool alt = left_alt || right_alt;
c00257a9:	0f b6 83 32 1f 00 00 	movzbl 0x1f32(%ebx),%eax
c00257b0:	84 c0                	test   %al,%al
c00257b2:	75 0b                	jne    c00257bf <keyboard_interrupt+0x52>
c00257b4:	0f b6 83 33 1f 00 00 	movzbl 0x1f33(%ebx),%eax
c00257bb:	84 c0                	test   %al,%al
c00257bd:	74 07                	je     c00257c6 <keyboard_interrupt+0x59>
c00257bf:	b8 01 00 00 00       	mov    $0x1,%eax
c00257c4:	eb 05                	jmp    c00257cb <keyboard_interrupt+0x5e>
c00257c6:	b8 00 00 00 00       	mov    $0x0,%eax
c00257cb:	88 45 ee             	mov    %al,-0x12(%ebp)
c00257ce:	80 65 ee 01          	andb   $0x1,-0x12(%ebp)
  bool ctrl = left_ctrl || right_ctrl;
c00257d2:	0f b6 83 34 1f 00 00 	movzbl 0x1f34(%ebx),%eax
c00257d9:	84 c0                	test   %al,%al
c00257db:	75 0b                	jne    c00257e8 <keyboard_interrupt+0x7b>
c00257dd:	0f b6 83 35 1f 00 00 	movzbl 0x1f35(%ebx),%eax
c00257e4:	84 c0                	test   %al,%al
c00257e6:	74 07                	je     c00257ef <keyboard_interrupt+0x82>
c00257e8:	b8 01 00 00 00       	mov    $0x1,%eax
c00257ed:	eb 05                	jmp    c00257f4 <keyboard_interrupt+0x87>
c00257ef:	b8 00 00 00 00       	mov    $0x0,%eax
c00257f4:	88 45 ed             	mov    %al,-0x13(%ebp)
c00257f7:	80 65 ed 01          	andb   $0x1,-0x13(%ebp)

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c00257fb:	6a 60                	push   $0x60
c00257fd:	e8 d6 fe ff ff       	call   c00256d8 <inb>
c0025802:	83 c4 04             	add    $0x4,%esp
c0025805:	0f b6 c0             	movzbl %al,%eax
c0025808:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (code == 0xe0)
c002580b:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
c0025812:	75 1a                	jne    c002582e <keyboard_interrupt+0xc1>
    code = (code << 8) | inb (DATA_REG);
c0025814:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025817:	c1 e0 08             	shl    $0x8,%eax
c002581a:	89 c6                	mov    %eax,%esi
c002581c:	6a 60                	push   $0x60
c002581e:	e8 b5 fe ff ff       	call   c00256d8 <inb>
c0025823:	83 c4 04             	add    $0x4,%esp
c0025826:	0f b6 c0             	movzbl %al,%eax
c0025829:	09 f0                	or     %esi,%eax
c002582b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c002582e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025831:	25 80 00 00 00       	and    $0x80,%eax
c0025836:	85 c0                	test   %eax,%eax
c0025838:	0f 95 c0             	setne  %al
c002583b:	88 45 ec             	mov    %al,-0x14(%ebp)
  code &= ~0x80u;
c002583e:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)

  /* Interpret key. */
  if (code == 0x3a) 
c0025845:	83 7d f4 3a          	cmpl   $0x3a,-0xc(%ebp)
c0025849:	75 32                	jne    c002587d <keyboard_interrupt+0x110>
    {
      /* Caps Lock. */
      if (!release)
c002584b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c002584f:	83 f0 01             	xor    $0x1,%eax
c0025852:	84 c0                	test   %al,%al
c0025854:	0f 84 91 01 00 00    	je     c00259eb <keyboard_interrupt+0x27e>
        caps_lock = !caps_lock;
c002585a:	0f b6 83 36 1f 00 00 	movzbl 0x1f36(%ebx),%eax
c0025861:	0f b6 c0             	movzbl %al,%eax
c0025864:	85 c0                	test   %eax,%eax
c0025866:	0f 95 c0             	setne  %al
c0025869:	83 f0 01             	xor    $0x1,%eax
c002586c:	0f b6 c0             	movzbl %al,%eax
c002586f:	83 e0 01             	and    $0x1,%eax
c0025872:	88 83 36 1f 00 00    	mov    %al,0x1f36(%ebx)
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0025878:	e9 6e 01 00 00       	jmp    c00259eb <keyboard_interrupt+0x27e>
  else if (map_key (invariant_keymap, code, &c)
c002587d:	83 ec 04             	sub    $0x4,%esp
c0025880:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0025883:	50                   	push   %eax
c0025884:	ff 75 f4             	push   -0xc(%ebp)
c0025887:	8d 83 68 00 00 00    	lea    0x68(%ebx),%eax
c002588d:	50                   	push   %eax
c002588e:	e8 60 01 00 00       	call   c00259f3 <map_key>
c0025893:	83 c4 10             	add    $0x10,%esp
c0025896:	84 c0                	test   %al,%al
c0025898:	75 53                	jne    c00258ed <keyboard_interrupt+0x180>
           || (!shift && map_key (unshifted_keymap, code, &c))
c002589a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c002589e:	83 f0 01             	xor    $0x1,%eax
c00258a1:	84 c0                	test   %al,%al
c00258a3:	74 1d                	je     c00258c2 <keyboard_interrupt+0x155>
c00258a5:	83 ec 04             	sub    $0x4,%esp
c00258a8:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00258ab:	50                   	push   %eax
c00258ac:	ff 75 f4             	push   -0xc(%ebp)
c00258af:	8d 83 c8 00 00 00    	lea    0xc8(%ebx),%eax
c00258b5:	50                   	push   %eax
c00258b6:	e8 38 01 00 00       	call   c00259f3 <map_key>
c00258bb:	83 c4 10             	add    $0x10,%esp
c00258be:	84 c0                	test   %al,%al
c00258c0:	75 2b                	jne    c00258ed <keyboard_interrupt+0x180>
           || (shift && map_key (shifted_keymap, code, &c)))
c00258c2:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c00258c6:	0f 84 dc 00 00 00    	je     c00259a8 <keyboard_interrupt+0x23b>
c00258cc:	83 ec 04             	sub    $0x4,%esp
c00258cf:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00258d2:	50                   	push   %eax
c00258d3:	ff 75 f4             	push   -0xc(%ebp)
c00258d6:	8d 83 08 01 00 00    	lea    0x108(%ebx),%eax
c00258dc:	50                   	push   %eax
c00258dd:	e8 11 01 00 00       	call   c00259f3 <map_key>
c00258e2:	83 c4 10             	add    $0x10,%esp
c00258e5:	84 c0                	test   %al,%al
c00258e7:	0f 84 bb 00 00 00    	je     c00259a8 <keyboard_interrupt+0x23b>
      if (!release) 
c00258ed:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00258f1:	83 f0 01             	xor    $0x1,%eax
c00258f4:	84 c0                	test   %al,%al
c00258f6:	0f 84 ee 00 00 00    	je     c00259ea <keyboard_interrupt+0x27d>
          if (c == 0177 && ctrl && alt)
c00258fc:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0025900:	3c 7f                	cmp    $0x7f,%al
c0025902:	75 11                	jne    c0025915 <keyboard_interrupt+0x1a8>
c0025904:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0025908:	74 0b                	je     c0025915 <keyboard_interrupt+0x1a8>
c002590a:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c002590e:	74 05                	je     c0025915 <keyboard_interrupt+0x1a8>
            shutdown_reboot ();
c0025910:	e8 23 2f 00 00       	call   c0028838 <shutdown_reboot>
          if (ctrl && c >= 0x40 && c < 0x60) 
c0025915:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0025919:	74 1c                	je     c0025937 <keyboard_interrupt+0x1ca>
c002591b:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002591f:	3c 3f                	cmp    $0x3f,%al
c0025921:	76 14                	jbe    c0025937 <keyboard_interrupt+0x1ca>
c0025923:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0025927:	3c 5f                	cmp    $0x5f,%al
c0025929:	77 0c                	ja     c0025937 <keyboard_interrupt+0x1ca>
              c -= 0x40; 
c002592b:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002592f:	83 e8 40             	sub    $0x40,%eax
c0025932:	88 45 eb             	mov    %al,-0x15(%ebp)
c0025935:	eb 22                	jmp    c0025959 <keyboard_interrupt+0x1ec>
          else if (shift == caps_lock)
c0025937:	0f b6 83 36 1f 00 00 	movzbl 0x1f36(%ebx),%eax
c002593e:	38 45 ef             	cmp    %al,-0x11(%ebp)
c0025941:	75 16                	jne    c0025959 <keyboard_interrupt+0x1ec>
            c = tolower (c);
c0025943:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0025947:	0f b6 c0             	movzbl %al,%eax
c002594a:	83 ec 0c             	sub    $0xc,%esp
c002594d:	50                   	push   %eax
c002594e:	e8 5c fd ff ff       	call   c00256af <tolower>
c0025953:	83 c4 10             	add    $0x10,%esp
c0025956:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (alt)
c0025959:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c002595d:	74 0a                	je     c0025969 <keyboard_interrupt+0x1fc>
            c += 0x80;
c002595f:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0025963:	83 c0 80             	add    $0xffffff80,%eax
c0025966:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (!input_full ())
c0025969:	e8 64 26 00 00       	call   c0027fd2 <input_full>
c002596e:	83 f0 01             	xor    $0x1,%eax
c0025971:	84 c0                	test   %al,%al
c0025973:	74 75                	je     c00259ea <keyboard_interrupt+0x27d>
              key_cnt++;
c0025975:	8b 83 38 1f 00 00    	mov    0x1f38(%ebx),%eax
c002597b:	8b 93 3c 1f 00 00    	mov    0x1f3c(%ebx),%edx
c0025981:	83 c0 01             	add    $0x1,%eax
c0025984:	83 d2 00             	adc    $0x0,%edx
c0025987:	89 83 38 1f 00 00    	mov    %eax,0x1f38(%ebx)
c002598d:	89 93 3c 1f 00 00    	mov    %edx,0x1f3c(%ebx)
              input_putc (c);
c0025993:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0025997:	0f b6 c0             	movzbl %al,%eax
c002599a:	83 ec 0c             	sub    $0xc,%esp
c002599d:	50                   	push   %eax
c002599e:	e8 3c 25 00 00       	call   c0027edf <input_putc>
c00259a3:	83 c4 10             	add    $0x10,%esp
      if (!release) 
c00259a6:	eb 42                	jmp    c00259ea <keyboard_interrupt+0x27d>
      for (key = shift_keys; key->scancode != 0; key++) 
c00259a8:	8d 83 48 01 00 00    	lea    0x148(%ebx),%eax
c00259ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00259b1:	eb 2c                	jmp    c00259df <keyboard_interrupt+0x272>
        if (key->scancode == code)
c00259b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00259b6:	8b 00                	mov    (%eax),%eax
c00259b8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00259bb:	75 1e                	jne    c00259db <keyboard_interrupt+0x26e>
            *key->state_var = !release;
c00259bd:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00259c1:	85 c0                	test   %eax,%eax
c00259c3:	0f 95 c0             	setne  %al
c00259c6:	83 f0 01             	xor    $0x1,%eax
c00259c9:	0f b6 c8             	movzbl %al,%ecx
c00259cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00259cf:	8b 50 04             	mov    0x4(%eax),%edx
c00259d2:	89 c8                	mov    %ecx,%eax
c00259d4:	83 e0 01             	and    $0x1,%eax
c00259d7:	88 02                	mov    %al,(%edx)
            break;
c00259d9:	eb 10                	jmp    c00259eb <keyboard_interrupt+0x27e>
      for (key = shift_keys; key->scancode != 0; key++) 
c00259db:	83 45 f0 08          	addl   $0x8,-0x10(%ebp)
c00259df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00259e2:	8b 00                	mov    (%eax),%eax
c00259e4:	85 c0                	test   %eax,%eax
c00259e6:	75 cb                	jne    c00259b3 <keyboard_interrupt+0x246>
}
c00259e8:	eb 01                	jmp    c00259eb <keyboard_interrupt+0x27e>
      if (!release) 
c00259ea:	90                   	nop
}
c00259eb:	90                   	nop
c00259ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00259ef:	5b                   	pop    %ebx
c00259f0:	5e                   	pop    %esi
c00259f1:	5d                   	pop    %ebp
c00259f2:	c3                   	ret    

c00259f3 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c00259f3:	55                   	push   %ebp
c00259f4:	89 e5                	mov    %esp,%ebp
c00259f6:	56                   	push   %esi
c00259f7:	53                   	push   %ebx
c00259f8:	e8 2f ba 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00259fd:	81 c3 7b 49 01 00    	add    $0x1497b,%ebx
  for (; k->first_scancode != 0; k++)
c0025a03:	eb 5b                	jmp    c0025a60 <map_key+0x6d>
    if (scancode >= k->first_scancode
c0025a05:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a08:	0f b6 00             	movzbl (%eax),%eax
c0025a0b:	0f b6 c0             	movzbl %al,%eax
c0025a0e:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0025a11:	72 49                	jb     c0025a5c <map_key+0x69>
        && scancode < k->first_scancode + strlen (k->chars)) 
c0025a13:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a16:	0f b6 00             	movzbl (%eax),%eax
c0025a19:	0f b6 f0             	movzbl %al,%esi
c0025a1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a1f:	8b 40 04             	mov    0x4(%eax),%eax
c0025a22:	83 ec 0c             	sub    $0xc,%esp
c0025a25:	50                   	push   %eax
c0025a26:	e8 3a 50 00 00       	call   c002aa65 <strlen>
c0025a2b:	83 c4 10             	add    $0x10,%esp
c0025a2e:	01 f0                	add    %esi,%eax
c0025a30:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0025a33:	73 27                	jae    c0025a5c <map_key+0x69>
      {
        *c = k->chars[scancode - k->first_scancode];
c0025a35:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a38:	8b 50 04             	mov    0x4(%eax),%edx
c0025a3b:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a3e:	0f b6 00             	movzbl (%eax),%eax
c0025a41:	0f b6 c8             	movzbl %al,%ecx
c0025a44:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025a47:	29 c8                	sub    %ecx,%eax
c0025a49:	01 d0                	add    %edx,%eax
c0025a4b:	0f b6 00             	movzbl (%eax),%eax
c0025a4e:	89 c2                	mov    %eax,%edx
c0025a50:	8b 45 10             	mov    0x10(%ebp),%eax
c0025a53:	88 10                	mov    %dl,(%eax)
        return true; 
c0025a55:	b8 01 00 00 00       	mov    $0x1,%eax
c0025a5a:	eb 13                	jmp    c0025a6f <map_key+0x7c>
  for (; k->first_scancode != 0; k++)
c0025a5c:	83 45 08 08          	addl   $0x8,0x8(%ebp)
c0025a60:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a63:	0f b6 00             	movzbl (%eax),%eax
c0025a66:	84 c0                	test   %al,%al
c0025a68:	75 9b                	jne    c0025a05 <map_key+0x12>
      }

  return false;
c0025a6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025a6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025a72:	5b                   	pop    %ebx
c0025a73:	5e                   	pop    %esi
c0025a74:	5d                   	pop    %ebp
c0025a75:	c3                   	ret    

c0025a76 <inb>:
{
c0025a76:	55                   	push   %ebp
c0025a77:	89 e5                	mov    %esp,%ebp
c0025a79:	83 ec 14             	sub    $0x14,%esp
c0025a7c:	e8 a7 b9 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025a81:	05 f7 48 01 00       	add    $0x148f7,%eax
c0025a86:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a89:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025a8d:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0025a91:	89 c2                	mov    %eax,%edx
c0025a93:	ec                   	in     (%dx),%al
c0025a94:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0025a97:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0025a9b:	c9                   	leave  
c0025a9c:	c3                   	ret    

c0025a9d <outb>:
{
c0025a9d:	55                   	push   %ebp
c0025a9e:	89 e5                	mov    %esp,%ebp
c0025aa0:	83 ec 08             	sub    $0x8,%esp
c0025aa3:	e8 80 b9 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025aa8:	05 d0 48 01 00       	add    $0x148d0,%eax
c0025aad:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ab0:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025ab3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0025ab7:	89 d0                	mov    %edx,%eax
c0025ab9:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025abc:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0025ac0:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0025ac4:	ee                   	out    %al,(%dx)
}
c0025ac5:	90                   	nop
c0025ac6:	c9                   	leave  
c0025ac7:	c3                   	ret    

c0025ac8 <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c0025ac8:	55                   	push   %ebp
c0025ac9:	89 e5                	mov    %esp,%ebp
c0025acb:	83 ec 08             	sub    $0x8,%esp
c0025ace:	e8 55 b9 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025ad3:	05 a5 48 01 00       	add    $0x148a5,%eax
c0025ad8:	8b 55 08             	mov    0x8(%ebp),%edx
c0025adb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025ade:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0025ae2:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0025ae6:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c0025aea:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0025aee:	66 ef                	out    %ax,(%dx)
}
c0025af0:	90                   	nop
c0025af1:	c9                   	leave  
c0025af2:	c3                   	ret    

c0025af3 <ptov>:
{
c0025af3:	55                   	push   %ebp
c0025af4:	89 e5                	mov    %esp,%ebp
c0025af6:	53                   	push   %ebx
c0025af7:	83 ec 04             	sub    $0x4,%esp
c0025afa:	e8 29 b9 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025aff:	05 79 48 01 00       	add    $0x14879,%eax
  ASSERT ((void *) paddr < PHYS_BASE);
c0025b04:	8b 55 08             	mov    0x8(%ebp),%edx
c0025b07:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c0025b0d:	76 28                	jbe    c0025b37 <ptov+0x44>
c0025b0f:	83 ec 0c             	sub    $0xc,%esp
c0025b12:	8d 90 84 82 ff ff    	lea    -0x7d7c(%eax),%edx
c0025b18:	52                   	push   %edx
c0025b19:	8d 90 9f 82 ff ff    	lea    -0x7d61(%eax),%edx
c0025b1f:	52                   	push   %edx
c0025b20:	8d 90 e8 82 ff ff    	lea    -0x7d18(%eax),%edx
c0025b26:	52                   	push   %edx
c0025b27:	6a 4a                	push   $0x4a
c0025b29:	8d 90 b6 82 ff ff    	lea    -0x7d4a(%eax),%edx
c0025b2f:	52                   	push   %edx
c0025b30:	89 c3                	mov    %eax,%ebx
c0025b32:	e8 2d 5c 00 00       	call   c002b764 <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c0025b37:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b3a:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0025b3f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025b42:	c9                   	leave  
c0025b43:	c3                   	ret    

c0025b44 <init>:
static void find_cursor (size_t *x, size_t *y);

/* Initializes the VGA text display. */
static void
init (void)
{
c0025b44:	55                   	push   %ebp
c0025b45:	89 e5                	mov    %esp,%ebp
c0025b47:	53                   	push   %ebx
c0025b48:	83 ec 04             	sub    $0x4,%esp
c0025b4b:	e8 dc b8 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0025b50:	81 c3 28 48 01 00    	add    $0x14828,%ebx
  /* Already initialized? */
  static bool inited;
  if (!inited)
c0025b56:	0f b6 83 4c 1f 00 00 	movzbl 0x1f4c(%ebx),%eax
c0025b5d:	83 f0 01             	xor    $0x1,%eax
c0025b60:	84 c0                	test   %al,%al
c0025b62:	74 36                	je     c0025b9a <init+0x56>
    {
      fb = ptov (0xb8000);
c0025b64:	83 ec 0c             	sub    $0xc,%esp
c0025b67:	68 00 80 0b 00       	push   $0xb8000
c0025b6c:	e8 82 ff ff ff       	call   c0025af3 <ptov>
c0025b71:	83 c4 10             	add    $0x10,%esp
c0025b74:	89 83 48 1f 00 00    	mov    %eax,0x1f48(%ebx)
      find_cursor (&cx, &cy);
c0025b7a:	83 ec 08             	sub    $0x8,%esp
c0025b7d:	8d 83 44 1f 00 00    	lea    0x1f44(%ebx),%eax
c0025b83:	50                   	push   %eax
c0025b84:	8d 83 40 1f 00 00    	lea    0x1f40(%ebx),%eax
c0025b8a:	50                   	push   %eax
c0025b8b:	e8 fc 02 00 00       	call   c0025e8c <find_cursor>
c0025b90:	83 c4 10             	add    $0x10,%esp
      inited = true; 
c0025b93:	c6 83 4c 1f 00 00 01 	movb   $0x1,0x1f4c(%ebx)
    }
}
c0025b9a:	90                   	nop
c0025b9b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025b9e:	c9                   	leave  
c0025b9f:	c3                   	ret    

c0025ba0 <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c0025ba0:	55                   	push   %ebp
c0025ba1:	89 e5                	mov    %esp,%ebp
c0025ba3:	53                   	push   %ebx
c0025ba4:	83 ec 14             	sub    $0x14,%esp
c0025ba7:	e8 80 b8 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0025bac:	81 c3 cc 47 01 00    	add    $0x147cc,%ebx
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c0025bb2:	e8 2f c3 ff ff       	call   c0021ee6 <intr_disable>
c0025bb7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  init ();
c0025bba:	e8 85 ff ff ff       	call   c0025b44 <init>
  
  switch (c) 
c0025bbf:	8b 45 08             	mov    0x8(%ebp),%eax
c0025bc2:	83 e8 07             	sub    $0x7,%eax
c0025bc5:	83 f8 06             	cmp    $0x6,%eax
c0025bc8:	0f 87 98 00 00 00    	ja     c0025c66 <.L12>
c0025bce:	c1 e0 02             	shl    $0x2,%eax
c0025bd1:	8b 84 18 cc 82 ff ff 	mov    -0x7d34(%eax,%ebx,1),%eax
c0025bd8:	01 d8                	add    %ebx,%eax
c0025bda:	ff e0                	jmp    *%eax

c0025bdc <.L16>:
    {
    case '\n':
      newline ();
c0025bdc:	e8 ca 01 00 00       	call   c0025dab <newline>
      break;
c0025be1:	e9 f1 00 00 00       	jmp    c0025cd7 <.L12+0x71>

c0025be6 <.L15>:

    case '\f':
      cls ();
c0025be6:	e8 05 01 00 00       	call   c0025cf0 <cls>
      break;
c0025beb:	e9 e7 00 00 00       	jmp    c0025cd7 <.L12+0x71>

c0025bf0 <.L18>:

    case '\b':
      if (cx > 0)
c0025bf0:	8b 83 40 1f 00 00    	mov    0x1f40(%ebx),%eax
c0025bf6:	85 c0                	test   %eax,%eax
c0025bf8:	0f 84 d2 00 00 00    	je     c0025cd0 <.L12+0x6a>
        cx--;
c0025bfe:	8b 83 40 1f 00 00    	mov    0x1f40(%ebx),%eax
c0025c04:	83 e8 01             	sub    $0x1,%eax
c0025c07:	89 83 40 1f 00 00    	mov    %eax,0x1f40(%ebx)
      break;
c0025c0d:	e9 be 00 00 00       	jmp    c0025cd0 <.L12+0x6a>

c0025c12 <.L13>:
      
    case '\r':
      cx = 0;
c0025c12:	c7 83 40 1f 00 00 00 	movl   $0x0,0x1f40(%ebx)
c0025c19:	00 00 00 
      break;
c0025c1c:	e9 b6 00 00 00       	jmp    c0025cd7 <.L12+0x71>

c0025c21 <.L17>:

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c0025c21:	8b 83 40 1f 00 00    	mov    0x1f40(%ebx),%eax
c0025c27:	83 c0 08             	add    $0x8,%eax
c0025c2a:	83 e0 f8             	and    $0xfffffff8,%eax
c0025c2d:	89 83 40 1f 00 00    	mov    %eax,0x1f40(%ebx)
      if (cx >= COL_CNT)
c0025c33:	8b 83 40 1f 00 00    	mov    0x1f40(%ebx),%eax
c0025c39:	83 f8 4f             	cmp    $0x4f,%eax
c0025c3c:	0f 86 91 00 00 00    	jbe    c0025cd3 <.L12+0x6d>
        newline ();
c0025c42:	e8 64 01 00 00       	call   c0025dab <newline>
      break;
c0025c47:	e9 87 00 00 00       	jmp    c0025cd3 <.L12+0x6d>

c0025c4c <.L19>:

    case '\a':
      intr_set_level (old_level);
c0025c4c:	83 ec 0c             	sub    $0xc,%esp
c0025c4f:	ff 75 f4             	push   -0xc(%ebp)
c0025c52:	e8 16 c2 ff ff       	call   c0021e6d <intr_set_level>
c0025c57:	83 c4 10             	add    $0x10,%esp
      speaker_beep ();
c0025c5a:	e8 62 2e 00 00       	call   c0028ac1 <speaker_beep>
      intr_disable ();
c0025c5f:	e8 82 c2 ff ff       	call   c0021ee6 <intr_disable>
      break;
c0025c64:	eb 71                	jmp    c0025cd7 <.L12+0x71>

c0025c66 <.L12>:
      
    default:
      fb[cy][cx][0] = c;
c0025c66:	8b 8b 48 1f 00 00    	mov    0x1f48(%ebx),%ecx
c0025c6c:	8b 93 44 1f 00 00    	mov    0x1f44(%ebx),%edx
c0025c72:	89 d0                	mov    %edx,%eax
c0025c74:	c1 e0 02             	shl    $0x2,%eax
c0025c77:	01 d0                	add    %edx,%eax
c0025c79:	c1 e0 05             	shl    $0x5,%eax
c0025c7c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0025c7f:	8b 83 40 1f 00 00    	mov    0x1f40(%ebx),%eax
c0025c85:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0025c88:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0025c8b:	8b 8b 48 1f 00 00    	mov    0x1f48(%ebx),%ecx
c0025c91:	8b 93 44 1f 00 00    	mov    0x1f44(%ebx),%edx
c0025c97:	89 d0                	mov    %edx,%eax
c0025c99:	c1 e0 02             	shl    $0x2,%eax
c0025c9c:	01 d0                	add    %edx,%eax
c0025c9e:	c1 e0 05             	shl    $0x5,%eax
c0025ca1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0025ca4:	8b 83 40 1f 00 00    	mov    0x1f40(%ebx),%eax
c0025caa:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c0025caf:	8b 83 40 1f 00 00    	mov    0x1f40(%ebx),%eax
c0025cb5:	83 c0 01             	add    $0x1,%eax
c0025cb8:	89 83 40 1f 00 00    	mov    %eax,0x1f40(%ebx)
c0025cbe:	8b 83 40 1f 00 00    	mov    0x1f40(%ebx),%eax
c0025cc4:	83 f8 4f             	cmp    $0x4f,%eax
c0025cc7:	76 0d                	jbe    c0025cd6 <.L12+0x70>
        newline ();
c0025cc9:	e8 dd 00 00 00       	call   c0025dab <newline>
      break;
c0025cce:	eb 06                	jmp    c0025cd6 <.L12+0x70>
      break;
c0025cd0:	90                   	nop
c0025cd1:	eb 04                	jmp    c0025cd7 <.L12+0x71>
      break;
c0025cd3:	90                   	nop
c0025cd4:	eb 01                	jmp    c0025cd7 <.L12+0x71>
      break;
c0025cd6:	90                   	nop
    }

  /* Update cursor position. */
  move_cursor ();
c0025cd7:	e8 47 01 00 00       	call   c0025e23 <move_cursor>

  intr_set_level (old_level);
c0025cdc:	83 ec 0c             	sub    $0xc,%esp
c0025cdf:	ff 75 f4             	push   -0xc(%ebp)
c0025ce2:	e8 86 c1 ff ff       	call   c0021e6d <intr_set_level>
c0025ce7:	83 c4 10             	add    $0x10,%esp
}
c0025cea:	90                   	nop
c0025ceb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025cee:	c9                   	leave  
c0025cef:	c3                   	ret    

c0025cf0 <cls>:

/* Clears the screen and moves the cursor to the upper left. */
static void
cls (void)
{
c0025cf0:	55                   	push   %ebp
c0025cf1:	89 e5                	mov    %esp,%ebp
c0025cf3:	53                   	push   %ebx
c0025cf4:	83 ec 14             	sub    $0x14,%esp
c0025cf7:	e8 30 b7 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0025cfc:	81 c3 7c 46 01 00    	add    $0x1467c,%ebx
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c0025d02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025d09:	eb 12                	jmp    c0025d1d <cls+0x2d>
    clear_row (y);
c0025d0b:	83 ec 0c             	sub    $0xc,%esp
c0025d0e:	ff 75 f4             	push   -0xc(%ebp)
c0025d11:	e8 2e 00 00 00       	call   c0025d44 <clear_row>
c0025d16:	83 c4 10             	add    $0x10,%esp
  for (y = 0; y < ROW_CNT; y++)
c0025d19:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0025d1d:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0025d21:	76 e8                	jbe    c0025d0b <cls+0x1b>

  cx = cy = 0;
c0025d23:	c7 83 44 1f 00 00 00 	movl   $0x0,0x1f44(%ebx)
c0025d2a:	00 00 00 
c0025d2d:	8b 83 44 1f 00 00    	mov    0x1f44(%ebx),%eax
c0025d33:	89 83 40 1f 00 00    	mov    %eax,0x1f40(%ebx)
  move_cursor ();
c0025d39:	e8 e5 00 00 00       	call   c0025e23 <move_cursor>
}
c0025d3e:	90                   	nop
c0025d3f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025d42:	c9                   	leave  
c0025d43:	c3                   	ret    

c0025d44 <clear_row>:

/* Clears row Y to spaces. */
static void
clear_row (size_t y) 
{
c0025d44:	55                   	push   %ebp
c0025d45:	89 e5                	mov    %esp,%ebp
c0025d47:	53                   	push   %ebx
c0025d48:	83 ec 10             	sub    $0x10,%esp
c0025d4b:	e8 e8 b6 00 00       	call   c0031438 <__x86.get_pc_thunk.dx>
c0025d50:	81 c2 28 46 01 00    	add    $0x14628,%edx
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c0025d56:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0025d5d:	eb 3f                	jmp    c0025d9e <clear_row+0x5a>
    {
      fb[y][x][0] = ' ';
c0025d5f:	8b 9a 48 1f 00 00    	mov    0x1f48(%edx),%ebx
c0025d65:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0025d68:	89 c8                	mov    %ecx,%eax
c0025d6a:	c1 e0 02             	shl    $0x2,%eax
c0025d6d:	01 c8                	add    %ecx,%eax
c0025d6f:	c1 e0 05             	shl    $0x5,%eax
c0025d72:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
c0025d75:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0025d78:	c6 04 41 20          	movb   $0x20,(%ecx,%eax,2)
      fb[y][x][1] = GRAY_ON_BLACK;
c0025d7c:	8b 9a 48 1f 00 00    	mov    0x1f48(%edx),%ebx
c0025d82:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0025d85:	89 c8                	mov    %ecx,%eax
c0025d87:	c1 e0 02             	shl    $0x2,%eax
c0025d8a:	01 c8                	add    %ecx,%eax
c0025d8c:	c1 e0 05             	shl    $0x5,%eax
c0025d8f:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
c0025d92:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0025d95:	c6 44 41 01 07       	movb   $0x7,0x1(%ecx,%eax,2)
  for (x = 0; x < COL_CNT; x++)
c0025d9a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0025d9e:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c0025da2:	76 bb                	jbe    c0025d5f <clear_row+0x1b>
    }
}
c0025da4:	90                   	nop
c0025da5:	90                   	nop
c0025da6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025da9:	c9                   	leave  
c0025daa:	c3                   	ret    

c0025dab <newline>:
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c0025dab:	55                   	push   %ebp
c0025dac:	89 e5                	mov    %esp,%ebp
c0025dae:	53                   	push   %ebx
c0025daf:	83 ec 04             	sub    $0x4,%esp
c0025db2:	e8 71 b6 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025db7:	05 c1 45 01 00       	add    $0x145c1,%eax
  cx = 0;
c0025dbc:	c7 80 40 1f 00 00 00 	movl   $0x0,0x1f40(%eax)
c0025dc3:	00 00 00 
  cy++;
c0025dc6:	8b 90 44 1f 00 00    	mov    0x1f44(%eax),%edx
c0025dcc:	83 c2 01             	add    $0x1,%edx
c0025dcf:	89 90 44 1f 00 00    	mov    %edx,0x1f44(%eax)
  if (cy >= ROW_CNT)
c0025dd5:	8b 90 44 1f 00 00    	mov    0x1f44(%eax),%edx
c0025ddb:	83 fa 18             	cmp    $0x18,%edx
c0025dde:	76 3d                	jbe    c0025e1d <newline+0x72>
    {
      cy = ROW_CNT - 1;
c0025de0:	c7 80 44 1f 00 00 18 	movl   $0x18,0x1f44(%eax)
c0025de7:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0025dea:	8b 90 48 1f 00 00    	mov    0x1f48(%eax),%edx
c0025df0:	8d 8a a0 00 00 00    	lea    0xa0(%edx),%ecx
c0025df6:	8b 90 48 1f 00 00    	mov    0x1f48(%eax),%edx
c0025dfc:	83 ec 04             	sub    $0x4,%esp
c0025dff:	68 00 0f 00 00       	push   $0xf00
c0025e04:	51                   	push   %ecx
c0025e05:	52                   	push   %edx
c0025e06:	89 c3                	mov    %eax,%ebx
c0025e08:	e8 7c 45 00 00       	call   c002a389 <memmove>
c0025e0d:	83 c4 10             	add    $0x10,%esp
      clear_row (ROW_CNT - 1);
c0025e10:	83 ec 0c             	sub    $0xc,%esp
c0025e13:	6a 18                	push   $0x18
c0025e15:	e8 2a ff ff ff       	call   c0025d44 <clear_row>
c0025e1a:	83 c4 10             	add    $0x10,%esp
    }
}
c0025e1d:	90                   	nop
c0025e1e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025e21:	c9                   	leave  
c0025e22:	c3                   	ret    

c0025e23 <move_cursor>:

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c0025e23:	55                   	push   %ebp
c0025e24:	89 e5                	mov    %esp,%ebp
c0025e26:	83 ec 10             	sub    $0x10,%esp
c0025e29:	e8 0a b6 00 00       	call   c0031438 <__x86.get_pc_thunk.dx>
c0025e2e:	81 c2 4a 45 01 00    	add    $0x1454a,%edx
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0025e34:	8b 82 44 1f 00 00    	mov    0x1f44(%edx),%eax
c0025e3a:	89 c1                	mov    %eax,%ecx
c0025e3c:	89 c8                	mov    %ecx,%eax
c0025e3e:	c1 e0 02             	shl    $0x2,%eax
c0025e41:	01 c8                	add    %ecx,%eax
c0025e43:	c1 e0 04             	shl    $0x4,%eax
c0025e46:	89 c1                	mov    %eax,%ecx
c0025e48:	8b 82 40 1f 00 00    	mov    0x1f40(%edx),%eax
c0025e4e:	01 c8                	add    %ecx,%eax
c0025e50:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  outw (0x3d4, 0x0e | (cp & 0xff00));
c0025e54:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0025e58:	b0 00                	mov    $0x0,%al
c0025e5a:	83 c8 0e             	or     $0xe,%eax
c0025e5d:	0f b7 c0             	movzwl %ax,%eax
c0025e60:	50                   	push   %eax
c0025e61:	68 d4 03 00 00       	push   $0x3d4
c0025e66:	e8 5d fc ff ff       	call   c0025ac8 <outw>
c0025e6b:	83 c4 08             	add    $0x8,%esp
  outw (0x3d4, 0x0f | (cp << 8));
c0025e6e:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0025e72:	c1 e0 08             	shl    $0x8,%eax
c0025e75:	83 c8 0f             	or     $0xf,%eax
c0025e78:	0f b7 c0             	movzwl %ax,%eax
c0025e7b:	50                   	push   %eax
c0025e7c:	68 d4 03 00 00       	push   $0x3d4
c0025e81:	e8 42 fc ff ff       	call   c0025ac8 <outw>
c0025e86:	83 c4 08             	add    $0x8,%esp
}
c0025e89:	90                   	nop
c0025e8a:	c9                   	leave  
c0025e8b:	c3                   	ret    

c0025e8c <find_cursor>:

/* Reads the current hardware cursor position into (*X,*Y). */
static void
find_cursor (size_t *x, size_t *y) 
{
c0025e8c:	55                   	push   %ebp
c0025e8d:	89 e5                	mov    %esp,%ebp
c0025e8f:	83 ec 10             	sub    $0x10,%esp
c0025e92:	e8 91 b5 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025e97:	05 e1 44 01 00       	add    $0x144e1,%eax
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
c0025e9c:	6a 0e                	push   $0xe
c0025e9e:	68 d4 03 00 00       	push   $0x3d4
c0025ea3:	e8 f5 fb ff ff       	call   c0025a9d <outb>
c0025ea8:	83 c4 08             	add    $0x8,%esp
  cp = inb (0x3d5) << 8;
c0025eab:	68 d5 03 00 00       	push   $0x3d5
c0025eb0:	e8 c1 fb ff ff       	call   c0025a76 <inb>
c0025eb5:	83 c4 04             	add    $0x4,%esp
c0025eb8:	0f b6 c0             	movzbl %al,%eax
c0025ebb:	c1 e0 08             	shl    $0x8,%eax
c0025ebe:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  outb (0x3d4, 0x0f);
c0025ec2:	6a 0f                	push   $0xf
c0025ec4:	68 d4 03 00 00       	push   $0x3d4
c0025ec9:	e8 cf fb ff ff       	call   c0025a9d <outb>
c0025ece:	83 c4 08             	add    $0x8,%esp
  cp |= inb (0x3d5);
c0025ed1:	68 d5 03 00 00       	push   $0x3d5
c0025ed6:	e8 9b fb ff ff       	call   c0025a76 <inb>
c0025edb:	83 c4 04             	add    $0x4,%esp
c0025ede:	0f b6 c0             	movzbl %al,%eax
c0025ee1:	66 09 45 fe          	or     %ax,-0x2(%ebp)

  *x = cp % COL_CNT;
c0025ee5:	0f b7 4d fe          	movzwl -0x2(%ebp),%ecx
c0025ee9:	0f b7 c1             	movzwl %cx,%eax
c0025eec:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c0025ef2:	c1 e8 10             	shr    $0x10,%eax
c0025ef5:	89 c2                	mov    %eax,%edx
c0025ef7:	66 c1 ea 06          	shr    $0x6,%dx
c0025efb:	89 d0                	mov    %edx,%eax
c0025efd:	c1 e0 02             	shl    $0x2,%eax
c0025f00:	01 d0                	add    %edx,%eax
c0025f02:	c1 e0 04             	shl    $0x4,%eax
c0025f05:	29 c1                	sub    %eax,%ecx
c0025f07:	89 ca                	mov    %ecx,%edx
c0025f09:	0f b7 d2             	movzwl %dx,%edx
c0025f0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f0f:	89 10                	mov    %edx,(%eax)
  *y = cp / COL_CNT;
c0025f11:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0025f15:	0f b7 c0             	movzwl %ax,%eax
c0025f18:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c0025f1e:	c1 e8 10             	shr    $0x10,%eax
c0025f21:	66 c1 e8 06          	shr    $0x6,%ax
c0025f25:	0f b7 d0             	movzwl %ax,%edx
c0025f28:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025f2b:	89 10                	mov    %edx,(%eax)
}
c0025f2d:	90                   	nop
c0025f2e:	c9                   	leave  
c0025f2f:	c3                   	ret    

c0025f30 <inb>:
{
c0025f30:	55                   	push   %ebp
c0025f31:	89 e5                	mov    %esp,%ebp
c0025f33:	83 ec 14             	sub    $0x14,%esp
c0025f36:	e8 ed b4 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025f3b:	05 3d 44 01 00       	add    $0x1443d,%eax
c0025f40:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f43:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025f47:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0025f4b:	89 c2                	mov    %eax,%edx
c0025f4d:	ec                   	in     (%dx),%al
c0025f4e:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0025f51:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0025f55:	c9                   	leave  
c0025f56:	c3                   	ret    

c0025f57 <outb>:
{
c0025f57:	55                   	push   %ebp
c0025f58:	89 e5                	mov    %esp,%ebp
c0025f5a:	83 ec 08             	sub    $0x8,%esp
c0025f5d:	e8 c6 b4 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0025f62:	05 16 44 01 00       	add    $0x14416,%eax
c0025f67:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f6a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025f6d:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0025f71:	89 d0                	mov    %edx,%eax
c0025f73:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025f76:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0025f7a:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0025f7e:	ee                   	out    %al,(%dx)
}
c0025f7f:	90                   	nop
c0025f80:	c9                   	leave  
c0025f81:	c3                   	ret    

c0025f82 <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0025f82:	55                   	push   %ebp
c0025f83:	89 e5                	mov    %esp,%ebp
c0025f85:	53                   	push   %ebx
c0025f86:	83 ec 04             	sub    $0x4,%esp
c0025f89:	e8 9e b4 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0025f8e:	81 c3 ea 43 01 00    	add    $0x143ea,%ebx
  ASSERT (mode == UNINIT);
c0025f94:	8b 83 68 1f 00 00    	mov    0x1f68(%ebx),%eax
c0025f9a:	85 c0                	test   %eax,%eax
c0025f9c:	74 26                	je     c0025fc4 <init_poll+0x42>
c0025f9e:	83 ec 0c             	sub    $0xc,%esp
c0025fa1:	8d 83 f0 82 ff ff    	lea    -0x7d10(%ebx),%eax
c0025fa7:	50                   	push   %eax
c0025fa8:	8d 83 ff 82 ff ff    	lea    -0x7d01(%ebx),%eax
c0025fae:	50                   	push   %eax
c0025faf:	8d 83 7c 83 ff ff    	lea    -0x7c84(%ebx),%eax
c0025fb5:	50                   	push   %eax
c0025fb6:	6a 45                	push   $0x45
c0025fb8:	8d 83 16 83 ff ff    	lea    -0x7cea(%ebx),%eax
c0025fbe:	50                   	push   %eax
c0025fbf:	e8 a0 57 00 00       	call   c002b764 <debug_panic>
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
c0025fc4:	83 ec 08             	sub    $0x8,%esp
c0025fc7:	6a 00                	push   $0x0
c0025fc9:	68 f9 03 00 00       	push   $0x3f9
c0025fce:	e8 84 ff ff ff       	call   c0025f57 <outb>
c0025fd3:	83 c4 10             	add    $0x10,%esp
  outb (FCR_REG, 0);                    /* Disable FIFO. */
c0025fd6:	83 ec 08             	sub    $0x8,%esp
c0025fd9:	6a 00                	push   $0x0
c0025fdb:	68 fa 03 00 00       	push   $0x3fa
c0025fe0:	e8 72 ff ff ff       	call   c0025f57 <outb>
c0025fe5:	83 c4 10             	add    $0x10,%esp
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
c0025fe8:	83 ec 0c             	sub    $0xc,%esp
c0025feb:	68 80 25 00 00       	push   $0x2580
c0025ff0:	e8 4c 02 00 00       	call   c0026241 <set_serial>
c0025ff5:	83 c4 10             	add    $0x10,%esp
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
c0025ff8:	83 ec 08             	sub    $0x8,%esp
c0025ffb:	6a 08                	push   $0x8
c0025ffd:	68 fc 03 00 00       	push   $0x3fc
c0026002:	e8 50 ff ff ff       	call   c0025f57 <outb>
c0026007:	83 c4 10             	add    $0x10,%esp
  intq_init (&txq);
c002600a:	83 ec 0c             	sub    $0xc,%esp
c002600d:	8d 83 88 1f 00 00    	lea    0x1f88(%ebx),%eax
c0026013:	50                   	push   %eax
c0026014:	e8 11 20 00 00       	call   c002802a <intq_init>
c0026019:	83 c4 10             	add    $0x10,%esp
  mode = POLL;
c002601c:	c7 83 68 1f 00 00 01 	movl   $0x1,0x1f68(%ebx)
c0026023:	00 00 00 
} 
c0026026:	90                   	nop
c0026027:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002602a:	c9                   	leave  
c002602b:	c3                   	ret    

c002602c <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c002602c:	55                   	push   %ebp
c002602d:	89 e5                	mov    %esp,%ebp
c002602f:	53                   	push   %ebx
c0026030:	83 ec 14             	sub    $0x14,%esp
c0026033:	e8 f4 b3 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0026038:	81 c3 40 43 01 00    	add    $0x14340,%ebx
  enum intr_level old_level;

  if (mode == UNINIT)
c002603e:	8b 83 68 1f 00 00    	mov    0x1f68(%ebx),%eax
c0026044:	85 c0                	test   %eax,%eax
c0026046:	75 05                	jne    c002604d <serial_init_queue+0x21>
    init_poll ();
c0026048:	e8 35 ff ff ff       	call   c0025f82 <init_poll>
  ASSERT (mode == POLL);
c002604d:	8b 83 68 1f 00 00    	mov    0x1f68(%ebx),%eax
c0026053:	83 f8 01             	cmp    $0x1,%eax
c0026056:	74 26                	je     c002607e <serial_init_queue+0x52>
c0026058:	83 ec 0c             	sub    $0xc,%esp
c002605b:	8d 83 2d 83 ff ff    	lea    -0x7cd3(%ebx),%eax
c0026061:	50                   	push   %eax
c0026062:	8d 83 ff 82 ff ff    	lea    -0x7d01(%ebx),%eax
c0026068:	50                   	push   %eax
c0026069:	8d 83 88 83 ff ff    	lea    -0x7c78(%ebx),%eax
c002606f:	50                   	push   %eax
c0026070:	6a 58                	push   $0x58
c0026072:	8d 83 16 83 ff ff    	lea    -0x7cea(%ebx),%eax
c0026078:	50                   	push   %eax
c0026079:	e8 e6 56 00 00       	call   c002b764 <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c002607e:	83 ec 04             	sub    $0x4,%esp
c0026081:	8d 83 3a 83 ff ff    	lea    -0x7cc6(%ebx),%eax
c0026087:	50                   	push   %eax
c0026088:	8d 83 9b c0 fe ff    	lea    -0x13f65(%ebx),%eax
c002608e:	50                   	push   %eax
c002608f:	6a 24                	push   $0x24
c0026091:	e8 d0 c0 ff ff       	call   c0022166 <intr_register_ext>
c0026096:	83 c4 10             	add    $0x10,%esp
  mode = QUEUE;
c0026099:	c7 83 68 1f 00 00 02 	movl   $0x2,0x1f68(%ebx)
c00260a0:	00 00 00 
  old_level = intr_disable ();
c00260a3:	e8 3e be ff ff       	call   c0021ee6 <intr_disable>
c00260a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  write_ier ();
c00260ab:	e8 53 02 00 00       	call   c0026303 <write_ier>
  intr_set_level (old_level);
c00260b0:	83 ec 0c             	sub    $0xc,%esp
c00260b3:	ff 75 f4             	push   -0xc(%ebp)
c00260b6:	e8 b2 bd ff ff       	call   c0021e6d <intr_set_level>
c00260bb:	83 c4 10             	add    $0x10,%esp
}
c00260be:	90                   	nop
c00260bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00260c2:	c9                   	leave  
c00260c3:	c3                   	ret    

c00260c4 <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c00260c4:	55                   	push   %ebp
c00260c5:	89 e5                	mov    %esp,%ebp
c00260c7:	53                   	push   %ebx
c00260c8:	83 ec 24             	sub    $0x24,%esp
c00260cb:	e8 5c b3 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00260d0:	81 c3 a8 42 01 00    	add    $0x142a8,%ebx
c00260d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00260d9:	88 45 e4             	mov    %al,-0x1c(%ebp)
  enum intr_level old_level = intr_disable ();
c00260dc:	e8 05 be ff ff       	call   c0021ee6 <intr_disable>
c00260e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (mode != QUEUE)
c00260e4:	8b 83 68 1f 00 00    	mov    0x1f68(%ebx),%eax
c00260ea:	83 f8 02             	cmp    $0x2,%eax
c00260ed:	74 21                	je     c0026110 <serial_putc+0x4c>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c00260ef:	8b 83 68 1f 00 00    	mov    0x1f68(%ebx),%eax
c00260f5:	85 c0                	test   %eax,%eax
c00260f7:	75 05                	jne    c00260fe <serial_putc+0x3a>
        init_poll ();
c00260f9:	e8 84 fe ff ff       	call   c0025f82 <init_poll>
      putc_poll (byte); 
c00260fe:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0026102:	83 ec 0c             	sub    $0xc,%esp
c0026105:	50                   	push   %eax
c0026106:	e8 88 02 00 00       	call   c0026393 <putc_poll>
c002610b:	83 c4 10             	add    $0x10,%esp
c002610e:	eb 59                	jmp    c0026169 <serial_putc+0xa5>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0026110:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0026114:	75 37                	jne    c002614d <serial_putc+0x89>
c0026116:	83 ec 0c             	sub    $0xc,%esp
c0026119:	8d 83 88 1f 00 00    	lea    0x1f88(%ebx),%eax
c002611f:	50                   	push   %eax
c0026120:	e8 b0 1f 00 00       	call   c00280d5 <intq_full>
c0026125:	83 c4 10             	add    $0x10,%esp
c0026128:	84 c0                	test   %al,%al
c002612a:	74 21                	je     c002614d <serial_putc+0x89>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c002612c:	83 ec 0c             	sub    $0xc,%esp
c002612f:	8d 83 88 1f 00 00    	lea    0x1f88(%ebx),%eax
c0026135:	50                   	push   %eax
c0026136:	e8 fd 1f 00 00       	call   c0028138 <intq_getc>
c002613b:	83 c4 10             	add    $0x10,%esp
c002613e:	0f b6 c0             	movzbl %al,%eax
c0026141:	83 ec 0c             	sub    $0xc,%esp
c0026144:	50                   	push   %eax
c0026145:	e8 49 02 00 00       	call   c0026393 <putc_poll>
c002614a:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c002614d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0026151:	83 ec 08             	sub    $0x8,%esp
c0026154:	50                   	push   %eax
c0026155:	8d 83 88 1f 00 00    	lea    0x1f88(%ebx),%eax
c002615b:	50                   	push   %eax
c002615c:	e8 da 20 00 00       	call   c002823b <intq_putc>
c0026161:	83 c4 10             	add    $0x10,%esp
      write_ier ();
c0026164:	e8 9a 01 00 00       	call   c0026303 <write_ier>
    }
  
  intr_set_level (old_level);
c0026169:	83 ec 0c             	sub    $0xc,%esp
c002616c:	ff 75 f4             	push   -0xc(%ebp)
c002616f:	e8 f9 bc ff ff       	call   c0021e6d <intr_set_level>
c0026174:	83 c4 10             	add    $0x10,%esp
}
c0026177:	90                   	nop
c0026178:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002617b:	c9                   	leave  
c002617c:	c3                   	ret    

c002617d <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c002617d:	55                   	push   %ebp
c002617e:	89 e5                	mov    %esp,%ebp
c0026180:	53                   	push   %ebx
c0026181:	83 ec 14             	sub    $0x14,%esp
c0026184:	e8 a3 b2 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0026189:	81 c3 ef 41 01 00    	add    $0x141ef,%ebx
  enum intr_level old_level = intr_disable ();
c002618f:	e8 52 bd ff ff       	call   c0021ee6 <intr_disable>
c0026194:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!intq_empty (&txq))
c0026197:	eb 21                	jmp    c00261ba <serial_flush+0x3d>
    putc_poll (intq_getc (&txq));
c0026199:	83 ec 0c             	sub    $0xc,%esp
c002619c:	8d 83 88 1f 00 00    	lea    0x1f88(%ebx),%eax
c00261a2:	50                   	push   %eax
c00261a3:	e8 90 1f 00 00       	call   c0028138 <intq_getc>
c00261a8:	83 c4 10             	add    $0x10,%esp
c00261ab:	0f b6 c0             	movzbl %al,%eax
c00261ae:	83 ec 0c             	sub    $0xc,%esp
c00261b1:	50                   	push   %eax
c00261b2:	e8 dc 01 00 00       	call   c0026393 <putc_poll>
c00261b7:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c00261ba:	83 ec 0c             	sub    $0xc,%esp
c00261bd:	8d 83 88 1f 00 00    	lea    0x1f88(%ebx),%eax
c00261c3:	50                   	push   %eax
c00261c4:	e8 b5 1e 00 00       	call   c002807e <intq_empty>
c00261c9:	83 c4 10             	add    $0x10,%esp
c00261cc:	83 f0 01             	xor    $0x1,%eax
c00261cf:	84 c0                	test   %al,%al
c00261d1:	75 c6                	jne    c0026199 <serial_flush+0x1c>
  intr_set_level (old_level);
c00261d3:	83 ec 0c             	sub    $0xc,%esp
c00261d6:	ff 75 f4             	push   -0xc(%ebp)
c00261d9:	e8 8f bc ff ff       	call   c0021e6d <intr_set_level>
c00261de:	83 c4 10             	add    $0x10,%esp
}
c00261e1:	90                   	nop
c00261e2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00261e5:	c9                   	leave  
c00261e6:	c3                   	ret    

c00261e7 <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c00261e7:	55                   	push   %ebp
c00261e8:	89 e5                	mov    %esp,%ebp
c00261ea:	53                   	push   %ebx
c00261eb:	83 ec 04             	sub    $0x4,%esp
c00261ee:	e8 39 b2 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00261f3:	81 c3 85 41 01 00    	add    $0x14185,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00261f9:	e8 4f bc ff ff       	call   c0021e4d <intr_get_level>
c00261fe:	85 c0                	test   %eax,%eax
c0026200:	74 29                	je     c002622b <serial_notify+0x44>
c0026202:	83 ec 0c             	sub    $0xc,%esp
c0026205:	8d 83 41 83 ff ff    	lea    -0x7cbf(%ebx),%eax
c002620b:	50                   	push   %eax
c002620c:	8d 83 ff 82 ff ff    	lea    -0x7d01(%ebx),%eax
c0026212:	50                   	push   %eax
c0026213:	8d 83 9c 83 ff ff    	lea    -0x7c64(%ebx),%eax
c0026219:	50                   	push   %eax
c002621a:	68 96 00 00 00       	push   $0x96
c002621f:	8d 83 16 83 ff ff    	lea    -0x7cea(%ebx),%eax
c0026225:	50                   	push   %eax
c0026226:	e8 39 55 00 00       	call   c002b764 <debug_panic>
  if (mode == QUEUE)
c002622b:	8b 83 68 1f 00 00    	mov    0x1f68(%ebx),%eax
c0026231:	83 f8 02             	cmp    $0x2,%eax
c0026234:	75 05                	jne    c002623b <serial_notify+0x54>
    write_ier ();
c0026236:	e8 c8 00 00 00       	call   c0026303 <write_ier>
}
c002623b:	90                   	nop
c002623c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002623f:	c9                   	leave  
c0026240:	c3                   	ret    

c0026241 <set_serial>:

/* Configures the serial port for BPS bits per second. */
static void
set_serial (int bps)
{
c0026241:	55                   	push   %ebp
c0026242:	89 e5                	mov    %esp,%ebp
c0026244:	53                   	push   %ebx
c0026245:	83 ec 14             	sub    $0x14,%esp
c0026248:	e8 e7 b1 00 00       	call   c0031434 <__x86.get_pc_thunk.cx>
c002624d:	81 c1 2b 41 01 00    	add    $0x1412b,%ecx
  int base_rate = 1843200 / 16;         /* Base rate of 16550A, in Hz. */
c0026253:	c7 45 f4 00 c2 01 00 	movl   $0x1c200,-0xc(%ebp)
  uint16_t divisor = base_rate / bps;   /* Clock rate divisor. */
c002625a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002625d:	99                   	cltd   
c002625e:	f7 7d 08             	idivl  0x8(%ebp)
c0026261:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

  ASSERT (bps >= 300 && bps <= 115200);
c0026265:	81 7d 08 2b 01 00 00 	cmpl   $0x12b,0x8(%ebp)
c002626c:	7e 09                	jle    c0026277 <set_serial+0x36>
c002626e:	81 7d 08 00 c2 01 00 	cmpl   $0x1c200,0x8(%ebp)
c0026275:	7e 2b                	jle    c00262a2 <set_serial+0x61>
c0026277:	83 ec 0c             	sub    $0xc,%esp
c002627a:	8d 81 5f 83 ff ff    	lea    -0x7ca1(%ecx),%eax
c0026280:	50                   	push   %eax
c0026281:	8d 81 ff 82 ff ff    	lea    -0x7d01(%ecx),%eax
c0026287:	50                   	push   %eax
c0026288:	8d 81 ac 83 ff ff    	lea    -0x7c54(%ecx),%eax
c002628e:	50                   	push   %eax
c002628f:	68 a2 00 00 00       	push   $0xa2
c0026294:	8d 81 16 83 ff ff    	lea    -0x7cea(%ecx),%eax
c002629a:	50                   	push   %eax
c002629b:	89 cb                	mov    %ecx,%ebx
c002629d:	e8 c2 54 00 00       	call   c002b764 <debug_panic>

  /* Enable DLAB. */
  outb (LCR_REG, LCR_N81 | LCR_DLAB);
c00262a2:	83 ec 08             	sub    $0x8,%esp
c00262a5:	68 83 00 00 00       	push   $0x83
c00262aa:	68 fb 03 00 00       	push   $0x3fb
c00262af:	e8 a3 fc ff ff       	call   c0025f57 <outb>
c00262b4:	83 c4 10             	add    $0x10,%esp

  /* Set data rate. */
  outb (LS_REG, divisor & 0xff);
c00262b7:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c00262bb:	0f b6 c0             	movzbl %al,%eax
c00262be:	83 ec 08             	sub    $0x8,%esp
c00262c1:	50                   	push   %eax
c00262c2:	68 f8 03 00 00       	push   $0x3f8
c00262c7:	e8 8b fc ff ff       	call   c0025f57 <outb>
c00262cc:	83 c4 10             	add    $0x10,%esp
  outb (MS_REG, divisor >> 8);
c00262cf:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c00262d3:	66 c1 e8 08          	shr    $0x8,%ax
c00262d7:	0f b6 c0             	movzbl %al,%eax
c00262da:	83 ec 08             	sub    $0x8,%esp
c00262dd:	50                   	push   %eax
c00262de:	68 f9 03 00 00       	push   $0x3f9
c00262e3:	e8 6f fc ff ff       	call   c0025f57 <outb>
c00262e8:	83 c4 10             	add    $0x10,%esp
  
  /* Reset DLAB. */
  outb (LCR_REG, LCR_N81);
c00262eb:	83 ec 08             	sub    $0x8,%esp
c00262ee:	6a 03                	push   $0x3
c00262f0:	68 fb 03 00 00       	push   $0x3fb
c00262f5:	e8 5d fc ff ff       	call   c0025f57 <outb>
c00262fa:	83 c4 10             	add    $0x10,%esp
}
c00262fd:	90                   	nop
c00262fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026301:	c9                   	leave  
c0026302:	c3                   	ret    

c0026303 <write_ier>:

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0026303:	55                   	push   %ebp
c0026304:	89 e5                	mov    %esp,%ebp
c0026306:	53                   	push   %ebx
c0026307:	83 ec 14             	sub    $0x14,%esp
c002630a:	e8 1d b1 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002630f:	81 c3 69 40 01 00    	add    $0x14069,%ebx
  uint8_t ier = 0;
c0026315:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0026319:	e8 2f bb ff ff       	call   c0021e4d <intr_get_level>
c002631e:	85 c0                	test   %eax,%eax
c0026320:	74 29                	je     c002634b <write_ier+0x48>
c0026322:	83 ec 0c             	sub    $0xc,%esp
c0026325:	8d 83 41 83 ff ff    	lea    -0x7cbf(%ebx),%eax
c002632b:	50                   	push   %eax
c002632c:	8d 83 ff 82 ff ff    	lea    -0x7d01(%ebx),%eax
c0026332:	50                   	push   %eax
c0026333:	8d 83 b8 83 ff ff    	lea    -0x7c48(%ebx),%eax
c0026339:	50                   	push   %eax
c002633a:	68 b5 00 00 00       	push   $0xb5
c002633f:	8d 83 16 83 ff ff    	lea    -0x7cea(%ebx),%eax
c0026345:	50                   	push   %eax
c0026346:	e8 19 54 00 00       	call   c002b764 <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c002634b:	83 ec 0c             	sub    $0xc,%esp
c002634e:	8d 83 88 1f 00 00    	lea    0x1f88(%ebx),%eax
c0026354:	50                   	push   %eax
c0026355:	e8 24 1d 00 00       	call   c002807e <intq_empty>
c002635a:	83 c4 10             	add    $0x10,%esp
c002635d:	83 f0 01             	xor    $0x1,%eax
c0026360:	84 c0                	test   %al,%al
c0026362:	74 04                	je     c0026368 <write_ier+0x65>
    ier |= IER_XMIT;
c0026364:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0026368:	e8 65 1c 00 00       	call   c0027fd2 <input_full>
c002636d:	83 f0 01             	xor    $0x1,%eax
c0026370:	84 c0                	test   %al,%al
c0026372:	74 04                	je     c0026378 <write_ier+0x75>
    ier |= IER_RECV;
c0026374:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
  
  outb (IER_REG, ier);
c0026378:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c002637c:	83 ec 08             	sub    $0x8,%esp
c002637f:	50                   	push   %eax
c0026380:	68 f9 03 00 00       	push   $0x3f9
c0026385:	e8 cd fb ff ff       	call   c0025f57 <outb>
c002638a:	83 c4 10             	add    $0x10,%esp
}
c002638d:	90                   	nop
c002638e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026391:	c9                   	leave  
c0026392:	c3                   	ret    

c0026393 <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c0026393:	55                   	push   %ebp
c0026394:	89 e5                	mov    %esp,%ebp
c0026396:	53                   	push   %ebx
c0026397:	83 ec 14             	sub    $0x14,%esp
c002639a:	e8 8d b0 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002639f:	81 c3 d9 3f 01 00    	add    $0x13fd9,%ebx
c00263a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00263a8:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c00263ab:	e8 9d ba ff ff       	call   c0021e4d <intr_get_level>
c00263b0:	85 c0                	test   %eax,%eax
c00263b2:	74 2a                	je     c00263de <putc_poll+0x4b>
c00263b4:	83 ec 0c             	sub    $0xc,%esp
c00263b7:	8d 83 41 83 ff ff    	lea    -0x7cbf(%ebx),%eax
c00263bd:	50                   	push   %eax
c00263be:	8d 83 ff 82 ff ff    	lea    -0x7d01(%ebx),%eax
c00263c4:	50                   	push   %eax
c00263c5:	8d 83 c4 83 ff ff    	lea    -0x7c3c(%ebx),%eax
c00263cb:	50                   	push   %eax
c00263cc:	68 c9 00 00 00       	push   $0xc9
c00263d1:	8d 83 16 83 ff ff    	lea    -0x7cea(%ebx),%eax
c00263d7:	50                   	push   %eax
c00263d8:	e8 87 53 00 00       	call   c002b764 <debug_panic>

  while ((inb (LSR_REG) & LSR_THRE) == 0)
    continue;
c00263dd:	90                   	nop
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c00263de:	83 ec 0c             	sub    $0xc,%esp
c00263e1:	68 fd 03 00 00       	push   $0x3fd
c00263e6:	e8 45 fb ff ff       	call   c0025f30 <inb>
c00263eb:	83 c4 10             	add    $0x10,%esp
c00263ee:	0f b6 c0             	movzbl %al,%eax
c00263f1:	83 e0 20             	and    $0x20,%eax
c00263f4:	85 c0                	test   %eax,%eax
c00263f6:	74 e5                	je     c00263dd <putc_poll+0x4a>
  outb (THR_REG, byte);
c00263f8:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00263fc:	83 ec 08             	sub    $0x8,%esp
c00263ff:	50                   	push   %eax
c0026400:	68 f8 03 00 00       	push   $0x3f8
c0026405:	e8 4d fb ff ff       	call   c0025f57 <outb>
c002640a:	83 c4 10             	add    $0x10,%esp
}
c002640d:	90                   	nop
c002640e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026411:	c9                   	leave  
c0026412:	c3                   	ret    

c0026413 <serial_interrupt>:

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0026413:	55                   	push   %ebp
c0026414:	89 e5                	mov    %esp,%ebp
c0026416:	53                   	push   %ebx
c0026417:	83 ec 04             	sub    $0x4,%esp
c002641a:	e8 0d b0 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002641f:	81 c3 59 3f 01 00    	add    $0x13f59,%ebx
  /* Inquire about interrupt in UART.  Without this, we can
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);
c0026425:	68 fa 03 00 00       	push   $0x3fa
c002642a:	e8 01 fb ff ff       	call   c0025f30 <inb>
c002642f:	83 c4 04             	add    $0x4,%esp

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0026432:	eb 1c                	jmp    c0026450 <serial_interrupt+0x3d>
    input_putc (inb (RBR_REG));
c0026434:	68 f8 03 00 00       	push   $0x3f8
c0026439:	e8 f2 fa ff ff       	call   c0025f30 <inb>
c002643e:	83 c4 04             	add    $0x4,%esp
c0026441:	0f b6 c0             	movzbl %al,%eax
c0026444:	83 ec 0c             	sub    $0xc,%esp
c0026447:	50                   	push   %eax
c0026448:	e8 92 1a 00 00       	call   c0027edf <input_putc>
c002644d:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0026450:	e8 7d 1b 00 00       	call   c0027fd2 <input_full>
c0026455:	83 f0 01             	xor    $0x1,%eax
c0026458:	84 c0                	test   %al,%al
c002645a:	74 42                	je     c002649e <serial_interrupt+0x8b>
c002645c:	83 ec 0c             	sub    $0xc,%esp
c002645f:	68 fd 03 00 00       	push   $0x3fd
c0026464:	e8 c7 fa ff ff       	call   c0025f30 <inb>
c0026469:	83 c4 10             	add    $0x10,%esp
c002646c:	0f b6 c0             	movzbl %al,%eax
c002646f:	83 e0 01             	and    $0x1,%eax
c0026472:	85 c0                	test   %eax,%eax
c0026474:	75 be                	jne    c0026434 <serial_interrupt+0x21>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0026476:	eb 26                	jmp    c002649e <serial_interrupt+0x8b>
    outb (THR_REG, intq_getc (&txq));
c0026478:	83 ec 0c             	sub    $0xc,%esp
c002647b:	8d 83 88 1f 00 00    	lea    0x1f88(%ebx),%eax
c0026481:	50                   	push   %eax
c0026482:	e8 b1 1c 00 00       	call   c0028138 <intq_getc>
c0026487:	83 c4 10             	add    $0x10,%esp
c002648a:	0f b6 c0             	movzbl %al,%eax
c002648d:	83 ec 08             	sub    $0x8,%esp
c0026490:	50                   	push   %eax
c0026491:	68 f8 03 00 00       	push   $0x3f8
c0026496:	e8 bc fa ff ff       	call   c0025f57 <outb>
c002649b:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c002649e:	83 ec 0c             	sub    $0xc,%esp
c00264a1:	8d 83 88 1f 00 00    	lea    0x1f88(%ebx),%eax
c00264a7:	50                   	push   %eax
c00264a8:	e8 d1 1b 00 00       	call   c002807e <intq_empty>
c00264ad:	83 c4 10             	add    $0x10,%esp
c00264b0:	83 f0 01             	xor    $0x1,%eax
c00264b3:	84 c0                	test   %al,%al
c00264b5:	74 1a                	je     c00264d1 <serial_interrupt+0xbe>
c00264b7:	83 ec 0c             	sub    $0xc,%esp
c00264ba:	68 fd 03 00 00       	push   $0x3fd
c00264bf:	e8 6c fa ff ff       	call   c0025f30 <inb>
c00264c4:	83 c4 10             	add    $0x10,%esp
c00264c7:	0f b6 c0             	movzbl %al,%eax
c00264ca:	83 e0 20             	and    $0x20,%eax
c00264cd:	85 c0                	test   %eax,%eax
c00264cf:	75 a7                	jne    c0026478 <serial_interrupt+0x65>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c00264d1:	e8 2d fe ff ff       	call   c0026303 <write_ier>
}
c00264d6:	90                   	nop
c00264d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00264da:	c9                   	leave  
c00264db:	c3                   	ret    

c00264dc <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c00264dc:	55                   	push   %ebp
c00264dd:	89 e5                	mov    %esp,%ebp
c00264df:	53                   	push   %ebx
c00264e0:	83 ec 04             	sub    $0x4,%esp
c00264e3:	e8 40 af 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00264e8:	05 90 3e 01 00       	add    $0x13e90,%eax
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c00264ed:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
c00264f1:	76 28                	jbe    c002651b <block_type_name+0x3f>
c00264f3:	83 ec 0c             	sub    $0xc,%esp
c00264f6:	8d 90 d0 83 ff ff    	lea    -0x7c30(%eax),%edx
c00264fc:	52                   	push   %edx
c00264fd:	8d 90 e1 83 ff ff    	lea    -0x7c1f(%eax),%edx
c0026503:	52                   	push   %edx
c0026504:	8d 90 e8 84 ff ff    	lea    -0x7b18(%eax),%edx
c002650a:	52                   	push   %edx
c002650b:	6a 2f                	push   $0x2f
c002650d:	8d 90 f8 83 ff ff    	lea    -0x7c08(%eax),%edx
c0026513:	52                   	push   %edx
c0026514:	89 c3                	mov    %eax,%ebx
c0026516:	e8 49 52 00 00       	call   c002b764 <debug_panic>
  return block_type_names[type];
c002651b:	8b 55 08             	mov    0x8(%ebp),%edx
c002651e:	8b 84 90 d8 01 00 00 	mov    0x1d8(%eax,%edx,4),%eax
}
c0026525:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026528:	c9                   	leave  
c0026529:	c3                   	ret    

c002652a <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c002652a:	55                   	push   %ebp
c002652b:	89 e5                	mov    %esp,%ebp
c002652d:	53                   	push   %ebx
c002652e:	83 ec 04             	sub    $0x4,%esp
c0026531:	e8 f2 ae 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026536:	05 42 3e 01 00       	add    $0x13e42,%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c002653b:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c002653f:	76 28                	jbe    c0026569 <block_get_role+0x3f>
c0026541:	83 ec 0c             	sub    $0xc,%esp
c0026544:	8d 90 0e 84 ff ff    	lea    -0x7bf2(%eax),%edx
c002654a:	52                   	push   %edx
c002654b:	8d 90 e1 83 ff ff    	lea    -0x7c1f(%eax),%edx
c0026551:	52                   	push   %edx
c0026552:	8d 90 20 85 ff ff    	lea    -0x7ae0(%eax),%edx
c0026558:	52                   	push   %edx
c0026559:	6a 38                	push   $0x38
c002655b:	8d 90 f8 83 ff ff    	lea    -0x7c08(%eax),%edx
c0026561:	52                   	push   %edx
c0026562:	89 c3                	mov    %eax,%ebx
c0026564:	e8 fb 51 00 00       	call   c002b764 <debug_panic>
  return block_by_role[role];
c0026569:	8b 55 08             	mov    0x8(%ebp),%edx
c002656c:	8b 84 90 f0 1f 00 00 	mov    0x1ff0(%eax,%edx,4),%eax
}
c0026573:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026576:	c9                   	leave  
c0026577:	c3                   	ret    

c0026578 <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c0026578:	55                   	push   %ebp
c0026579:	89 e5                	mov    %esp,%ebp
c002657b:	53                   	push   %ebx
c002657c:	83 ec 04             	sub    $0x4,%esp
c002657f:	e8 a4 ae 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026584:	05 f4 3d 01 00       	add    $0x13df4,%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c0026589:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c002658d:	76 28                	jbe    c00265b7 <block_set_role+0x3f>
c002658f:	83 ec 0c             	sub    $0xc,%esp
c0026592:	8d 90 0e 84 ff ff    	lea    -0x7bf2(%eax),%edx
c0026598:	52                   	push   %edx
c0026599:	8d 90 e1 83 ff ff    	lea    -0x7c1f(%eax),%edx
c002659f:	52                   	push   %edx
c00265a0:	8d 90 30 85 ff ff    	lea    -0x7ad0(%eax),%edx
c00265a6:	52                   	push   %edx
c00265a7:	6a 40                	push   $0x40
c00265a9:	8d 90 f8 83 ff ff    	lea    -0x7c08(%eax),%edx
c00265af:	52                   	push   %edx
c00265b0:	89 c3                	mov    %eax,%ebx
c00265b2:	e8 ad 51 00 00       	call   c002b764 <debug_panic>
  block_by_role[role] = block;
c00265b7:	8b 55 08             	mov    0x8(%ebp),%edx
c00265ba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00265bd:	89 8c 90 f0 1f 00 00 	mov    %ecx,0x1ff0(%eax,%edx,4)
}
c00265c4:	90                   	nop
c00265c5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00265c8:	c9                   	leave  
c00265c9:	c3                   	ret    

c00265ca <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c00265ca:	55                   	push   %ebp
c00265cb:	89 e5                	mov    %esp,%ebp
c00265cd:	53                   	push   %ebx
c00265ce:	83 ec 04             	sub    $0x4,%esp
c00265d1:	e8 52 ae 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00265d6:	05 a2 3d 01 00       	add    $0x13da2,%eax
  return list_elem_to_block (list_begin (&all_blocks));
c00265db:	83 ec 0c             	sub    $0xc,%esp
c00265de:	8d 90 c8 01 00 00    	lea    0x1c8(%eax),%edx
c00265e4:	52                   	push   %edx
c00265e5:	89 c3                	mov    %eax,%ebx
c00265e7:	e8 c5 54 00 00       	call   c002bab1 <list_begin>
c00265ec:	83 c4 10             	add    $0x10,%esp
c00265ef:	83 ec 0c             	sub    $0xc,%esp
c00265f2:	50                   	push   %eax
c00265f3:	e8 0e 04 00 00       	call   c0026a06 <list_elem_to_block>
c00265f8:	83 c4 10             	add    $0x10,%esp
}
c00265fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00265fe:	c9                   	leave  
c00265ff:	c3                   	ret    

c0026600 <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c0026600:	55                   	push   %ebp
c0026601:	89 e5                	mov    %esp,%ebp
c0026603:	53                   	push   %ebx
c0026604:	83 ec 04             	sub    $0x4,%esp
c0026607:	e8 1c ae 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002660c:	05 6c 3d 01 00       	add    $0x13d6c,%eax
  return list_elem_to_block (list_next (&block->list_elem));
c0026611:	8b 55 08             	mov    0x8(%ebp),%edx
c0026614:	83 ec 0c             	sub    $0xc,%esp
c0026617:	52                   	push   %edx
c0026618:	89 c3                	mov    %eax,%ebx
c002661a:	e8 dc 54 00 00       	call   c002bafb <list_next>
c002661f:	83 c4 10             	add    $0x10,%esp
c0026622:	83 ec 0c             	sub    $0xc,%esp
c0026625:	50                   	push   %eax
c0026626:	e8 db 03 00 00       	call   c0026a06 <list_elem_to_block>
c002662b:	83 c4 10             	add    $0x10,%esp
}
c002662e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026631:	c9                   	leave  
c0026632:	c3                   	ret    

c0026633 <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c0026633:	55                   	push   %ebp
c0026634:	89 e5                	mov    %esp,%ebp
c0026636:	53                   	push   %ebx
c0026637:	83 ec 14             	sub    $0x14,%esp
c002663a:	e8 ed ad 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002663f:	81 c3 39 3d 01 00    	add    $0x13d39,%ebx
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0026645:	83 ec 0c             	sub    $0xc,%esp
c0026648:	8d 83 c8 01 00 00    	lea    0x1c8(%ebx),%eax
c002664e:	50                   	push   %eax
c002664f:	e8 5d 54 00 00       	call   c002bab1 <list_begin>
c0026654:	83 c4 10             	add    $0x10,%esp
c0026657:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002665a:	eb 3b                	jmp    c0026697 <block_get_by_name+0x64>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
c002665c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002665f:	83 c0 04             	add    $0x4,%eax
c0026662:	83 e8 04             	sub    $0x4,%eax
c0026665:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!strcmp (name, block->name))
c0026668:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002666b:	83 c0 08             	add    $0x8,%eax
c002666e:	83 ec 08             	sub    $0x8,%esp
c0026671:	50                   	push   %eax
c0026672:	ff 75 08             	push   0x8(%ebp)
c0026675:	e8 cc 3e 00 00       	call   c002a546 <strcmp>
c002667a:	83 c4 10             	add    $0x10,%esp
c002667d:	85 c0                	test   %eax,%eax
c002667f:	75 05                	jne    c0026686 <block_get_by_name+0x53>
        return block;
c0026681:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026684:	eb 2d                	jmp    c00266b3 <block_get_by_name+0x80>
       e = list_next (e))
c0026686:	83 ec 0c             	sub    $0xc,%esp
c0026689:	ff 75 f4             	push   -0xc(%ebp)
c002668c:	e8 6a 54 00 00       	call   c002bafb <list_next>
c0026691:	83 c4 10             	add    $0x10,%esp
c0026694:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0026697:	83 ec 0c             	sub    $0xc,%esp
c002669a:	8d 83 c8 01 00 00    	lea    0x1c8(%ebx),%eax
c00266a0:	50                   	push   %eax
c00266a1:	e8 b6 54 00 00       	call   c002bb5c <list_end>
c00266a6:	83 c4 10             	add    $0x10,%esp
c00266a9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00266ac:	75 ae                	jne    c002665c <block_get_by_name+0x29>
    }

  return NULL;
c00266ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00266b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00266b6:	c9                   	leave  
c00266b7:	c3                   	ret    

c00266b8 <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c00266b8:	55                   	push   %ebp
c00266b9:	89 e5                	mov    %esp,%ebp
c00266bb:	56                   	push   %esi
c00266bc:	53                   	push   %ebx
c00266bd:	e8 6a ad 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00266c2:	81 c3 b6 3c 01 00    	add    $0x13cb6,%ebx
  if (sector >= block->size)
c00266c8:	8b 45 08             	mov    0x8(%ebp),%eax
c00266cb:	8b 40 1c             	mov    0x1c(%eax),%eax
c00266ce:	39 45 0c             	cmp    %eax,0xc(%ebp)
c00266d1:	72 38                	jb     c002670b <check_sector+0x53>
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c00266d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00266d6:	8b 70 1c             	mov    0x1c(%eax),%esi
c00266d9:	83 ec 0c             	sub    $0xc,%esp
c00266dc:	ff 75 08             	push   0x8(%ebp)
c00266df:	e8 30 01 00 00       	call   c0026814 <block_name>
c00266e4:	83 c4 10             	add    $0x10,%esp
c00266e7:	83 ec 04             	sub    $0x4,%esp
c00266ea:	56                   	push   %esi
c00266eb:	ff 75 0c             	push   0xc(%ebp)
c00266ee:	50                   	push   %eax
c00266ef:	8d 83 24 84 ff ff    	lea    -0x7bdc(%ebx),%eax
c00266f5:	50                   	push   %eax
c00266f6:	8d 83 40 85 ff ff    	lea    -0x7ac0(%ebx),%eax
c00266fc:	50                   	push   %eax
c00266fd:	6a 6f                	push   $0x6f
c00266ff:	8d 83 f8 83 ff ff    	lea    -0x7c08(%ebx),%eax
c0026705:	50                   	push   %eax
c0026706:	e8 59 50 00 00       	call   c002b764 <debug_panic>
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c002670b:	90                   	nop
c002670c:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002670f:	5b                   	pop    %ebx
c0026710:	5e                   	pop    %esi
c0026711:	5d                   	pop    %ebp
c0026712:	c3                   	ret    

c0026713 <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c0026713:	55                   	push   %ebp
c0026714:	89 e5                	mov    %esp,%ebp
c0026716:	83 ec 08             	sub    $0x8,%esp
c0026719:	e8 0a ad 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002671e:	05 5a 3c 01 00       	add    $0x13c5a,%eax
  check_sector (block, sector);
c0026723:	83 ec 08             	sub    $0x8,%esp
c0026726:	ff 75 0c             	push   0xc(%ebp)
c0026729:	ff 75 08             	push   0x8(%ebp)
c002672c:	e8 87 ff ff ff       	call   c00266b8 <check_sector>
c0026731:	83 c4 10             	add    $0x10,%esp
  block->ops->read (block->aux, sector, buffer);
c0026734:	8b 45 08             	mov    0x8(%ebp),%eax
c0026737:	8b 40 20             	mov    0x20(%eax),%eax
c002673a:	8b 00                	mov    (%eax),%eax
c002673c:	8b 55 08             	mov    0x8(%ebp),%edx
c002673f:	8b 52 24             	mov    0x24(%edx),%edx
c0026742:	83 ec 04             	sub    $0x4,%esp
c0026745:	ff 75 10             	push   0x10(%ebp)
c0026748:	ff 75 0c             	push   0xc(%ebp)
c002674b:	52                   	push   %edx
c002674c:	ff d0                	call   *%eax
c002674e:	83 c4 10             	add    $0x10,%esp
  block->read_cnt++;
c0026751:	8b 45 08             	mov    0x8(%ebp),%eax
c0026754:	8b 50 2c             	mov    0x2c(%eax),%edx
c0026757:	8b 40 28             	mov    0x28(%eax),%eax
c002675a:	83 c0 01             	add    $0x1,%eax
c002675d:	83 d2 00             	adc    $0x0,%edx
c0026760:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0026763:	89 41 28             	mov    %eax,0x28(%ecx)
c0026766:	89 51 2c             	mov    %edx,0x2c(%ecx)
}
c0026769:	90                   	nop
c002676a:	c9                   	leave  
c002676b:	c3                   	ret    

c002676c <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c002676c:	55                   	push   %ebp
c002676d:	89 e5                	mov    %esp,%ebp
c002676f:	53                   	push   %ebx
c0026770:	83 ec 04             	sub    $0x4,%esp
c0026773:	e8 b4 ac 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0026778:	81 c3 00 3c 01 00    	add    $0x13c00,%ebx
  check_sector (block, sector);
c002677e:	83 ec 08             	sub    $0x8,%esp
c0026781:	ff 75 0c             	push   0xc(%ebp)
c0026784:	ff 75 08             	push   0x8(%ebp)
c0026787:	e8 2c ff ff ff       	call   c00266b8 <check_sector>
c002678c:	83 c4 10             	add    $0x10,%esp
  ASSERT (block->type != BLOCK_FOREIGN);
c002678f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026792:	8b 40 18             	mov    0x18(%eax),%eax
c0026795:	83 f8 05             	cmp    $0x5,%eax
c0026798:	75 29                	jne    c00267c3 <block_write+0x57>
c002679a:	83 ec 0c             	sub    $0xc,%esp
c002679d:	8d 83 57 84 ff ff    	lea    -0x7ba9(%ebx),%eax
c00267a3:	50                   	push   %eax
c00267a4:	8d 83 e1 83 ff ff    	lea    -0x7c1f(%ebx),%eax
c00267aa:	50                   	push   %eax
c00267ab:	8d 83 50 85 ff ff    	lea    -0x7ab0(%ebx),%eax
c00267b1:	50                   	push   %eax
c00267b2:	68 89 00 00 00       	push   $0x89
c00267b7:	8d 83 f8 83 ff ff    	lea    -0x7c08(%ebx),%eax
c00267bd:	50                   	push   %eax
c00267be:	e8 a1 4f 00 00       	call   c002b764 <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c00267c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00267c6:	8b 40 20             	mov    0x20(%eax),%eax
c00267c9:	8b 40 04             	mov    0x4(%eax),%eax
c00267cc:	8b 55 08             	mov    0x8(%ebp),%edx
c00267cf:	8b 52 24             	mov    0x24(%edx),%edx
c00267d2:	83 ec 04             	sub    $0x4,%esp
c00267d5:	ff 75 10             	push   0x10(%ebp)
c00267d8:	ff 75 0c             	push   0xc(%ebp)
c00267db:	52                   	push   %edx
c00267dc:	ff d0                	call   *%eax
c00267de:	83 c4 10             	add    $0x10,%esp
  block->write_cnt++;
c00267e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00267e4:	8b 50 34             	mov    0x34(%eax),%edx
c00267e7:	8b 40 30             	mov    0x30(%eax),%eax
c00267ea:	83 c0 01             	add    $0x1,%eax
c00267ed:	83 d2 00             	adc    $0x0,%edx
c00267f0:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00267f3:	89 41 30             	mov    %eax,0x30(%ecx)
c00267f6:	89 51 34             	mov    %edx,0x34(%ecx)
}
c00267f9:	90                   	nop
c00267fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00267fd:	c9                   	leave  
c00267fe:	c3                   	ret    

c00267ff <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
c00267ff:	55                   	push   %ebp
c0026800:	89 e5                	mov    %esp,%ebp
c0026802:	e8 21 ac 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026807:	05 71 3b 01 00       	add    $0x13b71,%eax
  return block->size;
c002680c:	8b 45 08             	mov    0x8(%ebp),%eax
c002680f:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0026812:	5d                   	pop    %ebp
c0026813:	c3                   	ret    

c0026814 <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
c0026814:	55                   	push   %ebp
c0026815:	89 e5                	mov    %esp,%ebp
c0026817:	e8 0c ac 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002681c:	05 5c 3b 01 00       	add    $0x13b5c,%eax
  return block->name;
c0026821:	8b 45 08             	mov    0x8(%ebp),%eax
c0026824:	83 c0 08             	add    $0x8,%eax
}
c0026827:	5d                   	pop    %ebp
c0026828:	c3                   	ret    

c0026829 <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
c0026829:	55                   	push   %ebp
c002682a:	89 e5                	mov    %esp,%ebp
c002682c:	e8 f7 ab 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026831:	05 47 3b 01 00       	add    $0x13b47,%eax
  return block->type;
c0026836:	8b 45 08             	mov    0x8(%ebp),%eax
c0026839:	8b 40 18             	mov    0x18(%eax),%eax
}
c002683c:	5d                   	pop    %ebp
c002683d:	c3                   	ret    

c002683e <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c002683e:	55                   	push   %ebp
c002683f:	89 e5                	mov    %esp,%ebp
c0026841:	57                   	push   %edi
c0026842:	56                   	push   %esi
c0026843:	53                   	push   %ebx
c0026844:	83 ec 2c             	sub    $0x2c,%esp
c0026847:	e8 e0 ab 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002684c:	81 c3 2c 3b 01 00    	add    $0x13b2c,%ebx
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0026852:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0026859:	eb 65                	jmp    c00268c0 <block_print_stats+0x82>
    {
      struct block *block = block_by_role[i];
c002685b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002685e:	8b 84 83 f0 1f 00 00 	mov    0x1ff0(%ebx,%eax,4),%eax
c0026865:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (block != NULL)
c0026868:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002686c:	74 4e                	je     c00268bc <block_print_stats+0x7e>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c002686e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0026871:	8b 50 34             	mov    0x34(%eax),%edx
c0026874:	8b 40 30             	mov    0x30(%eax),%eax
c0026877:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002687a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c002687d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0026880:	8b 70 28             	mov    0x28(%eax),%esi
c0026883:	8b 78 2c             	mov    0x2c(%eax),%edi
c0026886:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0026889:	8b 40 18             	mov    0x18(%eax),%eax
c002688c:	83 ec 0c             	sub    $0xc,%esp
c002688f:	50                   	push   %eax
c0026890:	e8 47 fc ff ff       	call   c00264dc <block_type_name>
c0026895:	83 c4 10             	add    $0x10,%esp
c0026898:	89 c2                	mov    %eax,%edx
                  block->name, block_type_name (block->type),
c002689a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002689d:	83 c0 08             	add    $0x8,%eax
          printf ("%s (%s): %llu reads, %llu writes\n",
c00268a0:	83 ec 04             	sub    $0x4,%esp
c00268a3:	ff 75 d4             	push   -0x2c(%ebp)
c00268a6:	ff 75 d0             	push   -0x30(%ebp)
c00268a9:	57                   	push   %edi
c00268aa:	56                   	push   %esi
c00268ab:	52                   	push   %edx
c00268ac:	50                   	push   %eax
c00268ad:	8d 83 74 84 ff ff    	lea    -0x7b8c(%ebx),%eax
c00268b3:	50                   	push   %eax
c00268b4:	e8 2c 26 00 00       	call   c0028ee5 <printf>
c00268b9:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c00268bc:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c00268c0:	83 7d e4 03          	cmpl   $0x3,-0x1c(%ebp)
c00268c4:	7e 95                	jle    c002685b <block_print_stats+0x1d>
                  block->read_cnt, block->write_cnt);
        }
    }
}
c00268c6:	90                   	nop
c00268c7:	90                   	nop
c00268c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00268cb:	5b                   	pop    %ebx
c00268cc:	5e                   	pop    %esi
c00268cd:	5f                   	pop    %edi
c00268ce:	5d                   	pop    %ebp
c00268cf:	c3                   	ret    

c00268d0 <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c00268d0:	55                   	push   %ebp
c00268d1:	89 e5                	mov    %esp,%ebp
c00268d3:	53                   	push   %ebx
c00268d4:	83 ec 14             	sub    $0x14,%esp
c00268d7:	e8 50 ab 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00268dc:	81 c3 9c 3a 01 00    	add    $0x13a9c,%ebx
  struct block *block = malloc (sizeof *block);
c00268e2:	83 ec 0c             	sub    $0xc,%esp
c00268e5:	6a 38                	push   $0x38
c00268e7:	e8 27 de ff ff       	call   c0024713 <malloc>
c00268ec:	83 c4 10             	add    $0x10,%esp
c00268ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (block == NULL)
c00268f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00268f6:	75 1f                	jne    c0026917 <block_register+0x47>
    PANIC ("Failed to allocate memory for block device descriptor");
c00268f8:	8d 83 98 84 ff ff    	lea    -0x7b68(%ebx),%eax
c00268fe:	50                   	push   %eax
c00268ff:	8d 83 5c 85 ff ff    	lea    -0x7aa4(%ebx),%eax
c0026905:	50                   	push   %eax
c0026906:	68 c1 00 00 00       	push   $0xc1
c002690b:	8d 83 f8 83 ff ff    	lea    -0x7c08(%ebx),%eax
c0026911:	50                   	push   %eax
c0026912:	e8 4d 4e 00 00       	call   c002b764 <debug_panic>

  list_push_back (&all_blocks, &block->list_elem);
c0026917:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002691a:	83 ec 08             	sub    $0x8,%esp
c002691d:	50                   	push   %eax
c002691e:	8d 83 c8 01 00 00    	lea    0x1c8(%ebx),%eax
c0026924:	50                   	push   %eax
c0026925:	e8 20 56 00 00       	call   c002bf4a <list_push_back>
c002692a:	83 c4 10             	add    $0x10,%esp
  strlcpy (block->name, name, sizeof block->name);
c002692d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026930:	83 c0 08             	add    $0x8,%eax
c0026933:	83 ec 04             	sub    $0x4,%esp
c0026936:	6a 10                	push   $0x10
c0026938:	ff 75 08             	push   0x8(%ebp)
c002693b:	50                   	push   %eax
c002693c:	e8 c2 41 00 00       	call   c002ab03 <strlcpy>
c0026941:	83 c4 10             	add    $0x10,%esp
  block->type = type;
c0026944:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026947:	8b 55 0c             	mov    0xc(%ebp),%edx
c002694a:	89 50 18             	mov    %edx,0x18(%eax)
  block->size = size;
c002694d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026950:	8b 55 14             	mov    0x14(%ebp),%edx
c0026953:	89 50 1c             	mov    %edx,0x1c(%eax)
  block->ops = ops;
c0026956:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026959:	8b 55 18             	mov    0x18(%ebp),%edx
c002695c:	89 50 20             	mov    %edx,0x20(%eax)
  block->aux = aux;
c002695f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026962:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0026965:	89 50 24             	mov    %edx,0x24(%eax)
  block->read_cnt = 0;
c0026968:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002696b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0026972:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  block->write_cnt = 0;
c0026979:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002697c:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
c0026983:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c002698a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002698d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0026990:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026993:	83 c2 08             	add    $0x8,%edx
c0026996:	83 ec 04             	sub    $0x4,%esp
c0026999:	50                   	push   %eax
c002699a:	52                   	push   %edx
c002699b:	8d 83 ce 84 ff ff    	lea    -0x7b32(%ebx),%eax
c00269a1:	50                   	push   %eax
c00269a2:	e8 3e 25 00 00       	call   c0028ee5 <printf>
c00269a7:	83 c4 10             	add    $0x10,%esp
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c00269aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00269ad:	8b 40 1c             	mov    0x1c(%eax),%eax
c00269b0:	ba 00 00 00 00       	mov    $0x0,%edx
c00269b5:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c00269b9:	c1 e0 09             	shl    $0x9,%eax
c00269bc:	83 ec 08             	sub    $0x8,%esp
c00269bf:	52                   	push   %edx
c00269c0:	50                   	push   %eax
c00269c1:	e8 5b 33 00 00       	call   c0029d21 <print_human_readable_size>
c00269c6:	83 c4 10             	add    $0x10,%esp
  printf (")");
c00269c9:	83 ec 0c             	sub    $0xc,%esp
c00269cc:	6a 29                	push   $0x29
c00269ce:	e8 b5 76 00 00       	call   c002e088 <putchar>
c00269d3:	83 c4 10             	add    $0x10,%esp
  if (extra_info != NULL)
c00269d6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00269da:	74 15                	je     c00269f1 <block_register+0x121>
    printf (", %s", extra_info);
c00269dc:	83 ec 08             	sub    $0x8,%esp
c00269df:	ff 75 10             	push   0x10(%ebp)
c00269e2:	8d 83 e0 84 ff ff    	lea    -0x7b20(%ebx),%eax
c00269e8:	50                   	push   %eax
c00269e9:	e8 f7 24 00 00       	call   c0028ee5 <printf>
c00269ee:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c00269f1:	83 ec 0c             	sub    $0xc,%esp
c00269f4:	6a 0a                	push   $0xa
c00269f6:	e8 8d 76 00 00       	call   c002e088 <putchar>
c00269fb:	83 c4 10             	add    $0x10,%esp

  return block;
c00269fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0026a01:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026a04:	c9                   	leave  
c0026a05:	c3                   	ret    

c0026a06 <list_elem_to_block>:

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
c0026a06:	55                   	push   %ebp
c0026a07:	89 e5                	mov    %esp,%ebp
c0026a09:	53                   	push   %ebx
c0026a0a:	83 ec 04             	sub    $0x4,%esp
c0026a0d:	e8 16 aa 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026a12:	05 66 39 01 00       	add    $0x13966,%eax
  return (list_elem != list_end (&all_blocks)
c0026a17:	83 ec 0c             	sub    $0xc,%esp
c0026a1a:	8d 90 c8 01 00 00    	lea    0x1c8(%eax),%edx
c0026a20:	52                   	push   %edx
c0026a21:	89 c3                	mov    %eax,%ebx
c0026a23:	e8 34 51 00 00       	call   c002bb5c <list_end>
c0026a28:	83 c4 10             	add    $0x10,%esp
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0026a2b:	39 45 08             	cmp    %eax,0x8(%ebp)
c0026a2e:	74 0b                	je     c0026a3b <list_elem_to_block+0x35>
          ? list_entry (list_elem, struct block, list_elem)
c0026a30:	8b 45 08             	mov    0x8(%ebp),%eax
c0026a33:	83 c0 04             	add    $0x4,%eax
          : NULL);
c0026a36:	83 e8 04             	sub    $0x4,%eax
c0026a39:	eb 05                	jmp    c0026a40 <list_elem_to_block+0x3a>
c0026a3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0026a40:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026a43:	c9                   	leave  
c0026a44:	c3                   	ret    

c0026a45 <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c0026a45:	55                   	push   %ebp
c0026a46:	89 e5                	mov    %esp,%ebp
c0026a48:	53                   	push   %ebx
c0026a49:	83 ec 14             	sub    $0x14,%esp
c0026a4c:	e8 db a9 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0026a51:	81 c3 27 39 01 00    	add    $0x13927,%ebx
  int part_nr = 0;
c0026a57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  read_partition_table (block, 0, 0, &part_nr);
c0026a5e:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0026a61:	50                   	push   %eax
c0026a62:	6a 00                	push   $0x0
c0026a64:	6a 00                	push   $0x0
c0026a66:	ff 75 08             	push   0x8(%ebp)
c0026a69:	e8 31 00 00 00       	call   c0026a9f <read_partition_table>
c0026a6e:	83 c4 10             	add    $0x10,%esp
  if (part_nr == 0)
c0026a71:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a74:	85 c0                	test   %eax,%eax
c0026a76:	75 21                	jne    c0026a99 <partition_scan+0x54>
    printf ("%s: Device contains no partitions\n", block_name (block));
c0026a78:	83 ec 0c             	sub    $0xc,%esp
c0026a7b:	ff 75 08             	push   0x8(%ebp)
c0026a7e:	e8 91 fd ff ff       	call   c0026814 <block_name>
c0026a83:	83 c4 10             	add    $0x10,%esp
c0026a86:	83 ec 08             	sub    $0x8,%esp
c0026a89:	50                   	push   %eax
c0026a8a:	8d 83 6c 85 ff ff    	lea    -0x7a94(%ebx),%eax
c0026a90:	50                   	push   %eax
c0026a91:	e8 4f 24 00 00       	call   c0028ee5 <printf>
c0026a96:	83 c4 10             	add    $0x10,%esp
}
c0026a99:	90                   	nop
c0026a9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026a9d:	c9                   	leave  
c0026a9e:	c3                   	ret    

c0026a9f <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c0026a9f:	55                   	push   %ebp
c0026aa0:	89 e5                	mov    %esp,%ebp
c0026aa2:	56                   	push   %esi
c0026aa3:	53                   	push   %ebx
c0026aa4:	83 ec 10             	sub    $0x10,%esp
c0026aa7:	e8 80 a9 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0026aac:	81 c3 cc 38 01 00    	add    $0x138cc,%ebx

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c0026ab2:	83 ec 0c             	sub    $0xc,%esp
c0026ab5:	ff 75 08             	push   0x8(%ebp)
c0026ab8:	e8 42 fd ff ff       	call   c00267ff <block_size>
c0026abd:	83 c4 10             	add    $0x10,%esp
c0026ac0:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0026ac3:	72 29                	jb     c0026aee <read_partition_table+0x4f>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0026ac5:	83 ec 0c             	sub    $0xc,%esp
c0026ac8:	ff 75 08             	push   0x8(%ebp)
c0026acb:	e8 44 fd ff ff       	call   c0026814 <block_name>
c0026ad0:	83 c4 10             	add    $0x10,%esp
c0026ad3:	83 ec 04             	sub    $0x4,%esp
c0026ad6:	ff 75 0c             	push   0xc(%ebp)
c0026ad9:	50                   	push   %eax
c0026ada:	8d 83 90 85 ff ff    	lea    -0x7a70(%ebx),%eax
c0026ae0:	50                   	push   %eax
c0026ae1:	e8 ff 23 00 00       	call   c0028ee5 <printf>
c0026ae6:	83 c4 10             	add    $0x10,%esp
              block_name (block), sector);
      return;
c0026ae9:	e9 e5 01 00 00       	jmp    c0026cd3 <read_partition_table+0x234>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c0026aee:	83 ec 0c             	sub    $0xc,%esp
c0026af1:	68 00 02 00 00       	push   $0x200
c0026af6:	e8 18 dc ff ff       	call   c0024713 <malloc>
c0026afb:	83 c4 10             	add    $0x10,%esp
c0026afe:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pt == NULL)
c0026b01:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0026b05:	75 1c                	jne    c0026b23 <read_partition_table+0x84>
    PANIC ("Failed to allocate memory for partition table.");
c0026b07:	8d 83 c8 85 ff ff    	lea    -0x7a38(%ebx),%eax
c0026b0d:	50                   	push   %eax
c0026b0e:	8d 83 50 87 ff ff    	lea    -0x78b0(%ebx),%eax
c0026b14:	50                   	push   %eax
c0026b15:	6a 5a                	push   $0x5a
c0026b17:	8d 83 f7 85 ff ff    	lea    -0x7a09(%ebx),%eax
c0026b1d:	50                   	push   %eax
c0026b1e:	e8 41 4c 00 00       	call   c002b764 <debug_panic>
  block_read (block, 0, pt);
c0026b23:	83 ec 04             	sub    $0x4,%esp
c0026b26:	ff 75 f0             	push   -0x10(%ebp)
c0026b29:	6a 00                	push   $0x0
c0026b2b:	ff 75 08             	push   0x8(%ebp)
c0026b2e:	e8 e0 fb ff ff       	call   c0026713 <block_read>
c0026b33:	83 c4 10             	add    $0x10,%esp

  /* Check signature. */
  if (pt->signature != 0xaa55)
c0026b36:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026b39:	0f b7 80 fe 01 00 00 	movzwl 0x1fe(%eax),%eax
c0026b40:	66 3d 55 aa          	cmp    $0xaa55,%ax
c0026b44:	74 60                	je     c0026ba6 <read_partition_table+0x107>
    {
      if (primary_extended_sector == 0)
c0026b46:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0026b4a:	75 23                	jne    c0026b6f <read_partition_table+0xd0>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c0026b4c:	83 ec 0c             	sub    $0xc,%esp
c0026b4f:	ff 75 08             	push   0x8(%ebp)
c0026b52:	e8 bd fc ff ff       	call   c0026814 <block_name>
c0026b57:	83 c4 10             	add    $0x10,%esp
c0026b5a:	83 ec 08             	sub    $0x8,%esp
c0026b5d:	50                   	push   %eax
c0026b5e:	8d 83 14 86 ff ff    	lea    -0x79ec(%ebx),%eax
c0026b64:	50                   	push   %eax
c0026b65:	e8 7b 23 00 00       	call   c0028ee5 <printf>
c0026b6a:	83 c4 10             	add    $0x10,%esp
c0026b6d:	eb 24                	jmp    c0026b93 <read_partition_table+0xf4>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c0026b6f:	83 ec 0c             	sub    $0xc,%esp
c0026b72:	ff 75 08             	push   0x8(%ebp)
c0026b75:	e8 9a fc ff ff       	call   c0026814 <block_name>
c0026b7a:	83 c4 10             	add    $0x10,%esp
c0026b7d:	83 ec 04             	sub    $0x4,%esp
c0026b80:	ff 75 0c             	push   0xc(%ebp)
c0026b83:	50                   	push   %eax
c0026b84:	8d 83 3c 86 ff ff    	lea    -0x79c4(%ebx),%eax
c0026b8a:	50                   	push   %eax
c0026b8b:	e8 55 23 00 00       	call   c0028ee5 <printf>
c0026b90:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c0026b93:	83 ec 0c             	sub    $0xc,%esp
c0026b96:	ff 75 f0             	push   -0x10(%ebp)
c0026b99:	e8 b4 de ff ff       	call   c0024a52 <free>
c0026b9e:	83 c4 10             	add    $0x10,%esp
      return;
c0026ba1:	e9 2d 01 00 00       	jmp    c0026cd3 <read_partition_table+0x234>
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0026ba6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026bad:	e9 09 01 00 00       	jmp    c0026cbb <read_partition_table+0x21c>
    {
      struct partition_table_entry *e = &pt->partitions[i];
c0026bb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026bb5:	83 c0 1b             	add    $0x1b,%eax
c0026bb8:	c1 e0 04             	shl    $0x4,%eax
c0026bbb:	89 c2                	mov    %eax,%edx
c0026bbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026bc0:	01 d0                	add    %edx,%eax
c0026bc2:	83 c0 0e             	add    $0xe,%eax
c0026bc5:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (e->size == 0 || e->type == 0)
c0026bc8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026bcb:	8b 40 0c             	mov    0xc(%eax),%eax
c0026bce:	85 c0                	test   %eax,%eax
c0026bd0:	0f 84 e1 00 00 00    	je     c0026cb7 <read_partition_table+0x218>
c0026bd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026bd9:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0026bdd:	84 c0                	test   %al,%al
c0026bdf:	0f 84 d2 00 00 00    	je     c0026cb7 <read_partition_table+0x218>
        {
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
c0026be5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026be8:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0026bec:	3c 05                	cmp    $0x5,%al
c0026bee:	74 21                	je     c0026c11 <read_partition_table+0x172>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c0026bf0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026bf3:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0026bf7:	3c 0f                	cmp    $0xf,%al
c0026bf9:	74 16                	je     c0026c11 <read_partition_table+0x172>
               || e->type == 0x85    /* Linux extended partition. */
c0026bfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026bfe:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0026c02:	3c 85                	cmp    $0x85,%al
c0026c04:	74 0b                	je     c0026c11 <read_partition_table+0x172>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0026c06:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026c09:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0026c0d:	3c c5                	cmp    $0xc5,%al
c0026c0f:	75 67                	jne    c0026c78 <read_partition_table+0x1d9>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0026c11:	83 ec 0c             	sub    $0xc,%esp
c0026c14:	ff 75 08             	push   0x8(%ebp)
c0026c17:	e8 f8 fb ff ff       	call   c0026814 <block_name>
c0026c1c:	83 c4 10             	add    $0x10,%esp
c0026c1f:	83 ec 04             	sub    $0x4,%esp
c0026c22:	ff 75 0c             	push   0xc(%ebp)
c0026c25:	50                   	push   %eax
c0026c26:	8d 83 70 86 ff ff    	lea    -0x7990(%ebx),%eax
c0026c2c:	50                   	push   %eax
c0026c2d:	e8 b3 22 00 00       	call   c0028ee5 <printf>
c0026c32:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c0026c35:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0026c39:	75 1e                	jne    c0026c59 <read_partition_table+0x1ba>
            read_partition_table (block, e->offset, e->offset, part_nr);
c0026c3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026c3e:	8b 50 08             	mov    0x8(%eax),%edx
c0026c41:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026c44:	8b 40 08             	mov    0x8(%eax),%eax
c0026c47:	ff 75 14             	push   0x14(%ebp)
c0026c4a:	52                   	push   %edx
c0026c4b:	50                   	push   %eax
c0026c4c:	ff 75 08             	push   0x8(%ebp)
c0026c4f:	e8 4b fe ff ff       	call   c0026a9f <read_partition_table>
c0026c54:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c0026c57:	eb 5e                	jmp    c0026cb7 <read_partition_table+0x218>
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c0026c59:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026c5c:	8b 50 08             	mov    0x8(%eax),%edx
c0026c5f:	8b 45 10             	mov    0x10(%ebp),%eax
c0026c62:	01 d0                	add    %edx,%eax
c0026c64:	ff 75 14             	push   0x14(%ebp)
c0026c67:	ff 75 10             	push   0x10(%ebp)
c0026c6a:	50                   	push   %eax
c0026c6b:	ff 75 08             	push   0x8(%ebp)
c0026c6e:	e8 2c fe ff ff       	call   c0026a9f <read_partition_table>
c0026c73:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c0026c76:	eb 3f                	jmp    c0026cb7 <read_partition_table+0x218>
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c0026c78:	8b 45 14             	mov    0x14(%ebp),%eax
c0026c7b:	8b 00                	mov    (%eax),%eax
c0026c7d:	8d 50 01             	lea    0x1(%eax),%edx
c0026c80:	8b 45 14             	mov    0x14(%ebp),%eax
c0026c83:	89 10                	mov    %edx,(%eax)

          found_partition (block, e->type, e->offset + sector,
c0026c85:	8b 45 14             	mov    0x14(%ebp),%eax
c0026c88:	8b 08                	mov    (%eax),%ecx
c0026c8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026c8d:	8b 50 0c             	mov    0xc(%eax),%edx
c0026c90:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026c93:	8b 70 08             	mov    0x8(%eax),%esi
c0026c96:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026c99:	01 c6                	add    %eax,%esi
c0026c9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026c9e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0026ca2:	0f b6 c0             	movzbl %al,%eax
c0026ca5:	83 ec 0c             	sub    $0xc,%esp
c0026ca8:	51                   	push   %ecx
c0026ca9:	52                   	push   %edx
c0026caa:	56                   	push   %esi
c0026cab:	50                   	push   %eax
c0026cac:	ff 75 08             	push   0x8(%ebp)
c0026caf:	e8 26 00 00 00       	call   c0026cda <found_partition>
c0026cb4:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0026cb7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026cbb:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0026cbf:	0f 86 ed fe ff ff    	jbe    c0026bb2 <read_partition_table+0x113>
                           e->size, *part_nr);
        }
    }

  free (pt);
c0026cc5:	83 ec 0c             	sub    $0xc,%esp
c0026cc8:	ff 75 f0             	push   -0x10(%ebp)
c0026ccb:	e8 82 dd ff ff       	call   c0024a52 <free>
c0026cd0:	83 c4 10             	add    $0x10,%esp
}
c0026cd3:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0026cd6:	5b                   	pop    %ebx
c0026cd7:	5e                   	pop    %esi
c0026cd8:	5d                   	pop    %ebp
c0026cd9:	c3                   	ret    

c0026cda <found_partition>:
   if so then add it to the proper element of partitions[]. */
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
c0026cda:	55                   	push   %ebp
c0026cdb:	89 e5                	mov    %esp,%ebp
c0026cdd:	57                   	push   %edi
c0026cde:	56                   	push   %esi
c0026cdf:	53                   	push   %ebx
c0026ce0:	81 ec bc 00 00 00    	sub    $0xbc,%esp
c0026ce6:	e8 41 a7 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0026ceb:	81 c3 8d 36 01 00    	add    $0x1368d,%ebx
c0026cf1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026cf4:	88 85 44 ff ff ff    	mov    %al,-0xbc(%ebp)
  if (start >= block_size (block))
c0026cfa:	83 ec 0c             	sub    $0xc,%esp
c0026cfd:	ff 75 08             	push   0x8(%ebp)
c0026d00:	e8 fa fa ff ff       	call   c00267ff <block_size>
c0026d05:	83 c4 10             	add    $0x10,%esp
c0026d08:	39 45 10             	cmp    %eax,0x10(%ebp)
c0026d0b:	72 29                	jb     c0026d36 <found_partition+0x5c>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0026d0d:	83 ec 0c             	sub    $0xc,%esp
c0026d10:	ff 75 08             	push   0x8(%ebp)
c0026d13:	e8 fc fa ff ff       	call   c0026814 <block_name>
c0026d18:	83 c4 10             	add    $0x10,%esp
c0026d1b:	ff 75 10             	push   0x10(%ebp)
c0026d1e:	ff 75 18             	push   0x18(%ebp)
c0026d21:	50                   	push   %eax
c0026d22:	8d 83 98 86 ff ff    	lea    -0x7968(%ebx),%eax
c0026d28:	50                   	push   %eax
c0026d29:	e8 b7 21 00 00       	call   c0028ee5 <printf>
c0026d2e:	83 c4 10             	add    $0x10,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c0026d31:	e9 84 01 00 00       	jmp    c0026eba <found_partition+0x1e0>
  else if (start + size < start || start + size > block_size (block))
c0026d36:	8b 55 10             	mov    0x10(%ebp),%edx
c0026d39:	8b 45 14             	mov    0x14(%ebp),%eax
c0026d3c:	01 d0                	add    %edx,%eax
c0026d3e:	39 45 10             	cmp    %eax,0x10(%ebp)
c0026d41:	77 1b                	ja     c0026d5e <found_partition+0x84>
c0026d43:	8b 55 10             	mov    0x10(%ebp),%edx
c0026d46:	8b 45 14             	mov    0x14(%ebp),%eax
c0026d49:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0026d4c:	83 ec 0c             	sub    $0xc,%esp
c0026d4f:	ff 75 08             	push   0x8(%ebp)
c0026d52:	e8 a8 fa ff ff       	call   c00267ff <block_size>
c0026d57:	83 c4 10             	add    $0x10,%esp
c0026d5a:	39 c6                	cmp    %eax,%esi
c0026d5c:	76 44                	jbe    c0026da2 <found_partition+0xc8>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0026d5e:	83 ec 0c             	sub    $0xc,%esp
c0026d61:	ff 75 08             	push   0x8(%ebp)
c0026d64:	e8 96 fa ff ff       	call   c00267ff <block_size>
c0026d69:	83 c4 10             	add    $0x10,%esp
c0026d6c:	89 c6                	mov    %eax,%esi
c0026d6e:	8b 55 10             	mov    0x10(%ebp),%edx
c0026d71:	8b 45 14             	mov    0x14(%ebp),%eax
c0026d74:	8d 3c 02             	lea    (%edx,%eax,1),%edi
c0026d77:	83 ec 0c             	sub    $0xc,%esp
c0026d7a:	ff 75 08             	push   0x8(%ebp)
c0026d7d:	e8 92 fa ff ff       	call   c0026814 <block_name>
c0026d82:	83 c4 10             	add    $0x10,%esp
c0026d85:	83 ec 0c             	sub    $0xc,%esp
c0026d88:	56                   	push   %esi
c0026d89:	57                   	push   %edi
c0026d8a:	ff 75 18             	push   0x18(%ebp)
c0026d8d:	50                   	push   %eax
c0026d8e:	8d 83 d0 86 ff ff    	lea    -0x7930(%ebx),%eax
c0026d94:	50                   	push   %eax
c0026d95:	e8 4b 21 00 00       	call   c0028ee5 <printf>
c0026d9a:	83 c4 20             	add    $0x20,%esp
}
c0026d9d:	e9 18 01 00 00       	jmp    c0026eba <found_partition+0x1e0>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0026da2:	80 bd 44 ff ff ff 20 	cmpb   $0x20,-0xbc(%ebp)
c0026da9:	74 37                	je     c0026de2 <found_partition+0x108>
c0026dab:	80 bd 44 ff ff ff 21 	cmpb   $0x21,-0xbc(%ebp)
c0026db2:	74 27                	je     c0026ddb <found_partition+0x101>
c0026db4:	80 bd 44 ff ff ff 22 	cmpb   $0x22,-0xbc(%ebp)
c0026dbb:	74 17                	je     c0026dd4 <found_partition+0xfa>
c0026dbd:	80 bd 44 ff ff ff 23 	cmpb   $0x23,-0xbc(%ebp)
c0026dc4:	75 07                	jne    c0026dcd <found_partition+0xf3>
c0026dc6:	b8 03 00 00 00       	mov    $0x3,%eax
c0026dcb:	eb 1a                	jmp    c0026de7 <found_partition+0x10d>
c0026dcd:	b8 05 00 00 00       	mov    $0x5,%eax
c0026dd2:	eb 13                	jmp    c0026de7 <found_partition+0x10d>
c0026dd4:	b8 02 00 00 00       	mov    $0x2,%eax
c0026dd9:	eb 0c                	jmp    c0026de7 <found_partition+0x10d>
c0026ddb:	b8 01 00 00 00       	mov    $0x1,%eax
c0026de0:	eb 05                	jmp    c0026de7 <found_partition+0x10d>
c0026de2:	b8 00 00 00 00       	mov    $0x0,%eax
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c0026de7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      p = malloc (sizeof *p);
c0026dea:	83 ec 0c             	sub    $0xc,%esp
c0026ded:	6a 08                	push   $0x8
c0026def:	e8 1f d9 ff ff       	call   c0024713 <malloc>
c0026df4:	83 c4 10             	add    $0x10,%esp
c0026df7:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (p == NULL)
c0026dfa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0026dfe:	75 1f                	jne    c0026e1f <found_partition+0x145>
        PANIC ("Failed to allocate memory for partition descriptor");
c0026e00:	8d 83 04 87 ff ff    	lea    -0x78fc(%ebx),%eax
c0026e06:	50                   	push   %eax
c0026e07:	8d 83 68 87 ff ff    	lea    -0x7898(%ebx),%eax
c0026e0d:	50                   	push   %eax
c0026e0e:	68 b1 00 00 00       	push   $0xb1
c0026e13:	8d 83 f7 85 ff ff    	lea    -0x7a09(%ebx),%eax
c0026e19:	50                   	push   %eax
c0026e1a:	e8 45 49 00 00       	call   c002b764 <debug_panic>
      p->block = block;
c0026e1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0026e22:	8b 55 08             	mov    0x8(%ebp),%edx
c0026e25:	89 10                	mov    %edx,(%eax)
      p->start = start;
c0026e27:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0026e2a:	8b 55 10             	mov    0x10(%ebp),%edx
c0026e2d:	89 50 04             	mov    %edx,0x4(%eax)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0026e30:	83 ec 0c             	sub    $0xc,%esp
c0026e33:	ff 75 08             	push   0x8(%ebp)
c0026e36:	e8 d9 f9 ff ff       	call   c0026814 <block_name>
c0026e3b:	83 c4 10             	add    $0x10,%esp
c0026e3e:	83 ec 0c             	sub    $0xc,%esp
c0026e41:	ff 75 18             	push   0x18(%ebp)
c0026e44:	50                   	push   %eax
c0026e45:	8d 83 37 87 ff ff    	lea    -0x78c9(%ebx),%eax
c0026e4b:	50                   	push   %eax
c0026e4c:	6a 10                	push   $0x10
c0026e4e:	8d 45 d0             	lea    -0x30(%ebp),%eax
c0026e51:	50                   	push   %eax
c0026e52:	e8 5b 20 00 00       	call   c0028eb2 <snprintf>
c0026e57:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0026e5a:	0f b6 b5 44 ff ff ff 	movzbl -0xbc(%ebp),%esi
c0026e61:	0f b6 85 44 ff ff ff 	movzbl -0xbc(%ebp),%eax
c0026e68:	83 ec 0c             	sub    $0xc,%esp
c0026e6b:	50                   	push   %eax
c0026e6c:	e8 52 00 00 00       	call   c0026ec3 <partition_type_name>
c0026e71:	83 c4 10             	add    $0x10,%esp
c0026e74:	83 ec 0c             	sub    $0xc,%esp
c0026e77:	56                   	push   %esi
c0026e78:	50                   	push   %eax
c0026e79:	8d 83 3c 87 ff ff    	lea    -0x78c4(%ebx),%eax
c0026e7f:	50                   	push   %eax
c0026e80:	68 80 00 00 00       	push   $0x80
c0026e85:	8d 85 50 ff ff ff    	lea    -0xb0(%ebp),%eax
c0026e8b:	50                   	push   %eax
c0026e8c:	e8 21 20 00 00       	call   c0028eb2 <snprintf>
c0026e91:	83 c4 20             	add    $0x20,%esp
      block_register (name, type, extra_info, size, &partition_operations, p);
c0026e94:	83 ec 08             	sub    $0x8,%esp
c0026e97:	ff 75 e0             	push   -0x20(%ebp)
c0026e9a:	8d 83 08 02 00 00    	lea    0x208(%ebx),%eax
c0026ea0:	50                   	push   %eax
c0026ea1:	ff 75 14             	push   0x14(%ebp)
c0026ea4:	8d 85 50 ff ff ff    	lea    -0xb0(%ebp),%eax
c0026eaa:	50                   	push   %eax
c0026eab:	ff 75 e4             	push   -0x1c(%ebp)
c0026eae:	8d 45 d0             	lea    -0x30(%ebp),%eax
c0026eb1:	50                   	push   %eax
c0026eb2:	e8 19 fa ff ff       	call   c00268d0 <block_register>
c0026eb7:	83 c4 20             	add    $0x20,%esp
}
c0026eba:	90                   	nop
c0026ebb:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0026ebe:	5b                   	pop    %ebx
c0026ebf:	5e                   	pop    %esi
c0026ec0:	5f                   	pop    %edi
c0026ec1:	5d                   	pop    %ebp
c0026ec2:	c3                   	ret    

c0026ec3 <partition_type_name>:

/* Returns a human-readable name for the given partition TYPE. */
static const char *
partition_type_name (uint8_t type)
{
c0026ec3:	55                   	push   %ebp
c0026ec4:	89 e5                	mov    %esp,%ebp
c0026ec6:	83 ec 04             	sub    $0x4,%esp
c0026ec9:	e8 5a a5 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026ece:	05 aa 34 01 00       	add    $0x134aa,%eax
c0026ed3:	8b 55 08             	mov    0x8(%ebp),%edx
c0026ed6:	88 55 fc             	mov    %dl,-0x4(%ebp)
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0026ed9:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0026edd:	8b 94 90 28 02 00 00 	mov    0x228(%eax,%edx,4),%edx
c0026ee4:	85 d2                	test   %edx,%edx
c0026ee6:	74 0d                	je     c0026ef5 <partition_type_name+0x32>
c0026ee8:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0026eec:	8b 84 90 28 02 00 00 	mov    0x228(%eax,%edx,4),%eax
c0026ef3:	eb 06                	jmp    c0026efb <partition_type_name+0x38>
c0026ef5:	8d 80 46 87 ff ff    	lea    -0x78ba(%eax),%eax
}
c0026efb:	c9                   	leave  
c0026efc:	c3                   	ret    

c0026efd <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0026efd:	55                   	push   %ebp
c0026efe:	89 e5                	mov    %esp,%ebp
c0026f00:	53                   	push   %ebx
c0026f01:	83 ec 14             	sub    $0x14,%esp
c0026f04:	e8 1f a5 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026f09:	05 6f 34 01 00       	add    $0x1346f,%eax
  struct partition *p = p_;
c0026f0e:	8b 55 08             	mov    0x8(%ebp),%edx
c0026f11:	89 55 f4             	mov    %edx,-0xc(%ebp)
  block_read (p->block, p->start + sector, buffer);
c0026f14:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026f17:	8b 4a 04             	mov    0x4(%edx),%ecx
c0026f1a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026f1d:	01 d1                	add    %edx,%ecx
c0026f1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026f22:	8b 12                	mov    (%edx),%edx
c0026f24:	83 ec 04             	sub    $0x4,%esp
c0026f27:	ff 75 10             	push   0x10(%ebp)
c0026f2a:	51                   	push   %ecx
c0026f2b:	52                   	push   %edx
c0026f2c:	89 c3                	mov    %eax,%ebx
c0026f2e:	e8 e0 f7 ff ff       	call   c0026713 <block_read>
c0026f33:	83 c4 10             	add    $0x10,%esp
}
c0026f36:	90                   	nop
c0026f37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026f3a:	c9                   	leave  
c0026f3b:	c3                   	ret    

c0026f3c <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c0026f3c:	55                   	push   %ebp
c0026f3d:	89 e5                	mov    %esp,%ebp
c0026f3f:	53                   	push   %ebx
c0026f40:	83 ec 14             	sub    $0x14,%esp
c0026f43:	e8 e0 a4 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026f48:	05 30 34 01 00       	add    $0x13430,%eax
  struct partition *p = p_;
c0026f4d:	8b 55 08             	mov    0x8(%ebp),%edx
c0026f50:	89 55 f4             	mov    %edx,-0xc(%ebp)
  block_write (p->block, p->start + sector, buffer);
c0026f53:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026f56:	8b 4a 04             	mov    0x4(%edx),%ecx
c0026f59:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026f5c:	01 d1                	add    %edx,%ecx
c0026f5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026f61:	8b 12                	mov    (%edx),%edx
c0026f63:	83 ec 04             	sub    $0x4,%esp
c0026f66:	ff 75 10             	push   0x10(%ebp)
c0026f69:	51                   	push   %ecx
c0026f6a:	52                   	push   %edx
c0026f6b:	89 c3                	mov    %eax,%ebx
c0026f6d:	e8 fa f7 ff ff       	call   c002676c <block_write>
c0026f72:	83 c4 10             	add    $0x10,%esp
}
c0026f75:	90                   	nop
c0026f76:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0026f79:	c9                   	leave  
c0026f7a:	c3                   	ret    

c0026f7b <isspace>:
static inline int isspace (int c) {
c0026f7b:	55                   	push   %ebp
c0026f7c:	89 e5                	mov    %esp,%ebp
c0026f7e:	e8 a5 a4 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026f83:	05 f5 33 01 00       	add    $0x133f5,%eax
          || c == '\r' || c == '\t' || c == '\v');
c0026f88:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0026f8c:	74 1e                	je     c0026fac <isspace+0x31>
  return (c == ' ' || c == '\f' || c == '\n'
c0026f8e:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0026f92:	74 18                	je     c0026fac <isspace+0x31>
c0026f94:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0026f98:	74 12                	je     c0026fac <isspace+0x31>
          || c == '\r' || c == '\t' || c == '\v');
c0026f9a:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0026f9e:	74 0c                	je     c0026fac <isspace+0x31>
c0026fa0:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0026fa4:	74 06                	je     c0026fac <isspace+0x31>
c0026fa6:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0026faa:	75 07                	jne    c0026fb3 <isspace+0x38>
c0026fac:	b8 01 00 00 00       	mov    $0x1,%eax
c0026fb1:	eb 05                	jmp    c0026fb8 <isspace+0x3d>
c0026fb3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0026fb8:	5d                   	pop    %ebp
c0026fb9:	c3                   	ret    

c0026fba <inb>:
{
c0026fba:	55                   	push   %ebp
c0026fbb:	89 e5                	mov    %esp,%ebp
c0026fbd:	83 ec 14             	sub    $0x14,%esp
c0026fc0:	e8 63 a4 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026fc5:	05 b3 33 01 00       	add    $0x133b3,%eax
c0026fca:	8b 45 08             	mov    0x8(%ebp),%eax
c0026fcd:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026fd1:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0026fd5:	89 c2                	mov    %eax,%edx
c0026fd7:	ec                   	in     (%dx),%al
c0026fd8:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026fdb:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0026fdf:	c9                   	leave  
c0026fe0:	c3                   	ret    

c0026fe1 <insw>:
{
c0026fe1:	55                   	push   %ebp
c0026fe2:	89 e5                	mov    %esp,%ebp
c0026fe4:	57                   	push   %edi
c0026fe5:	53                   	push   %ebx
c0026fe6:	83 ec 04             	sub    $0x4,%esp
c0026fe9:	e8 3a a4 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0026fee:	05 8a 33 01 00       	add    $0x1338a,%eax
c0026ff3:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ff6:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0026ffa:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0026ffe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0027001:	8b 45 10             	mov    0x10(%ebp),%eax
c0027004:	89 cb                	mov    %ecx,%ebx
c0027006:	89 df                	mov    %ebx,%edi
c0027008:	89 c1                	mov    %eax,%ecx
c002700a:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c002700d:	89 c8                	mov    %ecx,%eax
c002700f:	89 fb                	mov    %edi,%ebx
c0027011:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0027014:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0027017:	90                   	nop
c0027018:	83 c4 04             	add    $0x4,%esp
c002701b:	5b                   	pop    %ebx
c002701c:	5f                   	pop    %edi
c002701d:	5d                   	pop    %ebp
c002701e:	c3                   	ret    

c002701f <outb>:
{
c002701f:	55                   	push   %ebp
c0027020:	89 e5                	mov    %esp,%ebp
c0027022:	83 ec 08             	sub    $0x8,%esp
c0027025:	e8 fe a3 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002702a:	05 4e 33 01 00       	add    $0x1334e,%eax
c002702f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027032:	8b 55 0c             	mov    0xc(%ebp),%edx
c0027035:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0027039:	89 d0                	mov    %edx,%eax
c002703b:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002703e:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0027042:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0027046:	ee                   	out    %al,(%dx)
}
c0027047:	90                   	nop
c0027048:	c9                   	leave  
c0027049:	c3                   	ret    

c002704a <outsw>:

/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
c002704a:	55                   	push   %ebp
c002704b:	89 e5                	mov    %esp,%ebp
c002704d:	56                   	push   %esi
c002704e:	53                   	push   %ebx
c002704f:	83 ec 04             	sub    $0x4,%esp
c0027052:	e8 d1 a3 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0027057:	05 21 33 01 00       	add    $0x13321,%eax
c002705c:	8b 45 08             	mov    0x8(%ebp),%eax
c002705f:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0027063:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0027067:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002706a:	8b 45 10             	mov    0x10(%ebp),%eax
c002706d:	89 cb                	mov    %ecx,%ebx
c002706f:	89 de                	mov    %ebx,%esi
c0027071:	89 c1                	mov    %eax,%ecx
c0027073:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c0027076:	89 c8                	mov    %ecx,%eax
c0027078:	89 f3                	mov    %esi,%ebx
c002707a:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c002707d:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0027080:	90                   	nop
c0027081:	83 c4 04             	add    $0x4,%esp
c0027084:	5b                   	pop    %ebx
c0027085:	5e                   	pop    %esi
c0027086:	5d                   	pop    %ebp
c0027087:	c3                   	ret    

c0027088 <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c0027088:	55                   	push   %ebp
c0027089:	89 e5                	mov    %esp,%ebp
c002708b:	53                   	push   %ebx
c002708c:	83 ec 14             	sub    $0x14,%esp
c002708f:	e8 98 a3 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027094:	81 c3 e4 32 01 00    	add    $0x132e4,%ebx
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c002709a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00270a1:	e9 bd 01 00 00       	jmp    c0027263 <ide_init+0x1db>
    {
      struct channel *c = &channels[chan_no];
c00270a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00270a9:	6b d0 64             	imul   $0x64,%eax,%edx
c00270ac:	8d 83 08 20 00 00    	lea    0x2008(%ebx),%eax
c00270b2:	01 d0                	add    %edx,%eax
c00270b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c00270b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00270ba:	ff 75 f4             	push   -0xc(%ebp)
c00270bd:	8d 93 3c 8c ff ff    	lea    -0x73c4(%ebx),%edx
c00270c3:	52                   	push   %edx
c00270c4:	6a 08                	push   $0x8
c00270c6:	50                   	push   %eax
c00270c7:	e8 e6 1d 00 00       	call   c0028eb2 <snprintf>
c00270cc:	83 c4 10             	add    $0x10,%esp
      switch (chan_no) 
c00270cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00270d3:	74 08                	je     c00270dd <ide_init+0x55>
c00270d5:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00270d9:	74 14                	je     c00270ef <ide_init+0x67>
c00270db:	eb 24                	jmp    c0027101 <ide_init+0x79>
        {
        case 0:
          c->reg_base = 0x1f0;
c00270dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00270e0:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
          c->irq = 14 + 0x20;
c00270e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00270e9:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
          break;
c00270ed:	eb 2e                	jmp    c002711d <ide_init+0x95>
        case 1:
          c->reg_base = 0x170;
c00270ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00270f2:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
          c->irq = 15 + 0x20;
c00270f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00270fb:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
          break;
c00270ff:	eb 1c                	jmp    c002711d <ide_init+0x95>
        default:
          NOT_REACHED ();
c0027101:	8d 83 44 8c ff ff    	lea    -0x73bc(%ebx),%eax
c0027107:	50                   	push   %eax
c0027108:	8d 83 98 8d ff ff    	lea    -0x7268(%ebx),%eax
c002710e:	50                   	push   %eax
c002710f:	6a 7c                	push   $0x7c
c0027111:	8d 83 66 8c ff ff    	lea    -0x739a(%ebx),%eax
c0027117:	50                   	push   %eax
c0027118:	e8 47 46 00 00       	call   c002b764 <debug_panic>
        }
      lock_init (&c->lock);
c002711d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027120:	83 c0 0c             	add    $0xc,%eax
c0027123:	83 ec 0c             	sub    $0xc,%esp
c0027126:	50                   	push   %eax
c0027127:	e8 a6 c6 ff ff       	call   c00237d2 <lock_init>
c002712c:	83 c4 10             	add    $0x10,%esp
      c->expecting_interrupt = false;
c002712f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027132:	c6 40 24 00          	movb   $0x0,0x24(%eax)
      sema_init (&c->completion_wait, 0);
c0027136:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027139:	83 c0 28             	add    $0x28,%eax
c002713c:	83 ec 08             	sub    $0x8,%esp
c002713f:	6a 00                	push   $0x0
c0027141:	50                   	push   %eax
c0027142:	e8 27 c3 ff ff       	call   c002346e <sema_init>
c0027147:	83 c4 10             	add    $0x10,%esp
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c002714a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0027151:	eb 5c                	jmp    c00271af <ide_init+0x127>
        {
          struct ata_disk *d = &c->devices[dev_no];
c0027153:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0027156:	89 d0                	mov    %edx,%eax
c0027158:	c1 e0 02             	shl    $0x2,%eax
c002715b:	01 d0                	add    %edx,%eax
c002715d:	c1 e0 02             	shl    $0x2,%eax
c0027160:	8d 50 30             	lea    0x30(%eax),%edx
c0027163:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027166:	01 d0                	add    %edx,%eax
c0027168:	83 c0 0c             	add    $0xc,%eax
c002716b:	89 45 e8             	mov    %eax,-0x18(%ebp)
          snprintf (d->name, sizeof d->name,
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
c002716e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027171:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0027174:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027177:	01 d0                	add    %edx,%eax
          snprintf (d->name, sizeof d->name,
c0027179:	8d 50 61             	lea    0x61(%eax),%edx
c002717c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002717f:	52                   	push   %edx
c0027180:	8d 93 7a 8c ff ff    	lea    -0x7386(%ebx),%edx
c0027186:	52                   	push   %edx
c0027187:	6a 08                	push   $0x8
c0027189:	50                   	push   %eax
c002718a:	e8 23 1d 00 00       	call   c0028eb2 <snprintf>
c002718f:	83 c4 10             	add    $0x10,%esp
          d->channel = c;
c0027192:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027195:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0027198:	89 50 08             	mov    %edx,0x8(%eax)
          d->dev_no = dev_no;
c002719b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002719e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00271a1:	89 50 0c             	mov    %edx,0xc(%eax)
          d->is_ata = false;
c00271a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00271a7:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      for (dev_no = 0; dev_no < 2; dev_no++)
c00271ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00271af:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c00271b3:	7e 9e                	jle    c0027153 <ide_init+0xcb>
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c00271b5:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00271b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00271bb:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c00271bf:	0f b6 c0             	movzbl %al,%eax
c00271c2:	83 ec 04             	sub    $0x4,%esp
c00271c5:	52                   	push   %edx
c00271c6:	8d 93 8b da fe ff    	lea    -0x12575(%ebx),%edx
c00271cc:	52                   	push   %edx
c00271cd:	50                   	push   %eax
c00271ce:	e8 93 af ff ff       	call   c0022166 <intr_register_ext>
c00271d3:	83 c4 10             	add    $0x10,%esp

      /* Reset hardware. */
      reset_channel (c);
c00271d6:	83 ec 0c             	sub    $0xc,%esp
c00271d9:	ff 75 ec             	push   -0x14(%ebp)
c00271dc:	e8 93 00 00 00       	call   c0027274 <reset_channel>
c00271e1:	83 c4 10             	add    $0x10,%esp

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c00271e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00271e7:	83 c0 3c             	add    $0x3c,%eax
c00271ea:	83 ec 0c             	sub    $0xc,%esp
c00271ed:	50                   	push   %eax
c00271ee:	e8 1c 03 00 00       	call   c002750f <check_device_type>
c00271f3:	83 c4 10             	add    $0x10,%esp
c00271f6:	84 c0                	test   %al,%al
c00271f8:	74 12                	je     c002720c <ide_init+0x184>
        check_device_type (&c->devices[1]);
c00271fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00271fd:	83 c0 50             	add    $0x50,%eax
c0027200:	83 ec 0c             	sub    $0xc,%esp
c0027203:	50                   	push   %eax
c0027204:	e8 06 03 00 00       	call   c002750f <check_device_type>
c0027209:	83 c4 10             	add    $0x10,%esp

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c002720c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0027213:	eb 44                	jmp    c0027259 <ide_init+0x1d1>
        if (c->devices[dev_no].is_ata)
c0027215:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0027218:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002721b:	89 d0                	mov    %edx,%eax
c002721d:	c1 e0 02             	shl    $0x2,%eax
c0027220:	01 d0                	add    %edx,%eax
c0027222:	c1 e0 02             	shl    $0x2,%eax
c0027225:	01 c8                	add    %ecx,%eax
c0027227:	83 c0 4c             	add    $0x4c,%eax
c002722a:	0f b6 00             	movzbl (%eax),%eax
c002722d:	84 c0                	test   %al,%al
c002722f:	74 24                	je     c0027255 <ide_init+0x1cd>
          identify_ata_device (&c->devices[dev_no]);
c0027231:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0027234:	89 d0                	mov    %edx,%eax
c0027236:	c1 e0 02             	shl    $0x2,%eax
c0027239:	01 d0                	add    %edx,%eax
c002723b:	c1 e0 02             	shl    $0x2,%eax
c002723e:	8d 50 30             	lea    0x30(%eax),%edx
c0027241:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027244:	01 d0                	add    %edx,%eax
c0027246:	83 c0 0c             	add    $0xc,%eax
c0027249:	83 ec 0c             	sub    $0xc,%esp
c002724c:	50                   	push   %eax
c002724d:	e8 c2 03 00 00       	call   c0027614 <identify_ata_device>
c0027252:	83 c4 10             	add    $0x10,%esp
      for (dev_no = 0; dev_no < 2; dev_no++)
c0027255:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0027259:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c002725d:	7e b6                	jle    c0027215 <ide_init+0x18d>
  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c002725f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0027263:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0027267:	0f 86 39 fe ff ff    	jbe    c00270a6 <ide_init+0x1e>
    }
}
c002726d:	90                   	nop
c002726e:	90                   	nop
c002726f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027272:	c9                   	leave  
c0027273:	c3                   	ret    

c0027274 <reset_channel>:

/* Resets an ATA channel and waits for any devices present on it
   to finish the reset. */
static void
reset_channel (struct channel *c) 
{
c0027274:	55                   	push   %ebp
c0027275:	89 e5                	mov    %esp,%ebp
c0027277:	53                   	push   %ebx
c0027278:	83 ec 14             	sub    $0x14,%esp
c002727b:	e8 ac a1 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027280:	81 c3 f8 30 01 00    	add    $0x130f8,%ebx
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0027286:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002728d:	e9 2b 01 00 00       	jmp    c00273bd <reset_channel+0x149>
    {
      struct ata_disk *d = &c->devices[dev_no];
c0027292:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027295:	89 d0                	mov    %edx,%eax
c0027297:	c1 e0 02             	shl    $0x2,%eax
c002729a:	01 d0                	add    %edx,%eax
c002729c:	c1 e0 02             	shl    $0x2,%eax
c002729f:	8d 50 30             	lea    0x30(%eax),%edx
c00272a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00272a5:	01 d0                	add    %edx,%eax
c00272a7:	83 c0 0c             	add    $0xc,%eax
c00272aa:	89 45 ec             	mov    %eax,-0x14(%ebp)

      select_device (d);
c00272ad:	83 ec 0c             	sub    $0xc,%esp
c00272b0:	ff 75 ec             	push   -0x14(%ebp)
c00272b3:	e8 96 0a 00 00       	call   c0027d4e <select_device>
c00272b8:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c00272bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00272be:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00272c2:	83 c0 02             	add    $0x2,%eax
c00272c5:	0f b7 c0             	movzwl %ax,%eax
c00272c8:	83 ec 08             	sub    $0x8,%esp
c00272cb:	6a 55                	push   $0x55
c00272cd:	50                   	push   %eax
c00272ce:	e8 4c fd ff ff       	call   c002701f <outb>
c00272d3:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c00272d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00272d9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00272dd:	83 c0 03             	add    $0x3,%eax
c00272e0:	0f b7 c0             	movzwl %ax,%eax
c00272e3:	83 ec 08             	sub    $0x8,%esp
c00272e6:	68 aa 00 00 00       	push   $0xaa
c00272eb:	50                   	push   %eax
c00272ec:	e8 2e fd ff ff       	call   c002701f <outb>
c00272f1:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0xaa);
c00272f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00272f7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00272fb:	83 c0 02             	add    $0x2,%eax
c00272fe:	0f b7 c0             	movzwl %ax,%eax
c0027301:	83 ec 08             	sub    $0x8,%esp
c0027304:	68 aa 00 00 00       	push   $0xaa
c0027309:	50                   	push   %eax
c002730a:	e8 10 fd ff ff       	call   c002701f <outb>
c002730f:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0x55);
c0027312:	8b 45 08             	mov    0x8(%ebp),%eax
c0027315:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027319:	83 c0 03             	add    $0x3,%eax
c002731c:	0f b7 c0             	movzwl %ax,%eax
c002731f:	83 ec 08             	sub    $0x8,%esp
c0027322:	6a 55                	push   $0x55
c0027324:	50                   	push   %eax
c0027325:	e8 f5 fc ff ff       	call   c002701f <outb>
c002732a:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c002732d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027330:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027334:	83 c0 02             	add    $0x2,%eax
c0027337:	0f b7 c0             	movzwl %ax,%eax
c002733a:	83 ec 08             	sub    $0x8,%esp
c002733d:	6a 55                	push   $0x55
c002733f:	50                   	push   %eax
c0027340:	e8 da fc ff ff       	call   c002701f <outb>
c0027345:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0027348:	8b 45 08             	mov    0x8(%ebp),%eax
c002734b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002734f:	83 c0 03             	add    $0x3,%eax
c0027352:	0f b7 c0             	movzwl %ax,%eax
c0027355:	83 ec 08             	sub    $0x8,%esp
c0027358:	68 aa 00 00 00       	push   $0xaa
c002735d:	50                   	push   %eax
c002735e:	e8 bc fc ff ff       	call   c002701f <outb>
c0027363:	83 c4 10             	add    $0x10,%esp

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0027366:	8b 45 08             	mov    0x8(%ebp),%eax
c0027369:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002736d:	83 c0 02             	add    $0x2,%eax
c0027370:	0f b7 c0             	movzwl %ax,%eax
c0027373:	83 ec 0c             	sub    $0xc,%esp
c0027376:	50                   	push   %eax
c0027377:	e8 3e fc ff ff       	call   c0026fba <inb>
c002737c:	83 c4 10             	add    $0x10,%esp
                         && inb (reg_lbal (c)) == 0xaa);
c002737f:	3c 55                	cmp    $0x55,%al
c0027381:	75 24                	jne    c00273a7 <reset_channel+0x133>
c0027383:	8b 45 08             	mov    0x8(%ebp),%eax
c0027386:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002738a:	83 c0 03             	add    $0x3,%eax
c002738d:	0f b7 c0             	movzwl %ax,%eax
c0027390:	83 ec 0c             	sub    $0xc,%esp
c0027393:	50                   	push   %eax
c0027394:	e8 21 fc ff ff       	call   c0026fba <inb>
c0027399:	83 c4 10             	add    $0x10,%esp
c002739c:	3c aa                	cmp    $0xaa,%al
c002739e:	75 07                	jne    c00273a7 <reset_channel+0x133>
c00273a0:	b8 01 00 00 00       	mov    $0x1,%eax
c00273a5:	eb 05                	jmp    c00273ac <reset_channel+0x138>
c00273a7:	b8 00 00 00 00       	mov    $0x0,%eax
c00273ac:	83 e0 01             	and    $0x1,%eax
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c00273af:	8d 4d ea             	lea    -0x16(%ebp),%ecx
c00273b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00273b5:	01 ca                	add    %ecx,%edx
c00273b7:	88 02                	mov    %al,(%edx)
  for (dev_no = 0; dev_no < 2; dev_no++)
c00273b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00273bd:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00273c1:	0f 8e cb fe ff ff    	jle    c0027292 <reset_channel+0x1e>
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
c00273c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00273ca:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00273ce:	66 05 06 02          	add    $0x206,%ax
c00273d2:	0f b7 c0             	movzwl %ax,%eax
c00273d5:	83 ec 08             	sub    $0x8,%esp
c00273d8:	6a 00                	push   $0x0
c00273da:	50                   	push   %eax
c00273db:	e8 3f fc ff ff       	call   c002701f <outb>
c00273e0:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c00273e3:	83 ec 08             	sub    $0x8,%esp
c00273e6:	6a 00                	push   $0x0
c00273e8:	6a 0a                	push   $0xa
c00273ea:	e8 f6 dd ff ff       	call   c00251e5 <timer_usleep>
c00273ef:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), CTL_SRST);
c00273f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00273f5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00273f9:	66 05 06 02          	add    $0x206,%ax
c00273fd:	0f b7 c0             	movzwl %ax,%eax
c0027400:	83 ec 08             	sub    $0x8,%esp
c0027403:	6a 04                	push   $0x4
c0027405:	50                   	push   %eax
c0027406:	e8 14 fc ff ff       	call   c002701f <outb>
c002740b:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c002740e:	83 ec 08             	sub    $0x8,%esp
c0027411:	6a 00                	push   $0x0
c0027413:	6a 0a                	push   $0xa
c0027415:	e8 cb dd ff ff       	call   c00251e5 <timer_usleep>
c002741a:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), 0);
c002741d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027420:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027424:	66 05 06 02          	add    $0x206,%ax
c0027428:	0f b7 c0             	movzwl %ax,%eax
c002742b:	83 ec 08             	sub    $0x8,%esp
c002742e:	6a 00                	push   $0x0
c0027430:	50                   	push   %eax
c0027431:	e8 e9 fb ff ff       	call   c002701f <outb>
c0027436:	83 c4 10             	add    $0x10,%esp

  timer_msleep (150);
c0027439:	83 ec 08             	sub    $0x8,%esp
c002743c:	6a 00                	push   $0x0
c002743e:	68 96 00 00 00       	push   $0x96
c0027443:	e8 68 dd ff ff       	call   c00251b0 <timer_msleep>
c0027448:	83 c4 10             	add    $0x10,%esp

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c002744b:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
c002744f:	84 c0                	test   %al,%al
c0027451:	74 24                	je     c0027477 <reset_channel+0x203>
    {
      select_device (&c->devices[0]);
c0027453:	8b 45 08             	mov    0x8(%ebp),%eax
c0027456:	83 c0 3c             	add    $0x3c,%eax
c0027459:	83 ec 0c             	sub    $0xc,%esp
c002745c:	50                   	push   %eax
c002745d:	e8 ec 08 00 00       	call   c0027d4e <select_device>
c0027462:	83 c4 10             	add    $0x10,%esp
      wait_while_busy (&c->devices[0]); 
c0027465:	8b 45 08             	mov    0x8(%ebp),%eax
c0027468:	83 c0 3c             	add    $0x3c,%eax
c002746b:	83 ec 0c             	sub    $0xc,%esp
c002746e:	50                   	push   %eax
c002746f:	e8 f8 07 00 00       	call   c0027c6c <wait_while_busy>
c0027474:	83 c4 10             	add    $0x10,%esp
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c0027477:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002747b:	84 c0                	test   %al,%al
c002747d:	0f 84 86 00 00 00    	je     c0027509 <reset_channel+0x295>
    {
      int i;

      select_device (&c->devices[1]);
c0027483:	8b 45 08             	mov    0x8(%ebp),%eax
c0027486:	83 c0 50             	add    $0x50,%eax
c0027489:	83 ec 0c             	sub    $0xc,%esp
c002748c:	50                   	push   %eax
c002748d:	e8 bc 08 00 00       	call   c0027d4e <select_device>
c0027492:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0027495:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002749c:	eb 4d                	jmp    c00274eb <reset_channel+0x277>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c002749e:	8b 45 08             	mov    0x8(%ebp),%eax
c00274a1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00274a5:	83 c0 02             	add    $0x2,%eax
c00274a8:	0f b7 c0             	movzwl %ax,%eax
c00274ab:	83 ec 0c             	sub    $0xc,%esp
c00274ae:	50                   	push   %eax
c00274af:	e8 06 fb ff ff       	call   c0026fba <inb>
c00274b4:	83 c4 10             	add    $0x10,%esp
c00274b7:	3c 01                	cmp    $0x1,%al
c00274b9:	75 1d                	jne    c00274d8 <reset_channel+0x264>
c00274bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00274be:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00274c2:	83 c0 03             	add    $0x3,%eax
c00274c5:	0f b7 c0             	movzwl %ax,%eax
c00274c8:	83 ec 0c             	sub    $0xc,%esp
c00274cb:	50                   	push   %eax
c00274cc:	e8 e9 fa ff ff       	call   c0026fba <inb>
c00274d1:	83 c4 10             	add    $0x10,%esp
c00274d4:	3c 01                	cmp    $0x1,%al
c00274d6:	74 1e                	je     c00274f6 <reset_channel+0x282>
            break;
          timer_msleep (10);
c00274d8:	83 ec 08             	sub    $0x8,%esp
c00274db:	6a 00                	push   $0x0
c00274dd:	6a 0a                	push   $0xa
c00274df:	e8 cc dc ff ff       	call   c00251b0 <timer_msleep>
c00274e4:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c00274e7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00274eb:	81 7d f0 b7 0b 00 00 	cmpl   $0xbb7,-0x10(%ebp)
c00274f2:	7e aa                	jle    c002749e <reset_channel+0x22a>
c00274f4:	eb 01                	jmp    c00274f7 <reset_channel+0x283>
            break;
c00274f6:	90                   	nop
        }
      wait_while_busy (&c->devices[1]);
c00274f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00274fa:	83 c0 50             	add    $0x50,%eax
c00274fd:	83 ec 0c             	sub    $0xc,%esp
c0027500:	50                   	push   %eax
c0027501:	e8 66 07 00 00       	call   c0027c6c <wait_while_busy>
c0027506:	83 c4 10             	add    $0x10,%esp
    }
}
c0027509:	90                   	nop
c002750a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002750d:	c9                   	leave  
c002750e:	c3                   	ret    

c002750f <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c002750f:	55                   	push   %ebp
c0027510:	89 e5                	mov    %esp,%ebp
c0027512:	83 ec 18             	sub    $0x18,%esp
c0027515:	e8 0e 9f 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002751a:	05 5e 2e 01 00       	add    $0x12e5e,%eax
  struct channel *c = d->channel;
c002751f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027522:	8b 40 08             	mov    0x8(%eax),%eax
c0027525:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint8_t error, lbam, lbah, status;

  select_device (d);
c0027528:	83 ec 0c             	sub    $0xc,%esp
c002752b:	ff 75 08             	push   0x8(%ebp)
c002752e:	e8 1b 08 00 00       	call   c0027d4e <select_device>
c0027533:	83 c4 10             	add    $0x10,%esp

  error = inb (reg_error (c));
c0027536:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027539:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002753d:	83 c0 01             	add    $0x1,%eax
c0027540:	0f b7 c0             	movzwl %ax,%eax
c0027543:	83 ec 0c             	sub    $0xc,%esp
c0027546:	50                   	push   %eax
c0027547:	e8 6e fa ff ff       	call   c0026fba <inb>
c002754c:	83 c4 10             	add    $0x10,%esp
c002754f:	88 45 f3             	mov    %al,-0xd(%ebp)
  lbam = inb (reg_lbam (c));
c0027552:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027555:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027559:	83 c0 04             	add    $0x4,%eax
c002755c:	0f b7 c0             	movzwl %ax,%eax
c002755f:	83 ec 0c             	sub    $0xc,%esp
c0027562:	50                   	push   %eax
c0027563:	e8 52 fa ff ff       	call   c0026fba <inb>
c0027568:	83 c4 10             	add    $0x10,%esp
c002756b:	88 45 f2             	mov    %al,-0xe(%ebp)
  lbah = inb (reg_lbah (c));
c002756e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027571:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027575:	83 c0 05             	add    $0x5,%eax
c0027578:	0f b7 c0             	movzwl %ax,%eax
c002757b:	83 ec 0c             	sub    $0xc,%esp
c002757e:	50                   	push   %eax
c002757f:	e8 36 fa ff ff       	call   c0026fba <inb>
c0027584:	83 c4 10             	add    $0x10,%esp
c0027587:	88 45 f1             	mov    %al,-0xf(%ebp)
  status = inb (reg_status (c));
c002758a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002758d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027591:	83 c0 07             	add    $0x7,%eax
c0027594:	0f b7 c0             	movzwl %ax,%eax
c0027597:	83 ec 0c             	sub    $0xc,%esp
c002759a:	50                   	push   %eax
c002759b:	e8 1a fa ff ff       	call   c0026fba <inb>
c00275a0:	83 c4 10             	add    $0x10,%esp
c00275a3:	88 45 f0             	mov    %al,-0x10(%ebp)

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c00275a6:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
c00275aa:	74 11                	je     c00275bd <check_device_type+0xae>
c00275ac:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c00275b0:	75 1e                	jne    c00275d0 <check_device_type+0xc1>
c00275b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00275b5:	8b 40 0c             	mov    0xc(%eax),%eax
c00275b8:	83 f8 01             	cmp    $0x1,%eax
c00275bb:	74 13                	je     c00275d0 <check_device_type+0xc1>
      || (status & STA_DRDY) == 0
c00275bd:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c00275c1:	83 e0 40             	and    $0x40,%eax
c00275c4:	85 c0                	test   %eax,%eax
c00275c6:	74 08                	je     c00275d0 <check_device_type+0xc1>
      || (status & STA_BSY) != 0)
c00275c8:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c00275cc:	84 c0                	test   %al,%al
c00275ce:	79 10                	jns    c00275e0 <check_device_type+0xd1>
    {
      d->is_ata = false;
c00275d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00275d3:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return error != 0x81;      
c00275d7:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c00275db:	0f 95 c0             	setne  %al
c00275de:	eb 32                	jmp    c0027612 <check_device_type+0x103>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c00275e0:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c00275e4:	75 06                	jne    c00275ec <check_device_type+0xdd>
c00275e6:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c00275ea:	74 0c                	je     c00275f8 <check_device_type+0xe9>
c00275ec:	80 7d f2 3c          	cmpb   $0x3c,-0xe(%ebp)
c00275f0:	75 0d                	jne    c00275ff <check_device_type+0xf0>
c00275f2:	80 7d f1 c3          	cmpb   $0xc3,-0xf(%ebp)
c00275f6:	75 07                	jne    c00275ff <check_device_type+0xf0>
c00275f8:	b8 01 00 00 00       	mov    $0x1,%eax
c00275fd:	eb 05                	jmp    c0027604 <check_device_type+0xf5>
c00275ff:	b8 00 00 00 00       	mov    $0x0,%eax
c0027604:	83 e0 01             	and    $0x1,%eax
c0027607:	8b 55 08             	mov    0x8(%ebp),%edx
c002760a:	88 42 10             	mov    %al,0x10(%edx)
      return true; 
c002760d:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
c0027612:	c9                   	leave  
c0027613:	c3                   	ret    

c0027614 <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c0027614:	55                   	push   %ebp
c0027615:	89 e5                	mov    %esp,%ebp
c0027617:	53                   	push   %ebx
c0027618:	81 ec a4 02 00 00    	sub    $0x2a4,%esp
c002761e:	e8 09 9e 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027623:	81 c3 55 2d 01 00    	add    $0x12d55,%ebx
  struct channel *c = d->channel;
c0027629:	8b 45 08             	mov    0x8(%ebp),%eax
c002762c:	8b 40 08             	mov    0x8(%eax),%eax
c002762f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c0027632:	8b 45 08             	mov    0x8(%ebp),%eax
c0027635:	0f b6 40 10          	movzbl 0x10(%eax),%eax
c0027639:	84 c0                	test   %al,%al
c002763b:	75 29                	jne    c0027666 <identify_ata_device+0x52>
c002763d:	83 ec 0c             	sub    $0xc,%esp
c0027640:	8d 83 7f 8c ff ff    	lea    -0x7381(%ebx),%eax
c0027646:	50                   	push   %eax
c0027647:	8d 83 89 8c ff ff    	lea    -0x7377(%ebx),%eax
c002764d:	50                   	push   %eax
c002764e:	8d 83 a4 8d ff ff    	lea    -0x725c(%ebx),%eax
c0027654:	50                   	push   %eax
c0027655:	68 0d 01 00 00       	push   $0x10d
c002765a:	8d 83 66 8c ff ff    	lea    -0x739a(%ebx),%eax
c0027660:	50                   	push   %eax
c0027661:	e8 fe 40 00 00       	call   c002b764 <debug_panic>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
c0027666:	83 ec 0c             	sub    $0xc,%esp
c0027669:	ff 75 08             	push   0x8(%ebp)
c002766c:	e8 55 07 00 00       	call   c0027dc6 <select_device_wait>
c0027671:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0027674:	83 ec 08             	sub    $0x8,%esp
c0027677:	68 ec 00 00 00       	push   $0xec
c002767c:	ff 75 f4             	push   -0xc(%ebp)
c002767f:	e8 a2 04 00 00       	call   c0027b26 <issue_pio_command>
c0027684:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0027687:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002768a:	83 c0 28             	add    $0x28,%eax
c002768d:	83 ec 0c             	sub    $0xc,%esp
c0027690:	50                   	push   %eax
c0027691:	e8 39 be ff ff       	call   c00234cf <sema_down>
c0027696:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0027699:	83 ec 0c             	sub    $0xc,%esp
c002769c:	ff 75 08             	push   0x8(%ebp)
c002769f:	e8 c8 05 00 00       	call   c0027c6c <wait_while_busy>
c00276a4:	83 c4 10             	add    $0x10,%esp
c00276a7:	83 f0 01             	xor    $0x1,%eax
c00276aa:	84 c0                	test   %al,%al
c00276ac:	74 0c                	je     c00276ba <identify_ata_device+0xa6>
    {
      d->is_ata = false;
c00276ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00276b1:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c00276b5:	e9 03 01 00 00       	jmp    c00277bd <identify_ata_device+0x1a9>
    }
  input_sector (c, id);
c00276ba:	83 ec 08             	sub    $0x8,%esp
c00276bd:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c00276c3:	50                   	push   %eax
c00276c4:	ff 75 f4             	push   -0xc(%ebp)
c00276c7:	e8 d0 04 00 00       	call   c0027b9c <input_sector>
c00276cc:	83 c4 10             	add    $0x10,%esp

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c00276cf:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c00276d5:	83 c0 78             	add    $0x78,%eax
c00276d8:	8b 00                	mov    (%eax),%eax
c00276da:	89 45 f0             	mov    %eax,-0x10(%ebp)
  model = descramble_ata_string (&id[10 * 2], 20);
c00276dd:	83 ec 08             	sub    $0x8,%esp
c00276e0:	6a 14                	push   $0x14
c00276e2:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c00276e8:	83 c0 14             	add    $0x14,%eax
c00276eb:	50                   	push   %eax
c00276ec:	e8 d1 00 00 00       	call   c00277c2 <descramble_ata_string>
c00276f1:	83 c4 10             	add    $0x10,%esp
c00276f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  serial = descramble_ata_string (&id[27 * 2], 40);
c00276f7:	83 ec 08             	sub    $0x8,%esp
c00276fa:	6a 28                	push   $0x28
c00276fc:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0027702:	83 c0 36             	add    $0x36,%eax
c0027705:	50                   	push   %eax
c0027706:	e8 b7 00 00 00       	call   c00277c2 <descramble_ata_string>
c002770b:	83 c4 10             	add    $0x10,%esp
c002770e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  snprintf (extra_info, sizeof extra_info,
c0027711:	83 ec 0c             	sub    $0xc,%esp
c0027714:	ff 75 e8             	push   -0x18(%ebp)
c0027717:	ff 75 ec             	push   -0x14(%ebp)
c002771a:	8d 83 a0 8c ff ff    	lea    -0x7360(%ebx),%eax
c0027720:	50                   	push   %eax
c0027721:	68 80 00 00 00       	push   $0x80
c0027726:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c002772c:	50                   	push   %eax
c002772d:	e8 80 17 00 00       	call   c0028eb2 <snprintf>
c0027732:	83 c4 20             	add    $0x20,%esp
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0027735:	81 7d f0 ff ff 1f 00 	cmpl   $0x1fffff,-0x10(%ebp)
c002773c:	76 49                	jbe    c0027787 <identify_ata_device+0x173>
    {
      printf ("%s: ignoring ", d->name);
c002773e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027741:	83 ec 08             	sub    $0x8,%esp
c0027744:	50                   	push   %eax
c0027745:	8d 83 b8 8c ff ff    	lea    -0x7348(%ebx),%eax
c002774b:	50                   	push   %eax
c002774c:	e8 94 17 00 00       	call   c0028ee5 <printf>
c0027751:	83 c4 10             	add    $0x10,%esp
      print_human_readable_size (capacity * 512);
c0027754:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027757:	c1 e0 09             	shl    $0x9,%eax
c002775a:	ba 00 00 00 00       	mov    $0x0,%edx
c002775f:	83 ec 08             	sub    $0x8,%esp
c0027762:	52                   	push   %edx
c0027763:	50                   	push   %eax
c0027764:	e8 b8 25 00 00       	call   c0029d21 <print_human_readable_size>
c0027769:	83 c4 10             	add    $0x10,%esp
      printf ("disk for safety\n");
c002776c:	83 ec 0c             	sub    $0xc,%esp
c002776f:	8d 83 c6 8c ff ff    	lea    -0x733a(%ebx),%eax
c0027775:	50                   	push   %eax
c0027776:	e8 71 68 00 00       	call   c002dfec <puts>
c002777b:	83 c4 10             	add    $0x10,%esp
      d->is_ata = false;
c002777e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027781:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0027785:	eb 36                	jmp    c00277bd <identify_ata_device+0x1a9>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0027787:	8b 45 08             	mov    0x8(%ebp),%eax
c002778a:	83 ec 08             	sub    $0x8,%esp
c002778d:	ff 75 08             	push   0x8(%ebp)
c0027790:	8d 93 28 06 00 00    	lea    0x628(%ebx),%edx
c0027796:	52                   	push   %edx
c0027797:	ff 75 f0             	push   -0x10(%ebp)
c002779a:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c00277a0:	52                   	push   %edx
c00277a1:	6a 04                	push   $0x4
c00277a3:	50                   	push   %eax
c00277a4:	e8 27 f1 ff ff       	call   c00268d0 <block_register>
c00277a9:	83 c4 20             	add    $0x20,%esp
c00277ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                          &ide_operations, d);
  partition_scan (block);
c00277af:	83 ec 0c             	sub    $0xc,%esp
c00277b2:	ff 75 e4             	push   -0x1c(%ebp)
c00277b5:	e8 8b f2 ff ff       	call   c0026a45 <partition_scan>
c00277ba:	83 c4 10             	add    $0x10,%esp
}
c00277bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00277c0:	c9                   	leave  
c00277c1:	c3                   	ret    

c00277c2 <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c00277c2:	55                   	push   %ebp
c00277c3:	89 e5                	mov    %esp,%ebp
c00277c5:	83 ec 10             	sub    $0x10,%esp
c00277c8:	e8 5b 9c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00277cd:	05 ab 2b 01 00       	add    $0x12bab,%eax
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c00277d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00277d9:	eb 3b                	jmp    c0027816 <descramble_ata_string+0x54>
    {
      char tmp = string[i];
c00277db:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00277de:	8b 45 08             	mov    0x8(%ebp),%eax
c00277e1:	01 d0                	add    %edx,%eax
c00277e3:	0f b6 00             	movzbl (%eax),%eax
c00277e6:	88 45 f7             	mov    %al,-0x9(%ebp)
      string[i] = string[i + 1];
c00277e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00277ec:	8d 50 01             	lea    0x1(%eax),%edx
c00277ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00277f2:	01 d0                	add    %edx,%eax
c00277f4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c00277f7:	8b 55 08             	mov    0x8(%ebp),%edx
c00277fa:	01 ca                	add    %ecx,%edx
c00277fc:	0f b6 00             	movzbl (%eax),%eax
c00277ff:	88 02                	mov    %al,(%edx)
      string[i + 1] = tmp;
c0027801:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027804:	8d 50 01             	lea    0x1(%eax),%edx
c0027807:	8b 45 08             	mov    0x8(%ebp),%eax
c002780a:	01 c2                	add    %eax,%edx
c002780c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0027810:	88 02                	mov    %al,(%edx)
  for (i = 0; i + 1 < size; i += 2)
c0027812:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
c0027816:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027819:	83 c0 01             	add    $0x1,%eax
c002781c:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002781f:	7f ba                	jg     c00277db <descramble_ata_string+0x19>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0027821:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0027825:	eb 2d                	jmp    c0027854 <descramble_ata_string+0x92>
    {
      int c = string[size - 1];
c0027827:	8b 45 0c             	mov    0xc(%ebp),%eax
c002782a:	8d 50 ff             	lea    -0x1(%eax),%edx
c002782d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027830:	01 d0                	add    %edx,%eax
c0027832:	0f b6 00             	movzbl (%eax),%eax
c0027835:	0f be c0             	movsbl %al,%eax
c0027838:	89 45 f8             	mov    %eax,-0x8(%ebp)
      if (c != '\0' && !isspace (c))
c002783b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c002783f:	74 0f                	je     c0027850 <descramble_ata_string+0x8e>
c0027841:	ff 75 f8             	push   -0x8(%ebp)
c0027844:	e8 32 f7 ff ff       	call   c0026f7b <isspace>
c0027849:	83 c4 04             	add    $0x4,%esp
c002784c:	85 c0                	test   %eax,%eax
c002784e:	74 0c                	je     c002785c <descramble_ata_string+0x9a>
  for (size--; size > 0; size--)
c0027850:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0027854:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0027858:	7f cd                	jg     c0027827 <descramble_ata_string+0x65>
c002785a:	eb 01                	jmp    c002785d <descramble_ata_string+0x9b>
        break; 
c002785c:	90                   	nop
    }
  string[size] = '\0';
c002785d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0027860:	8b 45 08             	mov    0x8(%ebp),%eax
c0027863:	01 d0                	add    %edx,%eax
c0027865:	c6 00 00             	movb   $0x0,(%eax)

  return string;
c0027868:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002786b:	c9                   	leave  
c002786c:	c3                   	ret    

c002786d <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c002786d:	55                   	push   %ebp
c002786e:	89 e5                	mov    %esp,%ebp
c0027870:	53                   	push   %ebx
c0027871:	83 ec 14             	sub    $0x14,%esp
c0027874:	e8 b3 9b 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027879:	81 c3 ff 2a 01 00    	add    $0x12aff,%ebx
  struct ata_disk *d = d_;
c002787f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027882:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0027885:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027888:	8b 40 08             	mov    0x8(%eax),%eax
c002788b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c002788e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027891:	83 c0 0c             	add    $0xc,%eax
c0027894:	83 ec 0c             	sub    $0xc,%esp
c0027897:	50                   	push   %eax
c0027898:	e8 9a bf ff ff       	call   c0023837 <lock_acquire>
c002789d:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c00278a0:	83 ec 08             	sub    $0x8,%esp
c00278a3:	ff 75 0c             	push   0xc(%ebp)
c00278a6:	ff 75 f4             	push   -0xc(%ebp)
c00278a9:	e8 59 01 00 00       	call   c0027a07 <select_sector>
c00278ae:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c00278b1:	83 ec 08             	sub    $0x8,%esp
c00278b4:	6a 20                	push   $0x20
c00278b6:	ff 75 f0             	push   -0x10(%ebp)
c00278b9:	e8 68 02 00 00       	call   c0027b26 <issue_pio_command>
c00278be:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c00278c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00278c4:	83 c0 28             	add    $0x28,%eax
c00278c7:	83 ec 0c             	sub    $0xc,%esp
c00278ca:	50                   	push   %eax
c00278cb:	e8 ff bb ff ff       	call   c00234cf <sema_down>
c00278d0:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c00278d3:	83 ec 0c             	sub    $0xc,%esp
c00278d6:	ff 75 f4             	push   -0xc(%ebp)
c00278d9:	e8 8e 03 00 00       	call   c0027c6c <wait_while_busy>
c00278de:	83 c4 10             	add    $0x10,%esp
c00278e1:	83 f0 01             	xor    $0x1,%eax
c00278e4:	84 c0                	test   %al,%al
c00278e6:	74 29                	je     c0027911 <ide_read+0xa4>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c00278e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00278eb:	83 ec 08             	sub    $0x8,%esp
c00278ee:	ff 75 0c             	push   0xc(%ebp)
c00278f1:	50                   	push   %eax
c00278f2:	8d 83 d8 8c ff ff    	lea    -0x7328(%ebx),%eax
c00278f8:	50                   	push   %eax
c00278f9:	8d 83 b8 8d ff ff    	lea    -0x7248(%ebx),%eax
c00278ff:	50                   	push   %eax
c0027900:	68 62 01 00 00       	push   $0x162
c0027905:	8d 83 66 8c ff ff    	lea    -0x739a(%ebx),%eax
c002790b:	50                   	push   %eax
c002790c:	e8 53 3e 00 00       	call   c002b764 <debug_panic>
  input_sector (c, buffer);
c0027911:	83 ec 08             	sub    $0x8,%esp
c0027914:	ff 75 10             	push   0x10(%ebp)
c0027917:	ff 75 f0             	push   -0x10(%ebp)
c002791a:	e8 7d 02 00 00       	call   c0027b9c <input_sector>
c002791f:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0027922:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027925:	83 c0 0c             	add    $0xc,%eax
c0027928:	83 ec 0c             	sub    $0xc,%esp
c002792b:	50                   	push   %eax
c002792c:	e8 b4 c1 ff ff       	call   c0023ae5 <lock_release>
c0027931:	83 c4 10             	add    $0x10,%esp
}
c0027934:	90                   	nop
c0027935:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027938:	c9                   	leave  
c0027939:	c3                   	ret    

c002793a <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c002793a:	55                   	push   %ebp
c002793b:	89 e5                	mov    %esp,%ebp
c002793d:	53                   	push   %ebx
c002793e:	83 ec 14             	sub    $0x14,%esp
c0027941:	e8 e6 9a 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027946:	81 c3 32 2a 01 00    	add    $0x12a32,%ebx
  struct ata_disk *d = d_;
c002794c:	8b 45 08             	mov    0x8(%ebp),%eax
c002794f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0027952:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027955:	8b 40 08             	mov    0x8(%eax),%eax
c0027958:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c002795b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002795e:	83 c0 0c             	add    $0xc,%eax
c0027961:	83 ec 0c             	sub    $0xc,%esp
c0027964:	50                   	push   %eax
c0027965:	e8 cd be ff ff       	call   c0023837 <lock_acquire>
c002796a:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c002796d:	83 ec 08             	sub    $0x8,%esp
c0027970:	ff 75 0c             	push   0xc(%ebp)
c0027973:	ff 75 f4             	push   -0xc(%ebp)
c0027976:	e8 8c 00 00 00       	call   c0027a07 <select_sector>
c002797b:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c002797e:	83 ec 08             	sub    $0x8,%esp
c0027981:	6a 30                	push   $0x30
c0027983:	ff 75 f0             	push   -0x10(%ebp)
c0027986:	e8 9b 01 00 00       	call   c0027b26 <issue_pio_command>
c002798b:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c002798e:	83 ec 0c             	sub    $0xc,%esp
c0027991:	ff 75 f4             	push   -0xc(%ebp)
c0027994:	e8 d3 02 00 00       	call   c0027c6c <wait_while_busy>
c0027999:	83 c4 10             	add    $0x10,%esp
c002799c:	83 f0 01             	xor    $0x1,%eax
c002799f:	84 c0                	test   %al,%al
c00279a1:	74 29                	je     c00279cc <ide_write+0x92>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c00279a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00279a6:	83 ec 08             	sub    $0x8,%esp
c00279a9:	ff 75 0c             	push   0xc(%ebp)
c00279ac:	50                   	push   %eax
c00279ad:	8d 83 f8 8c ff ff    	lea    -0x7308(%ebx),%eax
c00279b3:	50                   	push   %eax
c00279b4:	8d 83 c4 8d ff ff    	lea    -0x723c(%ebx),%eax
c00279ba:	50                   	push   %eax
c00279bb:	68 75 01 00 00       	push   $0x175
c00279c0:	8d 83 66 8c ff ff    	lea    -0x739a(%ebx),%eax
c00279c6:	50                   	push   %eax
c00279c7:	e8 98 3d 00 00       	call   c002b764 <debug_panic>
  output_sector (c, buffer);
c00279cc:	83 ec 08             	sub    $0x8,%esp
c00279cf:	ff 75 10             	push   0x10(%ebp)
c00279d2:	ff 75 f0             	push   -0x10(%ebp)
c00279d5:	e8 ed 01 00 00       	call   c0027bc7 <output_sector>
c00279da:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c00279dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00279e0:	83 c0 28             	add    $0x28,%eax
c00279e3:	83 ec 0c             	sub    $0xc,%esp
c00279e6:	50                   	push   %eax
c00279e7:	e8 e3 ba ff ff       	call   c00234cf <sema_down>
c00279ec:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c00279ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00279f2:	83 c0 0c             	add    $0xc,%eax
c00279f5:	83 ec 0c             	sub    $0xc,%esp
c00279f8:	50                   	push   %eax
c00279f9:	e8 e7 c0 ff ff       	call   c0023ae5 <lock_release>
c00279fe:	83 c4 10             	add    $0x10,%esp
}
c0027a01:	90                   	nop
c0027a02:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027a05:	c9                   	leave  
c0027a06:	c3                   	ret    

c0027a07 <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c0027a07:	55                   	push   %ebp
c0027a08:	89 e5                	mov    %esp,%ebp
c0027a0a:	53                   	push   %ebx
c0027a0b:	83 ec 14             	sub    $0x14,%esp
c0027a0e:	e8 15 9a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0027a13:	05 65 29 01 00       	add    $0x12965,%eax
  struct channel *c = d->channel;
c0027a18:	8b 55 08             	mov    0x8(%ebp),%edx
c0027a1b:	8b 52 08             	mov    0x8(%edx),%edx
c0027a1e:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (sec_no < (1UL << 28));
c0027a21:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
c0027a28:	76 2b                	jbe    c0027a55 <select_sector+0x4e>
c0027a2a:	83 ec 0c             	sub    $0xc,%esp
c0027a2d:	8d 90 19 8d ff ff    	lea    -0x72e7(%eax),%edx
c0027a33:	52                   	push   %edx
c0027a34:	8d 90 89 8c ff ff    	lea    -0x7377(%eax),%edx
c0027a3a:	52                   	push   %edx
c0027a3b:	8d 90 d0 8d ff ff    	lea    -0x7230(%eax),%edx
c0027a41:	52                   	push   %edx
c0027a42:	68 89 01 00 00       	push   $0x189
c0027a47:	8d 90 66 8c ff ff    	lea    -0x739a(%eax),%edx
c0027a4d:	52                   	push   %edx
c0027a4e:	89 c3                	mov    %eax,%ebx
c0027a50:	e8 0f 3d 00 00       	call   c002b764 <debug_panic>
  
  select_device_wait (d);
c0027a55:	83 ec 0c             	sub    $0xc,%esp
c0027a58:	ff 75 08             	push   0x8(%ebp)
c0027a5b:	e8 66 03 00 00       	call   c0027dc6 <select_device_wait>
c0027a60:	83 c4 10             	add    $0x10,%esp
  outb (reg_nsect (c), 1);
c0027a63:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027a66:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027a6a:	83 c0 02             	add    $0x2,%eax
c0027a6d:	0f b7 c0             	movzwl %ax,%eax
c0027a70:	83 ec 08             	sub    $0x8,%esp
c0027a73:	6a 01                	push   $0x1
c0027a75:	50                   	push   %eax
c0027a76:	e8 a4 f5 ff ff       	call   c002701f <outb>
c0027a7b:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbal (c), sec_no);
c0027a7e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a81:	0f b6 d0             	movzbl %al,%edx
c0027a84:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027a87:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027a8b:	83 c0 03             	add    $0x3,%eax
c0027a8e:	0f b7 c0             	movzwl %ax,%eax
c0027a91:	83 ec 08             	sub    $0x8,%esp
c0027a94:	52                   	push   %edx
c0027a95:	50                   	push   %eax
c0027a96:	e8 84 f5 ff ff       	call   c002701f <outb>
c0027a9b:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbam (c), sec_no >> 8);
c0027a9e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027aa1:	c1 e8 08             	shr    $0x8,%eax
c0027aa4:	0f b6 d0             	movzbl %al,%edx
c0027aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027aaa:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027aae:	83 c0 04             	add    $0x4,%eax
c0027ab1:	0f b7 c0             	movzwl %ax,%eax
c0027ab4:	83 ec 08             	sub    $0x8,%esp
c0027ab7:	52                   	push   %edx
c0027ab8:	50                   	push   %eax
c0027ab9:	e8 61 f5 ff ff       	call   c002701f <outb>
c0027abe:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbah (c), (sec_no >> 16));
c0027ac1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ac4:	c1 e8 10             	shr    $0x10,%eax
c0027ac7:	0f b6 d0             	movzbl %al,%edx
c0027aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027acd:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027ad1:	83 c0 05             	add    $0x5,%eax
c0027ad4:	0f b7 c0             	movzwl %ax,%eax
c0027ad7:	83 ec 08             	sub    $0x8,%esp
c0027ada:	52                   	push   %edx
c0027adb:	50                   	push   %eax
c0027adc:	e8 3e f5 ff ff       	call   c002701f <outb>
c0027ae1:	83 c4 10             	add    $0x10,%esp
  outb (reg_device (c),
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0027ae4:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ae7:	8b 40 0c             	mov    0xc(%eax),%eax
c0027aea:	83 f8 01             	cmp    $0x1,%eax
c0027aed:	75 07                	jne    c0027af6 <select_sector+0xef>
c0027aef:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
c0027af4:	eb 05                	jmp    c0027afb <select_sector+0xf4>
c0027af6:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
c0027afb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027afe:	c1 e8 18             	shr    $0x18,%eax
c0027b01:	09 d0                	or     %edx,%eax
  outb (reg_device (c),
c0027b03:	0f b6 d0             	movzbl %al,%edx
c0027b06:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027b09:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027b0d:	83 c0 06             	add    $0x6,%eax
c0027b10:	0f b7 c0             	movzwl %ax,%eax
c0027b13:	83 ec 08             	sub    $0x8,%esp
c0027b16:	52                   	push   %edx
c0027b17:	50                   	push   %eax
c0027b18:	e8 02 f5 ff ff       	call   c002701f <outb>
c0027b1d:	83 c4 10             	add    $0x10,%esp
}
c0027b20:	90                   	nop
c0027b21:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027b24:	c9                   	leave  
c0027b25:	c3                   	ret    

c0027b26 <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c0027b26:	55                   	push   %ebp
c0027b27:	89 e5                	mov    %esp,%ebp
c0027b29:	53                   	push   %ebx
c0027b2a:	83 ec 14             	sub    $0x14,%esp
c0027b2d:	e8 fa 98 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027b32:	81 c3 46 28 01 00    	add    $0x12846,%ebx
c0027b38:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027b3b:	88 45 f4             	mov    %al,-0xc(%ebp)
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c0027b3e:	e8 0a a3 ff ff       	call   c0021e4d <intr_get_level>
c0027b43:	83 f8 01             	cmp    $0x1,%eax
c0027b46:	74 29                	je     c0027b71 <issue_pio_command+0x4b>
c0027b48:	83 ec 0c             	sub    $0xc,%esp
c0027b4b:	8d 83 2e 8d ff ff    	lea    -0x72d2(%ebx),%eax
c0027b51:	50                   	push   %eax
c0027b52:	8d 83 89 8c ff ff    	lea    -0x7377(%ebx),%eax
c0027b58:	50                   	push   %eax
c0027b59:	8d 83 e0 8d ff ff    	lea    -0x7220(%ebx),%eax
c0027b5f:	50                   	push   %eax
c0027b60:	68 9b 01 00 00       	push   $0x19b
c0027b65:	8d 83 66 8c ff ff    	lea    -0x739a(%ebx),%eax
c0027b6b:	50                   	push   %eax
c0027b6c:	e8 f3 3b 00 00       	call   c002b764 <debug_panic>

  c->expecting_interrupt = true;
c0027b71:	8b 45 08             	mov    0x8(%ebp),%eax
c0027b74:	c6 40 24 01          	movb   $0x1,0x24(%eax)
  outb (reg_command (c), command);
c0027b78:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0027b7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0027b7f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027b83:	83 c0 07             	add    $0x7,%eax
c0027b86:	0f b7 c0             	movzwl %ax,%eax
c0027b89:	83 ec 08             	sub    $0x8,%esp
c0027b8c:	52                   	push   %edx
c0027b8d:	50                   	push   %eax
c0027b8e:	e8 8c f4 ff ff       	call   c002701f <outb>
c0027b93:	83 c4 10             	add    $0x10,%esp
}
c0027b96:	90                   	nop
c0027b97:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027b9a:	c9                   	leave  
c0027b9b:	c3                   	ret    

c0027b9c <input_sector>:

/* Reads a sector from channel C's data register in PIO mode into
   SECTOR, which must have room for BLOCK_SECTOR_SIZE bytes. */
static void
input_sector (struct channel *c, void *sector) 
{
c0027b9c:	55                   	push   %ebp
c0027b9d:	89 e5                	mov    %esp,%ebp
c0027b9f:	e8 84 98 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0027ba4:	05 d4 27 01 00       	add    $0x127d4,%eax
  insw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0027ba9:	8b 45 08             	mov    0x8(%ebp),%eax
c0027bac:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027bb0:	0f b7 c0             	movzwl %ax,%eax
c0027bb3:	68 00 01 00 00       	push   $0x100
c0027bb8:	ff 75 0c             	push   0xc(%ebp)
c0027bbb:	50                   	push   %eax
c0027bbc:	e8 20 f4 ff ff       	call   c0026fe1 <insw>
c0027bc1:	83 c4 0c             	add    $0xc,%esp
}
c0027bc4:	90                   	nop
c0027bc5:	c9                   	leave  
c0027bc6:	c3                   	ret    

c0027bc7 <output_sector>:

/* Writes SECTOR to channel C's data register in PIO mode.
   SECTOR must contain BLOCK_SECTOR_SIZE bytes. */
static void
output_sector (struct channel *c, const void *sector) 
{
c0027bc7:	55                   	push   %ebp
c0027bc8:	89 e5                	mov    %esp,%ebp
c0027bca:	e8 59 98 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0027bcf:	05 a9 27 01 00       	add    $0x127a9,%eax
  outsw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0027bd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0027bd7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027bdb:	0f b7 c0             	movzwl %ax,%eax
c0027bde:	68 00 01 00 00       	push   $0x100
c0027be3:	ff 75 0c             	push   0xc(%ebp)
c0027be6:	50                   	push   %eax
c0027be7:	e8 5e f4 ff ff       	call   c002704a <outsw>
c0027bec:	83 c4 0c             	add    $0xc,%esp
}
c0027bef:	90                   	nop
c0027bf0:	c9                   	leave  
c0027bf1:	c3                   	ret    

c0027bf2 <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c0027bf2:	55                   	push   %ebp
c0027bf3:	89 e5                	mov    %esp,%ebp
c0027bf5:	53                   	push   %ebx
c0027bf6:	83 ec 14             	sub    $0x14,%esp
c0027bf9:	e8 2e 98 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027bfe:	81 c3 7a 27 01 00    	add    $0x1277a,%ebx
  int i;

  for (i = 0; i < 1000; i++) 
c0027c04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0027c0b:	eb 38                	jmp    c0027c45 <wait_until_idle+0x53>
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0027c0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c10:	8b 40 08             	mov    0x8(%eax),%eax
c0027c13:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027c17:	83 c0 07             	add    $0x7,%eax
c0027c1a:	0f b7 c0             	movzwl %ax,%eax
c0027c1d:	50                   	push   %eax
c0027c1e:	e8 97 f3 ff ff       	call   c0026fba <inb>
c0027c23:	83 c4 04             	add    $0x4,%esp
c0027c26:	0f b6 c0             	movzbl %al,%eax
c0027c29:	25 88 00 00 00       	and    $0x88,%eax
c0027c2e:	85 c0                	test   %eax,%eax
c0027c30:	74 34                	je     c0027c66 <wait_until_idle+0x74>
        return;
      timer_usleep (10);
c0027c32:	83 ec 08             	sub    $0x8,%esp
c0027c35:	6a 00                	push   $0x0
c0027c37:	6a 0a                	push   $0xa
c0027c39:	e8 a7 d5 ff ff       	call   c00251e5 <timer_usleep>
c0027c3e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 1000; i++) 
c0027c41:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0027c45:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c0027c4c:	7e bf                	jle    c0027c0d <wait_until_idle+0x1b>
    }

  printf ("%s: idle timeout\n", d->name);
c0027c4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c51:	83 ec 08             	sub    $0x8,%esp
c0027c54:	50                   	push   %eax
c0027c55:	8d 83 4b 8d ff ff    	lea    -0x72b5(%ebx),%eax
c0027c5b:	50                   	push   %eax
c0027c5c:	e8 84 12 00 00       	call   c0028ee5 <printf>
c0027c61:	83 c4 10             	add    $0x10,%esp
c0027c64:	eb 01                	jmp    c0027c67 <wait_until_idle+0x75>
        return;
c0027c66:	90                   	nop
}
c0027c67:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027c6a:	c9                   	leave  
c0027c6b:	c3                   	ret    

c0027c6c <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c0027c6c:	55                   	push   %ebp
c0027c6d:	89 e5                	mov    %esp,%ebp
c0027c6f:	53                   	push   %ebx
c0027c70:	83 ec 14             	sub    $0x14,%esp
c0027c73:	e8 b4 97 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027c78:	81 c3 00 27 01 00    	add    $0x12700,%ebx
  struct channel *c = d->channel;
c0027c7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c81:	8b 40 08             	mov    0x8(%eax),%eax
c0027c84:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < 3000; i++)
c0027c87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0027c8e:	e9 92 00 00 00       	jmp    c0027d25 <wait_while_busy+0xb9>
    {
      if (i == 700)
c0027c93:	81 7d f4 bc 02 00 00 	cmpl   $0x2bc,-0xc(%ebp)
c0027c9a:	75 16                	jne    c0027cb2 <wait_while_busy+0x46>
        printf ("%s: busy, waiting...", d->name);
c0027c9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c9f:	83 ec 08             	sub    $0x8,%esp
c0027ca2:	50                   	push   %eax
c0027ca3:	8d 83 5d 8d ff ff    	lea    -0x72a3(%ebx),%eax
c0027ca9:	50                   	push   %eax
c0027caa:	e8 36 12 00 00       	call   c0028ee5 <printf>
c0027caf:	83 c4 10             	add    $0x10,%esp
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c0027cb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027cb5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027cb9:	66 05 06 02          	add    $0x206,%ax
c0027cbd:	0f b7 c0             	movzwl %ax,%eax
c0027cc0:	83 ec 0c             	sub    $0xc,%esp
c0027cc3:	50                   	push   %eax
c0027cc4:	e8 f1 f2 ff ff       	call   c0026fba <inb>
c0027cc9:	83 c4 10             	add    $0x10,%esp
c0027ccc:	84 c0                	test   %al,%al
c0027cce:	78 42                	js     c0027d12 <wait_while_busy+0xa6>
        {
          if (i >= 700)
c0027cd0:	81 7d f4 bb 02 00 00 	cmpl   $0x2bb,-0xc(%ebp)
c0027cd7:	7e 12                	jle    c0027ceb <wait_while_busy+0x7f>
            printf ("ok\n");
c0027cd9:	83 ec 0c             	sub    $0xc,%esp
c0027cdc:	8d 83 72 8d ff ff    	lea    -0x728e(%ebx),%eax
c0027ce2:	50                   	push   %eax
c0027ce3:	e8 04 63 00 00       	call   c002dfec <puts>
c0027ce8:	83 c4 10             	add    $0x10,%esp
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c0027ceb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027cee:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027cf2:	66 05 06 02          	add    $0x206,%ax
c0027cf6:	0f b7 c0             	movzwl %ax,%eax
c0027cf9:	83 ec 0c             	sub    $0xc,%esp
c0027cfc:	50                   	push   %eax
c0027cfd:	e8 b8 f2 ff ff       	call   c0026fba <inb>
c0027d02:	83 c4 10             	add    $0x10,%esp
c0027d05:	0f b6 c0             	movzbl %al,%eax
c0027d08:	83 e0 08             	and    $0x8,%eax
c0027d0b:	85 c0                	test   %eax,%eax
c0027d0d:	0f 95 c0             	setne  %al
c0027d10:	eb 37                	jmp    c0027d49 <wait_while_busy+0xdd>
        }
      timer_msleep (10);
c0027d12:	83 ec 08             	sub    $0x8,%esp
c0027d15:	6a 00                	push   $0x0
c0027d17:	6a 0a                	push   $0xa
c0027d19:	e8 92 d4 ff ff       	call   c00251b0 <timer_msleep>
c0027d1e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 3000; i++)
c0027d21:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0027d25:	81 7d f4 b7 0b 00 00 	cmpl   $0xbb7,-0xc(%ebp)
c0027d2c:	0f 8e 61 ff ff ff    	jle    c0027c93 <wait_while_busy+0x27>
    }

  printf ("failed\n");
c0027d32:	83 ec 0c             	sub    $0xc,%esp
c0027d35:	8d 83 75 8d ff ff    	lea    -0x728b(%ebx),%eax
c0027d3b:	50                   	push   %eax
c0027d3c:	e8 ab 62 00 00       	call   c002dfec <puts>
c0027d41:	83 c4 10             	add    $0x10,%esp
  return false;
c0027d44:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0027d49:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027d4c:	c9                   	leave  
c0027d4d:	c3                   	ret    

c0027d4e <select_device>:

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c0027d4e:	55                   	push   %ebp
c0027d4f:	89 e5                	mov    %esp,%ebp
c0027d51:	53                   	push   %ebx
c0027d52:	83 ec 14             	sub    $0x14,%esp
c0027d55:	e8 d2 96 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027d5a:	81 c3 1e 26 01 00    	add    $0x1261e,%ebx
  struct channel *c = d->channel;
c0027d60:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d63:	8b 40 08             	mov    0x8(%eax),%eax
c0027d66:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t dev = DEV_MBS;
c0027d69:	c6 45 f7 a0          	movb   $0xa0,-0x9(%ebp)
  if (d->dev_no == 1)
c0027d6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d70:	8b 40 0c             	mov    0xc(%eax),%eax
c0027d73:	83 f8 01             	cmp    $0x1,%eax
c0027d76:	75 04                	jne    c0027d7c <select_device+0x2e>
    dev |= DEV_DEV;
c0027d78:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
  outb (reg_device (c), dev);
c0027d7c:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0027d80:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027d83:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027d87:	83 c0 06             	add    $0x6,%eax
c0027d8a:	0f b7 c0             	movzwl %ax,%eax
c0027d8d:	52                   	push   %edx
c0027d8e:	50                   	push   %eax
c0027d8f:	e8 8b f2 ff ff       	call   c002701f <outb>
c0027d94:	83 c4 08             	add    $0x8,%esp
  inb (reg_alt_status (c));
c0027d97:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027d9a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027d9e:	66 05 06 02          	add    $0x206,%ax
c0027da2:	0f b7 c0             	movzwl %ax,%eax
c0027da5:	50                   	push   %eax
c0027da6:	e8 0f f2 ff ff       	call   c0026fba <inb>
c0027dab:	83 c4 04             	add    $0x4,%esp
  timer_nsleep (400);
c0027dae:	83 ec 08             	sub    $0x8,%esp
c0027db1:	6a 00                	push   $0x0
c0027db3:	68 90 01 00 00       	push   $0x190
c0027db8:	e8 5d d4 ff ff       	call   c002521a <timer_nsleep>
c0027dbd:	83 c4 10             	add    $0x10,%esp
}
c0027dc0:	90                   	nop
c0027dc1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027dc4:	c9                   	leave  
c0027dc5:	c3                   	ret    

c0027dc6 <select_device_wait>:

/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
c0027dc6:	55                   	push   %ebp
c0027dc7:	89 e5                	mov    %esp,%ebp
c0027dc9:	83 ec 08             	sub    $0x8,%esp
c0027dcc:	e8 57 96 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0027dd1:	05 a7 25 01 00       	add    $0x125a7,%eax
  wait_until_idle (d);
c0027dd6:	83 ec 0c             	sub    $0xc,%esp
c0027dd9:	ff 75 08             	push   0x8(%ebp)
c0027ddc:	e8 11 fe ff ff       	call   c0027bf2 <wait_until_idle>
c0027de1:	83 c4 10             	add    $0x10,%esp
  select_device (d);
c0027de4:	83 ec 0c             	sub    $0xc,%esp
c0027de7:	ff 75 08             	push   0x8(%ebp)
c0027dea:	e8 5f ff ff ff       	call   c0027d4e <select_device>
c0027def:	83 c4 10             	add    $0x10,%esp
  wait_until_idle (d);
c0027df2:	83 ec 0c             	sub    $0xc,%esp
c0027df5:	ff 75 08             	push   0x8(%ebp)
c0027df8:	e8 f5 fd ff ff       	call   c0027bf2 <wait_until_idle>
c0027dfd:	83 c4 10             	add    $0x10,%esp
}
c0027e00:	90                   	nop
c0027e01:	c9                   	leave  
c0027e02:	c3                   	ret    

c0027e03 <interrupt_handler>:

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c0027e03:	55                   	push   %ebp
c0027e04:	89 e5                	mov    %esp,%ebp
c0027e06:	53                   	push   %ebx
c0027e07:	83 ec 14             	sub    $0x14,%esp
c0027e0a:	e8 1d 96 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027e0f:	81 c3 69 25 01 00    	add    $0x12569,%ebx
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0027e15:	8d 83 08 20 00 00    	lea    0x2008(%ebx),%eax
c0027e1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0027e1e:	eb 65                	jmp    c0027e85 <interrupt_handler+0x82>
    if (f->vec_no == c->irq)
c0027e20:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e23:	8b 50 30             	mov    0x30(%eax),%edx
c0027e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e29:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c0027e2d:	0f b6 c0             	movzbl %al,%eax
c0027e30:	39 c2                	cmp    %eax,%edx
c0027e32:	75 4d                	jne    c0027e81 <interrupt_handler+0x7e>
      {
        if (c->expecting_interrupt) 
c0027e34:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e37:	0f b6 40 24          	movzbl 0x24(%eax),%eax
c0027e3b:	84 c0                	test   %al,%al
c0027e3d:	74 2a                	je     c0027e69 <interrupt_handler+0x66>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
c0027e3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e42:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0027e46:	83 c0 07             	add    $0x7,%eax
c0027e49:	0f b7 c0             	movzwl %ax,%eax
c0027e4c:	50                   	push   %eax
c0027e4d:	e8 68 f1 ff ff       	call   c0026fba <inb>
c0027e52:	83 c4 04             	add    $0x4,%esp
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c0027e55:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e58:	83 c0 28             	add    $0x28,%eax
c0027e5b:	83 ec 0c             	sub    $0xc,%esp
c0027e5e:	50                   	push   %eax
c0027e5f:	e8 ac b7 ff ff       	call   c0023610 <sema_up>
c0027e64:	83 c4 10             	add    $0x10,%esp
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
c0027e67:	eb 46                	jmp    c0027eaf <interrupt_handler+0xac>
          printf ("%s: unexpected interrupt\n", c->name);
c0027e69:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e6c:	83 ec 08             	sub    $0x8,%esp
c0027e6f:	50                   	push   %eax
c0027e70:	8d 83 7c 8d ff ff    	lea    -0x7284(%ebx),%eax
c0027e76:	50                   	push   %eax
c0027e77:	e8 69 10 00 00       	call   c0028ee5 <printf>
c0027e7c:	83 c4 10             	add    $0x10,%esp
        return;
c0027e7f:	eb 2e                	jmp    c0027eaf <interrupt_handler+0xac>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0027e81:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
c0027e85:	8d 83 d0 20 00 00    	lea    0x20d0(%ebx),%eax
c0027e8b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0027e8e:	72 90                	jb     c0027e20 <interrupt_handler+0x1d>
      }

  NOT_REACHED ();
c0027e90:	8d 83 44 8c ff ff    	lea    -0x73bc(%ebx),%eax
c0027e96:	50                   	push   %eax
c0027e97:	8d 83 f4 8d ff ff    	lea    -0x720c(%ebx),%eax
c0027e9d:	50                   	push   %eax
c0027e9e:	68 0c 02 00 00       	push   $0x20c
c0027ea3:	8d 83 66 8c ff ff    	lea    -0x739a(%ebx),%eax
c0027ea9:	50                   	push   %eax
c0027eaa:	e8 b5 38 00 00       	call   c002b764 <debug_panic>
}
c0027eaf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027eb2:	c9                   	leave  
c0027eb3:	c3                   	ret    

c0027eb4 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c0027eb4:	55                   	push   %ebp
c0027eb5:	89 e5                	mov    %esp,%ebp
c0027eb7:	53                   	push   %ebx
c0027eb8:	83 ec 04             	sub    $0x4,%esp
c0027ebb:	e8 68 95 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0027ec0:	05 b8 24 01 00       	add    $0x124b8,%eax
  intq_init (&buffer);
c0027ec5:	83 ec 0c             	sub    $0xc,%esp
c0027ec8:	8d 90 e8 20 00 00    	lea    0x20e8(%eax),%edx
c0027ece:	52                   	push   %edx
c0027ecf:	89 c3                	mov    %eax,%ebx
c0027ed1:	e8 54 01 00 00       	call   c002802a <intq_init>
c0027ed6:	83 c4 10             	add    $0x10,%esp
}
c0027ed9:	90                   	nop
c0027eda:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027edd:	c9                   	leave  
c0027ede:	c3                   	ret    

c0027edf <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c0027edf:	55                   	push   %ebp
c0027ee0:	89 e5                	mov    %esp,%ebp
c0027ee2:	53                   	push   %ebx
c0027ee3:	83 ec 14             	sub    $0x14,%esp
c0027ee6:	e8 41 95 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027eeb:	81 c3 8d 24 01 00    	add    $0x1248d,%ebx
c0027ef1:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ef4:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0027ef7:	e8 51 9f ff ff       	call   c0021e4d <intr_get_level>
c0027efc:	85 c0                	test   %eax,%eax
c0027efe:	74 26                	je     c0027f26 <input_putc+0x47>
c0027f00:	83 ec 0c             	sub    $0xc,%esp
c0027f03:	8d 83 08 8e ff ff    	lea    -0x71f8(%ebx),%eax
c0027f09:	50                   	push   %eax
c0027f0a:	8d 83 26 8e ff ff    	lea    -0x71da(%ebx),%eax
c0027f10:	50                   	push   %eax
c0027f11:	8d 83 68 8e ff ff    	lea    -0x7198(%ebx),%eax
c0027f17:	50                   	push   %eax
c0027f18:	6a 15                	push   $0x15
c0027f1a:	8d 83 3d 8e ff ff    	lea    -0x71c3(%ebx),%eax
c0027f20:	50                   	push   %eax
c0027f21:	e8 3e 38 00 00       	call   c002b764 <debug_panic>
  ASSERT (!intq_full (&buffer));
c0027f26:	83 ec 0c             	sub    $0xc,%esp
c0027f29:	8d 83 e8 20 00 00    	lea    0x20e8(%ebx),%eax
c0027f2f:	50                   	push   %eax
c0027f30:	e8 a0 01 00 00       	call   c00280d5 <intq_full>
c0027f35:	83 c4 10             	add    $0x10,%esp
c0027f38:	83 f0 01             	xor    $0x1,%eax
c0027f3b:	84 c0                	test   %al,%al
c0027f3d:	75 26                	jne    c0027f65 <input_putc+0x86>
c0027f3f:	83 ec 0c             	sub    $0xc,%esp
c0027f42:	8d 83 53 8e ff ff    	lea    -0x71ad(%ebx),%eax
c0027f48:	50                   	push   %eax
c0027f49:	8d 83 26 8e ff ff    	lea    -0x71da(%ebx),%eax
c0027f4f:	50                   	push   %eax
c0027f50:	8d 83 68 8e ff ff    	lea    -0x7198(%ebx),%eax
c0027f56:	50                   	push   %eax
c0027f57:	6a 16                	push   $0x16
c0027f59:	8d 83 3d 8e ff ff    	lea    -0x71c3(%ebx),%eax
c0027f5f:	50                   	push   %eax
c0027f60:	e8 ff 37 00 00       	call   c002b764 <debug_panic>

  intq_putc (&buffer, key);
c0027f65:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0027f69:	83 ec 08             	sub    $0x8,%esp
c0027f6c:	50                   	push   %eax
c0027f6d:	8d 83 e8 20 00 00    	lea    0x20e8(%ebx),%eax
c0027f73:	50                   	push   %eax
c0027f74:	e8 c2 02 00 00       	call   c002823b <intq_putc>
c0027f79:	83 c4 10             	add    $0x10,%esp
  serial_notify ();
c0027f7c:	e8 66 e2 ff ff       	call   c00261e7 <serial_notify>
}
c0027f81:	90                   	nop
c0027f82:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027f85:	c9                   	leave  
c0027f86:	c3                   	ret    

c0027f87 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c0027f87:	55                   	push   %ebp
c0027f88:	89 e5                	mov    %esp,%ebp
c0027f8a:	53                   	push   %ebx
c0027f8b:	83 ec 14             	sub    $0x14,%esp
c0027f8e:	e8 99 94 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027f93:	81 c3 e5 23 01 00    	add    $0x123e5,%ebx
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0027f99:	e8 48 9f ff ff       	call   c0021ee6 <intr_disable>
c0027f9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  key = intq_getc (&buffer);
c0027fa1:	83 ec 0c             	sub    $0xc,%esp
c0027fa4:	8d 83 e8 20 00 00    	lea    0x20e8(%ebx),%eax
c0027faa:	50                   	push   %eax
c0027fab:	e8 88 01 00 00       	call   c0028138 <intq_getc>
c0027fb0:	83 c4 10             	add    $0x10,%esp
c0027fb3:	88 45 f3             	mov    %al,-0xd(%ebp)
  serial_notify ();
c0027fb6:	e8 2c e2 ff ff       	call   c00261e7 <serial_notify>
  intr_set_level (old_level);
c0027fbb:	83 ec 0c             	sub    $0xc,%esp
c0027fbe:	ff 75 f4             	push   -0xc(%ebp)
c0027fc1:	e8 a7 9e ff ff       	call   c0021e6d <intr_set_level>
c0027fc6:	83 c4 10             	add    $0x10,%esp
  
  return key;
c0027fc9:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
}
c0027fcd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027fd0:	c9                   	leave  
c0027fd1:	c3                   	ret    

c0027fd2 <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c0027fd2:	55                   	push   %ebp
c0027fd3:	89 e5                	mov    %esp,%ebp
c0027fd5:	53                   	push   %ebx
c0027fd6:	83 ec 04             	sub    $0x4,%esp
c0027fd9:	e8 4e 94 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0027fde:	81 c3 9a 23 01 00    	add    $0x1239a,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0027fe4:	e8 64 9e ff ff       	call   c0021e4d <intr_get_level>
c0027fe9:	85 c0                	test   %eax,%eax
c0027feb:	74 26                	je     c0028013 <input_full+0x41>
c0027fed:	83 ec 0c             	sub    $0xc,%esp
c0027ff0:	8d 83 08 8e ff ff    	lea    -0x71f8(%ebx),%eax
c0027ff6:	50                   	push   %eax
c0027ff7:	8d 83 26 8e ff ff    	lea    -0x71da(%ebx),%eax
c0027ffd:	50                   	push   %eax
c0027ffe:	8d 83 74 8e ff ff    	lea    -0x718c(%ebx),%eax
c0028004:	50                   	push   %eax
c0028005:	6a 32                	push   $0x32
c0028007:	8d 83 3d 8e ff ff    	lea    -0x71c3(%ebx),%eax
c002800d:	50                   	push   %eax
c002800e:	e8 51 37 00 00       	call   c002b764 <debug_panic>
  return intq_full (&buffer);
c0028013:	83 ec 0c             	sub    $0xc,%esp
c0028016:	8d 83 e8 20 00 00    	lea    0x20e8(%ebx),%eax
c002801c:	50                   	push   %eax
c002801d:	e8 b3 00 00 00       	call   c00280d5 <intq_full>
c0028022:	83 c4 10             	add    $0x10,%esp
}
c0028025:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028028:	c9                   	leave  
c0028029:	c3                   	ret    

c002802a <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c002802a:	55                   	push   %ebp
c002802b:	89 e5                	mov    %esp,%ebp
c002802d:	53                   	push   %ebx
c002802e:	83 ec 04             	sub    $0x4,%esp
c0028031:	e8 f2 93 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028036:	05 42 23 01 00       	add    $0x12342,%eax
  lock_init (&q->lock);
c002803b:	8b 55 08             	mov    0x8(%ebp),%edx
c002803e:	83 ec 0c             	sub    $0xc,%esp
c0028041:	52                   	push   %edx
c0028042:	89 c3                	mov    %eax,%ebx
c0028044:	e8 89 b7 ff ff       	call   c00237d2 <lock_init>
c0028049:	83 c4 10             	add    $0x10,%esp
  q->not_full = q->not_empty = NULL;
c002804c:	8b 45 08             	mov    0x8(%ebp),%eax
c002804f:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
c0028056:	8b 45 08             	mov    0x8(%ebp),%eax
c0028059:	8b 50 1c             	mov    0x1c(%eax),%edx
c002805c:	8b 45 08             	mov    0x8(%ebp),%eax
c002805f:	89 50 18             	mov    %edx,0x18(%eax)
  q->head = q->tail = 0;
c0028062:	8b 45 08             	mov    0x8(%ebp),%eax
c0028065:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
c002806c:	8b 45 08             	mov    0x8(%ebp),%eax
c002806f:	8b 50 64             	mov    0x64(%eax),%edx
c0028072:	8b 45 08             	mov    0x8(%ebp),%eax
c0028075:	89 50 60             	mov    %edx,0x60(%eax)
}
c0028078:	90                   	nop
c0028079:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002807c:	c9                   	leave  
c002807d:	c3                   	ret    

c002807e <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c002807e:	55                   	push   %ebp
c002807f:	89 e5                	mov    %esp,%ebp
c0028081:	53                   	push   %ebx
c0028082:	83 ec 04             	sub    $0x4,%esp
c0028085:	e8 a2 93 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002808a:	81 c3 ee 22 01 00    	add    $0x122ee,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0028090:	e8 b8 9d ff ff       	call   c0021e4d <intr_get_level>
c0028095:	85 c0                	test   %eax,%eax
c0028097:	74 26                	je     c00280bf <intq_empty+0x41>
c0028099:	83 ec 0c             	sub    $0xc,%esp
c002809c:	8d 83 80 8e ff ff    	lea    -0x7180(%ebx),%eax
c00280a2:	50                   	push   %eax
c00280a3:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c00280a9:	50                   	push   %eax
c00280aa:	8d 83 94 8f ff ff    	lea    -0x706c(%ebx),%eax
c00280b0:	50                   	push   %eax
c00280b1:	6a 16                	push   $0x16
c00280b3:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c00280b9:	50                   	push   %eax
c00280ba:	e8 a5 36 00 00       	call   c002b764 <debug_panic>
  return q->head == q->tail;
c00280bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00280c2:	8b 50 60             	mov    0x60(%eax),%edx
c00280c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00280c8:	8b 40 64             	mov    0x64(%eax),%eax
c00280cb:	39 c2                	cmp    %eax,%edx
c00280cd:	0f 94 c0             	sete   %al
}
c00280d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00280d3:	c9                   	leave  
c00280d4:	c3                   	ret    

c00280d5 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c00280d5:	55                   	push   %ebp
c00280d6:	89 e5                	mov    %esp,%ebp
c00280d8:	53                   	push   %ebx
c00280d9:	83 ec 04             	sub    $0x4,%esp
c00280dc:	e8 4b 93 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00280e1:	81 c3 97 22 01 00    	add    $0x12297,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00280e7:	e8 61 9d ff ff       	call   c0021e4d <intr_get_level>
c00280ec:	85 c0                	test   %eax,%eax
c00280ee:	74 26                	je     c0028116 <intq_full+0x41>
c00280f0:	83 ec 0c             	sub    $0xc,%esp
c00280f3:	8d 83 80 8e ff ff    	lea    -0x7180(%ebx),%eax
c00280f9:	50                   	push   %eax
c00280fa:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c0028100:	50                   	push   %eax
c0028101:	8d 83 a0 8f ff ff    	lea    -0x7060(%ebx),%eax
c0028107:	50                   	push   %eax
c0028108:	6a 1e                	push   $0x1e
c002810a:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c0028110:	50                   	push   %eax
c0028111:	e8 4e 36 00 00       	call   c002b764 <debug_panic>
  return next (q->head) == q->tail;
c0028116:	8b 45 08             	mov    0x8(%ebp),%eax
c0028119:	8b 40 60             	mov    0x60(%eax),%eax
c002811c:	83 ec 0c             	sub    $0xc,%esp
c002811f:	50                   	push   %eax
c0028120:	e8 1c 02 00 00       	call   c0028341 <next>
c0028125:	83 c4 10             	add    $0x10,%esp
c0028128:	8b 55 08             	mov    0x8(%ebp),%edx
c002812b:	8b 52 64             	mov    0x64(%edx),%edx
c002812e:	39 d0                	cmp    %edx,%eax
c0028130:	0f 94 c0             	sete   %al
}
c0028133:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028136:	c9                   	leave  
c0028137:	c3                   	ret    

c0028138 <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c0028138:	55                   	push   %ebp
c0028139:	89 e5                	mov    %esp,%ebp
c002813b:	53                   	push   %ebx
c002813c:	83 ec 14             	sub    $0x14,%esp
c002813f:	e8 e8 92 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028144:	81 c3 34 22 01 00    	add    $0x12234,%ebx
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c002814a:	e8 fe 9c ff ff       	call   c0021e4d <intr_get_level>
c002814f:	85 c0                	test   %eax,%eax
c0028151:	0f 84 8b 00 00 00    	je     c00281e2 <intq_getc+0xaa>
c0028157:	83 ec 0c             	sub    $0xc,%esp
c002815a:	8d 83 80 8e ff ff    	lea    -0x7180(%ebx),%eax
c0028160:	50                   	push   %eax
c0028161:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c0028167:	50                   	push   %eax
c0028168:	8d 83 ac 8f ff ff    	lea    -0x7054(%ebx),%eax
c002816e:	50                   	push   %eax
c002816f:	6a 2a                	push   $0x2a
c0028171:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c0028177:	50                   	push   %eax
c0028178:	e8 e7 35 00 00       	call   c002b764 <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c002817d:	e8 c2 a0 ff ff       	call   c0022244 <intr_context>
c0028182:	83 f0 01             	xor    $0x1,%eax
c0028185:	84 c0                	test   %al,%al
c0028187:	75 26                	jne    c00281af <intq_getc+0x77>
c0028189:	83 ec 0c             	sub    $0xc,%esp
c002818c:	8d 83 ca 8e ff ff    	lea    -0x7136(%ebx),%eax
c0028192:	50                   	push   %eax
c0028193:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c0028199:	50                   	push   %eax
c002819a:	8d 83 ac 8f ff ff    	lea    -0x7054(%ebx),%eax
c00281a0:	50                   	push   %eax
c00281a1:	6a 2d                	push   $0x2d
c00281a3:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c00281a9:	50                   	push   %eax
c00281aa:	e8 b5 35 00 00       	call   c002b764 <debug_panic>
      lock_acquire (&q->lock);
c00281af:	8b 45 08             	mov    0x8(%ebp),%eax
c00281b2:	83 ec 0c             	sub    $0xc,%esp
c00281b5:	50                   	push   %eax
c00281b6:	e8 7c b6 ff ff       	call   c0023837 <lock_acquire>
c00281bb:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_empty);
c00281be:	8b 45 08             	mov    0x8(%ebp),%eax
c00281c1:	83 c0 1c             	add    $0x1c,%eax
c00281c4:	83 ec 08             	sub    $0x8,%esp
c00281c7:	50                   	push   %eax
c00281c8:	ff 75 08             	push   0x8(%ebp)
c00281cb:	e8 91 01 00 00       	call   c0028361 <wait>
c00281d0:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c00281d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00281d6:	83 ec 0c             	sub    $0xc,%esp
c00281d9:	50                   	push   %eax
c00281da:	e8 06 b9 ff ff       	call   c0023ae5 <lock_release>
c00281df:	83 c4 10             	add    $0x10,%esp
  while (intq_empty (q)) 
c00281e2:	83 ec 0c             	sub    $0xc,%esp
c00281e5:	ff 75 08             	push   0x8(%ebp)
c00281e8:	e8 91 fe ff ff       	call   c002807e <intq_empty>
c00281ed:	83 c4 10             	add    $0x10,%esp
c00281f0:	84 c0                	test   %al,%al
c00281f2:	75 89                	jne    c002817d <intq_getc+0x45>
    }
  
  byte = q->buf[q->tail];
c00281f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00281f7:	8b 40 64             	mov    0x64(%eax),%eax
c00281fa:	8b 55 08             	mov    0x8(%ebp),%edx
c00281fd:	0f b6 44 02 20       	movzbl 0x20(%edx,%eax,1),%eax
c0028202:	88 45 f7             	mov    %al,-0x9(%ebp)
  q->tail = next (q->tail);
c0028205:	8b 45 08             	mov    0x8(%ebp),%eax
c0028208:	8b 40 64             	mov    0x64(%eax),%eax
c002820b:	83 ec 0c             	sub    $0xc,%esp
c002820e:	50                   	push   %eax
c002820f:	e8 2d 01 00 00       	call   c0028341 <next>
c0028214:	83 c4 10             	add    $0x10,%esp
c0028217:	8b 55 08             	mov    0x8(%ebp),%edx
c002821a:	89 42 64             	mov    %eax,0x64(%edx)
  signal (q, &q->not_full);
c002821d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028220:	83 c0 18             	add    $0x18,%eax
c0028223:	83 ec 08             	sub    $0x8,%esp
c0028226:	50                   	push   %eax
c0028227:	ff 75 08             	push   0x8(%ebp)
c002822a:	e8 1a 02 00 00       	call   c0028449 <signal>
c002822f:	83 c4 10             	add    $0x10,%esp
  return byte;
c0028232:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c0028236:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028239:	c9                   	leave  
c002823a:	c3                   	ret    

c002823b <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c002823b:	55                   	push   %ebp
c002823c:	89 e5                	mov    %esp,%ebp
c002823e:	53                   	push   %ebx
c002823f:	83 ec 14             	sub    $0x14,%esp
c0028242:	e8 e5 91 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028247:	81 c3 31 21 01 00    	add    $0x12131,%ebx
c002824d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028250:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0028253:	e8 f5 9b ff ff       	call   c0021e4d <intr_get_level>
c0028258:	85 c0                	test   %eax,%eax
c002825a:	0f 84 8b 00 00 00    	je     c00282eb <intq_putc+0xb0>
c0028260:	83 ec 0c             	sub    $0xc,%esp
c0028263:	8d 83 80 8e ff ff    	lea    -0x7180(%ebx),%eax
c0028269:	50                   	push   %eax
c002826a:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c0028270:	50                   	push   %eax
c0028271:	8d 83 b8 8f ff ff    	lea    -0x7048(%ebx),%eax
c0028277:	50                   	push   %eax
c0028278:	6a 3f                	push   $0x3f
c002827a:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c0028280:	50                   	push   %eax
c0028281:	e8 de 34 00 00       	call   c002b764 <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c0028286:	e8 b9 9f ff ff       	call   c0022244 <intr_context>
c002828b:	83 f0 01             	xor    $0x1,%eax
c002828e:	84 c0                	test   %al,%al
c0028290:	75 26                	jne    c00282b8 <intq_putc+0x7d>
c0028292:	83 ec 0c             	sub    $0xc,%esp
c0028295:	8d 83 ca 8e ff ff    	lea    -0x7136(%ebx),%eax
c002829b:	50                   	push   %eax
c002829c:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c00282a2:	50                   	push   %eax
c00282a3:	8d 83 b8 8f ff ff    	lea    -0x7048(%ebx),%eax
c00282a9:	50                   	push   %eax
c00282aa:	6a 42                	push   $0x42
c00282ac:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c00282b2:	50                   	push   %eax
c00282b3:	e8 ac 34 00 00       	call   c002b764 <debug_panic>
      lock_acquire (&q->lock);
c00282b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00282bb:	83 ec 0c             	sub    $0xc,%esp
c00282be:	50                   	push   %eax
c00282bf:	e8 73 b5 ff ff       	call   c0023837 <lock_acquire>
c00282c4:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_full);
c00282c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00282ca:	83 c0 18             	add    $0x18,%eax
c00282cd:	83 ec 08             	sub    $0x8,%esp
c00282d0:	50                   	push   %eax
c00282d1:	ff 75 08             	push   0x8(%ebp)
c00282d4:	e8 88 00 00 00       	call   c0028361 <wait>
c00282d9:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c00282dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00282df:	83 ec 0c             	sub    $0xc,%esp
c00282e2:	50                   	push   %eax
c00282e3:	e8 fd b7 ff ff       	call   c0023ae5 <lock_release>
c00282e8:	83 c4 10             	add    $0x10,%esp
  while (intq_full (q))
c00282eb:	83 ec 0c             	sub    $0xc,%esp
c00282ee:	ff 75 08             	push   0x8(%ebp)
c00282f1:	e8 df fd ff ff       	call   c00280d5 <intq_full>
c00282f6:	83 c4 10             	add    $0x10,%esp
c00282f9:	84 c0                	test   %al,%al
c00282fb:	75 89                	jne    c0028286 <intq_putc+0x4b>
    }

  q->buf[q->head] = byte;
c00282fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0028300:	8b 40 60             	mov    0x60(%eax),%eax
c0028303:	8b 55 08             	mov    0x8(%ebp),%edx
c0028306:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c002830a:	88 4c 02 20          	mov    %cl,0x20(%edx,%eax,1)
  q->head = next (q->head);
c002830e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028311:	8b 40 60             	mov    0x60(%eax),%eax
c0028314:	83 ec 0c             	sub    $0xc,%esp
c0028317:	50                   	push   %eax
c0028318:	e8 24 00 00 00       	call   c0028341 <next>
c002831d:	83 c4 10             	add    $0x10,%esp
c0028320:	8b 55 08             	mov    0x8(%ebp),%edx
c0028323:	89 42 60             	mov    %eax,0x60(%edx)
  signal (q, &q->not_empty);
c0028326:	8b 45 08             	mov    0x8(%ebp),%eax
c0028329:	83 c0 1c             	add    $0x1c,%eax
c002832c:	83 ec 08             	sub    $0x8,%esp
c002832f:	50                   	push   %eax
c0028330:	ff 75 08             	push   0x8(%ebp)
c0028333:	e8 11 01 00 00       	call   c0028449 <signal>
c0028338:	83 c4 10             	add    $0x10,%esp
}
c002833b:	90                   	nop
c002833c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002833f:	c9                   	leave  
c0028340:	c3                   	ret    

c0028341 <next>:

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
c0028341:	55                   	push   %ebp
c0028342:	89 e5                	mov    %esp,%ebp
c0028344:	e8 df 90 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028349:	05 2f 20 01 00       	add    $0x1202f,%eax
  return (pos + 1) % INTQ_BUFSIZE;
c002834e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028351:	83 c0 01             	add    $0x1,%eax
c0028354:	99                   	cltd   
c0028355:	c1 ea 1a             	shr    $0x1a,%edx
c0028358:	01 d0                	add    %edx,%eax
c002835a:	83 e0 3f             	and    $0x3f,%eax
c002835d:	29 d0                	sub    %edx,%eax
}
c002835f:	5d                   	pop    %ebp
c0028360:	c3                   	ret    

c0028361 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0028361:	55                   	push   %ebp
c0028362:	89 e5                	mov    %esp,%ebp
c0028364:	53                   	push   %ebx
c0028365:	83 ec 04             	sub    $0x4,%esp
c0028368:	e8 bf 90 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002836d:	81 c3 0b 20 01 00    	add    $0x1200b,%ebx
  ASSERT (!intr_context ());
c0028373:	e8 cc 9e ff ff       	call   c0022244 <intr_context>
c0028378:	83 f0 01             	xor    $0x1,%eax
c002837b:	84 c0                	test   %al,%al
c002837d:	75 26                	jne    c00283a5 <wait+0x44>
c002837f:	83 ec 0c             	sub    $0xc,%esp
c0028382:	8d 83 ca 8e ff ff    	lea    -0x7136(%ebx),%eax
c0028388:	50                   	push   %eax
c0028389:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c002838f:	50                   	push   %eax
c0028390:	8d 83 c4 8f ff ff    	lea    -0x703c(%ebx),%eax
c0028396:	50                   	push   %eax
c0028397:	6a 59                	push   $0x59
c0028399:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c002839f:	50                   	push   %eax
c00283a0:	e8 bf 33 00 00       	call   c002b764 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c00283a5:	e8 a3 9a ff ff       	call   c0021e4d <intr_get_level>
c00283aa:	85 c0                	test   %eax,%eax
c00283ac:	74 26                	je     c00283d4 <wait+0x73>
c00283ae:	83 ec 0c             	sub    $0xc,%esp
c00283b1:	8d 83 80 8e ff ff    	lea    -0x7180(%ebx),%eax
c00283b7:	50                   	push   %eax
c00283b8:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c00283be:	50                   	push   %eax
c00283bf:	8d 83 c4 8f ff ff    	lea    -0x703c(%ebx),%eax
c00283c5:	50                   	push   %eax
c00283c6:	6a 5a                	push   $0x5a
c00283c8:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c00283ce:	50                   	push   %eax
c00283cf:	e8 90 33 00 00       	call   c002b764 <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c00283d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00283d7:	83 c0 1c             	add    $0x1c,%eax
c00283da:	39 45 0c             	cmp    %eax,0xc(%ebp)
c00283dd:	75 12                	jne    c00283f1 <wait+0x90>
c00283df:	83 ec 0c             	sub    $0xc,%esp
c00283e2:	ff 75 08             	push   0x8(%ebp)
c00283e5:	e8 94 fc ff ff       	call   c002807e <intq_empty>
c00283ea:	83 c4 10             	add    $0x10,%esp
c00283ed:	84 c0                	test   %al,%al
c00283ef:	75 43                	jne    c0028434 <wait+0xd3>
c00283f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00283f4:	83 c0 18             	add    $0x18,%eax
c00283f7:	39 45 0c             	cmp    %eax,0xc(%ebp)
c00283fa:	75 12                	jne    c002840e <wait+0xad>
c00283fc:	83 ec 0c             	sub    $0xc,%esp
c00283ff:	ff 75 08             	push   0x8(%ebp)
c0028402:	e8 ce fc ff ff       	call   c00280d5 <intq_full>
c0028407:	83 c4 10             	add    $0x10,%esp
c002840a:	84 c0                	test   %al,%al
c002840c:	75 26                	jne    c0028434 <wait+0xd3>
c002840e:	83 ec 0c             	sub    $0xc,%esp
c0028411:	8d 83 dc 8e ff ff    	lea    -0x7124(%ebx),%eax
c0028417:	50                   	push   %eax
c0028418:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c002841e:	50                   	push   %eax
c002841f:	8d 83 c4 8f ff ff    	lea    -0x703c(%ebx),%eax
c0028425:	50                   	push   %eax
c0028426:	6a 5b                	push   $0x5b
c0028428:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c002842e:	50                   	push   %eax
c002842f:	e8 30 33 00 00       	call   c002b764 <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0028434:	e8 48 8f ff ff       	call   c0021381 <thread_current>
c0028439:	8b 55 0c             	mov    0xc(%ebp),%edx
c002843c:	89 02                	mov    %eax,(%edx)
  thread_block ();
c002843e:	e8 b9 8d ff ff       	call   c00211fc <thread_block>
}
c0028443:	90                   	nop
c0028444:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028447:	c9                   	leave  
c0028448:	c3                   	ret    

c0028449 <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0028449:	55                   	push   %ebp
c002844a:	89 e5                	mov    %esp,%ebp
c002844c:	53                   	push   %ebx
c002844d:	83 ec 04             	sub    $0x4,%esp
c0028450:	e8 d7 8f 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028455:	81 c3 23 1f 01 00    	add    $0x11f23,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c002845b:	e8 ed 99 ff ff       	call   c0021e4d <intr_get_level>
c0028460:	85 c0                	test   %eax,%eax
c0028462:	74 26                	je     c002848a <signal+0x41>
c0028464:	83 ec 0c             	sub    $0xc,%esp
c0028467:	8d 83 80 8e ff ff    	lea    -0x7180(%ebx),%eax
c002846d:	50                   	push   %eax
c002846e:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c0028474:	50                   	push   %eax
c0028475:	8d 83 cc 8f ff ff    	lea    -0x7034(%ebx),%eax
c002847b:	50                   	push   %eax
c002847c:	6a 69                	push   $0x69
c002847e:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c0028484:	50                   	push   %eax
c0028485:	e8 da 32 00 00       	call   c002b764 <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c002848a:	8b 45 08             	mov    0x8(%ebp),%eax
c002848d:	83 c0 1c             	add    $0x1c,%eax
c0028490:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0028493:	75 15                	jne    c00284aa <signal+0x61>
c0028495:	83 ec 0c             	sub    $0xc,%esp
c0028498:	ff 75 08             	push   0x8(%ebp)
c002849b:	e8 de fb ff ff       	call   c002807e <intq_empty>
c00284a0:	83 c4 10             	add    $0x10,%esp
c00284a3:	83 f0 01             	xor    $0x1,%eax
c00284a6:	84 c0                	test   %al,%al
c00284a8:	75 46                	jne    c00284f0 <signal+0xa7>
c00284aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00284ad:	83 c0 18             	add    $0x18,%eax
c00284b0:	39 45 0c             	cmp    %eax,0xc(%ebp)
c00284b3:	75 15                	jne    c00284ca <signal+0x81>
c00284b5:	83 ec 0c             	sub    $0xc,%esp
c00284b8:	ff 75 08             	push   0x8(%ebp)
c00284bb:	e8 15 fc ff ff       	call   c00280d5 <intq_full>
c00284c0:	83 c4 10             	add    $0x10,%esp
c00284c3:	83 f0 01             	xor    $0x1,%eax
c00284c6:	84 c0                	test   %al,%al
c00284c8:	75 26                	jne    c00284f0 <signal+0xa7>
c00284ca:	83 ec 0c             	sub    $0xc,%esp
c00284cd:	8d 83 38 8f ff ff    	lea    -0x70c8(%ebx),%eax
c00284d3:	50                   	push   %eax
c00284d4:	8d 83 9e 8e ff ff    	lea    -0x7162(%ebx),%eax
c00284da:	50                   	push   %eax
c00284db:	8d 83 cc 8f ff ff    	lea    -0x7034(%ebx),%eax
c00284e1:	50                   	push   %eax
c00284e2:	6a 6a                	push   $0x6a
c00284e4:	8d 83 b5 8e ff ff    	lea    -0x714b(%ebx),%eax
c00284ea:	50                   	push   %eax
c00284eb:	e8 74 32 00 00       	call   c002b764 <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c00284f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00284f3:	8b 00                	mov    (%eax),%eax
c00284f5:	85 c0                	test   %eax,%eax
c00284f7:	74 1a                	je     c0028513 <signal+0xca>
    {
      thread_unblock (*waiter);
c00284f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00284fc:	8b 00                	mov    (%eax),%eax
c00284fe:	83 ec 0c             	sub    $0xc,%esp
c0028501:	50                   	push   %eax
c0028502:	e8 85 8d ff ff       	call   c002128c <thread_unblock>
c0028507:	83 c4 10             	add    $0x10,%esp
      *waiter = NULL;
c002850a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002850d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c0028513:	90                   	nop
c0028514:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028517:	c9                   	leave  
c0028518:	c3                   	ret    

c0028519 <inb>:
{
c0028519:	55                   	push   %ebp
c002851a:	89 e5                	mov    %esp,%ebp
c002851c:	83 ec 14             	sub    $0x14,%esp
c002851f:	e8 04 8f 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028524:	05 54 1e 01 00       	add    $0x11e54,%eax
c0028529:	8b 45 08             	mov    0x8(%ebp),%eax
c002852c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0028530:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0028534:	89 c2                	mov    %eax,%edx
c0028536:	ec                   	in     (%dx),%al
c0028537:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002853a:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c002853e:	c9                   	leave  
c002853f:	c3                   	ret    

c0028540 <outb>:
{
c0028540:	55                   	push   %ebp
c0028541:	89 e5                	mov    %esp,%ebp
c0028543:	83 ec 08             	sub    $0x8,%esp
c0028546:	e8 dd 8e 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002854b:	05 2d 1e 01 00       	add    $0x11e2d,%eax
c0028550:	8b 45 08             	mov    0x8(%ebp),%eax
c0028553:	8b 55 0c             	mov    0xc(%ebp),%edx
c0028556:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c002855a:	89 d0                	mov    %edx,%eax
c002855c:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002855f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0028563:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0028567:	ee                   	out    %al,(%dx)
}
c0028568:	90                   	nop
c0028569:	c9                   	leave  
c002856a:	c3                   	ret    

c002856b <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c002856b:	55                   	push   %ebp
c002856c:	89 e5                	mov    %esp,%ebp
c002856e:	53                   	push   %ebx
c002856f:	83 ec 24             	sub    $0x24,%esp
c0028572:	e8 b5 8e 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028577:	81 c3 01 1e 01 00    	add    $0x11e01,%ebx
     but for historical reasons everyone always uses BCD format
     except on obscure non-PC platforms, so we don't bother
     trying to detect the format in use. */
  do
    {
      sec = bcd_to_bin (cmos_read (RTC_REG_SEC));
c002857d:	83 ec 0c             	sub    $0xc,%esp
c0028580:	6a 00                	push   $0x0
c0028582:	e8 bb 01 00 00       	call   c0028742 <cmos_read>
c0028587:	83 c4 10             	add    $0x10,%esp
c002858a:	0f b6 c0             	movzbl %al,%eax
c002858d:	83 ec 0c             	sub    $0xc,%esp
c0028590:	50                   	push   %eax
c0028591:	e8 76 01 00 00       	call   c002870c <bcd_to_bin>
c0028596:	83 c4 10             	add    $0x10,%esp
c0028599:	89 45 e8             	mov    %eax,-0x18(%ebp)
      min = bcd_to_bin (cmos_read (RTC_REG_MIN));
c002859c:	83 ec 0c             	sub    $0xc,%esp
c002859f:	6a 02                	push   $0x2
c00285a1:	e8 9c 01 00 00       	call   c0028742 <cmos_read>
c00285a6:	83 c4 10             	add    $0x10,%esp
c00285a9:	0f b6 c0             	movzbl %al,%eax
c00285ac:	83 ec 0c             	sub    $0xc,%esp
c00285af:	50                   	push   %eax
c00285b0:	e8 57 01 00 00       	call   c002870c <bcd_to_bin>
c00285b5:	83 c4 10             	add    $0x10,%esp
c00285b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
c00285bb:	83 ec 0c             	sub    $0xc,%esp
c00285be:	6a 04                	push   $0x4
c00285c0:	e8 7d 01 00 00       	call   c0028742 <cmos_read>
c00285c5:	83 c4 10             	add    $0x10,%esp
c00285c8:	0f b6 c0             	movzbl %al,%eax
c00285cb:	83 ec 0c             	sub    $0xc,%esp
c00285ce:	50                   	push   %eax
c00285cf:	e8 38 01 00 00       	call   c002870c <bcd_to_bin>
c00285d4:	83 c4 10             	add    $0x10,%esp
c00285d7:	89 45 e0             	mov    %eax,-0x20(%ebp)
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
c00285da:	83 ec 0c             	sub    $0xc,%esp
c00285dd:	6a 07                	push   $0x7
c00285df:	e8 5e 01 00 00       	call   c0028742 <cmos_read>
c00285e4:	83 c4 10             	add    $0x10,%esp
c00285e7:	0f b6 c0             	movzbl %al,%eax
c00285ea:	83 ec 0c             	sub    $0xc,%esp
c00285ed:	50                   	push   %eax
c00285ee:	e8 19 01 00 00       	call   c002870c <bcd_to_bin>
c00285f3:	83 c4 10             	add    $0x10,%esp
c00285f6:	89 45 dc             	mov    %eax,-0x24(%ebp)
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
c00285f9:	83 ec 0c             	sub    $0xc,%esp
c00285fc:	6a 08                	push   $0x8
c00285fe:	e8 3f 01 00 00       	call   c0028742 <cmos_read>
c0028603:	83 c4 10             	add    $0x10,%esp
c0028606:	0f b6 c0             	movzbl %al,%eax
c0028609:	83 ec 0c             	sub    $0xc,%esp
c002860c:	50                   	push   %eax
c002860d:	e8 fa 00 00 00       	call   c002870c <bcd_to_bin>
c0028612:	83 c4 10             	add    $0x10,%esp
c0028615:	89 45 d8             	mov    %eax,-0x28(%ebp)
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
c0028618:	83 ec 0c             	sub    $0xc,%esp
c002861b:	6a 09                	push   $0x9
c002861d:	e8 20 01 00 00       	call   c0028742 <cmos_read>
c0028622:	83 c4 10             	add    $0x10,%esp
c0028625:	0f b6 c0             	movzbl %al,%eax
c0028628:	83 ec 0c             	sub    $0xc,%esp
c002862b:	50                   	push   %eax
c002862c:	e8 db 00 00 00       	call   c002870c <bcd_to_bin>
c0028631:	83 c4 10             	add    $0x10,%esp
c0028634:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c0028637:	83 ec 0c             	sub    $0xc,%esp
c002863a:	6a 00                	push   $0x0
c002863c:	e8 01 01 00 00       	call   c0028742 <cmos_read>
c0028641:	83 c4 10             	add    $0x10,%esp
c0028644:	0f b6 c0             	movzbl %al,%eax
c0028647:	83 ec 0c             	sub    $0xc,%esp
c002864a:	50                   	push   %eax
c002864b:	e8 bc 00 00 00       	call   c002870c <bcd_to_bin>
c0028650:	83 c4 10             	add    $0x10,%esp
c0028653:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c0028656:	0f 85 21 ff ff ff    	jne    c002857d <rtc_get_time+0x12>

  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
c002865c:	83 7d f4 45          	cmpl   $0x45,-0xc(%ebp)
c0028660:	7f 04                	jg     c0028666 <rtc_get_time+0xfb>
    year += 100;
c0028662:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
  year -= 70;
c0028666:	83 6d f4 46          	subl   $0x46,-0xc(%ebp)

  /* Break down all components into seconds. */
  time = (year * 365 + DIV_ROUND_UP (year - 2, 4)) * 24 * 60 * 60;
c002866a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002866d:	69 c8 6d 01 00 00    	imul   $0x16d,%eax,%ecx
c0028673:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028676:	83 c0 01             	add    $0x1,%eax
c0028679:	8d 50 03             	lea    0x3(%eax),%edx
c002867c:	85 c0                	test   %eax,%eax
c002867e:	0f 48 c2             	cmovs  %edx,%eax
c0028681:	c1 f8 02             	sar    $0x2,%eax
c0028684:	01 c8                	add    %ecx,%eax
c0028686:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c002868c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 1; i < mon; i++)
c002868f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c0028696:	eb 1a                	jmp    c00286b2 <rtc_get_time+0x147>
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0028698:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002869b:	83 e8 01             	sub    $0x1,%eax
c002869e:	8b 84 83 e8 8f ff ff 	mov    -0x7018(%ebx,%eax,4),%eax
c00286a5:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c00286ab:	01 45 f0             	add    %eax,-0x10(%ebp)
  for (i = 1; i < mon; i++)
c00286ae:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c00286b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00286b5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c00286b8:	7c de                	jl     c0028698 <rtc_get_time+0x12d>
  if (mon > 2 && year % 4 == 2)
c00286ba:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
c00286be:	7e 1a                	jle    c00286da <rtc_get_time+0x16f>
c00286c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286c3:	99                   	cltd   
c00286c4:	c1 ea 1e             	shr    $0x1e,%edx
c00286c7:	01 d0                	add    %edx,%eax
c00286c9:	83 e0 03             	and    $0x3,%eax
c00286cc:	29 d0                	sub    %edx,%eax
c00286ce:	83 f8 02             	cmp    $0x2,%eax
c00286d1:	75 07                	jne    c00286da <rtc_get_time+0x16f>
    time += 24 * 60 * 60;
c00286d3:	81 45 f0 80 51 01 00 	addl   $0x15180,-0x10(%ebp)
  time += (mday - 1) * 24 * 60 * 60;
c00286da:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00286dd:	83 e8 01             	sub    $0x1,%eax
c00286e0:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c00286e6:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += hour * 60 * 60;
c00286e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00286ec:	69 c0 10 0e 00 00    	imul   $0xe10,%eax,%eax
c00286f2:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += min * 60;
c00286f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00286f8:	6b c0 3c             	imul   $0x3c,%eax,%eax
c00286fb:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += sec;
c00286fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028701:	01 45 f0             	add    %eax,-0x10(%ebp)

  return time;
c0028704:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028707:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002870a:	c9                   	leave  
c002870b:	c3                   	ret    

c002870c <bcd_to_bin>:

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
c002870c:	55                   	push   %ebp
c002870d:	89 e5                	mov    %esp,%ebp
c002870f:	83 ec 04             	sub    $0x4,%esp
c0028712:	e8 11 8d 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028717:	05 61 1c 01 00       	add    $0x11c61,%eax
c002871c:	8b 45 08             	mov    0x8(%ebp),%eax
c002871f:	88 45 fc             	mov    %al,-0x4(%ebp)
  return (x & 0x0f) + ((x >> 4) * 10);
c0028722:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0028726:	83 e0 0f             	and    $0xf,%eax
c0028729:	89 c1                	mov    %eax,%ecx
c002872b:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c002872f:	c0 e8 04             	shr    $0x4,%al
c0028732:	0f b6 d0             	movzbl %al,%edx
c0028735:	89 d0                	mov    %edx,%eax
c0028737:	c1 e0 02             	shl    $0x2,%eax
c002873a:	01 d0                	add    %edx,%eax
c002873c:	01 c0                	add    %eax,%eax
c002873e:	01 c8                	add    %ecx,%eax
}
c0028740:	c9                   	leave  
c0028741:	c3                   	ret    

c0028742 <cmos_read>:

/* Reads a byte from the CMOS register with the given INDEX and
   returns the byte read. */
static uint8_t
cmos_read (uint8_t index)
{
c0028742:	55                   	push   %ebp
c0028743:	89 e5                	mov    %esp,%ebp
c0028745:	83 ec 04             	sub    $0x4,%esp
c0028748:	e8 db 8c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002874d:	05 2b 1c 01 00       	add    $0x11c2b,%eax
c0028752:	8b 45 08             	mov    0x8(%ebp),%eax
c0028755:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb (CMOS_REG_SET, index);
c0028758:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c002875c:	50                   	push   %eax
c002875d:	6a 70                	push   $0x70
c002875f:	e8 dc fd ff ff       	call   c0028540 <outb>
c0028764:	83 c4 08             	add    $0x8,%esp
  return inb (CMOS_REG_IO);
c0028767:	6a 71                	push   $0x71
c0028769:	e8 ab fd ff ff       	call   c0028519 <inb>
c002876e:	83 c4 04             	add    $0x4,%esp
}
c0028771:	c9                   	leave  
c0028772:	c3                   	ret    

c0028773 <inb>:
{
c0028773:	55                   	push   %ebp
c0028774:	89 e5                	mov    %esp,%ebp
c0028776:	83 ec 14             	sub    $0x14,%esp
c0028779:	e8 aa 8c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002877e:	05 fa 1b 01 00       	add    $0x11bfa,%eax
c0028783:	8b 45 08             	mov    0x8(%ebp),%eax
c0028786:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002878a:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c002878e:	89 c2                	mov    %eax,%edx
c0028790:	ec                   	in     (%dx),%al
c0028791:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0028794:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0028798:	c9                   	leave  
c0028799:	c3                   	ret    

c002879a <outb>:
{
c002879a:	55                   	push   %ebp
c002879b:	89 e5                	mov    %esp,%ebp
c002879d:	83 ec 08             	sub    $0x8,%esp
c00287a0:	e8 83 8c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00287a5:	05 d3 1b 01 00       	add    $0x11bd3,%eax
c00287aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00287ad:	8b 55 0c             	mov    0xc(%ebp),%edx
c00287b0:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00287b4:	89 d0                	mov    %edx,%eax
c00287b6:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00287b9:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00287bd:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00287c1:	ee                   	out    %al,(%dx)
}
c00287c2:	90                   	nop
c00287c3:	c9                   	leave  
c00287c4:	c3                   	ret    

c00287c5 <outw>:
{
c00287c5:	55                   	push   %ebp
c00287c6:	89 e5                	mov    %esp,%ebp
c00287c8:	83 ec 08             	sub    $0x8,%esp
c00287cb:	e8 58 8c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00287d0:	05 a8 1b 01 00       	add    $0x11ba8,%eax
c00287d5:	8b 55 08             	mov    0x8(%ebp),%edx
c00287d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00287db:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00287df:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c00287e3:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c00287e7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00287eb:	66 ef                	out    %ax,(%dx)
}
c00287ed:	90                   	nop
c00287ee:	c9                   	leave  
c00287ef:	c3                   	ret    

c00287f0 <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c00287f0:	55                   	push   %ebp
c00287f1:	89 e5                	mov    %esp,%ebp
c00287f3:	83 ec 08             	sub    $0x8,%esp
c00287f6:	e8 2d 8c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00287fb:	05 7d 1b 01 00       	add    $0x11b7d,%eax
  switch (how)
c0028800:	8b 80 50 21 00 00    	mov    0x2150(%eax),%eax
c0028806:	83 f8 01             	cmp    $0x1,%eax
c0028809:	74 07                	je     c0028812 <shutdown+0x22>
c002880b:	83 f8 02             	cmp    $0x2,%eax
c002880e:	74 07                	je     c0028817 <shutdown+0x27>
      shutdown_reboot ();
      break;

    default:
      /* Nothing to do. */
      break;
c0028810:	eb 0a                	jmp    c002881c <shutdown+0x2c>
      shutdown_power_off ();
c0028812:	e8 b6 00 00 00       	call   c00288cd <shutdown_power_off>
      shutdown_reboot ();
c0028817:	e8 1c 00 00 00       	call   c0028838 <shutdown_reboot>
    }
}
c002881c:	90                   	nop
c002881d:	c9                   	leave  
c002881e:	c3                   	ret    

c002881f <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c002881f:	55                   	push   %ebp
c0028820:	89 e5                	mov    %esp,%ebp
c0028822:	e8 01 8c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028827:	05 51 1b 01 00       	add    $0x11b51,%eax
  how = type;
c002882c:	8b 55 08             	mov    0x8(%ebp),%edx
c002882f:	89 90 50 21 00 00    	mov    %edx,0x2150(%eax)
}
c0028835:	90                   	nop
c0028836:	5d                   	pop    %ebp
c0028837:	c3                   	ret    

c0028838 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0028838:	55                   	push   %ebp
c0028839:	89 e5                	mov    %esp,%ebp
c002883b:	53                   	push   %ebx
c002883c:	83 ec 14             	sub    $0x14,%esp
c002883f:	e8 e8 8b 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028844:	81 c3 34 1b 01 00    	add    $0x11b34,%ebx
  printf ("Rebooting...\n");
c002884a:	83 ec 0c             	sub    $0xc,%esp
c002884d:	8d 83 18 90 ff ff    	lea    -0x6fe8(%ebx),%eax
c0028853:	50                   	push   %eax
c0028854:	e8 93 57 00 00       	call   c002dfec <puts>
c0028859:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c002885c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028863:	eb 2a                	jmp    c002888f <shutdown_reboot+0x57>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0028865:	83 ec 0c             	sub    $0xc,%esp
c0028868:	6a 64                	push   $0x64
c002886a:	e8 04 ff ff ff       	call   c0028773 <inb>
c002886f:	83 c4 10             	add    $0x10,%esp
c0028872:	0f b6 c0             	movzbl %al,%eax
c0028875:	83 e0 02             	and    $0x2,%eax
c0028878:	85 c0                	test   %eax,%eax
c002887a:	74 1e                	je     c002889a <shutdown_reboot+0x62>
            break;
          timer_udelay (2);
c002887c:	83 ec 08             	sub    $0x8,%esp
c002887f:	6a 00                	push   $0x0
c0028881:	6a 02                	push   $0x2
c0028883:	e8 fc c9 ff ff       	call   c0025284 <timer_udelay>
c0028888:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 0x10000; i++)
c002888b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002888f:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c0028896:	7e cd                	jle    c0028865 <shutdown_reboot+0x2d>
c0028898:	eb 01                	jmp    c002889b <shutdown_reboot+0x63>
            break;
c002889a:	90                   	nop
        }

      timer_udelay (50);
c002889b:	83 ec 08             	sub    $0x8,%esp
c002889e:	6a 00                	push   $0x0
c00288a0:	6a 32                	push   $0x32
c00288a2:	e8 dd c9 ff ff       	call   c0025284 <timer_udelay>
c00288a7:	83 c4 10             	add    $0x10,%esp

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
c00288aa:	83 ec 08             	sub    $0x8,%esp
c00288ad:	68 fe 00 00 00       	push   $0xfe
c00288b2:	6a 64                	push   $0x64
c00288b4:	e8 e1 fe ff ff       	call   c002879a <outb>
c00288b9:	83 c4 10             	add    $0x10,%esp
      timer_udelay (50);
c00288bc:	83 ec 08             	sub    $0x8,%esp
c00288bf:	6a 00                	push   $0x0
c00288c1:	6a 32                	push   $0x32
c00288c3:	e8 bc c9 ff ff       	call   c0025284 <timer_udelay>
c00288c8:	83 c4 10             	add    $0x10,%esp
    {
c00288cb:	eb 8f                	jmp    c002885c <shutdown_reboot+0x24>

c00288cd <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c00288cd:	55                   	push   %ebp
c00288ce:	89 e5                	mov    %esp,%ebp
c00288d0:	53                   	push   %ebx
c00288d1:	83 ec 14             	sub    $0x14,%esp
c00288d4:	e8 53 8b 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00288d9:	81 c3 9f 1a 01 00    	add    $0x11a9f,%ebx
  const char s[] = "Shutdown";
c00288df:	c7 45 eb 53 68 75 74 	movl   $0x74756853,-0x15(%ebp)
c00288e6:	c7 45 ef 64 6f 77 6e 	movl   $0x6e776f64,-0x11(%ebp)
c00288ed:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)

#ifdef FILESYS
  filesys_done ();
#endif

  print_stats ();
c00288f1:	e8 84 00 00 00       	call   c002897a <print_stats>

  printf ("Powering off...\n");
c00288f6:	83 ec 0c             	sub    $0xc,%esp
c00288f9:	8d 83 25 90 ff ff    	lea    -0x6fdb(%ebx),%eax
c00288ff:	50                   	push   %eax
c0028900:	e8 e7 56 00 00       	call   c002dfec <puts>
c0028905:	83 c4 10             	add    $0x10,%esp
  serial_flush ();
c0028908:	e8 70 d8 ff ff       	call   c002617d <serial_flush>

  /* ACPI power-off */
  outw (0xB004, 0x2000);
c002890d:	83 ec 08             	sub    $0x8,%esp
c0028910:	68 00 20 00 00       	push   $0x2000
c0028915:	68 04 b0 00 00       	push   $0xb004
c002891a:	e8 a6 fe ff ff       	call   c00287c5 <outw>
c002891f:	83 c4 10             	add    $0x10,%esp

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0028922:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0028925:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028928:	eb 1e                	jmp    c0028948 <shutdown_power_off+0x7b>
    outb (0x8900, *p);
c002892a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002892d:	0f b6 00             	movzbl (%eax),%eax
c0028930:	0f b6 c0             	movzbl %al,%eax
c0028933:	83 ec 08             	sub    $0x8,%esp
c0028936:	50                   	push   %eax
c0028937:	68 00 89 00 00       	push   $0x8900
c002893c:	e8 59 fe ff ff       	call   c002879a <outb>
c0028941:	83 c4 10             	add    $0x10,%esp
  for (p = s; *p != '\0'; p++)
c0028944:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028948:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002894b:	0f b6 00             	movzbl (%eax),%eax
c002894e:	84 c0                	test   %al,%al
c0028950:	75 d8                	jne    c002892a <shutdown_power_off+0x5d>
  /* For newer versions of qemu, you must run with -device
   * isa-debug-exit, which exits on any write to an IO port (by
   * default 0x501).  Qemu's exit code is double the value plus one,
   * so there is no way to exit cleanly.  We use 0x31 which should
   * result in a qemu exit code of 0x63.  */
  outb (0x501, 0x31);
c0028952:	83 ec 08             	sub    $0x8,%esp
c0028955:	6a 31                	push   $0x31
c0028957:	68 01 05 00 00       	push   $0x501
c002895c:	e8 39 fe ff ff       	call   c002879a <outb>
c0028961:	83 c4 10             	add    $0x10,%esp

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c0028964:	fa                   	cli    
c0028965:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c0028966:	83 ec 0c             	sub    $0xc,%esp
c0028969:	8d 83 35 90 ff ff    	lea    -0x6fcb(%ebx),%eax
c002896f:	50                   	push   %eax
c0028970:	e8 77 56 00 00       	call   c002dfec <puts>
c0028975:	83 c4 10             	add    $0x10,%esp
  for (;;);
c0028978:	eb fe                	jmp    c0028978 <shutdown_power_off+0xab>

c002897a <print_stats>:
}

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
c002897a:	55                   	push   %ebp
c002897b:	89 e5                	mov    %esp,%ebp
c002897d:	53                   	push   %ebx
c002897e:	83 ec 04             	sub    $0x4,%esp
c0028981:	e8 a6 8a 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028986:	81 c3 f2 19 01 00    	add    $0x119f2,%ebx
  timer_print_stats ();
c002898c:	e8 5d c9 ff ff       	call   c00252ee <timer_print_stats>
  thread_print_stats ();
c0028991:	e8 aa 86 ff ff       	call   c0021040 <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c0028996:	e8 bc 54 00 00       	call   c002de57 <console_print_stats>
  kbd_print_stats ();
c002899b:	e8 93 cd ff ff       	call   c0025733 <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
#endif
}
c00289a0:	90                   	nop
c00289a1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00289a4:	c9                   	leave  
c00289a5:	c3                   	ret    

c00289a6 <inb>:
{
c00289a6:	55                   	push   %ebp
c00289a7:	89 e5                	mov    %esp,%ebp
c00289a9:	83 ec 14             	sub    $0x14,%esp
c00289ac:	e8 77 8a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00289b1:	05 c7 19 01 00       	add    $0x119c7,%eax
c00289b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00289b9:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00289bd:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00289c1:	89 c2                	mov    %eax,%edx
c00289c3:	ec                   	in     (%dx),%al
c00289c4:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00289c7:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c00289cb:	c9                   	leave  
c00289cc:	c3                   	ret    

c00289cd <outb>:
{
c00289cd:	55                   	push   %ebp
c00289ce:	89 e5                	mov    %esp,%ebp
c00289d0:	83 ec 08             	sub    $0x8,%esp
c00289d3:	e8 50 8a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c00289d8:	05 a0 19 01 00       	add    $0x119a0,%eax
c00289dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00289e0:	8b 55 0c             	mov    0xc(%ebp),%edx
c00289e3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00289e7:	89 d0                	mov    %edx,%eax
c00289e9:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00289ec:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00289f0:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00289f4:	ee                   	out    %al,(%dx)
}
c00289f5:	90                   	nop
c00289f6:	c9                   	leave  
c00289f7:	c3                   	ret    

c00289f8 <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c00289f8:	55                   	push   %ebp
c00289f9:	89 e5                	mov    %esp,%ebp
c00289fb:	53                   	push   %ebx
c00289fc:	83 ec 14             	sub    $0x14,%esp
c00289ff:	e8 28 8a 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028a04:	81 c3 74 19 01 00    	add    $0x11974,%ebx
  if (frequency >= 20 && frequency <= 20000)
c0028a0a:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
c0028a0e:	7e 54                	jle    c0028a64 <speaker_on+0x6c>
c0028a10:	81 7d 08 20 4e 00 00 	cmpl   $0x4e20,0x8(%ebp)
c0028a17:	7f 4b                	jg     c0028a64 <speaker_on+0x6c>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c0028a19:	e8 c8 94 ff ff       	call   c0021ee6 <intr_disable>
c0028a1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
      pit_configure_channel (2, 3, frequency);
c0028a21:	83 ec 04             	sub    $0x4,%esp
c0028a24:	ff 75 08             	push   0x8(%ebp)
c0028a27:	6a 03                	push   $0x3
c0028a29:	6a 02                	push   $0x2
c0028a2b:	e8 a1 c3 ff ff       	call   c0024dd1 <pit_configure_channel>
c0028a30:	83 c4 10             	add    $0x10,%esp
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0028a33:	83 ec 0c             	sub    $0xc,%esp
c0028a36:	6a 61                	push   $0x61
c0028a38:	e8 69 ff ff ff       	call   c00289a6 <inb>
c0028a3d:	83 c4 10             	add    $0x10,%esp
c0028a40:	83 c8 03             	or     $0x3,%eax
c0028a43:	0f b6 c0             	movzbl %al,%eax
c0028a46:	83 ec 08             	sub    $0x8,%esp
c0028a49:	50                   	push   %eax
c0028a4a:	6a 61                	push   $0x61
c0028a4c:	e8 7c ff ff ff       	call   c00289cd <outb>
c0028a51:	83 c4 10             	add    $0x10,%esp
      intr_set_level (old_level);
c0028a54:	83 ec 0c             	sub    $0xc,%esp
c0028a57:	ff 75 f4             	push   -0xc(%ebp)
c0028a5a:	e8 0e 94 ff ff       	call   c0021e6d <intr_set_level>
c0028a5f:	83 c4 10             	add    $0x10,%esp
    {
c0028a62:	eb 06                	jmp    c0028a6a <speaker_on+0x72>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c0028a64:	e8 07 00 00 00       	call   c0028a70 <speaker_off>
    }
}
c0028a69:	90                   	nop
c0028a6a:	90                   	nop
c0028a6b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028a6e:	c9                   	leave  
c0028a6f:	c3                   	ret    

c0028a70 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0028a70:	55                   	push   %ebp
c0028a71:	89 e5                	mov    %esp,%ebp
c0028a73:	53                   	push   %ebx
c0028a74:	83 ec 14             	sub    $0x14,%esp
c0028a77:	e8 b0 89 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028a7c:	81 c3 fc 18 01 00    	add    $0x118fc,%ebx
  enum intr_level old_level = intr_disable ();
c0028a82:	e8 5f 94 ff ff       	call   c0021ee6 <intr_disable>
c0028a87:	89 45 f4             	mov    %eax,-0xc(%ebp)
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
c0028a8a:	83 ec 0c             	sub    $0xc,%esp
c0028a8d:	6a 61                	push   $0x61
c0028a8f:	e8 12 ff ff ff       	call   c00289a6 <inb>
c0028a94:	83 c4 10             	add    $0x10,%esp
c0028a97:	0f b6 c0             	movzbl %al,%eax
c0028a9a:	25 fc 00 00 00       	and    $0xfc,%eax
c0028a9f:	83 ec 08             	sub    $0x8,%esp
c0028aa2:	50                   	push   %eax
c0028aa3:	6a 61                	push   $0x61
c0028aa5:	e8 23 ff ff ff       	call   c00289cd <outb>
c0028aaa:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0028aad:	83 ec 0c             	sub    $0xc,%esp
c0028ab0:	ff 75 f4             	push   -0xc(%ebp)
c0028ab3:	e8 b5 93 ff ff       	call   c0021e6d <intr_set_level>
c0028ab8:	83 c4 10             	add    $0x10,%esp
}
c0028abb:	90                   	nop
c0028abc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028abf:	c9                   	leave  
c0028ac0:	c3                   	ret    

c0028ac1 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0028ac1:	55                   	push   %ebp
c0028ac2:	89 e5                	mov    %esp,%ebp
c0028ac4:	53                   	push   %ebx
c0028ac5:	83 ec 04             	sub    $0x4,%esp
c0028ac8:	e8 5f 89 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028acd:	81 c3 ab 18 01 00    	add    $0x118ab,%ebx

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0028ad3:	e8 75 93 ff ff       	call   c0021e4d <intr_get_level>
c0028ad8:	83 f8 01             	cmp    $0x1,%eax
c0028adb:	75 27                	jne    c0028b04 <speaker_beep+0x43>
    {
      speaker_on (440);
c0028add:	83 ec 0c             	sub    $0xc,%esp
c0028ae0:	68 b8 01 00 00       	push   $0x1b8
c0028ae5:	e8 0e ff ff ff       	call   c00289f8 <speaker_on>
c0028aea:	83 c4 10             	add    $0x10,%esp
      timer_msleep (250);
c0028aed:	83 ec 08             	sub    $0x8,%esp
c0028af0:	6a 00                	push   $0x0
c0028af2:	68 fa 00 00 00       	push   $0xfa
c0028af7:	e8 b4 c6 ff ff       	call   c00251b0 <timer_msleep>
c0028afc:	83 c4 10             	add    $0x10,%esp
      speaker_off ();
c0028aff:	e8 6c ff ff ff       	call   c0028a70 <speaker_off>
    }
}
c0028b04:	90                   	nop
c0028b05:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028b08:	c9                   	leave  
c0028b09:	c3                   	ret    

c0028b0a <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0028b0a:	55                   	push   %ebp
c0028b0b:	89 e5                	mov    %esp,%ebp
c0028b0d:	53                   	push   %ebx
c0028b0e:	83 ec 14             	sub    $0x14,%esp
c0028b11:	e8 16 89 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028b16:	81 c3 62 18 01 00    	add    $0x11862,%ebx
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0028b1c:	8b 45 04             	mov    0x4(%ebp),%eax
c0028b1f:	83 ec 08             	sub    $0x8,%esp
c0028b22:	50                   	push   %eax
c0028b23:	8d 83 48 90 ff ff    	lea    -0x6fb8(%ebx),%eax
c0028b29:	50                   	push   %eax
c0028b2a:	e8 b6 03 00 00       	call   c0028ee5 <printf>
c0028b2f:	83 c4 10             	add    $0x10,%esp
  for (frame = __builtin_frame_address (1);
c0028b32:	8b 45 00             	mov    0x0(%ebp),%eax
c0028b35:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028b38:	eb 23                	jmp    c0028b5d <debug_backtrace+0x53>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0028b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b3d:	83 c0 04             	add    $0x4,%eax
c0028b40:	8b 00                	mov    (%eax),%eax
c0028b42:	83 ec 08             	sub    $0x8,%esp
c0028b45:	50                   	push   %eax
c0028b46:	8d 83 57 90 ff ff    	lea    -0x6fa9(%ebx),%eax
c0028b4c:	50                   	push   %eax
c0028b4d:	e8 93 03 00 00       	call   c0028ee5 <printf>
c0028b52:	83 c4 10             	add    $0x10,%esp
       frame = frame[0]) 
c0028b55:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b58:	8b 00                	mov    (%eax),%eax
c0028b5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0028b5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b60:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c0028b65:	76 09                	jbe    c0028b70 <debug_backtrace+0x66>
c0028b67:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b6a:	8b 00                	mov    (%eax),%eax
c0028b6c:	85 c0                	test   %eax,%eax
c0028b6e:	75 ca                	jne    c0028b3a <debug_backtrace+0x30>
  printf (".\n");
c0028b70:	83 ec 0c             	sub    $0xc,%esp
c0028b73:	8d 83 5b 90 ff ff    	lea    -0x6fa5(%ebx),%eax
c0028b79:	50                   	push   %eax
c0028b7a:	e8 6d 54 00 00       	call   c002dfec <puts>
c0028b7f:	83 c4 10             	add    $0x10,%esp

  if (!explained) 
c0028b82:	0f b6 83 54 21 00 00 	movzbl 0x2154(%ebx),%eax
c0028b89:	83 f0 01             	xor    $0x1,%eax
c0028b8c:	84 c0                	test   %al,%al
c0028b8e:	74 19                	je     c0028ba9 <debug_backtrace+0x9f>
    {
      explained = true;
c0028b90:	c6 83 54 21 00 00 01 	movb   $0x1,0x2154(%ebx)
      printf ("The `backtrace' program can make call stacks useful.\n"
c0028b97:	83 ec 0c             	sub    $0xc,%esp
c0028b9a:	8d 83 60 90 ff ff    	lea    -0x6fa0(%ebx),%eax
c0028ba0:	50                   	push   %eax
c0028ba1:	e8 46 54 00 00       	call   c002dfec <puts>
c0028ba6:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0028ba9:	90                   	nop
c0028baa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028bad:	c9                   	leave  
c0028bae:	c3                   	ret    

c0028baf <swap_byte>:
static bool inited;     

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
c0028baf:	55                   	push   %ebp
c0028bb0:	89 e5                	mov    %esp,%ebp
c0028bb2:	83 ec 10             	sub    $0x10,%esp
c0028bb5:	e8 6e 88 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028bba:	05 be 17 01 00       	add    $0x117be,%eax
  uint8_t t = *a;
c0028bbf:	8b 45 08             	mov    0x8(%ebp),%eax
c0028bc2:	0f b6 00             	movzbl (%eax),%eax
c0028bc5:	88 45 ff             	mov    %al,-0x1(%ebp)
  *a = *b;
c0028bc8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028bcb:	0f b6 10             	movzbl (%eax),%edx
c0028bce:	8b 45 08             	mov    0x8(%ebp),%eax
c0028bd1:	88 10                	mov    %dl,(%eax)
  *b = t;
c0028bd3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028bd6:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0028bda:	88 10                	mov    %dl,(%eax)
}
c0028bdc:	90                   	nop
c0028bdd:	c9                   	leave  
c0028bde:	c3                   	ret    

c0028bdf <random_init>:

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0028bdf:	55                   	push   %ebp
c0028be0:	89 e5                	mov    %esp,%ebp
c0028be2:	53                   	push   %ebx
c0028be3:	83 ec 10             	sub    $0x10,%esp
c0028be6:	e8 41 88 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028beb:	81 c3 8d 17 01 00    	add    $0x1178d,%ebx
  uint8_t *seedp = (uint8_t *) &seed;
c0028bf1:	8d 45 08             	lea    0x8(%ebp),%eax
c0028bf4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  uint8_t j;

  if (inited)
c0028bf7:	0f b6 83 6a 22 00 00 	movzbl 0x226a(%ebx),%eax
c0028bfe:	84 c0                	test   %al,%al
c0028c00:	0f 85 a3 00 00 00    	jne    c0028ca9 <random_init+0xca>
    return;

  for (i = 0; i < 256; i++) 
c0028c06:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0028c0d:	eb 16                	jmp    c0028c25 <random_init+0x46>
    s[i] = i;
c0028c0f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028c12:	89 c2                	mov    %eax,%edx
c0028c14:	8d 8b 68 21 00 00    	lea    0x2168(%ebx),%ecx
c0028c1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028c1d:	01 c8                	add    %ecx,%eax
c0028c1f:	88 10                	mov    %dl,(%eax)
  for (i = 0; i < 256; i++) 
c0028c21:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0028c25:	81 7d f8 ff 00 00 00 	cmpl   $0xff,-0x8(%ebp)
c0028c2c:	7e e1                	jle    c0028c0f <random_init+0x30>
  for (i = j = 0; i < 256; i++) 
c0028c2e:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c0028c32:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0028c39:	eb 48                	jmp    c0028c83 <random_init+0xa4>
    {
      j += s[i] + seedp[i % sizeof seed];
c0028c3b:	8d 93 68 21 00 00    	lea    0x2168(%ebx),%edx
c0028c41:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028c44:	01 d0                	add    %edx,%eax
c0028c46:	0f b6 10             	movzbl (%eax),%edx
c0028c49:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028c4c:	83 e0 03             	and    $0x3,%eax
c0028c4f:	89 c1                	mov    %eax,%ecx
c0028c51:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028c54:	01 c8                	add    %ecx,%eax
c0028c56:	0f b6 00             	movzbl (%eax),%eax
c0028c59:	01 d0                	add    %edx,%eax
c0028c5b:	00 45 f7             	add    %al,-0x9(%ebp)
      swap_byte (s + i, s + j);
c0028c5e:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0028c62:	8d 83 68 21 00 00    	lea    0x2168(%ebx),%eax
c0028c68:	01 c2                	add    %eax,%edx
c0028c6a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c0028c6d:	8d 83 68 21 00 00    	lea    0x2168(%ebx),%eax
c0028c73:	01 c8                	add    %ecx,%eax
c0028c75:	52                   	push   %edx
c0028c76:	50                   	push   %eax
c0028c77:	e8 33 ff ff ff       	call   c0028baf <swap_byte>
c0028c7c:	83 c4 08             	add    $0x8,%esp
  for (i = j = 0; i < 256; i++) 
c0028c7f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0028c83:	81 7d f8 ff 00 00 00 	cmpl   $0xff,-0x8(%ebp)
c0028c8a:	7e af                	jle    c0028c3b <random_init+0x5c>
    }

  s_i = s_j = 0;
c0028c8c:	c6 83 69 22 00 00 00 	movb   $0x0,0x2269(%ebx)
c0028c93:	0f b6 83 69 22 00 00 	movzbl 0x2269(%ebx),%eax
c0028c9a:	88 83 68 22 00 00    	mov    %al,0x2268(%ebx)
  inited = true;
c0028ca0:	c6 83 6a 22 00 00 01 	movb   $0x1,0x226a(%ebx)
c0028ca7:	eb 01                	jmp    c0028caa <random_init+0xcb>
    return;
c0028ca9:	90                   	nop
}
c0028caa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028cad:	c9                   	leave  
c0028cae:	c3                   	ret    

c0028caf <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0028caf:	55                   	push   %ebp
c0028cb0:	89 e5                	mov    %esp,%ebp
c0028cb2:	53                   	push   %ebx
c0028cb3:	83 ec 10             	sub    $0x10,%esp
c0028cb6:	e8 71 87 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0028cbb:	81 c3 bd 16 01 00    	add    $0x116bd,%ebx
  uint8_t *buf;

  if (!inited)
c0028cc1:	0f b6 83 6a 22 00 00 	movzbl 0x226a(%ebx),%eax
c0028cc8:	83 f0 01             	xor    $0x1,%eax
c0028ccb:	84 c0                	test   %al,%al
c0028ccd:	74 0a                	je     c0028cd9 <random_bytes+0x2a>
    random_init (0);
c0028ccf:	6a 00                	push   $0x0
c0028cd1:	e8 09 ff ff ff       	call   c0028bdf <random_init>
c0028cd6:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c0028cd9:	8b 45 08             	mov    0x8(%ebp),%eax
c0028cdc:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028cdf:	e9 9d 00 00 00       	jmp    c0028d81 <random_bytes+0xd2>
    {
      uint8_t s_k;
      
      s_i++;
c0028ce4:	0f b6 83 68 22 00 00 	movzbl 0x2268(%ebx),%eax
c0028ceb:	83 c0 01             	add    $0x1,%eax
c0028cee:	88 83 68 22 00 00    	mov    %al,0x2268(%ebx)
      s_j += s[s_i];
c0028cf4:	0f b6 83 68 22 00 00 	movzbl 0x2268(%ebx),%eax
c0028cfb:	0f b6 c0             	movzbl %al,%eax
c0028cfe:	0f b6 94 03 68 21 00 	movzbl 0x2168(%ebx,%eax,1),%edx
c0028d05:	00 
c0028d06:	0f b6 83 69 22 00 00 	movzbl 0x2269(%ebx),%eax
c0028d0d:	01 d0                	add    %edx,%eax
c0028d0f:	88 83 69 22 00 00    	mov    %al,0x2269(%ebx)
      swap_byte (s + s_i, s + s_j);
c0028d15:	0f b6 83 69 22 00 00 	movzbl 0x2269(%ebx),%eax
c0028d1c:	0f b6 d0             	movzbl %al,%edx
c0028d1f:	8d 83 68 21 00 00    	lea    0x2168(%ebx),%eax
c0028d25:	01 c2                	add    %eax,%edx
c0028d27:	0f b6 83 68 22 00 00 	movzbl 0x2268(%ebx),%eax
c0028d2e:	0f b6 c8             	movzbl %al,%ecx
c0028d31:	8d 83 68 21 00 00    	lea    0x2168(%ebx),%eax
c0028d37:	01 c8                	add    %ecx,%eax
c0028d39:	52                   	push   %edx
c0028d3a:	50                   	push   %eax
c0028d3b:	e8 6f fe ff ff       	call   c0028baf <swap_byte>
c0028d40:	83 c4 08             	add    $0x8,%esp

      s_k = s[s_i] + s[s_j];
c0028d43:	0f b6 83 68 22 00 00 	movzbl 0x2268(%ebx),%eax
c0028d4a:	0f b6 c0             	movzbl %al,%eax
c0028d4d:	0f b6 94 03 68 21 00 	movzbl 0x2168(%ebx,%eax,1),%edx
c0028d54:	00 
c0028d55:	0f b6 83 69 22 00 00 	movzbl 0x2269(%ebx),%eax
c0028d5c:	0f b6 c0             	movzbl %al,%eax
c0028d5f:	0f b6 84 03 68 21 00 	movzbl 0x2168(%ebx,%eax,1),%eax
c0028d66:	00 
c0028d67:	01 d0                	add    %edx,%eax
c0028d69:	88 45 f7             	mov    %al,-0x9(%ebp)
      *buf = s[s_k];
c0028d6c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0028d70:	0f b6 94 03 68 21 00 	movzbl 0x2168(%ebx,%eax,1),%edx
c0028d77:	00 
c0028d78:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028d7b:	88 10                	mov    %dl,(%eax)
  for (buf = buf_; size-- > 0; buf++)
c0028d7d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0028d81:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028d84:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028d87:	89 55 0c             	mov    %edx,0xc(%ebp)
c0028d8a:	85 c0                	test   %eax,%eax
c0028d8c:	0f 85 52 ff ff ff    	jne    c0028ce4 <random_bytes+0x35>
    }
}
c0028d92:	90                   	nop
c0028d93:	90                   	nop
c0028d94:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028d97:	c9                   	leave  
c0028d98:	c3                   	ret    

c0028d99 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0028d99:	55                   	push   %ebp
c0028d9a:	89 e5                	mov    %esp,%ebp
c0028d9c:	83 ec 10             	sub    $0x10,%esp
c0028d9f:	e8 84 86 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028da4:	05 d4 15 01 00       	add    $0x115d4,%eax
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0028da9:	6a 04                	push   $0x4
c0028dab:	8d 45 fc             	lea    -0x4(%ebp),%eax
c0028dae:	50                   	push   %eax
c0028daf:	e8 fb fe ff ff       	call   c0028caf <random_bytes>
c0028db4:	83 c4 08             	add    $0x8,%esp
  return ul;
c0028db7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028dba:	c9                   	leave  
c0028dbb:	c3                   	ret    

c0028dbc <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0028dbc:	55                   	push   %ebp
c0028dbd:	89 e5                	mov    %esp,%ebp
c0028dbf:	e8 64 86 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028dc4:	05 b4 15 01 00       	add    $0x115b4,%eax
c0028dc9:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0028dcd:	7e 0d                	jle    c0028ddc <isdigit+0x20>
c0028dcf:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0028dd3:	7f 07                	jg     c0028ddc <isdigit+0x20>
c0028dd5:	b8 01 00 00 00       	mov    $0x1,%eax
c0028dda:	eb 05                	jmp    c0028de1 <isdigit+0x25>
c0028ddc:	b8 00 00 00 00       	mov    $0x0,%eax
c0028de1:	5d                   	pop    %ebp
c0028de2:	c3                   	ret    

c0028de3 <isprint>:
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0028de3:	55                   	push   %ebp
c0028de4:	89 e5                	mov    %esp,%ebp
c0028de6:	e8 3d 86 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028deb:	05 8d 15 01 00       	add    $0x1158d,%eax
c0028df0:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0028df4:	7e 0d                	jle    c0028e03 <isprint+0x20>
c0028df6:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c0028dfa:	7f 07                	jg     c0028e03 <isprint+0x20>
c0028dfc:	b8 01 00 00 00       	mov    $0x1,%eax
c0028e01:	eb 05                	jmp    c0028e08 <isprint+0x25>
c0028e03:	b8 00 00 00 00       	mov    $0x0,%eax
c0028e08:	5d                   	pop    %ebp
c0028e09:	c3                   	ret    

c0028e0a <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c0028e0a:	55                   	push   %ebp
c0028e0b:	89 e5                	mov    %esp,%ebp
c0028e0d:	83 ec 18             	sub    $0x18,%esp
c0028e10:	e8 13 86 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028e15:	05 63 15 01 00       	add    $0x11563,%eax
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c0028e1a:	8b 55 08             	mov    0x8(%ebp),%edx
c0028e1d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  aux.length = 0;
c0028e20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0028e27:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028e2b:	74 08                	je     c0028e35 <vsnprintf+0x2b>
c0028e2d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0028e30:	83 ea 01             	sub    $0x1,%edx
c0028e33:	eb 05                	jmp    c0028e3a <vsnprintf+0x30>
c0028e35:	ba 00 00 00 00       	mov    $0x0,%edx
c0028e3a:	89 55 f4             	mov    %edx,-0xc(%ebp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c0028e3d:	8d 55 ec             	lea    -0x14(%ebp),%edx
c0028e40:	52                   	push   %edx
c0028e41:	8d 80 ef ea fe ff    	lea    -0x11511(%eax),%eax
c0028e47:	50                   	push   %eax
c0028e48:	ff 75 14             	push   0x14(%ebp)
c0028e4b:	ff 75 10             	push   0x10(%ebp)
c0028e4e:	e8 c8 00 00 00       	call   c0028f1b <__vprintf>
c0028e53:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
c0028e56:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028e5a:	74 06                	je     c0028e62 <vsnprintf+0x58>
    *aux.p = '\0';
c0028e5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028e5f:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
c0028e62:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028e65:	c9                   	leave  
c0028e66:	c3                   	ret    

c0028e67 <vsnprintf_helper>:

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0028e67:	55                   	push   %ebp
c0028e68:	89 e5                	mov    %esp,%ebp
c0028e6a:	83 ec 14             	sub    $0x14,%esp
c0028e6d:	e8 b6 85 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028e72:	05 06 15 01 00       	add    $0x11506,%eax
c0028e77:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e7a:	88 45 ec             	mov    %al,-0x14(%ebp)
  struct vsnprintf_aux *aux = aux_;
c0028e7d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028e80:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (aux->length++ < aux->max_length)
c0028e83:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028e86:	8b 40 04             	mov    0x4(%eax),%eax
c0028e89:	8d 48 01             	lea    0x1(%eax),%ecx
c0028e8c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0028e8f:	89 4a 04             	mov    %ecx,0x4(%edx)
c0028e92:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0028e95:	8b 52 08             	mov    0x8(%edx),%edx
c0028e98:	39 d0                	cmp    %edx,%eax
c0028e9a:	7d 13                	jge    c0028eaf <vsnprintf_helper+0x48>
    *aux->p++ = ch;
c0028e9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028e9f:	8b 00                	mov    (%eax),%eax
c0028ea1:	8d 48 01             	lea    0x1(%eax),%ecx
c0028ea4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0028ea7:	89 0a                	mov    %ecx,(%edx)
c0028ea9:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c0028ead:	88 10                	mov    %dl,(%eax)
}
c0028eaf:	90                   	nop
c0028eb0:	c9                   	leave  
c0028eb1:	c3                   	ret    

c0028eb2 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c0028eb2:	55                   	push   %ebp
c0028eb3:	89 e5                	mov    %esp,%ebp
c0028eb5:	83 ec 18             	sub    $0x18,%esp
c0028eb8:	e8 6b 85 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028ebd:	05 bb 14 01 00       	add    $0x114bb,%eax
  va_list args;
  int retval;

  va_start (args, format);
c0028ec2:	8d 45 14             	lea    0x14(%ebp),%eax
c0028ec5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vsnprintf (buffer, buf_size, format, args);
c0028ec8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028ecb:	50                   	push   %eax
c0028ecc:	ff 75 10             	push   0x10(%ebp)
c0028ecf:	ff 75 0c             	push   0xc(%ebp)
c0028ed2:	ff 75 08             	push   0x8(%ebp)
c0028ed5:	e8 30 ff ff ff       	call   c0028e0a <vsnprintf>
c0028eda:	83 c4 10             	add    $0x10,%esp
c0028edd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c0028ee0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028ee3:	c9                   	leave  
c0028ee4:	c3                   	ret    

c0028ee5 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c0028ee5:	55                   	push   %ebp
c0028ee6:	89 e5                	mov    %esp,%ebp
c0028ee8:	53                   	push   %ebx
c0028ee9:	83 ec 14             	sub    $0x14,%esp
c0028eec:	e8 37 85 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0028ef1:	05 87 14 01 00       	add    $0x11487,%eax
  va_list args;
  int retval;

  va_start (args, format);
c0028ef6:	8d 55 0c             	lea    0xc(%ebp),%edx
c0028ef9:	89 55 f0             	mov    %edx,-0x10(%ebp)
  retval = vprintf (format, args);
c0028efc:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028eff:	83 ec 08             	sub    $0x8,%esp
c0028f02:	52                   	push   %edx
c0028f03:	ff 75 08             	push   0x8(%ebp)
c0028f06:	89 c3                	mov    %eax,%ebx
c0028f08:	e8 9b 50 00 00       	call   c002dfa8 <vprintf>
c0028f0d:	83 c4 10             	add    $0x10,%esp
c0028f10:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c0028f13:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028f16:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028f19:	c9                   	leave  
c0028f1a:	c3                   	ret    

c0028f1b <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c0028f1b:	55                   	push   %ebp
c0028f1c:	89 e5                	mov    %esp,%ebp
c0028f1e:	57                   	push   %edi
c0028f1f:	56                   	push   %esi
c0028f20:	53                   	push   %ebx
c0028f21:	83 ec 5c             	sub    $0x5c,%esp
c0028f24:	e8 07 85 00 00       	call   c0031430 <__x86.get_pc_thunk.si>
c0028f29:	81 c6 4f 14 01 00    	add    $0x1144f,%esi
  for (; *format != '\0'; format++)
c0028f2f:	e9 b1 04 00 00       	jmp    c00293e5 <.L26+0x24>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c0028f34:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f37:	0f b6 00             	movzbl (%eax),%eax
c0028f3a:	3c 25                	cmp    $0x25,%al
c0028f3c:	74 1d                	je     c0028f5b <__vprintf+0x40>
        {
          output (*format, aux);
c0028f3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f41:	0f b6 00             	movzbl (%eax),%eax
c0028f44:	0f be c0             	movsbl %al,%eax
c0028f47:	83 ec 08             	sub    $0x8,%esp
c0028f4a:	ff 75 14             	push   0x14(%ebp)
c0028f4d:	50                   	push   %eax
c0028f4e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f51:	ff d0                	call   *%eax
c0028f53:	83 c4 10             	add    $0x10,%esp
          continue;
c0028f56:	e9 86 04 00 00       	jmp    c00293e1 <.L26+0x20>
        }
      format++;
c0028f5b:	83 45 08 01          	addl   $0x1,0x8(%ebp)

      /* %% => %. */
      if (*format == '%') 
c0028f5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f62:	0f b6 00             	movzbl (%eax),%eax
c0028f65:	3c 25                	cmp    $0x25,%al
c0028f67:	75 15                	jne    c0028f7e <__vprintf+0x63>
        {
          output ('%', aux);
c0028f69:	83 ec 08             	sub    $0x8,%esp
c0028f6c:	ff 75 14             	push   0x14(%ebp)
c0028f6f:	6a 25                	push   $0x25
c0028f71:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f74:	ff d0                	call   *%eax
c0028f76:	83 c4 10             	add    $0x10,%esp
          continue;
c0028f79:	e9 63 04 00 00       	jmp    c00293e1 <.L26+0x20>
        }

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);
c0028f7e:	83 ec 04             	sub    $0x4,%esp
c0028f81:	8d 45 0c             	lea    0xc(%ebp),%eax
c0028f84:	50                   	push   %eax
c0028f85:	8d 45 bc             	lea    -0x44(%ebp),%eax
c0028f88:	50                   	push   %eax
c0028f89:	ff 75 08             	push   0x8(%ebp)
c0028f8c:	e8 6c 04 00 00       	call   c00293fd <parse_conversion>
c0028f91:	83 c4 10             	add    $0x10,%esp
c0028f94:	89 45 08             	mov    %eax,0x8(%ebp)

      /* Do conversion. */
      switch (*format) 
c0028f97:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f9a:	0f b6 00             	movzbl (%eax),%eax
c0028f9d:	0f be c0             	movsbl %al,%eax
c0028fa0:	83 e8 45             	sub    $0x45,%eax
c0028fa3:	83 f8 33             	cmp    $0x33,%eax
c0028fa6:	0f 87 15 04 00 00    	ja     c00293c1 <.L26>
c0028fac:	c1 e0 02             	shl    $0x2,%eax
c0028faf:	8b 84 30 9c 91 ff ff 	mov    -0x6e64(%eax,%esi,1),%eax
c0028fb6:	01 f0                	add    %esi,%eax
c0028fb8:	ff e0                	jmp    *%eax

c0028fba <.L32>:
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c0028fba:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0028fbd:	83 f8 08             	cmp    $0x8,%eax
c0028fc0:	0f 87 db 00 00 00    	ja     c00290a1 <.L34>
c0028fc6:	c1 e0 02             	shl    $0x2,%eax
c0028fc9:	8b 84 30 6c 92 ff ff 	mov    -0x6d94(%eax,%esi,1),%eax
c0028fd0:	01 f0                	add    %esi,%eax
c0028fd2:	ff e0                	jmp    *%eax

c0028fd4 <.L43>:
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c0028fd4:	8b 55 0c             	mov    0xc(%ebp),%edx
c0028fd7:	8d 42 04             	lea    0x4(%edx),%eax
c0028fda:	89 45 0c             	mov    %eax,0xc(%ebp)
c0028fdd:	8b 02                	mov    (%edx),%eax
c0028fdf:	0f be c0             	movsbl %al,%eax
c0028fe2:	99                   	cltd   
c0028fe3:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0028fe6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0028fe9:	e9 d5 00 00 00       	jmp    c00290c3 <.L34+0x22>

c0028fee <.L42>:
              case SHORT:
                value = (short) va_arg (args, int);
c0028fee:	8b 55 0c             	mov    0xc(%ebp),%edx
c0028ff1:	8d 42 04             	lea    0x4(%edx),%eax
c0028ff4:	89 45 0c             	mov    %eax,0xc(%ebp)
c0028ff7:	8b 02                	mov    (%edx),%eax
c0028ff9:	98                   	cwtl   
c0028ffa:	99                   	cltd   
c0028ffb:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0028ffe:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0029001:	e9 bd 00 00 00       	jmp    c00290c3 <.L34+0x22>

c0029006 <.L41>:
              case INT:
                value = va_arg (args, int);
c0029006:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029009:	8d 42 04             	lea    0x4(%edx),%eax
c002900c:	89 45 0c             	mov    %eax,0xc(%ebp)
c002900f:	8b 02                	mov    (%edx),%eax
c0029011:	99                   	cltd   
c0029012:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0029015:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0029018:	e9 a6 00 00 00       	jmp    c00290c3 <.L34+0x22>

c002901d <.L40>:
              case INTMAX:
                value = va_arg (args, intmax_t);
c002901d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029020:	8d 42 08             	lea    0x8(%edx),%eax
c0029023:	89 45 0c             	mov    %eax,0xc(%ebp)
c0029026:	8b 02                	mov    (%edx),%eax
c0029028:	8b 52 04             	mov    0x4(%edx),%edx
c002902b:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002902e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0029031:	e9 8d 00 00 00       	jmp    c00290c3 <.L34+0x22>

c0029036 <.L39>:
              case LONG:
                value = va_arg (args, long);
c0029036:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029039:	8d 42 04             	lea    0x4(%edx),%eax
c002903c:	89 45 0c             	mov    %eax,0xc(%ebp)
c002903f:	8b 02                	mov    (%edx),%eax
c0029041:	99                   	cltd   
c0029042:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0029045:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0029048:	eb 79                	jmp    c00290c3 <.L34+0x22>

c002904a <.L38>:
              case LONGLONG:
                value = va_arg (args, long long);
c002904a:	8b 55 0c             	mov    0xc(%ebp),%edx
c002904d:	8d 42 08             	lea    0x8(%edx),%eax
c0029050:	89 45 0c             	mov    %eax,0xc(%ebp)
c0029053:	8b 02                	mov    (%edx),%eax
c0029055:	8b 52 04             	mov    0x4(%edx),%edx
c0029058:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002905b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c002905e:	eb 63                	jmp    c00290c3 <.L34+0x22>

c0029060 <.L37>:
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c0029060:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029063:	8d 42 04             	lea    0x4(%edx),%eax
c0029066:	89 45 0c             	mov    %eax,0xc(%ebp)
c0029069:	8b 02                	mov    (%edx),%eax
c002906b:	99                   	cltd   
c002906c:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002906f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0029072:	eb 4f                	jmp    c00290c3 <.L34+0x22>

c0029074 <.L35>:
              case SIZET:
                value = va_arg (args, size_t);
c0029074:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029077:	8d 42 04             	lea    0x4(%edx),%eax
c002907a:	89 45 0c             	mov    %eax,0xc(%ebp)
c002907d:	8b 02                	mov    (%edx),%eax
c002907f:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0029082:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                if (value > SIZE_MAX / 2)
c0029089:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
c002908e:	b8 00 00 00 00       	mov    $0x0,%eax
c0029093:	3b 55 e0             	cmp    -0x20(%ebp),%edx
c0029096:	1b 45 e4             	sbb    -0x1c(%ebp),%eax
c0029099:	7d 27                	jge    c00290c2 <.L34+0x21>
                  value = value - SIZE_MAX - 1;
c002909b:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
                break;
c002909f:	eb 21                	jmp    c00290c2 <.L34+0x21>

c00290a1 <.L34>:
              default:
                NOT_REACHED ();
c00290a1:	8d 86 34 91 ff ff    	lea    -0x6ecc(%esi),%eax
c00290a7:	50                   	push   %eax
c00290a8:	8d 86 68 93 ff ff    	lea    -0x6c98(%esi),%eax
c00290ae:	50                   	push   %eax
c00290af:	68 dc 00 00 00       	push   $0xdc
c00290b4:	8d 86 56 91 ff ff    	lea    -0x6eaa(%esi),%eax
c00290ba:	50                   	push   %eax
c00290bb:	89 f3                	mov    %esi,%ebx
c00290bd:	e8 a2 26 00 00       	call   c002b764 <debug_panic>
                break;
c00290c2:	90                   	nop
              }

            format_integer (value < 0 ? -value : value,
c00290c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00290c6:	c1 e8 1f             	shr    $0x1f,%eax
c00290c9:	0f b6 c0             	movzbl %al,%eax
c00290cc:	89 45 9c             	mov    %eax,-0x64(%ebp)
c00290cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00290d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00290d5:	89 c1                	mov    %eax,%ecx
c00290d7:	f7 d9                	neg    %ecx
c00290d9:	89 4d b0             	mov    %ecx,-0x50(%ebp)
c00290dc:	89 d3                	mov    %edx,%ebx
c00290de:	83 d3 00             	adc    $0x0,%ebx
c00290e1:	89 5d b4             	mov    %ebx,-0x4c(%ebp)
c00290e4:	f7 5d b4             	negl   -0x4c(%ebp)
c00290e7:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c00290ea:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
c00290ed:	89 cf                	mov    %ecx,%edi
c00290ef:	0f 48 f8             	cmovs  %eax,%edi
c00290f2:	89 7d a8             	mov    %edi,-0x58(%ebp)
c00290f5:	89 d0                	mov    %edx,%eax
c00290f7:	0f 49 c3             	cmovns %ebx,%eax
c00290fa:	89 45 ac             	mov    %eax,-0x54(%ebp)
c00290fd:	8b 4d a8             	mov    -0x58(%ebp),%ecx
c0029100:	8b 5d ac             	mov    -0x54(%ebp),%ebx
c0029103:	ff 75 14             	push   0x14(%ebp)
c0029106:	ff 75 10             	push   0x10(%ebp)
c0029109:	8d 45 bc             	lea    -0x44(%ebp),%eax
c002910c:	50                   	push   %eax
c002910d:	8d 86 80 01 00 00    	lea    0x180(%esi),%eax
c0029113:	50                   	push   %eax
c0029114:	ff 75 9c             	push   -0x64(%ebp)
c0029117:	6a 01                	push   $0x1
c0029119:	53                   	push   %ebx
c002911a:	51                   	push   %ecx
c002911b:	e8 be 05 00 00       	call   c00296de <format_integer>
c0029120:	83 c4 20             	add    $0x20,%esp
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c0029123:	e9 b9 02 00 00       	jmp    c00293e1 <.L26+0x20>

c0029128 <.L27>:
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
c0029128:	8b 45 c8             	mov    -0x38(%ebp),%eax
c002912b:	83 f8 08             	cmp    $0x8,%eax
c002912e:	0f 87 f4 00 00 00    	ja     c0029228 <.L47>
c0029134:	c1 e0 02             	shl    $0x2,%eax
c0029137:	8b 84 30 90 92 ff ff 	mov    -0x6d70(%eax,%esi,1),%eax
c002913e:	01 f0                	add    %esi,%eax
c0029140:	ff e0                	jmp    *%eax

c0029142 <.L56>:
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c0029142:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029145:	8d 42 04             	lea    0x4(%edx),%eax
c0029148:	89 45 0c             	mov    %eax,0xc(%ebp)
c002914b:	8b 02                	mov    (%edx),%eax
c002914d:	0f b6 c0             	movzbl %al,%eax
c0029150:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0029153:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c002915a:	e9 ea 00 00 00       	jmp    c0029249 <.L47+0x21>

c002915f <.L55>:
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c002915f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029162:	8d 42 04             	lea    0x4(%edx),%eax
c0029165:	89 45 0c             	mov    %eax,0xc(%ebp)
c0029168:	8b 02                	mov    (%edx),%eax
c002916a:	0f b7 c0             	movzwl %ax,%eax
c002916d:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0029170:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0029177:	e9 cd 00 00 00       	jmp    c0029249 <.L47+0x21>

c002917c <.L54>:
              case INT:
                value = va_arg (args, unsigned);
c002917c:	8b 55 0c             	mov    0xc(%ebp),%edx
c002917f:	8d 42 04             	lea    0x4(%edx),%eax
c0029182:	89 45 0c             	mov    %eax,0xc(%ebp)
c0029185:	8b 02                	mov    (%edx),%eax
c0029187:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002918a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0029191:	e9 b3 00 00 00       	jmp    c0029249 <.L47+0x21>

c0029196 <.L53>:
              case INTMAX:
                value = va_arg (args, uintmax_t);
c0029196:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029199:	8d 42 08             	lea    0x8(%edx),%eax
c002919c:	89 45 0c             	mov    %eax,0xc(%ebp)
c002919f:	8b 02                	mov    (%edx),%eax
c00291a1:	8b 52 04             	mov    0x4(%edx),%edx
c00291a4:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00291a7:	89 55 dc             	mov    %edx,-0x24(%ebp)
                break;
c00291aa:	e9 9a 00 00 00       	jmp    c0029249 <.L47+0x21>

c00291af <.L52>:
              case LONG:
                value = va_arg (args, unsigned long);
c00291af:	8b 55 0c             	mov    0xc(%ebp),%edx
c00291b2:	8d 42 04             	lea    0x4(%edx),%eax
c00291b5:	89 45 0c             	mov    %eax,0xc(%ebp)
c00291b8:	8b 02                	mov    (%edx),%eax
c00291ba:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00291bd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c00291c4:	e9 80 00 00 00       	jmp    c0029249 <.L47+0x21>

c00291c9 <.L51>:
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c00291c9:	8b 55 0c             	mov    0xc(%ebp),%edx
c00291cc:	8d 42 08             	lea    0x8(%edx),%eax
c00291cf:	89 45 0c             	mov    %eax,0xc(%ebp)
c00291d2:	8b 02                	mov    (%edx),%eax
c00291d4:	8b 52 04             	mov    0x4(%edx),%edx
c00291d7:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00291da:	89 55 dc             	mov    %edx,-0x24(%ebp)
                break;
c00291dd:	eb 6a                	jmp    c0029249 <.L47+0x21>

c00291df <.L50>:
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c00291df:	8b 55 0c             	mov    0xc(%ebp),%edx
c00291e2:	8d 42 04             	lea    0x4(%edx),%eax
c00291e5:	89 45 0c             	mov    %eax,0xc(%ebp)
c00291e8:	8b 02                	mov    (%edx),%eax
c00291ea:	99                   	cltd   
c00291eb:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00291ee:	89 55 dc             	mov    %edx,-0x24(%ebp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c00291f1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00291f4:	80 e4 ff             	and    $0xff,%ah
c00291f7:	89 45 a0             	mov    %eax,-0x60(%ebp)
c00291fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00291fd:	83 e0 00             	and    $0x0,%eax
c0029200:	89 45 a4             	mov    %eax,-0x5c(%ebp)
c0029203:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0029206:	8b 55 a4             	mov    -0x5c(%ebp),%edx
c0029209:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002920c:	89 55 dc             	mov    %edx,-0x24(%ebp)
#endif
                break;
c002920f:	eb 38                	jmp    c0029249 <.L47+0x21>

c0029211 <.L48>:
              case SIZET:
                value = va_arg (args, size_t);
c0029211:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029214:	8d 42 04             	lea    0x4(%edx),%eax
c0029217:	89 45 0c             	mov    %eax,0xc(%ebp)
c002921a:	8b 02                	mov    (%edx),%eax
c002921c:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002921f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0029226:	eb 21                	jmp    c0029249 <.L47+0x21>

c0029228 <.L47>:
              default:
                NOT_REACHED ();
c0029228:	8d 86 34 91 ff ff    	lea    -0x6ecc(%esi),%eax
c002922e:	50                   	push   %eax
c002922f:	8d 86 68 93 ff ff    	lea    -0x6c98(%esi),%eax
c0029235:	50                   	push   %eax
c0029236:	68 0b 01 00 00       	push   $0x10b
c002923b:	8d 86 56 91 ff ff    	lea    -0x6eaa(%esi),%eax
c0029241:	50                   	push   %eax
c0029242:	89 f3                	mov    %esi,%ebx
c0029244:	e8 1b 25 00 00       	call   c002b764 <debug_panic>
              }

            switch (*format) 
c0029249:	8b 45 08             	mov    0x8(%ebp),%eax
c002924c:	0f b6 00             	movzbl (%eax),%eax
c002924f:	0f be c0             	movsbl %al,%eax
c0029252:	83 f8 78             	cmp    $0x78,%eax
c0029255:	74 2f                	je     c0029286 <.L47+0x5e>
c0029257:	83 f8 78             	cmp    $0x78,%eax
c002925a:	7f 40                	jg     c002929c <.L47+0x74>
c002925c:	83 f8 75             	cmp    $0x75,%eax
c002925f:	74 1a                	je     c002927b <.L47+0x53>
c0029261:	83 f8 75             	cmp    $0x75,%eax
c0029264:	7f 36                	jg     c002929c <.L47+0x74>
c0029266:	83 f8 58             	cmp    $0x58,%eax
c0029269:	74 26                	je     c0029291 <.L47+0x69>
c002926b:	83 f8 6f             	cmp    $0x6f,%eax
c002926e:	75 2c                	jne    c002929c <.L47+0x74>
              {
              case 'o': b = &base_o; break;
c0029270:	8d 86 90 01 00 00    	lea    0x190(%esi),%eax
c0029276:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c0029279:	eb 42                	jmp    c00292bd <.L47+0x95>
              case 'u': b = &base_d; break;
c002927b:	8d 86 80 01 00 00    	lea    0x180(%esi),%eax
c0029281:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c0029284:	eb 37                	jmp    c00292bd <.L47+0x95>
              case 'x': b = &base_x; break;
c0029286:	8d 86 a0 01 00 00    	lea    0x1a0(%esi),%eax
c002928c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c002928f:	eb 2c                	jmp    c00292bd <.L47+0x95>
              case 'X': b = &base_X; break;
c0029291:	8d 86 b0 01 00 00    	lea    0x1b0(%esi),%eax
c0029297:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c002929a:	eb 21                	jmp    c00292bd <.L47+0x95>
              default: NOT_REACHED ();
c002929c:	8d 86 34 91 ff ff    	lea    -0x6ecc(%esi),%eax
c00292a2:	50                   	push   %eax
c00292a3:	8d 86 68 93 ff ff    	lea    -0x6c98(%esi),%eax
c00292a9:	50                   	push   %eax
c00292aa:	68 14 01 00 00       	push   $0x114
c00292af:	8d 86 56 91 ff ff    	lea    -0x6eaa(%esi),%eax
c00292b5:	50                   	push   %eax
c00292b6:	89 f3                	mov    %esi,%ebx
c00292b8:	e8 a7 24 00 00       	call   c002b764 <debug_panic>
              }

            format_integer (value, false, false, b, &c, output, aux);
c00292bd:	ff 75 14             	push   0x14(%ebp)
c00292c0:	ff 75 10             	push   0x10(%ebp)
c00292c3:	8d 45 bc             	lea    -0x44(%ebp),%eax
c00292c6:	50                   	push   %eax
c00292c7:	ff 75 d4             	push   -0x2c(%ebp)
c00292ca:	6a 00                	push   $0x0
c00292cc:	6a 00                	push   $0x0
c00292ce:	ff 75 dc             	push   -0x24(%ebp)
c00292d1:	ff 75 d8             	push   -0x28(%ebp)
c00292d4:	e8 05 04 00 00       	call   c00296de <format_integer>
c00292d9:	83 c4 20             	add    $0x20,%esp
          }
          break;
c00292dc:	e9 00 01 00 00       	jmp    c00293e1 <.L26+0x20>

c00292e1 <.L33>:

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c00292e1:	8b 55 0c             	mov    0xc(%ebp),%edx
c00292e4:	8d 42 04             	lea    0x4(%edx),%eax
c00292e7:	89 45 0c             	mov    %eax,0xc(%ebp)
c00292ea:	8b 02                	mov    (%edx),%eax
c00292ec:	88 45 bb             	mov    %al,-0x45(%ebp)
            format_string (&ch, 1, &c, output, aux);
c00292ef:	83 ec 0c             	sub    $0xc,%esp
c00292f2:	ff 75 14             	push   0x14(%ebp)
c00292f5:	ff 75 10             	push   0x10(%ebp)
c00292f8:	8d 45 bc             	lea    -0x44(%ebp),%eax
c00292fb:	50                   	push   %eax
c00292fc:	6a 01                	push   $0x1
c00292fe:	8d 45 bb             	lea    -0x45(%ebp),%eax
c0029301:	50                   	push   %eax
c0029302:	e8 43 07 00 00       	call   c0029a4a <format_string>
c0029307:	83 c4 20             	add    $0x20,%esp
          }
          break;
c002930a:	e9 d2 00 00 00       	jmp    c00293e1 <.L26+0x20>

c002930f <.L29>:

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c002930f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029312:	8d 42 04             	lea    0x4(%edx),%eax
c0029315:	89 45 0c             	mov    %eax,0xc(%ebp)
c0029318:	8b 02                	mov    (%edx),%eax
c002931a:	89 45 d0             	mov    %eax,-0x30(%ebp)
            if (s == NULL)
c002931d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
c0029321:	75 09                	jne    c002932c <.L29+0x1d>
              s = "(null)";
c0029323:	8d 86 68 91 ff ff    	lea    -0x6e98(%esi),%eax
c0029329:	89 45 d0             	mov    %eax,-0x30(%ebp)

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c002932c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c002932f:	83 ec 08             	sub    $0x8,%esp
c0029332:	50                   	push   %eax
c0029333:	ff 75 d0             	push   -0x30(%ebp)
c0029336:	89 f3                	mov    %esi,%ebx
c0029338:	e8 8c 17 00 00       	call   c002aac9 <strnlen>
c002933d:	83 c4 10             	add    $0x10,%esp
c0029340:	89 c2                	mov    %eax,%edx
c0029342:	83 ec 0c             	sub    $0xc,%esp
c0029345:	ff 75 14             	push   0x14(%ebp)
c0029348:	ff 75 10             	push   0x10(%ebp)
c002934b:	8d 45 bc             	lea    -0x44(%ebp),%eax
c002934e:	50                   	push   %eax
c002934f:	52                   	push   %edx
c0029350:	ff 75 d0             	push   -0x30(%ebp)
c0029353:	e8 f2 06 00 00       	call   c0029a4a <format_string>
c0029358:	83 c4 20             	add    $0x20,%esp
          }
          break;
c002935b:	e9 81 00 00 00       	jmp    c00293e1 <.L26+0x20>

c0029360 <.L30>:
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c0029360:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029363:	8d 42 04             	lea    0x4(%edx),%eax
c0029366:	89 45 0c             	mov    %eax,0xc(%ebp)
c0029369:	8b 02                	mov    (%edx),%eax
c002936b:	89 45 cc             	mov    %eax,-0x34(%ebp)

            c.flags = POUND;
c002936e:	c7 45 bc 08 00 00 00 	movl   $0x8,-0x44(%ebp)
            format_integer ((uintptr_t) p, false, false,
c0029375:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0029378:	89 c1                	mov    %eax,%ecx
c002937a:	bb 00 00 00 00       	mov    $0x0,%ebx
c002937f:	ff 75 14             	push   0x14(%ebp)
c0029382:	ff 75 10             	push   0x10(%ebp)
c0029385:	8d 45 bc             	lea    -0x44(%ebp),%eax
c0029388:	50                   	push   %eax
c0029389:	8d 86 a0 01 00 00    	lea    0x1a0(%esi),%eax
c002938f:	50                   	push   %eax
c0029390:	6a 00                	push   $0x0
c0029392:	6a 00                	push   $0x0
c0029394:	53                   	push   %ebx
c0029395:	51                   	push   %ecx
c0029396:	e8 43 03 00 00       	call   c00296de <format_integer>
c002939b:	83 c4 20             	add    $0x20,%esp
                            &base_x, &c, output, aux);
          }
          break;
c002939e:	eb 41                	jmp    c00293e1 <.L26+0x20>

c00293a0 <.L31>:
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c00293a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00293a3:	0f b6 00             	movzbl (%eax),%eax
c00293a6:	0f be c0             	movsbl %al,%eax
c00293a9:	50                   	push   %eax
c00293aa:	ff 75 14             	push   0x14(%ebp)
c00293ad:	ff 75 10             	push   0x10(%ebp)
c00293b0:	8d 86 6f 91 ff ff    	lea    -0x6e91(%esi),%eax
c00293b6:	50                   	push   %eax
c00293b7:	e8 35 07 00 00       	call   c0029af1 <__printf>
c00293bc:	83 c4 10             	add    $0x10,%esp
          break;
c00293bf:	eb 20                	jmp    c00293e1 <.L26+0x20>

c00293c1 <.L26>:

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c00293c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00293c4:	0f b6 00             	movzbl (%eax),%eax
c00293c7:	0f be c0             	movsbl %al,%eax
c00293ca:	50                   	push   %eax
c00293cb:	ff 75 14             	push   0x14(%ebp)
c00293ce:	ff 75 10             	push   0x10(%ebp)
c00293d1:	8d 86 85 91 ff ff    	lea    -0x6e7b(%esi),%eax
c00293d7:	50                   	push   %eax
c00293d8:	e8 14 07 00 00       	call   c0029af1 <__printf>
c00293dd:	83 c4 10             	add    $0x10,%esp
          break;
c00293e0:	90                   	nop
  for (; *format != '\0'; format++)
c00293e1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c00293e5:	8b 45 08             	mov    0x8(%ebp),%eax
c00293e8:	0f b6 00             	movzbl (%eax),%eax
c00293eb:	84 c0                	test   %al,%al
c00293ed:	0f 85 41 fb ff ff    	jne    c0028f34 <__vprintf+0x19>
        }
    }
}
c00293f3:	90                   	nop
c00293f4:	90                   	nop
c00293f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00293f8:	5b                   	pop    %ebx
c00293f9:	5e                   	pop    %esi
c00293fa:	5f                   	pop    %edi
c00293fb:	5d                   	pop    %ebp
c00293fc:	c3                   	ret    

c00293fd <parse_conversion>:
   that indicates the conversion (e.g. the `d' in `%d').  Uses
   *ARGS for `*' field widths and precisions. */
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
c00293fd:	55                   	push   %ebp
c00293fe:	89 e5                	mov    %esp,%ebp
c0029400:	53                   	push   %ebx
c0029401:	e8 26 80 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0029406:	81 c3 72 0f 01 00    	add    $0x10f72,%ebx
  /* Parse flag characters. */
  c->flags = 0;
c002940c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002940f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (;;) 
    {
      switch (*format++) 
c0029415:	8b 45 08             	mov    0x8(%ebp),%eax
c0029418:	8d 50 01             	lea    0x1(%eax),%edx
c002941b:	89 55 08             	mov    %edx,0x8(%ebp)
c002941e:	0f b6 00             	movzbl (%eax),%eax
c0029421:	0f be c0             	movsbl %al,%eax
c0029424:	83 e8 20             	sub    $0x20,%eax
c0029427:	83 f8 10             	cmp    $0x10,%eax
c002942a:	77 74                	ja     c00294a0 <.L68>
c002942c:	c1 e0 02             	shl    $0x2,%eax
c002942f:	8b 84 18 b4 92 ff ff 	mov    -0x6d4c(%eax,%ebx,1),%eax
c0029436:	01 d8                	add    %ebx,%eax
c0029438:	ff e0                	jmp    *%eax

c002943a <.L71>:
        {
        case '-':
          c->flags |= MINUS;
c002943a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002943d:	8b 00                	mov    (%eax),%eax
c002943f:	83 c8 01             	or     $0x1,%eax
c0029442:	89 c2                	mov    %eax,%edx
c0029444:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029447:	89 10                	mov    %edx,(%eax)
          break;
c0029449:	eb 68                	jmp    c00294b3 <.L68+0x13>

c002944b <.L72>:
        case '+':
          c->flags |= PLUS;
c002944b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002944e:	8b 00                	mov    (%eax),%eax
c0029450:	83 c8 02             	or     $0x2,%eax
c0029453:	89 c2                	mov    %eax,%edx
c0029455:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029458:	89 10                	mov    %edx,(%eax)
          break;
c002945a:	eb 57                	jmp    c00294b3 <.L68+0x13>

c002945c <.L75>:
        case ' ':
          c->flags |= SPACE;
c002945c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002945f:	8b 00                	mov    (%eax),%eax
c0029461:	83 c8 04             	or     $0x4,%eax
c0029464:	89 c2                	mov    %eax,%edx
c0029466:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029469:	89 10                	mov    %edx,(%eax)
          break;
c002946b:	eb 46                	jmp    c00294b3 <.L68+0x13>

c002946d <.L74>:
        case '#':
          c->flags |= POUND;
c002946d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029470:	8b 00                	mov    (%eax),%eax
c0029472:	83 c8 08             	or     $0x8,%eax
c0029475:	89 c2                	mov    %eax,%edx
c0029477:	8b 45 0c             	mov    0xc(%ebp),%eax
c002947a:	89 10                	mov    %edx,(%eax)
          break;
c002947c:	eb 35                	jmp    c00294b3 <.L68+0x13>

c002947e <.L69>:
        case '0':
          c->flags |= ZERO;
c002947e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029481:	8b 00                	mov    (%eax),%eax
c0029483:	83 c8 10             	or     $0x10,%eax
c0029486:	89 c2                	mov    %eax,%edx
c0029488:	8b 45 0c             	mov    0xc(%ebp),%eax
c002948b:	89 10                	mov    %edx,(%eax)
          break;
c002948d:	eb 24                	jmp    c00294b3 <.L68+0x13>

c002948f <.L73>:
        case '\'':
          c->flags |= GROUP;
c002948f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029492:	8b 00                	mov    (%eax),%eax
c0029494:	83 c8 20             	or     $0x20,%eax
c0029497:	89 c2                	mov    %eax,%edx
c0029499:	8b 45 0c             	mov    0xc(%ebp),%eax
c002949c:	89 10                	mov    %edx,(%eax)
          break;
c002949e:	eb 13                	jmp    c00294b3 <.L68+0x13>

c00294a0 <.L68>:
        default:
          format--;
c00294a0:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
          goto not_a_flag;
c00294a4:	90                   	nop
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c00294a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294a8:	8b 00                	mov    (%eax),%eax
c00294aa:	83 e0 01             	and    $0x1,%eax
c00294ad:	85 c0                	test   %eax,%eax
c00294af:	74 16                	je     c00294c7 <.L68+0x27>
c00294b1:	eb 05                	jmp    c00294b8 <.L68+0x18>
      switch (*format++) 
c00294b3:	e9 5d ff ff ff       	jmp    c0029415 <parse_conversion+0x18>
    c->flags &= ~ZERO;
c00294b8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294bb:	8b 00                	mov    (%eax),%eax
c00294bd:	83 e0 ef             	and    $0xffffffef,%eax
c00294c0:	89 c2                	mov    %eax,%edx
c00294c2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294c5:	89 10                	mov    %edx,(%eax)
  if (c->flags & PLUS)
c00294c7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294ca:	8b 00                	mov    (%eax),%eax
c00294cc:	83 e0 02             	and    $0x2,%eax
c00294cf:	85 c0                	test   %eax,%eax
c00294d1:	74 0f                	je     c00294e2 <.L68+0x42>
    c->flags &= ~SPACE;
c00294d3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294d6:	8b 00                	mov    (%eax),%eax
c00294d8:	83 e0 fb             	and    $0xfffffffb,%eax
c00294db:	89 c2                	mov    %eax,%edx
c00294dd:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294e0:	89 10                	mov    %edx,(%eax)

  /* Parse field width. */
  c->width = 0;
c00294e2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294e5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (*format == '*')
c00294ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00294ef:	0f b6 00             	movzbl (%eax),%eax
c00294f2:	3c 2a                	cmp    $0x2a,%al
c00294f4:	75 44                	jne    c002953a <.L68+0x9a>
    {
      format++;
c00294f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      c->width = va_arg (*args, int);
c00294fa:	8b 45 10             	mov    0x10(%ebp),%eax
c00294fd:	8b 00                	mov    (%eax),%eax
c00294ff:	8d 48 04             	lea    0x4(%eax),%ecx
c0029502:	8b 55 10             	mov    0x10(%ebp),%edx
c0029505:	89 0a                	mov    %ecx,(%edx)
c0029507:	8b 10                	mov    (%eax),%edx
c0029509:	8b 45 0c             	mov    0xc(%ebp),%eax
c002950c:	89 50 04             	mov    %edx,0x4(%eax)
c002950f:	eb 3f                	jmp    c0029550 <.L68+0xb0>
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c0029511:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029514:	8b 50 04             	mov    0x4(%eax),%edx
c0029517:	89 d0                	mov    %edx,%eax
c0029519:	c1 e0 02             	shl    $0x2,%eax
c002951c:	01 d0                	add    %edx,%eax
c002951e:	01 c0                	add    %eax,%eax
c0029520:	89 c2                	mov    %eax,%edx
c0029522:	8b 45 08             	mov    0x8(%ebp),%eax
c0029525:	0f b6 00             	movzbl (%eax),%eax
c0029528:	0f be c0             	movsbl %al,%eax
c002952b:	01 d0                	add    %edx,%eax
c002952d:	8d 50 d0             	lea    -0x30(%eax),%edx
c0029530:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029533:	89 50 04             	mov    %edx,0x4(%eax)
      for (; isdigit (*format); format++)
c0029536:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c002953a:	8b 45 08             	mov    0x8(%ebp),%eax
c002953d:	0f b6 00             	movzbl (%eax),%eax
c0029540:	0f be c0             	movsbl %al,%eax
c0029543:	50                   	push   %eax
c0029544:	e8 73 f8 ff ff       	call   c0028dbc <isdigit>
c0029549:	83 c4 04             	add    $0x4,%esp
c002954c:	85 c0                	test   %eax,%eax
c002954e:	75 c1                	jne    c0029511 <.L68+0x71>
    }
  if (c->width < 0) 
c0029550:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029553:	8b 40 04             	mov    0x4(%eax),%eax
c0029556:	85 c0                	test   %eax,%eax
c0029558:	79 1f                	jns    c0029579 <.L68+0xd9>
    {
      c->width = -c->width;
c002955a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002955d:	8b 40 04             	mov    0x4(%eax),%eax
c0029560:	f7 d8                	neg    %eax
c0029562:	89 c2                	mov    %eax,%edx
c0029564:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029567:	89 50 04             	mov    %edx,0x4(%eax)
      c->flags |= MINUS;
c002956a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002956d:	8b 00                	mov    (%eax),%eax
c002956f:	83 c8 01             	or     $0x1,%eax
c0029572:	89 c2                	mov    %eax,%edx
c0029574:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029577:	89 10                	mov    %edx,(%eax)
    }
      
  /* Parse precision. */
  c->precision = -1;
c0029579:	8b 45 0c             	mov    0xc(%ebp),%eax
c002957c:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  if (*format == '.') 
c0029583:	8b 45 08             	mov    0x8(%ebp),%eax
c0029586:	0f b6 00             	movzbl (%eax),%eax
c0029589:	3c 2e                	cmp    $0x2e,%al
c002958b:	0f 85 88 00 00 00    	jne    c0029619 <.L68+0x179>
    {
      format++;
c0029591:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      if (*format == '*') 
c0029595:	8b 45 08             	mov    0x8(%ebp),%eax
c0029598:	0f b6 00             	movzbl (%eax),%eax
c002959b:	3c 2a                	cmp    $0x2a,%al
c002959d:	75 1b                	jne    c00295ba <.L68+0x11a>
        {
          format++;
c002959f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->precision = va_arg (*args, int);
c00295a3:	8b 45 10             	mov    0x10(%ebp),%eax
c00295a6:	8b 00                	mov    (%eax),%eax
c00295a8:	8d 48 04             	lea    0x4(%eax),%ecx
c00295ab:	8b 55 10             	mov    0x10(%ebp),%edx
c00295ae:	89 0a                	mov    %ecx,(%edx)
c00295b0:	8b 10                	mov    (%eax),%edx
c00295b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295b5:	89 50 08             	mov    %edx,0x8(%eax)
c00295b8:	eb 4b                	jmp    c0029605 <.L68+0x165>
        }
      else 
        {
          c->precision = 0;
c00295ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295bd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          for (; isdigit (*format); format++)
c00295c4:	eb 29                	jmp    c00295ef <.L68+0x14f>
            c->precision = c->precision * 10 + *format - '0';
c00295c6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295c9:	8b 50 08             	mov    0x8(%eax),%edx
c00295cc:	89 d0                	mov    %edx,%eax
c00295ce:	c1 e0 02             	shl    $0x2,%eax
c00295d1:	01 d0                	add    %edx,%eax
c00295d3:	01 c0                	add    %eax,%eax
c00295d5:	89 c2                	mov    %eax,%edx
c00295d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00295da:	0f b6 00             	movzbl (%eax),%eax
c00295dd:	0f be c0             	movsbl %al,%eax
c00295e0:	01 d0                	add    %edx,%eax
c00295e2:	8d 50 d0             	lea    -0x30(%eax),%edx
c00295e5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295e8:	89 50 08             	mov    %edx,0x8(%eax)
          for (; isdigit (*format); format++)
c00295eb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c00295ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00295f2:	0f b6 00             	movzbl (%eax),%eax
c00295f5:	0f be c0             	movsbl %al,%eax
c00295f8:	50                   	push   %eax
c00295f9:	e8 be f7 ff ff       	call   c0028dbc <isdigit>
c00295fe:	83 c4 04             	add    $0x4,%esp
c0029601:	85 c0                	test   %eax,%eax
c0029603:	75 c1                	jne    c00295c6 <.L68+0x126>
        }
      if (c->precision < 0) 
c0029605:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029608:	8b 40 08             	mov    0x8(%eax),%eax
c002960b:	85 c0                	test   %eax,%eax
c002960d:	79 0a                	jns    c0029619 <.L68+0x179>
        c->precision = -1;
c002960f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029612:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    }
  if (c->precision >= 0)
c0029619:	8b 45 0c             	mov    0xc(%ebp),%eax
c002961c:	8b 40 08             	mov    0x8(%eax),%eax
c002961f:	85 c0                	test   %eax,%eax
c0029621:	78 0f                	js     c0029632 <.L68+0x192>
    c->flags &= ~ZERO;
c0029623:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029626:	8b 00                	mov    (%eax),%eax
c0029628:	83 e0 ef             	and    $0xffffffef,%eax
c002962b:	89 c2                	mov    %eax,%edx
c002962d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029630:	89 10                	mov    %edx,(%eax)

  /* Parse type. */
  c->type = INT;
c0029632:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029635:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  switch (*format++) 
c002963c:	8b 45 08             	mov    0x8(%ebp),%eax
c002963f:	8d 50 01             	lea    0x1(%eax),%edx
c0029642:	89 55 08             	mov    %edx,0x8(%ebp)
c0029645:	0f b6 00             	movzbl (%eax),%eax
c0029648:	0f be c0             	movsbl %al,%eax
c002964b:	83 e8 68             	sub    $0x68,%eax
c002964e:	83 f8 12             	cmp    $0x12,%eax
c0029651:	77 7e                	ja     c00296d1 <.L92>
c0029653:	c1 e0 02             	shl    $0x2,%eax
c0029656:	8b 84 18 f8 92 ff ff 	mov    -0x6d08(%eax,%ebx,1),%eax
c002965d:	01 d8                	add    %ebx,%eax
c002965f:	ff e0                	jmp    *%eax

c0029661 <.L98>:
    {
    case 'h':
      if (*format == 'h') 
c0029661:	8b 45 08             	mov    0x8(%ebp),%eax
c0029664:	0f b6 00             	movzbl (%eax),%eax
c0029667:	3c 68                	cmp    $0x68,%al
c0029669:	75 10                	jne    c002967b <.L98+0x1a>
        {
          format++;
c002966b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->type = CHAR;
c002966f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029672:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        }
      else
        c->type = SHORT;
      break;
c0029679:	eb 5b                	jmp    c00296d6 <.L92+0x5>
        c->type = SHORT;
c002967b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002967e:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
      break;
c0029685:	eb 4f                	jmp    c00296d6 <.L92+0x5>

c0029687 <.L97>:
      
    case 'j':
      c->type = INTMAX;
c0029687:	8b 45 0c             	mov    0xc(%ebp),%eax
c002968a:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      break;
c0029691:	eb 43                	jmp    c00296d6 <.L92+0x5>

c0029693 <.L96>:

    case 'l':
      if (*format == 'l')
c0029693:	8b 45 08             	mov    0x8(%ebp),%eax
c0029696:	0f b6 00             	movzbl (%eax),%eax
c0029699:	3c 6c                	cmp    $0x6c,%al
c002969b:	75 10                	jne    c00296ad <.L96+0x1a>
        {
          format++;
c002969d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->type = LONGLONG;
c00296a1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00296a4:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
        }
      else
        c->type = LONG;
      break;
c00296ab:	eb 29                	jmp    c00296d6 <.L92+0x5>
        c->type = LONG;
c00296ad:	8b 45 0c             	mov    0xc(%ebp),%eax
c00296b0:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
      break;
c00296b7:	eb 1d                	jmp    c00296d6 <.L92+0x5>

c00296b9 <.L95>:

    case 't':
      c->type = PTRDIFFT;
c00296b9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00296bc:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
      break;
c00296c3:	eb 11                	jmp    c00296d6 <.L92+0x5>

c00296c5 <.L93>:

    case 'z':
      c->type = SIZET;
c00296c5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00296c8:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
      break;
c00296cf:	eb 05                	jmp    c00296d6 <.L92+0x5>

c00296d1 <.L92>:

    default:
      format--;
c00296d1:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
      break;
c00296d5:	90                   	nop
    }

  return format;
c00296d6:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00296d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00296dc:	c9                   	leave  
c00296dd:	c3                   	ret    

c00296de <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c00296de:	55                   	push   %ebp
c00296df:	89 e5                	mov    %esp,%ebp
c00296e1:	57                   	push   %edi
c00296e2:	56                   	push   %esi
c00296e3:	53                   	push   %ebx
c00296e4:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
c00296ea:	e8 4d 7d 00 00       	call   c003143c <__x86.get_pc_thunk.di>
c00296ef:	81 c7 89 0c 01 00    	add    $0x10c89,%edi
c00296f5:	8b 55 10             	mov    0x10(%ebp),%edx
c00296f8:	8b 75 14             	mov    0x14(%ebp),%esi
c00296fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00296fe:	89 45 80             	mov    %eax,-0x80(%ebp)
c0029701:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029704:	89 45 84             	mov    %eax,-0x7c(%ebp)
c0029707:	89 d0                	mov    %edx,%eax
c0029709:	88 85 7c ff ff ff    	mov    %al,-0x84(%ebp)
c002970f:	89 f0                	mov    %esi,%eax
c0029711:	88 85 78 ff ff ff    	mov    %al,-0x88(%ebp)
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c0029717:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (is_signed) 
c002971e:	80 bd 7c ff ff ff 00 	cmpb   $0x0,-0x84(%ebp)
c0029725:	74 5c                	je     c0029783 <format_integer+0xa5>
    {
      if (c->flags & PLUS)
c0029727:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002972a:	8b 00                	mov    (%eax),%eax
c002972c:	83 e0 02             	and    $0x2,%eax
c002972f:	85 c0                	test   %eax,%eax
c0029731:	74 1a                	je     c002974d <format_integer+0x6f>
        sign = negative ? '-' : '+';
c0029733:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c002973a:	74 07                	je     c0029743 <format_integer+0x65>
c002973c:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0029741:	eb 05                	jmp    c0029748 <format_integer+0x6a>
c0029743:	b8 2b 00 00 00       	mov    $0x2b,%eax
c0029748:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002974b:	eb 36                	jmp    c0029783 <format_integer+0xa5>
      else if (c->flags & SPACE)
c002974d:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0029750:	8b 00                	mov    (%eax),%eax
c0029752:	83 e0 04             	and    $0x4,%eax
c0029755:	85 c0                	test   %eax,%eax
c0029757:	74 1a                	je     c0029773 <format_integer+0x95>
        sign = negative ? '-' : ' ';
c0029759:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0029760:	74 07                	je     c0029769 <format_integer+0x8b>
c0029762:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0029767:	eb 05                	jmp    c002976e <format_integer+0x90>
c0029769:	b8 20 00 00 00       	mov    $0x20,%eax
c002976e:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0029771:	eb 10                	jmp    c0029783 <format_integer+0xa5>
      else if (negative)
c0029773:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c002977a:	74 07                	je     c0029783 <format_integer+0xa5>
        sign = '-';
c002977c:	c7 45 e0 2d 00 00 00 	movl   $0x2d,-0x20(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c0029783:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0029786:	8b 00                	mov    (%eax),%eax
c0029788:	83 e0 08             	and    $0x8,%eax
c002978b:	85 c0                	test   %eax,%eax
c002978d:	74 20                	je     c00297af <format_integer+0xd1>
c002978f:	8b 45 80             	mov    -0x80(%ebp),%eax
c0029792:	80 f4 00             	xor    $0x0,%ah
c0029795:	89 c1                	mov    %eax,%ecx
c0029797:	8b 45 84             	mov    -0x7c(%ebp),%eax
c002979a:	80 f4 00             	xor    $0x0,%ah
c002979d:	89 c3                	mov    %eax,%ebx
c002979f:	89 d8                	mov    %ebx,%eax
c00297a1:	09 c8                	or     %ecx,%eax
c00297a3:	85 c0                	test   %eax,%eax
c00297a5:	74 08                	je     c00297af <format_integer+0xd1>
c00297a7:	8b 45 18             	mov    0x18(%ebp),%eax
c00297aa:	8b 40 08             	mov    0x8(%eax),%eax
c00297ad:	eb 05                	jmp    c00297b4 <format_integer+0xd6>
c00297af:	b8 00 00 00 00       	mov    $0x0,%eax
c00297b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c00297b7:	8d 45 90             	lea    -0x70(%ebp),%eax
c00297ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  digit_cnt = 0;
c00297bd:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  while (value > 0) 
c00297c4:	e9 89 00 00 00       	jmp    c0029852 <format_integer+0x174>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c00297c9:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00297cc:	8b 00                	mov    (%eax),%eax
c00297ce:	83 e0 20             	and    $0x20,%eax
c00297d1:	85 c0                	test   %eax,%eax
c00297d3:	74 24                	je     c00297f9 <format_integer+0x11b>
c00297d5:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c00297d9:	7e 1e                	jle    c00297f9 <format_integer+0x11b>
c00297db:	8b 45 18             	mov    0x18(%ebp),%eax
c00297de:	8b 48 0c             	mov    0xc(%eax),%ecx
c00297e1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00297e4:	99                   	cltd   
c00297e5:	f7 f9                	idiv   %ecx
c00297e7:	89 d0                	mov    %edx,%eax
c00297e9:	85 c0                	test   %eax,%eax
c00297eb:	75 0c                	jne    c00297f9 <format_integer+0x11b>
        *cp++ = ',';
c00297ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00297f0:	8d 50 01             	lea    0x1(%eax),%edx
c00297f3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00297f6:	c6 00 2c             	movb   $0x2c,(%eax)
      *cp++ = b->digits[value % b->base];
c00297f9:	8b 45 18             	mov    0x18(%ebp),%eax
c00297fc:	8b 70 04             	mov    0x4(%eax),%esi
c00297ff:	8b 45 18             	mov    0x18(%ebp),%eax
c0029802:	8b 00                	mov    (%eax),%eax
c0029804:	89 c1                	mov    %eax,%ecx
c0029806:	89 c3                	mov    %eax,%ebx
c0029808:	c1 fb 1f             	sar    $0x1f,%ebx
c002980b:	8b 45 80             	mov    -0x80(%ebp),%eax
c002980e:	8b 55 84             	mov    -0x7c(%ebp),%edx
c0029811:	53                   	push   %ebx
c0029812:	51                   	push   %ecx
c0029813:	52                   	push   %edx
c0029814:	50                   	push   %eax
c0029815:	89 fb                	mov    %edi,%ebx
c0029817:	e8 3d 19 00 00       	call   c002b159 <__umoddi3>
c002981c:	83 c4 10             	add    $0x10,%esp
c002981f:	8d 0c 06             	lea    (%esi,%eax,1),%ecx
c0029822:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0029825:	8d 50 01             	lea    0x1(%eax),%edx
c0029828:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002982b:	0f b6 11             	movzbl (%ecx),%edx
c002982e:	88 10                	mov    %dl,(%eax)
      value /= b->base;
c0029830:	8b 45 18             	mov    0x18(%ebp),%eax
c0029833:	8b 00                	mov    (%eax),%eax
c0029835:	99                   	cltd   
c0029836:	52                   	push   %edx
c0029837:	50                   	push   %eax
c0029838:	ff 75 84             	push   -0x7c(%ebp)
c002983b:	ff 75 80             	push   -0x80(%ebp)
c002983e:	89 fb                	mov    %edi,%ebx
c0029840:	e8 d6 18 00 00       	call   c002b11b <__udivdi3>
c0029845:	83 c4 10             	add    $0x10,%esp
c0029848:	89 45 80             	mov    %eax,-0x80(%ebp)
c002984b:	89 55 84             	mov    %edx,-0x7c(%ebp)
      digit_cnt++;
c002984e:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  while (value > 0) 
c0029852:	8b 45 80             	mov    -0x80(%ebp),%eax
c0029855:	80 f4 00             	xor    $0x0,%ah
c0029858:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
c002985e:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0029861:	80 f4 00             	xor    $0x0,%ah
c0029864:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
c002986a:	8b 9d 70 ff ff ff    	mov    -0x90(%ebp),%ebx
c0029870:	8b b5 74 ff ff ff    	mov    -0x8c(%ebp),%esi
c0029876:	89 f0                	mov    %esi,%eax
c0029878:	09 d8                	or     %ebx,%eax
c002987a:	85 c0                	test   %eax,%eax
c002987c:	0f 85 47 ff ff ff    	jne    c00297c9 <format_integer+0xeb>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c0029882:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0029885:	8b 40 08             	mov    0x8(%eax),%eax
c0029888:	85 c0                	test   %eax,%eax
c002988a:	78 08                	js     c0029894 <format_integer+0x1b6>
c002988c:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002988f:	8b 40 08             	mov    0x8(%eax),%eax
c0029892:	eb 05                	jmp    c0029899 <format_integer+0x1bb>
c0029894:	b8 01 00 00 00       	mov    $0x1,%eax
c0029899:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c002989c:	eb 0c                	jmp    c00298aa <format_integer+0x1cc>
    *cp++ = '0';
c002989e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00298a1:	8d 50 01             	lea    0x1(%eax),%edx
c00298a4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00298a7:	c6 00 30             	movb   $0x30,(%eax)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00298aa:	8d 55 90             	lea    -0x70(%ebp),%edx
c00298ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00298b0:	29 d0                	sub    %edx,%eax
c00298b2:	39 45 d0             	cmp    %eax,-0x30(%ebp)
c00298b5:	7e 0b                	jle    c00298c2 <format_integer+0x1e4>
c00298b7:	8d 45 90             	lea    -0x70(%ebp),%eax
c00298ba:	83 c0 3f             	add    $0x3f,%eax
c00298bd:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c00298c0:	72 dc                	jb     c002989e <format_integer+0x1c0>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00298c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00298c5:	8b 00                	mov    (%eax),%eax
c00298c7:	83 e0 08             	and    $0x8,%eax
c00298ca:	85 c0                	test   %eax,%eax
c00298cc:	74 2b                	je     c00298f9 <format_integer+0x21b>
c00298ce:	8b 45 18             	mov    0x18(%ebp),%eax
c00298d1:	8b 00                	mov    (%eax),%eax
c00298d3:	83 f8 08             	cmp    $0x8,%eax
c00298d6:	75 21                	jne    c00298f9 <format_integer+0x21b>
c00298d8:	8d 45 90             	lea    -0x70(%ebp),%eax
c00298db:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c00298de:	74 0d                	je     c00298ed <format_integer+0x20f>
c00298e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00298e3:	83 e8 01             	sub    $0x1,%eax
c00298e6:	0f b6 00             	movzbl (%eax),%eax
c00298e9:	3c 30                	cmp    $0x30,%al
c00298eb:	74 0c                	je     c00298f9 <format_integer+0x21b>
    *cp++ = '0';
c00298ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00298f0:	8d 50 01             	lea    0x1(%eax),%edx
c00298f3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00298f6:	c6 00 30             	movb   $0x30,(%eax)

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c00298f9:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00298fc:	8b 40 04             	mov    0x4(%eax),%eax
c00298ff:	8d 4d 90             	lea    -0x70(%ebp),%ecx
c0029902:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0029905:	29 ca                	sub    %ecx,%edx
c0029907:	29 d0                	sub    %edx,%eax
c0029909:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002990d:	74 07                	je     c0029916 <format_integer+0x238>
c002990f:	ba 02 00 00 00       	mov    $0x2,%edx
c0029914:	eb 05                	jmp    c002991b <format_integer+0x23d>
c0029916:	ba 00 00 00 00       	mov    $0x0,%edx
c002991b:	29 d0                	sub    %edx,%eax
c002991d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0029921:	0f 95 c2             	setne  %dl
c0029924:	0f b6 d2             	movzbl %dl,%edx
c0029927:	29 d0                	sub    %edx,%eax
c0029929:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (pad_cnt < 0)
c002992c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0029930:	79 07                	jns    c0029939 <format_integer+0x25b>
    pad_cnt = 0;
c0029932:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c0029939:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002993c:	8b 00                	mov    (%eax),%eax
c002993e:	83 e0 11             	and    $0x11,%eax
c0029941:	85 c0                	test   %eax,%eax
c0029943:	75 14                	jne    c0029959 <format_integer+0x27b>
    output_dup (' ', pad_cnt, output, aux);
c0029945:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0029948:	ff 75 24             	push   0x24(%ebp)
c002994b:	ff 75 20             	push   0x20(%ebp)
c002994e:	50                   	push   %eax
c002994f:	6a 20                	push   $0x20
c0029951:	e8 b8 00 00 00       	call   c0029a0e <output_dup>
c0029956:	83 c4 10             	add    $0x10,%esp
  if (sign)
c0029959:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002995d:	74 15                	je     c0029974 <format_integer+0x296>
    output (sign, aux);
c002995f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0029962:	0f be c0             	movsbl %al,%eax
c0029965:	83 ec 08             	sub    $0x8,%esp
c0029968:	ff 75 24             	push   0x24(%ebp)
c002996b:	50                   	push   %eax
c002996c:	8b 45 20             	mov    0x20(%ebp),%eax
c002996f:	ff d0                	call   *%eax
c0029971:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0029974:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0029978:	74 25                	je     c002999f <format_integer+0x2c1>
    {
      output ('0', aux);
c002997a:	83 ec 08             	sub    $0x8,%esp
c002997d:	ff 75 24             	push   0x24(%ebp)
c0029980:	6a 30                	push   $0x30
c0029982:	8b 45 20             	mov    0x20(%ebp),%eax
c0029985:	ff d0                	call   *%eax
c0029987:	83 c4 10             	add    $0x10,%esp
      output (x, aux); 
c002998a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002998d:	0f be c0             	movsbl %al,%eax
c0029990:	83 ec 08             	sub    $0x8,%esp
c0029993:	ff 75 24             	push   0x24(%ebp)
c0029996:	50                   	push   %eax
c0029997:	8b 45 20             	mov    0x20(%ebp),%eax
c002999a:	ff d0                	call   *%eax
c002999c:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c002999f:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00299a2:	8b 00                	mov    (%eax),%eax
c00299a4:	83 e0 10             	and    $0x10,%eax
c00299a7:	85 c0                	test   %eax,%eax
c00299a9:	74 32                	je     c00299dd <format_integer+0x2ff>
    output_dup ('0', pad_cnt, output, aux);
c00299ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00299ae:	ff 75 24             	push   0x24(%ebp)
c00299b1:	ff 75 20             	push   0x20(%ebp)
c00299b4:	50                   	push   %eax
c00299b5:	6a 30                	push   $0x30
c00299b7:	e8 52 00 00 00       	call   c0029a0e <output_dup>
c00299bc:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c00299bf:	eb 1c                	jmp    c00299dd <format_integer+0x2ff>
    output (*--cp, aux);
c00299c1:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
c00299c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00299c8:	0f b6 00             	movzbl (%eax),%eax
c00299cb:	0f be c0             	movsbl %al,%eax
c00299ce:	83 ec 08             	sub    $0x8,%esp
c00299d1:	ff 75 24             	push   0x24(%ebp)
c00299d4:	50                   	push   %eax
c00299d5:	8b 45 20             	mov    0x20(%ebp),%eax
c00299d8:	ff d0                	call   *%eax
c00299da:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c00299dd:	8d 45 90             	lea    -0x70(%ebp),%eax
c00299e0:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c00299e3:	77 dc                	ja     c00299c1 <format_integer+0x2e3>
  if (c->flags & MINUS)
c00299e5:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00299e8:	8b 00                	mov    (%eax),%eax
c00299ea:	83 e0 01             	and    $0x1,%eax
c00299ed:	85 c0                	test   %eax,%eax
c00299ef:	74 14                	je     c0029a05 <format_integer+0x327>
    output_dup (' ', pad_cnt, output, aux);
c00299f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00299f4:	ff 75 24             	push   0x24(%ebp)
c00299f7:	ff 75 20             	push   0x20(%ebp)
c00299fa:	50                   	push   %eax
c00299fb:	6a 20                	push   $0x20
c00299fd:	e8 0c 00 00 00       	call   c0029a0e <output_dup>
c0029a02:	83 c4 10             	add    $0x10,%esp
}
c0029a05:	90                   	nop
c0029a06:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0029a09:	5b                   	pop    %ebx
c0029a0a:	5e                   	pop    %esi
c0029a0b:	5f                   	pop    %edi
c0029a0c:	5d                   	pop    %ebp
c0029a0d:	c3                   	ret    

c0029a0e <output_dup>:

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0029a0e:	55                   	push   %ebp
c0029a0f:	89 e5                	mov    %esp,%ebp
c0029a11:	83 ec 18             	sub    $0x18,%esp
c0029a14:	e8 0f 7a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029a19:	05 5f 09 01 00       	add    $0x1095f,%eax
c0029a1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a21:	88 45 f4             	mov    %al,-0xc(%ebp)
  while (cnt-- > 0)
c0029a24:	eb 13                	jmp    c0029a39 <output_dup+0x2b>
    output (ch, aux);
c0029a26:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0029a2a:	83 ec 08             	sub    $0x8,%esp
c0029a2d:	ff 75 14             	push   0x14(%ebp)
c0029a30:	50                   	push   %eax
c0029a31:	8b 45 10             	mov    0x10(%ebp),%eax
c0029a34:	ff d0                	call   *%eax
c0029a36:	83 c4 10             	add    $0x10,%esp
  while (cnt-- > 0)
c0029a39:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a3c:	8d 50 ff             	lea    -0x1(%eax),%edx
c0029a3f:	89 55 0c             	mov    %edx,0xc(%ebp)
c0029a42:	85 c0                	test   %eax,%eax
c0029a44:	75 e0                	jne    c0029a26 <output_dup+0x18>
}
c0029a46:	90                   	nop
c0029a47:	90                   	nop
c0029a48:	c9                   	leave  
c0029a49:	c3                   	ret    

c0029a4a <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0029a4a:	55                   	push   %ebp
c0029a4b:	89 e5                	mov    %esp,%ebp
c0029a4d:	83 ec 18             	sub    $0x18,%esp
c0029a50:	e8 d3 79 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029a55:	05 23 09 01 00       	add    $0x10923,%eax
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0029a5a:	8b 45 10             	mov    0x10(%ebp),%eax
c0029a5d:	8b 40 04             	mov    0x4(%eax),%eax
c0029a60:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0029a63:	7d 26                	jge    c0029a8b <format_string+0x41>
c0029a65:	8b 45 10             	mov    0x10(%ebp),%eax
c0029a68:	8b 00                	mov    (%eax),%eax
c0029a6a:	83 e0 01             	and    $0x1,%eax
c0029a6d:	85 c0                	test   %eax,%eax
c0029a6f:	75 1a                	jne    c0029a8b <format_string+0x41>
    output_dup (' ', c->width - length, output, aux);
c0029a71:	8b 45 10             	mov    0x10(%ebp),%eax
c0029a74:	8b 40 04             	mov    0x4(%eax),%eax
c0029a77:	2b 45 0c             	sub    0xc(%ebp),%eax
c0029a7a:	ff 75 18             	push   0x18(%ebp)
c0029a7d:	ff 75 14             	push   0x14(%ebp)
c0029a80:	50                   	push   %eax
c0029a81:	6a 20                	push   $0x20
c0029a83:	e8 86 ff ff ff       	call   c0029a0e <output_dup>
c0029a88:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0029a8b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0029a92:	eb 21                	jmp    c0029ab5 <format_string+0x6b>
    output (string[i], aux);
c0029a94:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029a97:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a9a:	01 d0                	add    %edx,%eax
c0029a9c:	0f b6 00             	movzbl (%eax),%eax
c0029a9f:	0f be c0             	movsbl %al,%eax
c0029aa2:	83 ec 08             	sub    $0x8,%esp
c0029aa5:	ff 75 18             	push   0x18(%ebp)
c0029aa8:	50                   	push   %eax
c0029aa9:	8b 45 14             	mov    0x14(%ebp),%eax
c0029aac:	ff d0                	call   *%eax
c0029aae:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0029ab1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0029ab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ab8:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029abb:	7c d7                	jl     c0029a94 <format_string+0x4a>
  if (c->width > length && (c->flags & MINUS) != 0)
c0029abd:	8b 45 10             	mov    0x10(%ebp),%eax
c0029ac0:	8b 40 04             	mov    0x4(%eax),%eax
c0029ac3:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0029ac6:	7d 26                	jge    c0029aee <format_string+0xa4>
c0029ac8:	8b 45 10             	mov    0x10(%ebp),%eax
c0029acb:	8b 00                	mov    (%eax),%eax
c0029acd:	83 e0 01             	and    $0x1,%eax
c0029ad0:	85 c0                	test   %eax,%eax
c0029ad2:	74 1a                	je     c0029aee <format_string+0xa4>
    output_dup (' ', c->width - length, output, aux);
c0029ad4:	8b 45 10             	mov    0x10(%ebp),%eax
c0029ad7:	8b 40 04             	mov    0x4(%eax),%eax
c0029ada:	2b 45 0c             	sub    0xc(%ebp),%eax
c0029add:	ff 75 18             	push   0x18(%ebp)
c0029ae0:	ff 75 14             	push   0x14(%ebp)
c0029ae3:	50                   	push   %eax
c0029ae4:	6a 20                	push   $0x20
c0029ae6:	e8 23 ff ff ff       	call   c0029a0e <output_dup>
c0029aeb:	83 c4 10             	add    $0x10,%esp
}
c0029aee:	90                   	nop
c0029aef:	c9                   	leave  
c0029af0:	c3                   	ret    

c0029af1 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0029af1:	55                   	push   %ebp
c0029af2:	89 e5                	mov    %esp,%ebp
c0029af4:	83 ec 18             	sub    $0x18,%esp
c0029af7:	e8 2c 79 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029afc:	05 7c 08 01 00       	add    $0x1087c,%eax
  va_list args;

  va_start (args, aux);
c0029b01:	8d 45 14             	lea    0x14(%ebp),%eax
c0029b04:	89 45 f4             	mov    %eax,-0xc(%ebp)
  __vprintf (format, args, output, aux);
c0029b07:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b0a:	ff 75 10             	push   0x10(%ebp)
c0029b0d:	ff 75 0c             	push   0xc(%ebp)
c0029b10:	50                   	push   %eax
c0029b11:	ff 75 08             	push   0x8(%ebp)
c0029b14:	e8 02 f4 ff ff       	call   c0028f1b <__vprintf>
c0029b19:	83 c4 10             	add    $0x10,%esp
  va_end (args);
}
c0029b1c:	90                   	nop
c0029b1d:	c9                   	leave  
c0029b1e:	c3                   	ret    

c0029b1f <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0029b1f:	55                   	push   %ebp
c0029b20:	89 e5                	mov    %esp,%ebp
c0029b22:	53                   	push   %ebx
c0029b23:	83 ec 34             	sub    $0x34,%esp
c0029b26:	e8 01 79 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0029b2b:	81 c3 4d 08 01 00    	add    $0x1084d,%ebx
c0029b31:	8b 45 14             	mov    0x14(%ebp),%eax
c0029b34:	88 45 d4             	mov    %al,-0x2c(%ebp)
  const uint8_t *buf = buf_;
c0029b37:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029b3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const size_t per_line = 16; /* Maximum bytes per line. */
c0029b3d:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  while (size > 0)
c0029b44:	e9 c7 01 00 00       	jmp    c0029d10 <hex_dump+0x1f1>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c0029b49:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b4c:	ba 00 00 00 00       	mov    $0x0,%edx
c0029b51:	f7 75 e8             	divl   -0x18(%ebp)
c0029b54:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      end = per_line;
c0029b57:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029b5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (end - start > size)
c0029b5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029b60:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0029b63:	39 45 10             	cmp    %eax,0x10(%ebp)
c0029b66:	73 0b                	jae    c0029b73 <hex_dump+0x54>
        end = start + size;
c0029b68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0029b6b:	8b 45 10             	mov    0x10(%ebp),%eax
c0029b6e:	01 d0                	add    %edx,%eax
c0029b70:	89 45 f0             	mov    %eax,-0x10(%ebp)
      n = end - start;
c0029b73:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029b76:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0029b79:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0029b7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b7f:	ba 00 00 00 00       	mov    $0x0,%edx
c0029b84:	f7 75 e8             	divl   -0x18(%ebp)
c0029b87:	0f af 45 e8          	imul   -0x18(%ebp),%eax
c0029b8b:	ba 00 00 00 00       	mov    $0x0,%edx
c0029b90:	83 ec 04             	sub    $0x4,%esp
c0029b93:	52                   	push   %edx
c0029b94:	50                   	push   %eax
c0029b95:	8d 83 44 93 ff ff    	lea    -0x6cbc(%ebx),%eax
c0029b9b:	50                   	push   %eax
c0029b9c:	e8 44 f3 ff ff       	call   c0028ee5 <printf>
c0029ba1:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0029ba4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0029bab:	eb 16                	jmp    c0029bc3 <hex_dump+0xa4>
        printf ("   ");
c0029bad:	83 ec 0c             	sub    $0xc,%esp
c0029bb0:	8d 83 4c 93 ff ff    	lea    -0x6cb4(%ebx),%eax
c0029bb6:	50                   	push   %eax
c0029bb7:	e8 29 f3 ff ff       	call   c0028ee5 <printf>
c0029bbc:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0029bbf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0029bc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029bc6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0029bc9:	72 e2                	jb     c0029bad <hex_dump+0x8e>
      for (; i < end; i++) 
c0029bcb:	eb 44                	jmp    c0029c11 <hex_dump+0xf2>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0029bcd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029bd0:	d1 e8                	shr    %eax
c0029bd2:	83 e8 01             	sub    $0x1,%eax
        printf ("%02hhx%c",
c0029bd5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0029bd8:	75 07                	jne    c0029be1 <hex_dump+0xc2>
c0029bda:	ba 2d 00 00 00       	mov    $0x2d,%edx
c0029bdf:	eb 05                	jmp    c0029be6 <hex_dump+0xc7>
c0029be1:	ba 20 00 00 00       	mov    $0x20,%edx
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0029be6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029be9:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0029bec:	89 c1                	mov    %eax,%ecx
c0029bee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029bf1:	01 c8                	add    %ecx,%eax
c0029bf3:	0f b6 00             	movzbl (%eax),%eax
        printf ("%02hhx%c",
c0029bf6:	0f b6 c0             	movzbl %al,%eax
c0029bf9:	83 ec 04             	sub    $0x4,%esp
c0029bfc:	52                   	push   %edx
c0029bfd:	50                   	push   %eax
c0029bfe:	8d 83 50 93 ff ff    	lea    -0x6cb0(%ebx),%eax
c0029c04:	50                   	push   %eax
c0029c05:	e8 db f2 ff ff       	call   c0028ee5 <printf>
c0029c0a:	83 c4 10             	add    $0x10,%esp
      for (; i < end; i++) 
c0029c0d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0029c11:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029c14:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0029c17:	72 b4                	jb     c0029bcd <hex_dump+0xae>
      if (ascii) 
c0029c19:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c0029c1d:	0f 84 ce 00 00 00    	je     c0029cf1 <hex_dump+0x1d2>
        {
          for (; i < per_line; i++)
c0029c23:	eb 16                	jmp    c0029c3b <hex_dump+0x11c>
            printf ("   ");
c0029c25:	83 ec 0c             	sub    $0xc,%esp
c0029c28:	8d 83 4c 93 ff ff    	lea    -0x6cb4(%ebx),%eax
c0029c2e:	50                   	push   %eax
c0029c2f:	e8 b1 f2 ff ff       	call   c0028ee5 <printf>
c0029c34:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0029c37:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0029c3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029c3e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0029c41:	72 e2                	jb     c0029c25 <hex_dump+0x106>
          printf ("|");
c0029c43:	83 ec 0c             	sub    $0xc,%esp
c0029c46:	6a 7c                	push   $0x7c
c0029c48:	e8 3b 44 00 00       	call   c002e088 <putchar>
c0029c4d:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0029c50:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0029c57:	eb 11                	jmp    c0029c6a <hex_dump+0x14b>
            printf (" ");
c0029c59:	83 ec 0c             	sub    $0xc,%esp
c0029c5c:	6a 20                	push   $0x20
c0029c5e:	e8 25 44 00 00       	call   c002e088 <putchar>
c0029c63:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0029c66:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0029c6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029c6d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0029c70:	72 e7                	jb     c0029c59 <hex_dump+0x13a>
          for (; i < end; i++)
c0029c72:	eb 4d                	jmp    c0029cc1 <hex_dump+0x1a2>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0029c74:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029c77:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0029c7a:	89 c2                	mov    %eax,%edx
c0029c7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c7f:	01 d0                	add    %edx,%eax
c0029c81:	0f b6 00             	movzbl (%eax),%eax
c0029c84:	0f b6 c0             	movzbl %al,%eax
c0029c87:	83 ec 0c             	sub    $0xc,%esp
c0029c8a:	50                   	push   %eax
c0029c8b:	e8 53 f1 ff ff       	call   c0028de3 <isprint>
c0029c90:	83 c4 10             	add    $0x10,%esp
            printf ("%c",
c0029c93:	85 c0                	test   %eax,%eax
c0029c95:	74 15                	je     c0029cac <hex_dump+0x18d>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0029c97:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029c9a:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0029c9d:	89 c2                	mov    %eax,%edx
c0029c9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ca2:	01 d0                	add    %edx,%eax
c0029ca4:	0f b6 00             	movzbl (%eax),%eax
            printf ("%c",
c0029ca7:	0f b6 c0             	movzbl %al,%eax
c0029caa:	eb 05                	jmp    c0029cb1 <hex_dump+0x192>
c0029cac:	b8 2e 00 00 00       	mov    $0x2e,%eax
c0029cb1:	83 ec 0c             	sub    $0xc,%esp
c0029cb4:	50                   	push   %eax
c0029cb5:	e8 ce 43 00 00       	call   c002e088 <putchar>
c0029cba:	83 c4 10             	add    $0x10,%esp
          for (; i < end; i++)
c0029cbd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0029cc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029cc4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0029cc7:	72 ab                	jb     c0029c74 <hex_dump+0x155>
          for (; i < per_line; i++)
c0029cc9:	eb 11                	jmp    c0029cdc <hex_dump+0x1bd>
            printf (" ");
c0029ccb:	83 ec 0c             	sub    $0xc,%esp
c0029cce:	6a 20                	push   $0x20
c0029cd0:	e8 b3 43 00 00       	call   c002e088 <putchar>
c0029cd5:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0029cd8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0029cdc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029cdf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0029ce2:	72 e7                	jb     c0029ccb <hex_dump+0x1ac>
          printf ("|");
c0029ce4:	83 ec 0c             	sub    $0xc,%esp
c0029ce7:	6a 7c                	push   $0x7c
c0029ce9:	e8 9a 43 00 00       	call   c002e088 <putchar>
c0029cee:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0029cf1:	83 ec 0c             	sub    $0xc,%esp
c0029cf4:	6a 0a                	push   $0xa
c0029cf6:	e8 8d 43 00 00       	call   c002e088 <putchar>
c0029cfb:	83 c4 10             	add    $0x10,%esp

      ofs += n;
c0029cfe:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0029d01:	01 45 08             	add    %eax,0x8(%ebp)
      buf += n;
c0029d04:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0029d07:	01 45 f4             	add    %eax,-0xc(%ebp)
      size -= n;
c0029d0a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0029d0d:	29 45 10             	sub    %eax,0x10(%ebp)
  while (size > 0)
c0029d10:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029d14:	0f 85 2f fe ff ff    	jne    c0029b49 <hex_dump+0x2a>
    }
}
c0029d1a:	90                   	nop
c0029d1b:	90                   	nop
c0029d1c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029d1f:	c9                   	leave  
c0029d20:	c3                   	ret    

c0029d21 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0029d21:	55                   	push   %ebp
c0029d22:	89 e5                	mov    %esp,%ebp
c0029d24:	53                   	push   %ebx
c0029d25:	83 ec 24             	sub    $0x24,%esp
c0029d28:	e8 07 77 00 00       	call   c0031434 <__x86.get_pc_thunk.cx>
c0029d2d:	81 c1 4b 06 01 00    	add    $0x1064b,%ecx
c0029d33:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0029d36:	89 5d e0             	mov    %ebx,-0x20(%ebp)
c0029d39:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0029d3c:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  if (size == 1)
c0029d3f:	8b 5d e0             	mov    -0x20(%ebp),%ebx
c0029d42:	83 f3 01             	xor    $0x1,%ebx
c0029d45:	89 d8                	mov    %ebx,%eax
c0029d47:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c0029d4a:	80 f7 00             	xor    $0x0,%bh
c0029d4d:	89 da                	mov    %ebx,%edx
c0029d4f:	09 d0                	or     %edx,%eax
c0029d51:	85 c0                	test   %eax,%eax
c0029d53:	75 14                	jne    c0029d69 <print_human_readable_size+0x48>
    printf ("1 byte");
c0029d55:	83 ec 0c             	sub    $0xc,%esp
c0029d58:	8d 81 59 93 ff ff    	lea    -0x6ca7(%ecx),%eax
c0029d5e:	50                   	push   %eax
c0029d5f:	e8 81 f1 ff ff       	call   c0028ee5 <printf>
c0029d64:	83 c4 10             	add    $0x10,%esp

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
    }
}
c0029d67:	eb 5b                	jmp    c0029dc4 <print_human_readable_size+0xa3>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0029d69:	8d 81 30 06 00 00    	lea    0x630(%ecx),%eax
c0029d6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029d72:	eb 17                	jmp    c0029d8b <print_human_readable_size+0x6a>
        size /= 1024;
c0029d74:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0029d77:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0029d7a:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0029d7e:	c1 ea 0a             	shr    $0xa,%edx
c0029d81:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0029d84:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0029d87:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c0029d8b:	ba ff 03 00 00       	mov    $0x3ff,%edx
c0029d90:	b8 00 00 00 00       	mov    $0x0,%eax
c0029d95:	3b 55 e0             	cmp    -0x20(%ebp),%edx
c0029d98:	1b 45 e4             	sbb    -0x1c(%ebp),%eax
c0029d9b:	73 0c                	jae    c0029da9 <print_human_readable_size+0x88>
c0029d9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029da0:	83 c0 04             	add    $0x4,%eax
c0029da3:	8b 00                	mov    (%eax),%eax
c0029da5:	85 c0                	test   %eax,%eax
c0029da7:	75 cb                	jne    c0029d74 <print_human_readable_size+0x53>
      printf ("%"PRIu64" %s", size, *fp);
c0029da9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029dac:	8b 00                	mov    (%eax),%eax
c0029dae:	50                   	push   %eax
c0029daf:	ff 75 e4             	push   -0x1c(%ebp)
c0029db2:	ff 75 e0             	push   -0x20(%ebp)
c0029db5:	8d 81 60 93 ff ff    	lea    -0x6ca0(%ecx),%eax
c0029dbb:	50                   	push   %eax
c0029dbc:	e8 24 f1 ff ff       	call   c0028ee5 <printf>
c0029dc1:	83 c4 10             	add    $0x10,%esp
}
c0029dc4:	90                   	nop
c0029dc5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029dc8:	c9                   	leave  
c0029dc9:	c3                   	ret    

c0029dca <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0029dca:	55                   	push   %ebp
c0029dcb:	89 e5                	mov    %esp,%ebp
c0029dcd:	e8 56 76 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029dd2:	05 a6 05 01 00       	add    $0x105a6,%eax
c0029dd7:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0029ddb:	7e 0d                	jle    c0029dea <isdigit+0x20>
c0029ddd:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0029de1:	7f 07                	jg     c0029dea <isdigit+0x20>
c0029de3:	b8 01 00 00 00       	mov    $0x1,%eax
c0029de8:	eb 05                	jmp    c0029def <isdigit+0x25>
c0029dea:	b8 00 00 00 00       	mov    $0x0,%eax
c0029def:	5d                   	pop    %ebp
c0029df0:	c3                   	ret    

c0029df1 <isspace>:
static inline int isspace (int c) {
c0029df1:	55                   	push   %ebp
c0029df2:	89 e5                	mov    %esp,%ebp
c0029df4:	e8 2f 76 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029df9:	05 7f 05 01 00       	add    $0x1057f,%eax
          || c == '\r' || c == '\t' || c == '\v');
c0029dfe:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0029e02:	74 1e                	je     c0029e22 <isspace+0x31>
  return (c == ' ' || c == '\f' || c == '\n'
c0029e04:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0029e08:	74 18                	je     c0029e22 <isspace+0x31>
c0029e0a:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0029e0e:	74 12                	je     c0029e22 <isspace+0x31>
          || c == '\r' || c == '\t' || c == '\v');
c0029e10:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0029e14:	74 0c                	je     c0029e22 <isspace+0x31>
c0029e16:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0029e1a:	74 06                	je     c0029e22 <isspace+0x31>
c0029e1c:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0029e20:	75 07                	jne    c0029e29 <isspace+0x38>
c0029e22:	b8 01 00 00 00       	mov    $0x1,%eax
c0029e27:	eb 05                	jmp    c0029e2e <isspace+0x3d>
c0029e29:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029e2e:	5d                   	pop    %ebp
c0029e2f:	c3                   	ret    

c0029e30 <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c0029e30:	55                   	push   %ebp
c0029e31:	89 e5                	mov    %esp,%ebp
c0029e33:	53                   	push   %ebx
c0029e34:	83 ec 14             	sub    $0x14,%esp
c0029e37:	e8 ec 75 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029e3c:	05 3c 05 01 00       	add    $0x1053c,%eax
  bool negative;
  int value;

  ASSERT (s != NULL);
c0029e41:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029e45:	75 2c                	jne    c0029e73 <atoi+0x43>
c0029e47:	83 ec 0c             	sub    $0xc,%esp
c0029e4a:	8d 90 84 93 ff ff    	lea    -0x6c7c(%eax),%edx
c0029e50:	52                   	push   %edx
c0029e51:	8d 90 8e 93 ff ff    	lea    -0x6c72(%eax),%edx
c0029e57:	52                   	push   %edx
c0029e58:	8d 90 ec 93 ff ff    	lea    -0x6c14(%eax),%edx
c0029e5e:	52                   	push   %edx
c0029e5f:	6a 0f                	push   $0xf
c0029e61:	8d 90 a5 93 ff ff    	lea    -0x6c5b(%eax),%edx
c0029e67:	52                   	push   %edx
c0029e68:	89 c3                	mov    %eax,%ebx
c0029e6a:	e8 f5 18 00 00       	call   c002b764 <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c0029e6f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  while (isspace ((unsigned char) *s))
c0029e73:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e76:	0f b6 00             	movzbl (%eax),%eax
c0029e79:	0f b6 c0             	movzbl %al,%eax
c0029e7c:	83 ec 0c             	sub    $0xc,%esp
c0029e7f:	50                   	push   %eax
c0029e80:	e8 6c ff ff ff       	call   c0029df1 <isspace>
c0029e85:	83 c4 10             	add    $0x10,%esp
c0029e88:	85 c0                	test   %eax,%eax
c0029e8a:	75 e3                	jne    c0029e6f <atoi+0x3f>

  /* Parse sign. */
  negative = false;
c0029e8c:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (*s == '+')
c0029e90:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e93:	0f b6 00             	movzbl (%eax),%eax
c0029e96:	3c 2b                	cmp    $0x2b,%al
c0029e98:	75 06                	jne    c0029ea0 <atoi+0x70>
    s++;
c0029e9a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0029e9e:	eb 12                	jmp    c0029eb2 <atoi+0x82>
  else if (*s == '-')
c0029ea0:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ea3:	0f b6 00             	movzbl (%eax),%eax
c0029ea6:	3c 2d                	cmp    $0x2d,%al
c0029ea8:	75 08                	jne    c0029eb2 <atoi+0x82>
    {
      negative = true;
c0029eaa:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
      s++;
c0029eae:	83 45 08 01          	addl   $0x1,0x8(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0029eb2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0029eb9:	eb 25                	jmp    c0029ee0 <atoi+0xb0>
    value = value * 10 - (*s - '0');
c0029ebb:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0029ebe:	89 d0                	mov    %edx,%eax
c0029ec0:	c1 e0 02             	shl    $0x2,%eax
c0029ec3:	01 d0                	add    %edx,%eax
c0029ec5:	01 c0                	add    %eax,%eax
c0029ec7:	89 c1                	mov    %eax,%ecx
c0029ec9:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ecc:	0f b6 00             	movzbl (%eax),%eax
c0029ecf:	0f be c0             	movsbl %al,%eax
c0029ed2:	8d 50 d0             	lea    -0x30(%eax),%edx
c0029ed5:	89 c8                	mov    %ecx,%eax
c0029ed7:	29 d0                	sub    %edx,%eax
c0029ed9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (value = 0; isdigit (*s); s++)
c0029edc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0029ee0:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ee3:	0f b6 00             	movzbl (%eax),%eax
c0029ee6:	0f be c0             	movsbl %al,%eax
c0029ee9:	83 ec 0c             	sub    $0xc,%esp
c0029eec:	50                   	push   %eax
c0029eed:	e8 d8 fe ff ff       	call   c0029dca <isdigit>
c0029ef2:	83 c4 10             	add    $0x10,%esp
c0029ef5:	85 c0                	test   %eax,%eax
c0029ef7:	75 c2                	jne    c0029ebb <atoi+0x8b>
  if (!negative)
c0029ef9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0029efd:	83 f0 01             	xor    $0x1,%eax
c0029f00:	84 c0                	test   %al,%al
c0029f02:	74 03                	je     c0029f07 <atoi+0xd7>
    value = -value;
c0029f04:	f7 5d f0             	negl   -0x10(%ebp)

  return value;
c0029f07:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0029f0a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029f0d:	c9                   	leave  
c0029f0e:	c3                   	ret    

c0029f0f <compare_thunk>:

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c0029f0f:	55                   	push   %ebp
c0029f10:	89 e5                	mov    %esp,%ebp
c0029f12:	83 ec 18             	sub    $0x18,%esp
c0029f15:	e8 0e 75 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029f1a:	05 5e 04 01 00       	add    $0x1045e,%eax
  int (**compare) (const void *, const void *) = aux;
c0029f1f:	8b 45 10             	mov    0x10(%ebp),%eax
c0029f22:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return (*compare) (a, b);
c0029f25:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029f28:	8b 00                	mov    (%eax),%eax
c0029f2a:	83 ec 08             	sub    $0x8,%esp
c0029f2d:	ff 75 0c             	push   0xc(%ebp)
c0029f30:	ff 75 08             	push   0x8(%ebp)
c0029f33:	ff d0                	call   *%eax
c0029f35:	83 c4 10             	add    $0x10,%esp
}
c0029f38:	c9                   	leave  
c0029f39:	c3                   	ret    

c0029f3a <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c0029f3a:	55                   	push   %ebp
c0029f3b:	89 e5                	mov    %esp,%ebp
c0029f3d:	83 ec 08             	sub    $0x8,%esp
c0029f40:	e8 e3 74 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029f45:	05 33 04 01 00       	add    $0x10433,%eax
  sort (array, cnt, size, compare_thunk, &compare);
c0029f4a:	83 ec 0c             	sub    $0xc,%esp
c0029f4d:	8d 55 14             	lea    0x14(%ebp),%edx
c0029f50:	52                   	push   %edx
c0029f51:	8d 80 97 fb fe ff    	lea    -0x10469(%eax),%eax
c0029f57:	50                   	push   %eax
c0029f58:	ff 75 10             	push   0x10(%ebp)
c0029f5b:	ff 75 0c             	push   0xc(%ebp)
c0029f5e:	ff 75 08             	push   0x8(%ebp)
c0029f61:	e8 7e 01 00 00       	call   c002a0e4 <sort>
c0029f66:	83 c4 20             	add    $0x20,%esp
}
c0029f69:	90                   	nop
c0029f6a:	c9                   	leave  
c0029f6b:	c3                   	ret    

c0029f6c <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0029f6c:	55                   	push   %ebp
c0029f6d:	89 e5                	mov    %esp,%ebp
c0029f6f:	83 ec 10             	sub    $0x10,%esp
c0029f72:	e8 b1 74 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029f77:	05 01 04 01 00       	add    $0x10401,%eax
  unsigned char *a = array + (a_idx - 1) * size;
c0029f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029f7f:	83 e8 01             	sub    $0x1,%eax
c0029f82:	0f af 45 14          	imul   0x14(%ebp),%eax
c0029f86:	89 c2                	mov    %eax,%edx
c0029f88:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f8b:	01 d0                	add    %edx,%eax
c0029f8d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned char *b = array + (b_idx - 1) * size;
c0029f90:	8b 45 10             	mov    0x10(%ebp),%eax
c0029f93:	83 e8 01             	sub    $0x1,%eax
c0029f96:	0f af 45 14          	imul   0x14(%ebp),%eax
c0029f9a:	89 c2                	mov    %eax,%edx
c0029f9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f9f:	01 d0                	add    %edx,%eax
c0029fa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t i;

  for (i = 0; i < size; i++)
c0029fa4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0029fab:	eb 35                	jmp    c0029fe2 <do_swap+0x76>
    {
      unsigned char t = a[i];
c0029fad:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0029fb0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029fb3:	01 d0                	add    %edx,%eax
c0029fb5:	0f b6 00             	movzbl (%eax),%eax
c0029fb8:	88 45 f3             	mov    %al,-0xd(%ebp)
      a[i] = b[i];
c0029fbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029fbe:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029fc1:	01 d0                	add    %edx,%eax
c0029fc3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c0029fc6:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0029fc9:	01 ca                	add    %ecx,%edx
c0029fcb:	0f b6 00             	movzbl (%eax),%eax
c0029fce:	88 02                	mov    %al,(%edx)
      b[i] = t;
c0029fd0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029fd3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029fd6:	01 c2                	add    %eax,%edx
c0029fd8:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c0029fdc:	88 02                	mov    %al,(%edx)
  for (i = 0; i < size; i++)
c0029fde:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0029fe2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029fe5:	3b 45 14             	cmp    0x14(%ebp),%eax
c0029fe8:	72 c3                	jb     c0029fad <do_swap+0x41>
    }
}
c0029fea:	90                   	nop
c0029feb:	90                   	nop
c0029fec:	c9                   	leave  
c0029fed:	c3                   	ret    

c0029fee <do_compare>:
   strcmp()-type result. */
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
c0029fee:	55                   	push   %ebp
c0029fef:	89 e5                	mov    %esp,%ebp
c0029ff1:	83 ec 08             	sub    $0x8,%esp
c0029ff4:	e8 2f 74 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0029ff9:	05 7f 03 01 00       	add    $0x1037f,%eax
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0029ffe:	8b 45 10             	mov    0x10(%ebp),%eax
c002a001:	83 e8 01             	sub    $0x1,%eax
c002a004:	0f af 45 14          	imul   0x14(%ebp),%eax
c002a008:	89 c2                	mov    %eax,%edx
c002a00a:	8b 45 08             	mov    0x8(%ebp),%eax
c002a00d:	01 c2                	add    %eax,%edx
c002a00f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a012:	83 e8 01             	sub    $0x1,%eax
c002a015:	0f af 45 14          	imul   0x14(%ebp),%eax
c002a019:	89 c1                	mov    %eax,%ecx
c002a01b:	8b 45 08             	mov    0x8(%ebp),%eax
c002a01e:	01 c8                	add    %ecx,%eax
c002a020:	83 ec 04             	sub    $0x4,%esp
c002a023:	ff 75 1c             	push   0x1c(%ebp)
c002a026:	52                   	push   %edx
c002a027:	50                   	push   %eax
c002a028:	8b 45 18             	mov    0x18(%ebp),%eax
c002a02b:	ff d0                	call   *%eax
c002a02d:	83 c4 10             	add    $0x10,%esp
}
c002a030:	c9                   	leave  
c002a031:	c3                   	ret    

c002a032 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c002a032:	55                   	push   %ebp
c002a033:	89 e5                	mov    %esp,%ebp
c002a035:	83 ec 18             	sub    $0x18,%esp
c002a038:	e8 eb 73 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a03d:	05 3b 03 01 00       	add    $0x1033b,%eax
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c002a042:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a045:	01 c0                	add    %eax,%eax
c002a047:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t right = 2 * i + 1;
c002a04a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a04d:	01 c0                	add    %eax,%eax
c002a04f:	83 c0 01             	add    $0x1,%eax
c002a052:	89 45 ec             	mov    %eax,-0x14(%ebp)
      size_t max = i;
c002a055:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a058:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c002a05b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a05e:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a061:	77 27                	ja     c002a08a <heapify+0x58>
c002a063:	83 ec 08             	sub    $0x8,%esp
c002a066:	ff 75 1c             	push   0x1c(%ebp)
c002a069:	ff 75 18             	push   0x18(%ebp)
c002a06c:	ff 75 14             	push   0x14(%ebp)
c002a06f:	ff 75 f4             	push   -0xc(%ebp)
c002a072:	ff 75 f0             	push   -0x10(%ebp)
c002a075:	ff 75 08             	push   0x8(%ebp)
c002a078:	e8 71 ff ff ff       	call   c0029fee <do_compare>
c002a07d:	83 c4 20             	add    $0x20,%esp
c002a080:	85 c0                	test   %eax,%eax
c002a082:	7e 06                	jle    c002a08a <heapify+0x58>
        max = left;
c002a084:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a087:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (right <= cnt
c002a08a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002a08d:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a090:	77 27                	ja     c002a0b9 <heapify+0x87>
          && do_compare (array, right, max, size, compare, aux) > 0) 
c002a092:	83 ec 08             	sub    $0x8,%esp
c002a095:	ff 75 1c             	push   0x1c(%ebp)
c002a098:	ff 75 18             	push   0x18(%ebp)
c002a09b:	ff 75 14             	push   0x14(%ebp)
c002a09e:	ff 75 f4             	push   -0xc(%ebp)
c002a0a1:	ff 75 ec             	push   -0x14(%ebp)
c002a0a4:	ff 75 08             	push   0x8(%ebp)
c002a0a7:	e8 42 ff ff ff       	call   c0029fee <do_compare>
c002a0ac:	83 c4 20             	add    $0x20,%esp
c002a0af:	85 c0                	test   %eax,%eax
c002a0b1:	7e 06                	jle    c002a0b9 <heapify+0x87>
        max = right;
c002a0b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002a0b6:	89 45 f4             	mov    %eax,-0xc(%ebp)

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c002a0b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a0bc:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a0bf:	74 1f                	je     c002a0e0 <heapify+0xae>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c002a0c1:	ff 75 14             	push   0x14(%ebp)
c002a0c4:	ff 75 f4             	push   -0xc(%ebp)
c002a0c7:	ff 75 0c             	push   0xc(%ebp)
c002a0ca:	ff 75 08             	push   0x8(%ebp)
c002a0cd:	e8 9a fe ff ff       	call   c0029f6c <do_swap>
c002a0d2:	83 c4 10             	add    $0x10,%esp
      i = max;
c002a0d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a0d8:	89 45 0c             	mov    %eax,0xc(%ebp)
    {
c002a0db:	e9 62 ff ff ff       	jmp    c002a042 <heapify+0x10>
        break;
c002a0e0:	90                   	nop
    }
}
c002a0e1:	90                   	nop
c002a0e2:	c9                   	leave  
c002a0e3:	c3                   	ret    

c002a0e4 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c002a0e4:	55                   	push   %ebp
c002a0e5:	89 e5                	mov    %esp,%ebp
c002a0e7:	53                   	push   %ebx
c002a0e8:	83 ec 14             	sub    $0x14,%esp
c002a0eb:	e8 38 73 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a0f0:	05 88 02 01 00       	add    $0x10288,%eax
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c002a0f5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a0f9:	75 31                	jne    c002a12c <sort+0x48>
c002a0fb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a0ff:	74 2b                	je     c002a12c <sort+0x48>
c002a101:	83 ec 0c             	sub    $0xc,%esp
c002a104:	8d 90 b8 93 ff ff    	lea    -0x6c48(%eax),%edx
c002a10a:	52                   	push   %edx
c002a10b:	8d 90 8e 93 ff ff    	lea    -0x6c72(%eax),%edx
c002a111:	52                   	push   %edx
c002a112:	8d 90 f4 93 ff ff    	lea    -0x6c0c(%eax),%edx
c002a118:	52                   	push   %edx
c002a119:	68 8a 00 00 00       	push   $0x8a
c002a11e:	8d 90 a5 93 ff ff    	lea    -0x6c5b(%eax),%edx
c002a124:	52                   	push   %edx
c002a125:	89 c3                	mov    %eax,%ebx
c002a127:	e8 38 16 00 00       	call   c002b764 <debug_panic>
  ASSERT (compare != NULL);
c002a12c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002a130:	75 2b                	jne    c002a15d <sort+0x79>
c002a132:	83 ec 0c             	sub    $0xc,%esp
c002a135:	8d 90 d2 93 ff ff    	lea    -0x6c2e(%eax),%edx
c002a13b:	52                   	push   %edx
c002a13c:	8d 90 8e 93 ff ff    	lea    -0x6c72(%eax),%edx
c002a142:	52                   	push   %edx
c002a143:	8d 90 f4 93 ff ff    	lea    -0x6c0c(%eax),%edx
c002a149:	52                   	push   %edx
c002a14a:	68 8b 00 00 00       	push   $0x8b
c002a14f:	8d 90 a5 93 ff ff    	lea    -0x6c5b(%eax),%edx
c002a155:	52                   	push   %edx
c002a156:	89 c3                	mov    %eax,%ebx
c002a158:	e8 07 16 00 00       	call   c002b764 <debug_panic>
  ASSERT (size > 0);
c002a15d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a161:	75 2b                	jne    c002a18e <sort+0xaa>
c002a163:	83 ec 0c             	sub    $0xc,%esp
c002a166:	8d 90 e2 93 ff ff    	lea    -0x6c1e(%eax),%edx
c002a16c:	52                   	push   %edx
c002a16d:	8d 90 8e 93 ff ff    	lea    -0x6c72(%eax),%edx
c002a173:	52                   	push   %edx
c002a174:	8d 90 f4 93 ff ff    	lea    -0x6c0c(%eax),%edx
c002a17a:	52                   	push   %edx
c002a17b:	68 8c 00 00 00       	push   $0x8c
c002a180:	8d 90 a5 93 ff ff    	lea    -0x6c5b(%eax),%edx
c002a186:	52                   	push   %edx
c002a187:	89 c3                	mov    %eax,%ebx
c002a189:	e8 d6 15 00 00       	call   c002b764 <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c002a18e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a191:	d1 e8                	shr    %eax
c002a193:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a196:	eb 21                	jmp    c002a1b9 <sort+0xd5>
    heapify (array, i, cnt, size, compare, aux);
c002a198:	83 ec 08             	sub    $0x8,%esp
c002a19b:	ff 75 18             	push   0x18(%ebp)
c002a19e:	ff 75 14             	push   0x14(%ebp)
c002a1a1:	ff 75 10             	push   0x10(%ebp)
c002a1a4:	ff 75 0c             	push   0xc(%ebp)
c002a1a7:	ff 75 f4             	push   -0xc(%ebp)
c002a1aa:	ff 75 08             	push   0x8(%ebp)
c002a1ad:	e8 80 fe ff ff       	call   c002a032 <heapify>
c002a1b2:	83 c4 20             	add    $0x20,%esp
  for (i = cnt / 2; i > 0; i--)
c002a1b5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c002a1b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a1bd:	75 d9                	jne    c002a198 <sort+0xb4>

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c002a1bf:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a1c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a1c5:	eb 37                	jmp    c002a1fe <sort+0x11a>
    {
      do_swap (array, 1, i, size);
c002a1c7:	ff 75 10             	push   0x10(%ebp)
c002a1ca:	ff 75 f4             	push   -0xc(%ebp)
c002a1cd:	6a 01                	push   $0x1
c002a1cf:	ff 75 08             	push   0x8(%ebp)
c002a1d2:	e8 95 fd ff ff       	call   c0029f6c <do_swap>
c002a1d7:	83 c4 10             	add    $0x10,%esp
      heapify (array, 1, i - 1, size, compare, aux); 
c002a1da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a1dd:	83 e8 01             	sub    $0x1,%eax
c002a1e0:	83 ec 08             	sub    $0x8,%esp
c002a1e3:	ff 75 18             	push   0x18(%ebp)
c002a1e6:	ff 75 14             	push   0x14(%ebp)
c002a1e9:	ff 75 10             	push   0x10(%ebp)
c002a1ec:	50                   	push   %eax
c002a1ed:	6a 01                	push   $0x1
c002a1ef:	ff 75 08             	push   0x8(%ebp)
c002a1f2:	e8 3b fe ff ff       	call   c002a032 <heapify>
c002a1f7:	83 c4 20             	add    $0x20,%esp
  for (i = cnt; i > 1; i--) 
c002a1fa:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c002a1fe:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002a202:	77 c3                	ja     c002a1c7 <sort+0xe3>
    }
}
c002a204:	90                   	nop
c002a205:	90                   	nop
c002a206:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a209:	c9                   	leave  
c002a20a:	c3                   	ret    

c002a20b <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c002a20b:	55                   	push   %ebp
c002a20c:	89 e5                	mov    %esp,%ebp
c002a20e:	83 ec 08             	sub    $0x8,%esp
c002a211:	e8 12 72 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a216:	05 62 01 01 00       	add    $0x10162,%eax
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c002a21b:	83 ec 08             	sub    $0x8,%esp
c002a21e:	8d 55 18             	lea    0x18(%ebp),%edx
c002a221:	52                   	push   %edx
c002a222:	8d 80 97 fb fe ff    	lea    -0x10469(%eax),%eax
c002a228:	50                   	push   %eax
c002a229:	ff 75 14             	push   0x14(%ebp)
c002a22c:	ff 75 10             	push   0x10(%ebp)
c002a22f:	ff 75 0c             	push   0xc(%ebp)
c002a232:	ff 75 08             	push   0x8(%ebp)
c002a235:	e8 05 00 00 00       	call   c002a23f <binary_search>
c002a23a:	83 c4 20             	add    $0x20,%esp
}
c002a23d:	c9                   	leave  
c002a23e:	c3                   	ret    

c002a23f <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c002a23f:	55                   	push   %ebp
c002a240:	89 e5                	mov    %esp,%ebp
c002a242:	83 ec 28             	sub    $0x28,%esp
c002a245:	e8 de 71 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a24a:	05 2e 01 01 00       	add    $0x1012e,%eax
  const unsigned char *first = array;
c002a24f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a252:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *last = array + size * cnt;
c002a255:	8b 45 14             	mov    0x14(%ebp),%eax
c002a258:	0f af 45 10          	imul   0x10(%ebp),%eax
c002a25c:	89 c2                	mov    %eax,%edx
c002a25e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a261:	01 d0                	add    %edx,%eax
c002a263:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while (first < last) 
c002a266:	eb 61                	jmp    c002a2c9 <binary_search+0x8a>
    {
      size_t range = (last - first) / size;
c002a268:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a26b:	2b 45 f4             	sub    -0xc(%ebp),%eax
c002a26e:	ba 00 00 00 00       	mov    $0x0,%edx
c002a273:	f7 75 14             	divl   0x14(%ebp)
c002a276:	89 45 ec             	mov    %eax,-0x14(%ebp)
      const unsigned char *middle = first + (range / 2) * size;
c002a279:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002a27c:	d1 e8                	shr    %eax
c002a27e:	0f af 45 14          	imul   0x14(%ebp),%eax
c002a282:	89 c2                	mov    %eax,%edx
c002a284:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a287:	01 d0                	add    %edx,%eax
c002a289:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int cmp = compare (key, middle, aux);
c002a28c:	83 ec 04             	sub    $0x4,%esp
c002a28f:	ff 75 1c             	push   0x1c(%ebp)
c002a292:	ff 75 e8             	push   -0x18(%ebp)
c002a295:	ff 75 08             	push   0x8(%ebp)
c002a298:	8b 45 18             	mov    0x18(%ebp),%eax
c002a29b:	ff d0                	call   *%eax
c002a29d:	83 c4 10             	add    $0x10,%esp
c002a2a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if (cmp < 0) 
c002a2a3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002a2a7:	79 08                	jns    c002a2b1 <binary_search+0x72>
        last = middle;
c002a2a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a2ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a2af:	eb 18                	jmp    c002a2c9 <binary_search+0x8a>
      else if (cmp > 0) 
c002a2b1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002a2b5:	7e 0d                	jle    c002a2c4 <binary_search+0x85>
        first = middle + size;
c002a2b7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c002a2ba:	8b 45 14             	mov    0x14(%ebp),%eax
c002a2bd:	01 d0                	add    %edx,%eax
c002a2bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a2c2:	eb 05                	jmp    c002a2c9 <binary_search+0x8a>
      else
        return (void *) middle;
c002a2c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a2c7:	eb 0d                	jmp    c002a2d6 <binary_search+0x97>
  while (first < last) 
c002a2c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a2cc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a2cf:	72 97                	jb     c002a268 <binary_search+0x29>
    }
  
  return NULL;
c002a2d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a2d6:	c9                   	leave  
c002a2d7:	c3                   	ret    

c002a2d8 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c002a2d8:	55                   	push   %ebp
c002a2d9:	89 e5                	mov    %esp,%ebp
c002a2db:	53                   	push   %ebx
c002a2dc:	83 ec 14             	sub    $0x14,%esp
c002a2df:	e8 44 71 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a2e4:	05 94 00 01 00       	add    $0x10094,%eax
  unsigned char *dst = dst_;
c002a2e9:	8b 55 08             	mov    0x8(%ebp),%edx
c002a2ec:	89 55 f4             	mov    %edx,-0xc(%ebp)
  const unsigned char *src = src_;
c002a2ef:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a2f2:	89 55 f0             	mov    %edx,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c002a2f5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a2f9:	75 2e                	jne    c002a329 <memcpy+0x51>
c002a2fb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a2ff:	74 28                	je     c002a329 <memcpy+0x51>
c002a301:	83 ec 0c             	sub    $0xc,%esp
c002a304:	8d 90 fc 93 ff ff    	lea    -0x6c04(%eax),%edx
c002a30a:	52                   	push   %edx
c002a30b:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a311:	52                   	push   %edx
c002a312:	8d 90 0c 95 ff ff    	lea    -0x6af4(%eax),%edx
c002a318:	52                   	push   %edx
c002a319:	6a 0c                	push   $0xc
c002a31b:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a321:	52                   	push   %edx
c002a322:	89 c3                	mov    %eax,%ebx
c002a324:	e8 3b 14 00 00       	call   c002b764 <debug_panic>
  ASSERT (src != NULL || size == 0);
c002a329:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002a32d:	75 45                	jne    c002a374 <memcpy+0x9c>
c002a32f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a333:	74 3f                	je     c002a374 <memcpy+0x9c>
c002a335:	83 ec 0c             	sub    $0xc,%esp
c002a338:	8d 90 3f 94 ff ff    	lea    -0x6bc1(%eax),%edx
c002a33e:	52                   	push   %edx
c002a33f:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a345:	52                   	push   %edx
c002a346:	8d 90 0c 95 ff ff    	lea    -0x6af4(%eax),%edx
c002a34c:	52                   	push   %edx
c002a34d:	6a 0d                	push   $0xd
c002a34f:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a355:	52                   	push   %edx
c002a356:	89 c3                	mov    %eax,%ebx
c002a358:	e8 07 14 00 00       	call   c002b764 <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c002a35d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002a360:	8d 42 01             	lea    0x1(%edx),%eax
c002a363:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a366:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a369:	8d 48 01             	lea    0x1(%eax),%ecx
c002a36c:	89 4d f4             	mov    %ecx,-0xc(%ebp)
c002a36f:	0f b6 12             	movzbl (%edx),%edx
c002a372:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c002a374:	8b 45 10             	mov    0x10(%ebp),%eax
c002a377:	8d 50 ff             	lea    -0x1(%eax),%edx
c002a37a:	89 55 10             	mov    %edx,0x10(%ebp)
c002a37d:	85 c0                	test   %eax,%eax
c002a37f:	75 dc                	jne    c002a35d <memcpy+0x85>

  return dst_;
c002a381:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a384:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a387:	c9                   	leave  
c002a388:	c3                   	ret    

c002a389 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c002a389:	55                   	push   %ebp
c002a38a:	89 e5                	mov    %esp,%ebp
c002a38c:	53                   	push   %ebx
c002a38d:	83 ec 14             	sub    $0x14,%esp
c002a390:	e8 93 70 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a395:	05 e3 ff 00 00       	add    $0xffe3,%eax
  unsigned char *dst = dst_;
c002a39a:	8b 55 08             	mov    0x8(%ebp),%edx
c002a39d:	89 55 f4             	mov    %edx,-0xc(%ebp)
  const unsigned char *src = src_;
c002a3a0:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a3a3:	89 55 f0             	mov    %edx,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c002a3a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a3aa:	75 2e                	jne    c002a3da <memmove+0x51>
c002a3ac:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a3b0:	74 28                	je     c002a3da <memmove+0x51>
c002a3b2:	83 ec 0c             	sub    $0xc,%esp
c002a3b5:	8d 90 fc 93 ff ff    	lea    -0x6c04(%eax),%edx
c002a3bb:	52                   	push   %edx
c002a3bc:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a3c2:	52                   	push   %edx
c002a3c3:	8d 90 14 95 ff ff    	lea    -0x6aec(%eax),%edx
c002a3c9:	52                   	push   %edx
c002a3ca:	6a 1d                	push   $0x1d
c002a3cc:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a3d2:	52                   	push   %edx
c002a3d3:	89 c3                	mov    %eax,%ebx
c002a3d5:	e8 8a 13 00 00       	call   c002b764 <debug_panic>
  ASSERT (src != NULL || size == 0);
c002a3da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002a3de:	75 2e                	jne    c002a40e <memmove+0x85>
c002a3e0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a3e4:	74 28                	je     c002a40e <memmove+0x85>
c002a3e6:	83 ec 0c             	sub    $0xc,%esp
c002a3e9:	8d 90 3f 94 ff ff    	lea    -0x6bc1(%eax),%edx
c002a3ef:	52                   	push   %edx
c002a3f0:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a3f6:	52                   	push   %edx
c002a3f7:	8d 90 14 95 ff ff    	lea    -0x6aec(%eax),%edx
c002a3fd:	52                   	push   %edx
c002a3fe:	6a 1e                	push   $0x1e
c002a400:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a406:	52                   	push   %edx
c002a407:	89 c3                	mov    %eax,%ebx
c002a409:	e8 56 13 00 00       	call   c002b764 <debug_panic>

  if (dst < src) 
c002a40e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a411:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a414:	73 28                	jae    c002a43e <memmove+0xb5>
    {
      while (size-- > 0)
c002a416:	eb 17                	jmp    c002a42f <memmove+0xa6>
        *dst++ = *src++;
c002a418:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002a41b:	8d 42 01             	lea    0x1(%edx),%eax
c002a41e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a421:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a424:	8d 48 01             	lea    0x1(%eax),%ecx
c002a427:	89 4d f4             	mov    %ecx,-0xc(%ebp)
c002a42a:	0f b6 12             	movzbl (%edx),%edx
c002a42d:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c002a42f:	8b 45 10             	mov    0x10(%ebp),%eax
c002a432:	8d 50 ff             	lea    -0x1(%eax),%edx
c002a435:	89 55 10             	mov    %edx,0x10(%ebp)
c002a438:	85 c0                	test   %eax,%eax
c002a43a:	75 dc                	jne    c002a418 <memmove+0x8f>
c002a43c:	eb 2e                	jmp    c002a46c <memmove+0xe3>
    }
  else 
    {
      dst += size;
c002a43e:	8b 45 10             	mov    0x10(%ebp),%eax
c002a441:	01 45 f4             	add    %eax,-0xc(%ebp)
      src += size;
c002a444:	8b 45 10             	mov    0x10(%ebp),%eax
c002a447:	01 45 f0             	add    %eax,-0x10(%ebp)
      while (size-- > 0)
c002a44a:	eb 13                	jmp    c002a45f <memmove+0xd6>
        *--dst = *--src;
c002a44c:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c002a450:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c002a454:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a457:	0f b6 10             	movzbl (%eax),%edx
c002a45a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a45d:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c002a45f:	8b 45 10             	mov    0x10(%ebp),%eax
c002a462:	8d 50 ff             	lea    -0x1(%eax),%edx
c002a465:	89 55 10             	mov    %edx,0x10(%ebp)
c002a468:	85 c0                	test   %eax,%eax
c002a46a:	75 e0                	jne    c002a44c <memmove+0xc3>
    }

  return dst;
c002a46c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a46f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a472:	c9                   	leave  
c002a473:	c3                   	ret    

c002a474 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c002a474:	55                   	push   %ebp
c002a475:	89 e5                	mov    %esp,%ebp
c002a477:	53                   	push   %ebx
c002a478:	83 ec 14             	sub    $0x14,%esp
c002a47b:	e8 a8 6f 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a480:	05 f8 fe 00 00       	add    $0xfef8,%eax
  const unsigned char *a = a_;
c002a485:	8b 55 08             	mov    0x8(%ebp),%edx
c002a488:	89 55 f4             	mov    %edx,-0xc(%ebp)
  const unsigned char *b = b_;
c002a48b:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a48e:	89 55 f0             	mov    %edx,-0x10(%ebp)

  ASSERT (a != NULL || size == 0);
c002a491:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a495:	75 2e                	jne    c002a4c5 <memcmp+0x51>
c002a497:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a49b:	74 28                	je     c002a4c5 <memcmp+0x51>
c002a49d:	83 ec 0c             	sub    $0xc,%esp
c002a4a0:	8d 90 58 94 ff ff    	lea    -0x6ba8(%eax),%edx
c002a4a6:	52                   	push   %edx
c002a4a7:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a4ad:	52                   	push   %edx
c002a4ae:	8d 90 1c 95 ff ff    	lea    -0x6ae4(%eax),%edx
c002a4b4:	52                   	push   %edx
c002a4b5:	6a 3a                	push   $0x3a
c002a4b7:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a4bd:	52                   	push   %edx
c002a4be:	89 c3                	mov    %eax,%ebx
c002a4c0:	e8 9f 12 00 00       	call   c002b764 <debug_panic>
  ASSERT (b != NULL || size == 0);
c002a4c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002a4c9:	75 64                	jne    c002a52f <memcmp+0xbb>
c002a4cb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a4cf:	74 5e                	je     c002a52f <memcmp+0xbb>
c002a4d1:	83 ec 0c             	sub    $0xc,%esp
c002a4d4:	8d 90 6f 94 ff ff    	lea    -0x6b91(%eax),%edx
c002a4da:	52                   	push   %edx
c002a4db:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a4e1:	52                   	push   %edx
c002a4e2:	8d 90 1c 95 ff ff    	lea    -0x6ae4(%eax),%edx
c002a4e8:	52                   	push   %edx
c002a4e9:	6a 3b                	push   $0x3b
c002a4eb:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a4f1:	52                   	push   %edx
c002a4f2:	89 c3                	mov    %eax,%ebx
c002a4f4:	e8 6b 12 00 00       	call   c002b764 <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c002a4f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a4fc:	0f b6 10             	movzbl (%eax),%edx
c002a4ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a502:	0f b6 00             	movzbl (%eax),%eax
c002a505:	38 c2                	cmp    %al,%dl
c002a507:	74 1e                	je     c002a527 <memcmp+0xb3>
      return *a > *b ? +1 : -1;
c002a509:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a50c:	0f b6 10             	movzbl (%eax),%edx
c002a50f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a512:	0f b6 00             	movzbl (%eax),%eax
c002a515:	38 c2                	cmp    %al,%dl
c002a517:	76 07                	jbe    c002a520 <memcmp+0xac>
c002a519:	b8 01 00 00 00       	mov    $0x1,%eax
c002a51e:	eb 21                	jmp    c002a541 <memcmp+0xcd>
c002a520:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002a525:	eb 1a                	jmp    c002a541 <memcmp+0xcd>
  for (; size-- > 0; a++, b++)
c002a527:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002a52b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002a52f:	8b 45 10             	mov    0x10(%ebp),%eax
c002a532:	8d 50 ff             	lea    -0x1(%eax),%edx
c002a535:	89 55 10             	mov    %edx,0x10(%ebp)
c002a538:	85 c0                	test   %eax,%eax
c002a53a:	75 bd                	jne    c002a4f9 <memcmp+0x85>
  return 0;
c002a53c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a541:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a544:	c9                   	leave  
c002a545:	c3                   	ret    

c002a546 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c002a546:	55                   	push   %ebp
c002a547:	89 e5                	mov    %esp,%ebp
c002a549:	53                   	push   %ebx
c002a54a:	83 ec 14             	sub    $0x14,%esp
c002a54d:	e8 d6 6e 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a552:	05 26 fe 00 00       	add    $0xfe26,%eax
  const unsigned char *a = (const unsigned char *) a_;
c002a557:	8b 55 08             	mov    0x8(%ebp),%edx
c002a55a:	89 55 f4             	mov    %edx,-0xc(%ebp)
  const unsigned char *b = (const unsigned char *) b_;
c002a55d:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a560:	89 55 f0             	mov    %edx,-0x10(%ebp)

  ASSERT (a != NULL);
c002a563:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a567:	75 28                	jne    c002a591 <strcmp+0x4b>
c002a569:	83 ec 0c             	sub    $0xc,%esp
c002a56c:	8d 90 86 94 ff ff    	lea    -0x6b7a(%eax),%edx
c002a572:	52                   	push   %edx
c002a573:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a579:	52                   	push   %edx
c002a57a:	8d 90 24 95 ff ff    	lea    -0x6adc(%eax),%edx
c002a580:	52                   	push   %edx
c002a581:	6a 4e                	push   $0x4e
c002a583:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a589:	52                   	push   %edx
c002a58a:	89 c3                	mov    %eax,%ebx
c002a58c:	e8 d3 11 00 00       	call   c002b764 <debug_panic>
  ASSERT (b != NULL);
c002a591:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002a595:	75 30                	jne    c002a5c7 <strcmp+0x81>
c002a597:	83 ec 0c             	sub    $0xc,%esp
c002a59a:	8d 90 90 94 ff ff    	lea    -0x6b70(%eax),%edx
c002a5a0:	52                   	push   %edx
c002a5a1:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a5a7:	52                   	push   %edx
c002a5a8:	8d 90 24 95 ff ff    	lea    -0x6adc(%eax),%edx
c002a5ae:	52                   	push   %edx
c002a5af:	6a 4f                	push   $0x4f
c002a5b1:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a5b7:	52                   	push   %edx
c002a5b8:	89 c3                	mov    %eax,%ebx
c002a5ba:	e8 a5 11 00 00       	call   c002b764 <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c002a5bf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      b++;
c002a5c3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  while (*a != '\0' && *a == *b) 
c002a5c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5ca:	0f b6 00             	movzbl (%eax),%eax
c002a5cd:	84 c0                	test   %al,%al
c002a5cf:	74 10                	je     c002a5e1 <strcmp+0x9b>
c002a5d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5d4:	0f b6 10             	movzbl (%eax),%edx
c002a5d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a5da:	0f b6 00             	movzbl (%eax),%eax
c002a5dd:	38 c2                	cmp    %al,%dl
c002a5df:	74 de                	je     c002a5bf <strcmp+0x79>
    }

  return *a < *b ? -1 : *a > *b;
c002a5e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5e4:	0f b6 10             	movzbl (%eax),%edx
c002a5e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a5ea:	0f b6 00             	movzbl (%eax),%eax
c002a5ed:	38 c2                	cmp    %al,%dl
c002a5ef:	72 16                	jb     c002a607 <strcmp+0xc1>
c002a5f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5f4:	0f b6 10             	movzbl (%eax),%edx
c002a5f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a5fa:	0f b6 00             	movzbl (%eax),%eax
c002a5fd:	38 c2                	cmp    %al,%dl
c002a5ff:	0f 97 c0             	seta   %al
c002a602:	0f b6 c0             	movzbl %al,%eax
c002a605:	eb 05                	jmp    c002a60c <strcmp+0xc6>
c002a607:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002a60c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a60f:	c9                   	leave  
c002a610:	c3                   	ret    

c002a611 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c002a611:	55                   	push   %ebp
c002a612:	89 e5                	mov    %esp,%ebp
c002a614:	53                   	push   %ebx
c002a615:	83 ec 14             	sub    $0x14,%esp
c002a618:	e8 0b 6e 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a61d:	05 5b fd 00 00       	add    $0xfd5b,%eax
  const unsigned char *block = block_;
c002a622:	8b 55 08             	mov    0x8(%ebp),%edx
c002a625:	89 55 f4             	mov    %edx,-0xc(%ebp)
  unsigned char ch = ch_;
c002a628:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a62b:	88 55 f3             	mov    %dl,-0xd(%ebp)

  ASSERT (block != NULL || size == 0);
c002a62e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a632:	75 42                	jne    c002a676 <memchr+0x65>
c002a634:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a638:	74 3c                	je     c002a676 <memchr+0x65>
c002a63a:	83 ec 0c             	sub    $0xc,%esp
c002a63d:	8d 90 9a 94 ff ff    	lea    -0x6b66(%eax),%edx
c002a643:	52                   	push   %edx
c002a644:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a64a:	52                   	push   %edx
c002a64b:	8d 90 2c 95 ff ff    	lea    -0x6ad4(%eax),%edx
c002a651:	52                   	push   %edx
c002a652:	6a 63                	push   $0x63
c002a654:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a65a:	52                   	push   %edx
c002a65b:	89 c3                	mov    %eax,%ebx
c002a65d:	e8 02 11 00 00       	call   c002b764 <debug_panic>

  for (; size-- > 0; block++)
    if (*block == ch)
c002a662:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a665:	0f b6 00             	movzbl (%eax),%eax
c002a668:	38 45 f3             	cmp    %al,-0xd(%ebp)
c002a66b:	75 05                	jne    c002a672 <memchr+0x61>
      return (void *) block;
c002a66d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a670:	eb 16                	jmp    c002a688 <memchr+0x77>
  for (; size-- > 0; block++)
c002a672:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002a676:	8b 45 10             	mov    0x10(%ebp),%eax
c002a679:	8d 50 ff             	lea    -0x1(%eax),%edx
c002a67c:	89 55 10             	mov    %edx,0x10(%ebp)
c002a67f:	85 c0                	test   %eax,%eax
c002a681:	75 df                	jne    c002a662 <memchr+0x51>

  return NULL;
c002a683:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a688:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a68b:	c9                   	leave  
c002a68c:	c3                   	ret    

c002a68d <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c002a68d:	55                   	push   %ebp
c002a68e:	89 e5                	mov    %esp,%ebp
c002a690:	53                   	push   %ebx
c002a691:	83 ec 14             	sub    $0x14,%esp
c002a694:	e8 8f 6d 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a699:	05 df fc 00 00       	add    $0xfcdf,%eax
  char c = c_;
c002a69e:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a6a1:	88 55 f7             	mov    %dl,-0x9(%ebp)

  ASSERT (string != NULL);
c002a6a4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a6a8:	75 28                	jne    c002a6d2 <strchr+0x45>
c002a6aa:	83 ec 0c             	sub    $0xc,%esp
c002a6ad:	8d 90 b5 94 ff ff    	lea    -0x6b4b(%eax),%edx
c002a6b3:	52                   	push   %edx
c002a6b4:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a6ba:	52                   	push   %edx
c002a6bb:	8d 90 34 95 ff ff    	lea    -0x6acc(%eax),%edx
c002a6c1:	52                   	push   %edx
c002a6c2:	6a 75                	push   $0x75
c002a6c4:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a6ca:	52                   	push   %edx
c002a6cb:	89 c3                	mov    %eax,%ebx
c002a6cd:	e8 92 10 00 00       	call   c002b764 <debug_panic>

  for (;;) 
    if (*string == c)
c002a6d2:	8b 45 08             	mov    0x8(%ebp),%eax
c002a6d5:	0f b6 00             	movzbl (%eax),%eax
c002a6d8:	38 45 f7             	cmp    %al,-0x9(%ebp)
c002a6db:	75 05                	jne    c002a6e2 <strchr+0x55>
      return (char *) string;
c002a6dd:	8b 45 08             	mov    0x8(%ebp),%eax
c002a6e0:	eb 17                	jmp    c002a6f9 <strchr+0x6c>
    else if (*string == '\0')
c002a6e2:	8b 45 08             	mov    0x8(%ebp),%eax
c002a6e5:	0f b6 00             	movzbl (%eax),%eax
c002a6e8:	84 c0                	test   %al,%al
c002a6ea:	75 07                	jne    c002a6f3 <strchr+0x66>
      return NULL;
c002a6ec:	b8 00 00 00 00       	mov    $0x0,%eax
c002a6f1:	eb 06                	jmp    c002a6f9 <strchr+0x6c>
    else
      string++;
c002a6f3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    if (*string == c)
c002a6f7:	eb d9                	jmp    c002a6d2 <strchr+0x45>
}
c002a6f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a6fc:	c9                   	leave  
c002a6fd:	c3                   	ret    

c002a6fe <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c002a6fe:	55                   	push   %ebp
c002a6ff:	89 e5                	mov    %esp,%ebp
c002a701:	83 ec 18             	sub    $0x18,%esp
c002a704:	e8 1f 6d 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a709:	05 6f fc 00 00       	add    $0xfc6f,%eax
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c002a70e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002a715:	eb 25                	jmp    c002a73c <strcspn+0x3e>
    if (strchr (stop, string[length]) != NULL)
c002a717:	8b 55 08             	mov    0x8(%ebp),%edx
c002a71a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a71d:	01 d0                	add    %edx,%eax
c002a71f:	0f b6 00             	movzbl (%eax),%eax
c002a722:	0f be c0             	movsbl %al,%eax
c002a725:	83 ec 08             	sub    $0x8,%esp
c002a728:	50                   	push   %eax
c002a729:	ff 75 0c             	push   0xc(%ebp)
c002a72c:	e8 5c ff ff ff       	call   c002a68d <strchr>
c002a731:	83 c4 10             	add    $0x10,%esp
c002a734:	85 c0                	test   %eax,%eax
c002a736:	75 15                	jne    c002a74d <strcspn+0x4f>
  for (length = 0; string[length] != '\0'; length++)
c002a738:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002a73c:	8b 55 08             	mov    0x8(%ebp),%edx
c002a73f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a742:	01 d0                	add    %edx,%eax
c002a744:	0f b6 00             	movzbl (%eax),%eax
c002a747:	84 c0                	test   %al,%al
c002a749:	75 cc                	jne    c002a717 <strcspn+0x19>
c002a74b:	eb 01                	jmp    c002a74e <strcspn+0x50>
      break;
c002a74d:	90                   	nop
  return length;
c002a74e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a751:	c9                   	leave  
c002a752:	c3                   	ret    

c002a753 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c002a753:	55                   	push   %ebp
c002a754:	89 e5                	mov    %esp,%ebp
c002a756:	83 ec 08             	sub    $0x8,%esp
c002a759:	e8 ca 6c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a75e:	05 1a fc 00 00       	add    $0xfc1a,%eax
  for (; *string != '\0'; string++)
c002a763:	eb 25                	jmp    c002a78a <strpbrk+0x37>
    if (strchr (stop, *string) != NULL)
c002a765:	8b 45 08             	mov    0x8(%ebp),%eax
c002a768:	0f b6 00             	movzbl (%eax),%eax
c002a76b:	0f be c0             	movsbl %al,%eax
c002a76e:	83 ec 08             	sub    $0x8,%esp
c002a771:	50                   	push   %eax
c002a772:	ff 75 0c             	push   0xc(%ebp)
c002a775:	e8 13 ff ff ff       	call   c002a68d <strchr>
c002a77a:	83 c4 10             	add    $0x10,%esp
c002a77d:	85 c0                	test   %eax,%eax
c002a77f:	74 05                	je     c002a786 <strpbrk+0x33>
      return (char *) string;
c002a781:	8b 45 08             	mov    0x8(%ebp),%eax
c002a784:	eb 13                	jmp    c002a799 <strpbrk+0x46>
  for (; *string != '\0'; string++)
c002a786:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c002a78a:	8b 45 08             	mov    0x8(%ebp),%eax
c002a78d:	0f b6 00             	movzbl (%eax),%eax
c002a790:	84 c0                	test   %al,%al
c002a792:	75 d1                	jne    c002a765 <strpbrk+0x12>
  return NULL;
c002a794:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a799:	c9                   	leave  
c002a79a:	c3                   	ret    

c002a79b <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c002a79b:	55                   	push   %ebp
c002a79c:	89 e5                	mov    %esp,%ebp
c002a79e:	83 ec 10             	sub    $0x10,%esp
c002a7a1:	e8 82 6c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a7a6:	05 d2 fb 00 00       	add    $0xfbd2,%eax
  char c = c_;
c002a7ab:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a7ae:	88 45 fb             	mov    %al,-0x5(%ebp)
  const char *p = NULL;
c002a7b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (; *string != '\0'; string++)
c002a7b8:	eb 15                	jmp    c002a7cf <strrchr+0x34>
    if (*string == c)
c002a7ba:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7bd:	0f b6 00             	movzbl (%eax),%eax
c002a7c0:	38 45 fb             	cmp    %al,-0x5(%ebp)
c002a7c3:	75 06                	jne    c002a7cb <strrchr+0x30>
      p = string;
c002a7c5:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7c8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  for (; *string != '\0'; string++)
c002a7cb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c002a7cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7d2:	0f b6 00             	movzbl (%eax),%eax
c002a7d5:	84 c0                	test   %al,%al
c002a7d7:	75 e1                	jne    c002a7ba <strrchr+0x1f>
  return (char *) p;
c002a7d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002a7dc:	c9                   	leave  
c002a7dd:	c3                   	ret    

c002a7de <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c002a7de:	55                   	push   %ebp
c002a7df:	89 e5                	mov    %esp,%ebp
c002a7e1:	83 ec 18             	sub    $0x18,%esp
c002a7e4:	e8 3f 6c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a7e9:	05 8f fb 00 00       	add    $0xfb8f,%eax
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c002a7ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002a7f5:	eb 25                	jmp    c002a81c <strspn+0x3e>
    if (strchr (skip, string[length]) == NULL)
c002a7f7:	8b 55 08             	mov    0x8(%ebp),%edx
c002a7fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a7fd:	01 d0                	add    %edx,%eax
c002a7ff:	0f b6 00             	movzbl (%eax),%eax
c002a802:	0f be c0             	movsbl %al,%eax
c002a805:	83 ec 08             	sub    $0x8,%esp
c002a808:	50                   	push   %eax
c002a809:	ff 75 0c             	push   0xc(%ebp)
c002a80c:	e8 7c fe ff ff       	call   c002a68d <strchr>
c002a811:	83 c4 10             	add    $0x10,%esp
c002a814:	85 c0                	test   %eax,%eax
c002a816:	74 15                	je     c002a82d <strspn+0x4f>
  for (length = 0; string[length] != '\0'; length++)
c002a818:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002a81c:	8b 55 08             	mov    0x8(%ebp),%edx
c002a81f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a822:	01 d0                	add    %edx,%eax
c002a824:	0f b6 00             	movzbl (%eax),%eax
c002a827:	84 c0                	test   %al,%al
c002a829:	75 cc                	jne    c002a7f7 <strspn+0x19>
c002a82b:	eb 01                	jmp    c002a82e <strspn+0x50>
      break;
c002a82d:	90                   	nop
  return length;
c002a82e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a831:	c9                   	leave  
c002a832:	c3                   	ret    

c002a833 <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c002a833:	55                   	push   %ebp
c002a834:	89 e5                	mov    %esp,%ebp
c002a836:	83 ec 18             	sub    $0x18,%esp
c002a839:	e8 ea 6b 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a83e:	05 3a fb 00 00       	add    $0xfb3a,%eax
  size_t haystack_len = strlen (haystack);
c002a843:	83 ec 0c             	sub    $0xc,%esp
c002a846:	ff 75 08             	push   0x8(%ebp)
c002a849:	e8 17 02 00 00       	call   c002aa65 <strlen>
c002a84e:	83 c4 10             	add    $0x10,%esp
c002a851:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t needle_len = strlen (needle);
c002a854:	83 ec 0c             	sub    $0xc,%esp
c002a857:	ff 75 0c             	push   0xc(%ebp)
c002a85a:	e8 06 02 00 00       	call   c002aa65 <strlen>
c002a85f:	83 c4 10             	add    $0x10,%esp
c002a862:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (haystack_len >= needle_len) 
c002a865:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a868:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002a86b:	72 40                	jb     c002a8ad <strstr+0x7a>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c002a86d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002a874:	eb 2c                	jmp    c002a8a2 <strstr+0x6f>
        if (!memcmp (haystack + i, needle, needle_len))
c002a876:	8b 55 08             	mov    0x8(%ebp),%edx
c002a879:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a87c:	01 d0                	add    %edx,%eax
c002a87e:	83 ec 04             	sub    $0x4,%esp
c002a881:	ff 75 ec             	push   -0x14(%ebp)
c002a884:	ff 75 0c             	push   0xc(%ebp)
c002a887:	50                   	push   %eax
c002a888:	e8 e7 fb ff ff       	call   c002a474 <memcmp>
c002a88d:	83 c4 10             	add    $0x10,%esp
c002a890:	85 c0                	test   %eax,%eax
c002a892:	75 0a                	jne    c002a89e <strstr+0x6b>
          return (char *) haystack + i;
c002a894:	8b 55 08             	mov    0x8(%ebp),%edx
c002a897:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a89a:	01 d0                	add    %edx,%eax
c002a89c:	eb 14                	jmp    c002a8b2 <strstr+0x7f>
      for (i = 0; i <= haystack_len - needle_len; i++)
c002a89e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002a8a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a8a5:	2b 45 ec             	sub    -0x14(%ebp),%eax
c002a8a8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002a8ab:	76 c9                	jbe    c002a876 <strstr+0x43>
    }

  return NULL;
c002a8ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a8b2:	c9                   	leave  
c002a8b3:	c3                   	ret    

c002a8b4 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c002a8b4:	55                   	push   %ebp
c002a8b5:	89 e5                	mov    %esp,%ebp
c002a8b7:	53                   	push   %ebx
c002a8b8:	83 ec 14             	sub    $0x14,%esp
c002a8bb:	e8 68 6b 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002a8c0:	05 b8 fa 00 00       	add    $0xfab8,%eax
  char *token;
  
  ASSERT (delimiters != NULL);
c002a8c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a8c9:	75 2b                	jne    c002a8f6 <strtok_r+0x42>
c002a8cb:	83 ec 0c             	sub    $0xc,%esp
c002a8ce:	8d 90 c4 94 ff ff    	lea    -0x6b3c(%eax),%edx
c002a8d4:	52                   	push   %edx
c002a8d5:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a8db:	52                   	push   %edx
c002a8dc:	8d 90 3c 95 ff ff    	lea    -0x6ac4(%eax),%edx
c002a8e2:	52                   	push   %edx
c002a8e3:	68 ef 00 00 00       	push   $0xef
c002a8e8:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a8ee:	52                   	push   %edx
c002a8ef:	89 c3                	mov    %eax,%ebx
c002a8f1:	e8 6e 0e 00 00       	call   c002b764 <debug_panic>
  ASSERT (save_ptr != NULL);
c002a8f6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a8fa:	75 2b                	jne    c002a927 <strtok_r+0x73>
c002a8fc:	83 ec 0c             	sub    $0xc,%esp
c002a8ff:	8d 90 d7 94 ff ff    	lea    -0x6b29(%eax),%edx
c002a905:	52                   	push   %edx
c002a906:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a90c:	52                   	push   %edx
c002a90d:	8d 90 3c 95 ff ff    	lea    -0x6ac4(%eax),%edx
c002a913:	52                   	push   %edx
c002a914:	68 f0 00 00 00       	push   $0xf0
c002a919:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a91f:	52                   	push   %edx
c002a920:	89 c3                	mov    %eax,%ebx
c002a922:	e8 3d 0e 00 00       	call   c002b764 <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c002a927:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a92b:	75 08                	jne    c002a935 <strtok_r+0x81>
    s = *save_ptr;
c002a92d:	8b 55 10             	mov    0x10(%ebp),%edx
c002a930:	8b 12                	mov    (%edx),%edx
c002a932:	89 55 08             	mov    %edx,0x8(%ebp)
  ASSERT (s != NULL);
c002a935:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a939:	75 48                	jne    c002a983 <strtok_r+0xcf>
c002a93b:	83 ec 0c             	sub    $0xc,%esp
c002a93e:	8d 90 e8 94 ff ff    	lea    -0x6b18(%eax),%edx
c002a944:	52                   	push   %edx
c002a945:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002a94b:	52                   	push   %edx
c002a94c:	8d 90 3c 95 ff ff    	lea    -0x6ac4(%eax),%edx
c002a952:	52                   	push   %edx
c002a953:	68 f6 00 00 00       	push   $0xf6
c002a958:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002a95e:	52                   	push   %edx
c002a95f:	89 c3                	mov    %eax,%ebx
c002a961:	e8 fe 0d 00 00       	call   c002b764 <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c002a966:	8b 45 08             	mov    0x8(%ebp),%eax
c002a969:	0f b6 00             	movzbl (%eax),%eax
c002a96c:	84 c0                	test   %al,%al
c002a96e:	75 0f                	jne    c002a97f <strtok_r+0xcb>
        {
          *save_ptr = s;
c002a970:	8b 45 10             	mov    0x10(%ebp),%eax
c002a973:	8b 55 08             	mov    0x8(%ebp),%edx
c002a976:	89 10                	mov    %edx,(%eax)
          return NULL;
c002a978:	b8 00 00 00 00       	mov    $0x0,%eax
c002a97d:	eb 70                	jmp    c002a9ef <strtok_r+0x13b>
        }

      s++;
c002a97f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  while (strchr (delimiters, *s) != NULL) 
c002a983:	8b 45 08             	mov    0x8(%ebp),%eax
c002a986:	0f b6 00             	movzbl (%eax),%eax
c002a989:	0f be c0             	movsbl %al,%eax
c002a98c:	83 ec 08             	sub    $0x8,%esp
c002a98f:	50                   	push   %eax
c002a990:	ff 75 0c             	push   0xc(%ebp)
c002a993:	e8 f5 fc ff ff       	call   c002a68d <strchr>
c002a998:	83 c4 10             	add    $0x10,%esp
c002a99b:	85 c0                	test   %eax,%eax
c002a99d:	75 c7                	jne    c002a966 <strtok_r+0xb2>
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
c002a99f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (strchr (delimiters, *s) == NULL)
c002a9a5:	eb 04                	jmp    c002a9ab <strtok_r+0xf7>
    s++;
c002a9a7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  while (strchr (delimiters, *s) == NULL)
c002a9ab:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9ae:	0f b6 00             	movzbl (%eax),%eax
c002a9b1:	0f be c0             	movsbl %al,%eax
c002a9b4:	83 ec 08             	sub    $0x8,%esp
c002a9b7:	50                   	push   %eax
c002a9b8:	ff 75 0c             	push   0xc(%ebp)
c002a9bb:	e8 cd fc ff ff       	call   c002a68d <strchr>
c002a9c0:	83 c4 10             	add    $0x10,%esp
c002a9c3:	85 c0                	test   %eax,%eax
c002a9c5:	74 e0                	je     c002a9a7 <strtok_r+0xf3>
  if (*s != '\0') 
c002a9c7:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9ca:	0f b6 00             	movzbl (%eax),%eax
c002a9cd:	84 c0                	test   %al,%al
c002a9cf:	74 13                	je     c002a9e4 <strtok_r+0x130>
    {
      *s = '\0';
c002a9d1:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9d4:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c002a9d7:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9da:	8d 50 01             	lea    0x1(%eax),%edx
c002a9dd:	8b 45 10             	mov    0x10(%ebp),%eax
c002a9e0:	89 10                	mov    %edx,(%eax)
c002a9e2:	eb 08                	jmp    c002a9ec <strtok_r+0x138>
    }
  else 
    *save_ptr = s;
c002a9e4:	8b 45 10             	mov    0x10(%ebp),%eax
c002a9e7:	8b 55 08             	mov    0x8(%ebp),%edx
c002a9ea:	89 10                	mov    %edx,(%eax)
  return token;
c002a9ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a9ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a9f2:	c9                   	leave  
c002a9f3:	c3                   	ret    

c002a9f4 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c002a9f4:	55                   	push   %ebp
c002a9f5:	89 e5                	mov    %esp,%ebp
c002a9f7:	53                   	push   %ebx
c002a9f8:	83 ec 14             	sub    $0x14,%esp
c002a9fb:	e8 28 6a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002aa00:	05 78 f9 00 00       	add    $0xf978,%eax
  unsigned char *dst = dst_;
c002aa05:	8b 55 08             	mov    0x8(%ebp),%edx
c002aa08:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (dst != NULL || size == 0);
c002aa0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002aa0f:	75 3f                	jne    c002aa50 <memset+0x5c>
c002aa11:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002aa15:	74 39                	je     c002aa50 <memset+0x5c>
c002aa17:	83 ec 0c             	sub    $0xc,%esp
c002aa1a:	8d 90 fc 93 ff ff    	lea    -0x6c04(%eax),%edx
c002aa20:	52                   	push   %edx
c002aa21:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002aa27:	52                   	push   %edx
c002aa28:	8d 90 48 95 ff ff    	lea    -0x6ab8(%eax),%edx
c002aa2e:	52                   	push   %edx
c002aa2f:	68 1b 01 00 00       	push   $0x11b
c002aa34:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002aa3a:	52                   	push   %edx
c002aa3b:	89 c3                	mov    %eax,%ebx
c002aa3d:	e8 22 0d 00 00       	call   c002b764 <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c002aa42:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aa45:	8d 50 01             	lea    0x1(%eax),%edx
c002aa48:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002aa4b:	8b 55 0c             	mov    0xc(%ebp),%edx
c002aa4e:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c002aa50:	8b 45 10             	mov    0x10(%ebp),%eax
c002aa53:	8d 50 ff             	lea    -0x1(%eax),%edx
c002aa56:	89 55 10             	mov    %edx,0x10(%ebp)
c002aa59:	85 c0                	test   %eax,%eax
c002aa5b:	75 e5                	jne    c002aa42 <memset+0x4e>

  return dst_;
c002aa5d:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002aa60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002aa63:	c9                   	leave  
c002aa64:	c3                   	ret    

c002aa65 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c002aa65:	55                   	push   %ebp
c002aa66:	89 e5                	mov    %esp,%ebp
c002aa68:	53                   	push   %ebx
c002aa69:	83 ec 14             	sub    $0x14,%esp
c002aa6c:	e8 b7 69 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002aa71:	05 07 f9 00 00       	add    $0xf907,%eax
  const char *p;

  ASSERT (string != NULL);
c002aa76:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aa7a:	75 2b                	jne    c002aaa7 <strlen+0x42>
c002aa7c:	83 ec 0c             	sub    $0xc,%esp
c002aa7f:	8d 90 b5 94 ff ff    	lea    -0x6b4b(%eax),%edx
c002aa85:	52                   	push   %edx
c002aa86:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002aa8c:	52                   	push   %edx
c002aa8d:	8d 90 50 95 ff ff    	lea    -0x6ab0(%eax),%edx
c002aa93:	52                   	push   %edx
c002aa94:	68 29 01 00 00       	push   $0x129
c002aa99:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002aa9f:	52                   	push   %edx
c002aaa0:	89 c3                	mov    %eax,%ebx
c002aaa2:	e8 bd 0c 00 00       	call   c002b764 <debug_panic>

  for (p = string; *p != '\0'; p++)
c002aaa7:	8b 45 08             	mov    0x8(%ebp),%eax
c002aaaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002aaad:	eb 05                	jmp    c002aab4 <strlen+0x4f>
    continue;
c002aaaf:	90                   	nop
  for (p = string; *p != '\0'; p++)
c002aab0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002aab4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aab7:	0f b6 00             	movzbl (%eax),%eax
c002aaba:	84 c0                	test   %al,%al
c002aabc:	75 f1                	jne    c002aaaf <strlen+0x4a>
  return p - string;
c002aabe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aac1:	2b 45 08             	sub    0x8(%ebp),%eax
}
c002aac4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002aac7:	c9                   	leave  
c002aac8:	c3                   	ret    

c002aac9 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c002aac9:	55                   	push   %ebp
c002aaca:	89 e5                	mov    %esp,%ebp
c002aacc:	83 ec 10             	sub    $0x10,%esp
c002aacf:	e8 54 69 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002aad4:	05 a4 f8 00 00       	add    $0xf8a4,%eax
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c002aad9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002aae0:	eb 05                	jmp    c002aae7 <strnlen+0x1e>
    continue;
c002aae2:	90                   	nop
  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c002aae3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c002aae7:	8b 55 08             	mov    0x8(%ebp),%edx
c002aaea:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002aaed:	01 d0                	add    %edx,%eax
c002aaef:	0f b6 00             	movzbl (%eax),%eax
c002aaf2:	84 c0                	test   %al,%al
c002aaf4:	74 08                	je     c002aafe <strnlen+0x35>
c002aaf6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002aaf9:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aafc:	72 e4                	jb     c002aae2 <strnlen+0x19>
  return length;
c002aafe:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002ab01:	c9                   	leave  
c002ab02:	c3                   	ret    

c002ab03 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c002ab03:	55                   	push   %ebp
c002ab04:	89 e5                	mov    %esp,%ebp
c002ab06:	53                   	push   %ebx
c002ab07:	83 ec 14             	sub    $0x14,%esp
c002ab0a:	e8 19 69 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002ab0f:	05 69 f8 00 00       	add    $0xf869,%eax
  size_t src_len;

  ASSERT (dst != NULL);
c002ab14:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ab18:	75 2b                	jne    c002ab45 <strlcpy+0x42>
c002ab1a:	83 ec 0c             	sub    $0xc,%esp
c002ab1d:	8d 90 f2 94 ff ff    	lea    -0x6b0e(%eax),%edx
c002ab23:	52                   	push   %edx
c002ab24:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002ab2a:	52                   	push   %edx
c002ab2b:	8d 90 58 95 ff ff    	lea    -0x6aa8(%eax),%edx
c002ab31:	52                   	push   %edx
c002ab32:	68 4a 01 00 00       	push   $0x14a
c002ab37:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002ab3d:	52                   	push   %edx
c002ab3e:	89 c3                	mov    %eax,%ebx
c002ab40:	e8 1f 0c 00 00       	call   c002b764 <debug_panic>
  ASSERT (src != NULL);
c002ab45:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ab49:	75 2b                	jne    c002ab76 <strlcpy+0x73>
c002ab4b:	83 ec 0c             	sub    $0xc,%esp
c002ab4e:	8d 90 fe 94 ff ff    	lea    -0x6b02(%eax),%edx
c002ab54:	52                   	push   %edx
c002ab55:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002ab5b:	52                   	push   %edx
c002ab5c:	8d 90 58 95 ff ff    	lea    -0x6aa8(%eax),%edx
c002ab62:	52                   	push   %edx
c002ab63:	68 4b 01 00 00       	push   $0x14b
c002ab68:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002ab6e:	52                   	push   %edx
c002ab6f:	89 c3                	mov    %eax,%ebx
c002ab71:	e8 ee 0b 00 00       	call   c002b764 <debug_panic>

  src_len = strlen (src);
c002ab76:	83 ec 0c             	sub    $0xc,%esp
c002ab79:	ff 75 0c             	push   0xc(%ebp)
c002ab7c:	e8 e4 fe ff ff       	call   c002aa65 <strlen>
c002ab81:	83 c4 10             	add    $0x10,%esp
c002ab84:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (size > 0) 
c002ab87:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002ab8b:	74 36                	je     c002abc3 <strlcpy+0xc0>
    {
      size_t dst_len = size - 1;
c002ab8d:	8b 45 10             	mov    0x10(%ebp),%eax
c002ab90:	83 e8 01             	sub    $0x1,%eax
c002ab93:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < dst_len)
c002ab96:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ab99:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002ab9c:	73 06                	jae    c002aba4 <strlcpy+0xa1>
        dst_len = src_len;
c002ab9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002aba1:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst, src, dst_len);
c002aba4:	83 ec 04             	sub    $0x4,%esp
c002aba7:	ff 75 f4             	push   -0xc(%ebp)
c002abaa:	ff 75 0c             	push   0xc(%ebp)
c002abad:	ff 75 08             	push   0x8(%ebp)
c002abb0:	e8 23 f7 ff ff       	call   c002a2d8 <memcpy>
c002abb5:	83 c4 10             	add    $0x10,%esp
      dst[dst_len] = '\0';
c002abb8:	8b 55 08             	mov    0x8(%ebp),%edx
c002abbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002abbe:	01 d0                	add    %edx,%eax
c002abc0:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len;
c002abc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002abc6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002abc9:	c9                   	leave  
c002abca:	c3                   	ret    

c002abcb <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c002abcb:	55                   	push   %ebp
c002abcc:	89 e5                	mov    %esp,%ebp
c002abce:	53                   	push   %ebx
c002abcf:	83 ec 14             	sub    $0x14,%esp
c002abd2:	e8 51 68 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002abd7:	05 a1 f7 00 00       	add    $0xf7a1,%eax
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c002abdc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002abe0:	75 2b                	jne    c002ac0d <strlcat+0x42>
c002abe2:	83 ec 0c             	sub    $0xc,%esp
c002abe5:	8d 90 f2 94 ff ff    	lea    -0x6b0e(%eax),%edx
c002abeb:	52                   	push   %edx
c002abec:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002abf2:	52                   	push   %edx
c002abf3:	8d 90 60 95 ff ff    	lea    -0x6aa0(%eax),%edx
c002abf9:	52                   	push   %edx
c002abfa:	68 68 01 00 00       	push   $0x168
c002abff:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002ac05:	52                   	push   %edx
c002ac06:	89 c3                	mov    %eax,%ebx
c002ac08:	e8 57 0b 00 00       	call   c002b764 <debug_panic>
  ASSERT (src != NULL);
c002ac0d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ac11:	75 2b                	jne    c002ac3e <strlcat+0x73>
c002ac13:	83 ec 0c             	sub    $0xc,%esp
c002ac16:	8d 90 fe 94 ff ff    	lea    -0x6b02(%eax),%edx
c002ac1c:	52                   	push   %edx
c002ac1d:	8d 90 15 94 ff ff    	lea    -0x6beb(%eax),%edx
c002ac23:	52                   	push   %edx
c002ac24:	8d 90 60 95 ff ff    	lea    -0x6aa0(%eax),%edx
c002ac2a:	52                   	push   %edx
c002ac2b:	68 69 01 00 00       	push   $0x169
c002ac30:	8d 90 2c 94 ff ff    	lea    -0x6bd4(%eax),%edx
c002ac36:	52                   	push   %edx
c002ac37:	89 c3                	mov    %eax,%ebx
c002ac39:	e8 26 0b 00 00       	call   c002b764 <debug_panic>

  src_len = strlen (src);
c002ac3e:	83 ec 0c             	sub    $0xc,%esp
c002ac41:	ff 75 0c             	push   0xc(%ebp)
c002ac44:	e8 1c fe ff ff       	call   c002aa65 <strlen>
c002ac49:	83 c4 10             	add    $0x10,%esp
c002ac4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  dst_len = strlen (dst);
c002ac4f:	83 ec 0c             	sub    $0xc,%esp
c002ac52:	ff 75 08             	push   0x8(%ebp)
c002ac55:	e8 0b fe ff ff       	call   c002aa65 <strlen>
c002ac5a:	83 c4 10             	add    $0x10,%esp
c002ac5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size > 0 && dst_len < size) 
c002ac60:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002ac64:	74 4c                	je     c002acb2 <strlcat+0xe7>
c002ac66:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ac69:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ac6c:	73 44                	jae    c002acb2 <strlcat+0xe7>
    {
      size_t copy_cnt = size - dst_len - 1;
c002ac6e:	8b 45 10             	mov    0x10(%ebp),%eax
c002ac71:	2b 45 ec             	sub    -0x14(%ebp),%eax
c002ac74:	83 e8 01             	sub    $0x1,%eax
c002ac77:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < copy_cnt)
c002ac7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ac7d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002ac80:	73 06                	jae    c002ac88 <strlcat+0xbd>
        copy_cnt = src_len;
c002ac82:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ac85:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst + dst_len, src, copy_cnt);
c002ac88:	8b 55 08             	mov    0x8(%ebp),%edx
c002ac8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ac8e:	01 d0                	add    %edx,%eax
c002ac90:	83 ec 04             	sub    $0x4,%esp
c002ac93:	ff 75 f4             	push   -0xc(%ebp)
c002ac96:	ff 75 0c             	push   0xc(%ebp)
c002ac99:	50                   	push   %eax
c002ac9a:	e8 39 f6 ff ff       	call   c002a2d8 <memcpy>
c002ac9f:	83 c4 10             	add    $0x10,%esp
      dst[dst_len + copy_cnt] = '\0';
c002aca2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002aca5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aca8:	01 c2                	add    %eax,%edx
c002acaa:	8b 45 08             	mov    0x8(%ebp),%eax
c002acad:	01 d0                	add    %edx,%eax
c002acaf:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len + dst_len;
c002acb2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002acb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002acb8:	01 d0                	add    %edx,%eax
}
c002acba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002acbd:	c9                   	leave  
c002acbe:	c3                   	ret    

c002acbf <divl>:
   yield a 32-bit quotient.  Returns the quotient.
   Traps with a divide error (#DE) if the quotient does not fit
   in 32 bits. */
static inline uint32_t
divl (uint64_t n, uint32_t d)
{
c002acbf:	55                   	push   %ebp
c002acc0:	89 e5                	mov    %esp,%ebp
c002acc2:	83 ec 18             	sub    $0x18,%esp
c002acc5:	e8 5e 67 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002acca:	05 ae f6 00 00       	add    $0xf6ae,%eax
c002accf:	8b 45 08             	mov    0x8(%ebp),%eax
c002acd2:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002acd5:	8b 45 0c             	mov    0xc(%ebp),%eax
c002acd8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t n1 = n >> 32;
c002acdb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002acde:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002ace1:	89 d0                	mov    %edx,%eax
c002ace3:	31 d2                	xor    %edx,%edx
c002ace5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  uint32_t n0 = n;
c002ace8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002aceb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  uint32_t q, r;

  asm ("divl %4"
c002acee:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002acf1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002acf4:	f7 75 10             	divl   0x10(%ebp)
c002acf7:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002acfa:	89 45 f0             	mov    %eax,-0x10(%ebp)
       : "=d" (r), "=a" (q)
       : "0" (n1), "1" (n0), "rm" (d));

  return q;
c002acfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002ad00:	c9                   	leave  
c002ad01:	c3                   	ret    

c002ad02 <nlz>:

/* Returns the number of leading zero bits in X,
   which must be nonzero. */
static int
nlz (uint32_t x) 
{
c002ad02:	55                   	push   %ebp
c002ad03:	89 e5                	mov    %esp,%ebp
c002ad05:	83 ec 10             	sub    $0x10,%esp
c002ad08:	e8 1b 67 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002ad0d:	05 6b f6 00 00       	add    $0xf66b,%eax
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c002ad12:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (x <= 0x0000FFFF)
c002ad19:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
c002ad20:	77 08                	ja     c002ad2a <nlz+0x28>
    {
      n += 16;
c002ad22:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
      x <<= 16; 
c002ad26:	c1 65 08 10          	shll   $0x10,0x8(%ebp)
    }
  if (x <= 0x00FFFFFF)
c002ad2a:	81 7d 08 ff ff ff 00 	cmpl   $0xffffff,0x8(%ebp)
c002ad31:	77 08                	ja     c002ad3b <nlz+0x39>
    {
      n += 8;
c002ad33:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
      x <<= 8; 
c002ad37:	c1 65 08 08          	shll   $0x8,0x8(%ebp)
    }
  if (x <= 0x0FFFFFFF)
c002ad3b:	81 7d 08 ff ff ff 0f 	cmpl   $0xfffffff,0x8(%ebp)
c002ad42:	77 08                	ja     c002ad4c <nlz+0x4a>
    {
      n += 4;
c002ad44:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
      x <<= 4;
c002ad48:	c1 65 08 04          	shll   $0x4,0x8(%ebp)
    }
  if (x <= 0x3FFFFFFF)
c002ad4c:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
c002ad53:	77 08                	ja     c002ad5d <nlz+0x5b>
    {
      n += 2;
c002ad55:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
      x <<= 2; 
c002ad59:	c1 65 08 02          	shll   $0x2,0x8(%ebp)
    }
  if (x <= 0x7FFFFFFF)
c002ad5d:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad60:	85 c0                	test   %eax,%eax
c002ad62:	78 04                	js     c002ad68 <nlz+0x66>
    n++;
c002ad64:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return n;
c002ad68:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002ad6b:	c9                   	leave  
c002ad6c:	c3                   	ret    

c002ad6d <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c002ad6d:	55                   	push   %ebp
c002ad6e:	89 e5                	mov    %esp,%ebp
c002ad70:	57                   	push   %edi
c002ad71:	56                   	push   %esi
c002ad72:	53                   	push   %ebx
c002ad73:	83 ec 44             	sub    $0x44,%esp
c002ad76:	e8 ad 66 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002ad7b:	05 fd f5 00 00       	add    $0xf5fd,%eax
c002ad80:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad83:	89 45 b8             	mov    %eax,-0x48(%ebp)
c002ad86:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ad89:	89 45 bc             	mov    %eax,-0x44(%ebp)
c002ad8c:	8b 45 10             	mov    0x10(%ebp),%eax
c002ad8f:	89 45 b0             	mov    %eax,-0x50(%ebp)
c002ad92:	8b 45 14             	mov    0x14(%ebp),%eax
c002ad95:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if ((d >> 32) == 0) 
c002ad98:	8b 45 b0             	mov    -0x50(%ebp),%eax
c002ad9b:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c002ad9e:	89 d0                	mov    %edx,%eax
c002ada0:	31 d2                	xor    %edx,%edx
c002ada2:	89 c7                	mov    %eax,%edi
c002ada4:	83 f7 00             	xor    $0x0,%edi
c002ada7:	89 f9                	mov    %edi,%ecx
c002ada9:	89 d0                	mov    %edx,%eax
c002adab:	80 f4 00             	xor    $0x0,%ah
c002adae:	89 c3                	mov    %eax,%ebx
c002adb0:	89 d8                	mov    %ebx,%eax
c002adb2:	09 c8                	or     %ecx,%eax
c002adb4:	85 c0                	test   %eax,%eax
c002adb6:	0f 85 a3 00 00 00    	jne    c002ae5f <udiv64+0xf2>
             <=> [(bd - 1)/d] < b
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
c002adbc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c002adc3:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
      uint32_t n1 = n >> 32;
c002adca:	8b 45 b8             	mov    -0x48(%ebp),%eax
c002adcd:	8b 55 bc             	mov    -0x44(%ebp),%edx
c002add0:	89 d0                	mov    %edx,%eax
c002add2:	31 d2                	xor    %edx,%edx
c002add4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      uint32_t n0 = n; 
c002add7:	8b 45 b8             	mov    -0x48(%ebp),%eax
c002adda:	89 45 d0             	mov    %eax,-0x30(%ebp)
      uint32_t d0 = d;
c002addd:	8b 45 b0             	mov    -0x50(%ebp),%eax
c002ade0:	89 45 cc             	mov    %eax,-0x34(%ebp)

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c002ade3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002ade6:	ba 00 00 00 00       	mov    $0x0,%edx
c002adeb:	f7 75 cc             	divl   -0x34(%ebp)
c002adee:	89 d0                	mov    %edx,%eax
c002adf0:	ba 00 00 00 00       	mov    $0x0,%edx
c002adf5:	8b 4d d8             	mov    -0x28(%ebp),%ecx
c002adf8:	89 cb                	mov    %ecx,%ebx
c002adfa:	0f af da             	imul   %edx,%ebx
c002adfd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
c002ae00:	0f af c8             	imul   %eax,%ecx
c002ae03:	01 d9                	add    %ebx,%ecx
c002ae05:	f7 65 d8             	mull   -0x28(%ebp)
c002ae08:	01 d1                	add    %edx,%ecx
c002ae0a:	89 ca                	mov    %ecx,%edx
c002ae0c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
c002ae0f:	bb 00 00 00 00       	mov    $0x0,%ebx
c002ae14:	01 c8                	add    %ecx,%eax
c002ae16:	11 da                	adc    %ebx,%edx
c002ae18:	83 ec 04             	sub    $0x4,%esp
c002ae1b:	ff 75 cc             	push   -0x34(%ebp)
c002ae1e:	52                   	push   %edx
c002ae1f:	50                   	push   %eax
c002ae20:	e8 9a fe ff ff       	call   c002acbf <divl>
c002ae25:	83 c4 10             	add    $0x10,%esp
c002ae28:	89 c6                	mov    %eax,%esi
c002ae2a:	bf 00 00 00 00       	mov    $0x0,%edi
c002ae2f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002ae32:	ba 00 00 00 00       	mov    $0x0,%edx
c002ae37:	f7 75 cc             	divl   -0x34(%ebp)
c002ae3a:	ba 00 00 00 00       	mov    $0x0,%edx
c002ae3f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
c002ae42:	89 cb                	mov    %ecx,%ebx
c002ae44:	0f af da             	imul   %edx,%ebx
c002ae47:	8b 4d dc             	mov    -0x24(%ebp),%ecx
c002ae4a:	0f af c8             	imul   %eax,%ecx
c002ae4d:	01 d9                	add    %ebx,%ecx
c002ae4f:	f7 65 d8             	mull   -0x28(%ebp)
c002ae52:	01 d1                	add    %edx,%ecx
c002ae54:	89 ca                	mov    %ecx,%edx
c002ae56:	01 f0                	add    %esi,%eax
c002ae58:	11 fa                	adc    %edi,%edx
c002ae5a:	e9 df 00 00 00       	jmp    c002af3e <udiv64+0x1d1>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c002ae5f:	8b 45 b8             	mov    -0x48(%ebp),%eax
c002ae62:	8b 55 bc             	mov    -0x44(%ebp),%edx
c002ae65:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c002ae68:	89 d0                	mov    %edx,%eax
c002ae6a:	1b 45 b4             	sbb    -0x4c(%ebp),%eax
c002ae6d:	73 0f                	jae    c002ae7e <udiv64+0x111>
        return 0;
c002ae6f:	b8 00 00 00 00       	mov    $0x0,%eax
c002ae74:	ba 00 00 00 00       	mov    $0x0,%edx
c002ae79:	e9 c0 00 00 00       	jmp    c002af3e <udiv64+0x1d1>
      else 
        {
          uint32_t d1 = d >> 32;
c002ae7e:	8b 45 b0             	mov    -0x50(%ebp),%eax
c002ae81:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c002ae84:	89 d0                	mov    %edx,%eax
c002ae86:	31 d2                	xor    %edx,%edx
c002ae88:	89 45 ec             	mov    %eax,-0x14(%ebp)
          int s = nlz (d1);
c002ae8b:	83 ec 04             	sub    $0x4,%esp
c002ae8e:	ff 75 ec             	push   -0x14(%ebp)
c002ae91:	e8 6c fe ff ff       	call   c002ad02 <nlz>
c002ae96:	83 c4 08             	add    $0x8,%esp
c002ae99:	89 45 e8             	mov    %eax,-0x18(%ebp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c002ae9c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002ae9f:	8b 45 b0             	mov    -0x50(%ebp),%eax
c002aea2:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c002aea5:	0f a5 c2             	shld   %cl,%eax,%edx
c002aea8:	d3 e0                	shl    %cl,%eax
c002aeaa:	f6 c1 20             	test   $0x20,%cl
c002aead:	74 04                	je     c002aeb3 <udiv64+0x146>
c002aeaf:	89 c2                	mov    %eax,%edx
c002aeb1:	31 c0                	xor    %eax,%eax
c002aeb3:	89 d0                	mov    %edx,%eax
c002aeb5:	31 d2                	xor    %edx,%edx
c002aeb7:	89 c1                	mov    %eax,%ecx
c002aeb9:	8b 45 b8             	mov    -0x48(%ebp),%eax
c002aebc:	8b 55 bc             	mov    -0x44(%ebp),%edx
c002aebf:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c002aec3:	d1 ea                	shr    %edx
c002aec5:	83 ec 04             	sub    $0x4,%esp
c002aec8:	51                   	push   %ecx
c002aec9:	52                   	push   %edx
c002aeca:	50                   	push   %eax
c002aecb:	e8 ef fd ff ff       	call   c002acbf <divl>
c002aed0:	83 c4 10             	add    $0x10,%esp
c002aed3:	89 c2                	mov    %eax,%edx
c002aed5:	b8 1f 00 00 00       	mov    $0x1f,%eax
c002aeda:	2b 45 e8             	sub    -0x18(%ebp),%eax
c002aedd:	89 c1                	mov    %eax,%ecx
c002aedf:	d3 ea                	shr    %cl,%edx
c002aee1:	89 d0                	mov    %edx,%eax
c002aee3:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002aee6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c002aeed:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002aef0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002aef3:	83 c0 ff             	add    $0xffffffff,%eax
c002aef6:	83 d2 ff             	adc    $0xffffffff,%edx
c002aef9:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c002aefc:	89 cb                	mov    %ecx,%ebx
c002aefe:	0f af da             	imul   %edx,%ebx
c002af01:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c002af04:	0f af c8             	imul   %eax,%ecx
c002af07:	8d 34 0b             	lea    (%ebx,%ecx,1),%esi
c002af0a:	f7 65 b0             	mull   -0x50(%ebp)
c002af0d:	89 c1                	mov    %eax,%ecx
c002af0f:	89 d3                	mov    %edx,%ebx
c002af11:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c002af14:	89 c3                	mov    %eax,%ebx
c002af16:	8b 45 b8             	mov    -0x48(%ebp),%eax
c002af19:	8b 55 bc             	mov    -0x44(%ebp),%edx
c002af1c:	29 c8                	sub    %ecx,%eax
c002af1e:	19 da                	sbb    %ebx,%edx
c002af20:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c002af23:	89 d0                	mov    %edx,%eax
c002af25:	1b 45 b4             	sbb    -0x4c(%ebp),%eax
c002af28:	73 0e                	jae    c002af38 <udiv64+0x1cb>
c002af2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002af2d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002af30:	83 c0 ff             	add    $0xffffffff,%eax
c002af33:	83 d2 ff             	adc    $0xffffffff,%edx
c002af36:	eb 06                	jmp    c002af3e <udiv64+0x1d1>
c002af38:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002af3b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
        }
    }
}
c002af3e:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002af41:	5b                   	pop    %ebx
c002af42:	5e                   	pop    %esi
c002af43:	5f                   	pop    %edi
c002af44:	5d                   	pop    %ebp
c002af45:	c3                   	ret    

c002af46 <umod64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
c002af46:	55                   	push   %ebp
c002af47:	89 e5                	mov    %esp,%ebp
c002af49:	53                   	push   %ebx
c002af4a:	83 ec 14             	sub    $0x14,%esp
c002af4d:	e8 d6 64 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002af52:	05 26 f4 00 00       	add    $0xf426,%eax
c002af57:	8b 45 08             	mov    0x8(%ebp),%eax
c002af5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002af5d:	8b 45 0c             	mov    0xc(%ebp),%eax
c002af60:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002af63:	8b 45 10             	mov    0x10(%ebp),%eax
c002af66:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002af69:	8b 45 14             	mov    0x14(%ebp),%eax
c002af6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * udiv64 (n, d);
c002af6f:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c002af72:	ff 75 ec             	push   -0x14(%ebp)
c002af75:	ff 75 e8             	push   -0x18(%ebp)
c002af78:	ff 75 f4             	push   -0xc(%ebp)
c002af7b:	ff 75 f0             	push   -0x10(%ebp)
c002af7e:	e8 ea fd ff ff       	call   c002ad6d <udiv64>
c002af83:	83 c4 10             	add    $0x10,%esp
c002af86:	89 c2                	mov    %eax,%edx
c002af88:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002af8b:	0f af d0             	imul   %eax,%edx
c002af8e:	89 d8                	mov    %ebx,%eax
c002af90:	29 d0                	sub    %edx,%eax
}
c002af92:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002af95:	c9                   	leave  
c002af96:	c3                   	ret    

c002af97 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c002af97:	55                   	push   %ebp
c002af98:	89 e5                	mov    %esp,%ebp
c002af9a:	57                   	push   %edi
c002af9b:	56                   	push   %esi
c002af9c:	83 ec 30             	sub    $0x30,%esp
c002af9f:	e8 84 64 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002afa4:	05 d4 f3 00 00       	add    $0xf3d4,%eax
c002afa9:	8b 45 08             	mov    0x8(%ebp),%eax
c002afac:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002afaf:	8b 45 0c             	mov    0xc(%ebp),%eax
c002afb2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c002afb5:	8b 45 10             	mov    0x10(%ebp),%eax
c002afb8:	89 45 c8             	mov    %eax,-0x38(%ebp)
c002afbb:	8b 45 14             	mov    0x14(%ebp),%eax
c002afbe:	89 45 cc             	mov    %eax,-0x34(%ebp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c002afc1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002afc5:	79 0f                	jns    c002afd6 <sdiv64+0x3f>
c002afc7:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002afca:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002afcd:	f7 d8                	neg    %eax
c002afcf:	83 d2 00             	adc    $0x0,%edx
c002afd2:	f7 da                	neg    %edx
c002afd4:	eb 06                	jmp    c002afdc <sdiv64+0x45>
c002afd6:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002afd9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002afdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002afdf:	89 55 f4             	mov    %edx,-0xc(%ebp)
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c002afe2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c002afe6:	79 0f                	jns    c002aff7 <sdiv64+0x60>
c002afe8:	8b 45 c8             	mov    -0x38(%ebp),%eax
c002afeb:	8b 55 cc             	mov    -0x34(%ebp),%edx
c002afee:	f7 d8                	neg    %eax
c002aff0:	83 d2 00             	adc    $0x0,%edx
c002aff3:	f7 da                	neg    %edx
c002aff5:	eb 06                	jmp    c002affd <sdiv64+0x66>
c002aff7:	8b 45 c8             	mov    -0x38(%ebp),%eax
c002affa:	8b 55 cc             	mov    -0x34(%ebp),%edx
c002affd:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002b000:	89 55 ec             	mov    %edx,-0x14(%ebp)
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c002b003:	ff 75 ec             	push   -0x14(%ebp)
c002b006:	ff 75 e8             	push   -0x18(%ebp)
c002b009:	ff 75 f4             	push   -0xc(%ebp)
c002b00c:	ff 75 f0             	push   -0x10(%ebp)
c002b00f:	e8 59 fd ff ff       	call   c002ad6d <udiv64>
c002b014:	83 c4 10             	add    $0x10,%esp
c002b017:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002b01a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c002b01d:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002b020:	33 45 c8             	xor    -0x38(%ebp),%eax
c002b023:	89 c6                	mov    %eax,%esi
c002b025:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002b028:	33 45 cc             	xor    -0x34(%ebp),%eax
c002b02b:	89 c7                	mov    %eax,%edi
c002b02d:	85 ff                	test   %edi,%edi
c002b02f:	79 0f                	jns    c002b040 <sdiv64+0xa9>
c002b031:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002b034:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002b037:	f7 d8                	neg    %eax
c002b039:	83 d2 00             	adc    $0x0,%edx
c002b03c:	f7 da                	neg    %edx
c002b03e:	eb 06                	jmp    c002b046 <sdiv64+0xaf>
c002b040:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002b043:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}
c002b046:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002b049:	5e                   	pop    %esi
c002b04a:	5f                   	pop    %edi
c002b04b:	5d                   	pop    %ebp
c002b04c:	c3                   	ret    

c002b04d <smod64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
c002b04d:	55                   	push   %ebp
c002b04e:	89 e5                	mov    %esp,%ebp
c002b050:	53                   	push   %ebx
c002b051:	83 ec 14             	sub    $0x14,%esp
c002b054:	e8 cf 63 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b059:	05 1f f3 00 00       	add    $0xf31f,%eax
c002b05e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b061:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b064:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b067:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b06a:	8b 45 10             	mov    0x10(%ebp),%eax
c002b06d:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002b070:	8b 45 14             	mov    0x14(%ebp),%eax
c002b073:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * sdiv64 (n, d);
c002b076:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c002b079:	ff 75 ec             	push   -0x14(%ebp)
c002b07c:	ff 75 e8             	push   -0x18(%ebp)
c002b07f:	ff 75 f4             	push   -0xc(%ebp)
c002b082:	ff 75 f0             	push   -0x10(%ebp)
c002b085:	e8 0d ff ff ff       	call   c002af97 <sdiv64>
c002b08a:	83 c4 10             	add    $0x10,%esp
c002b08d:	89 c2                	mov    %eax,%edx
c002b08f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b092:	0f af d0             	imul   %eax,%edx
c002b095:	89 d8                	mov    %ebx,%eax
c002b097:	29 d0                	sub    %edx,%eax
}
c002b099:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b09c:	c9                   	leave  
c002b09d:	c3                   	ret    

c002b09e <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c002b09e:	55                   	push   %ebp
c002b09f:	89 e5                	mov    %esp,%ebp
c002b0a1:	83 ec 10             	sub    $0x10,%esp
c002b0a4:	e8 7f 63 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b0a9:	05 cf f2 00 00       	add    $0xf2cf,%eax
c002b0ae:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0b1:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002b0b4:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b0b7:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002b0ba:	8b 45 10             	mov    0x10(%ebp),%eax
c002b0bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b0c0:	8b 45 14             	mov    0x14(%ebp),%eax
c002b0c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return sdiv64 (n, d);
c002b0c6:	ff 75 f4             	push   -0xc(%ebp)
c002b0c9:	ff 75 f0             	push   -0x10(%ebp)
c002b0cc:	ff 75 fc             	push   -0x4(%ebp)
c002b0cf:	ff 75 f8             	push   -0x8(%ebp)
c002b0d2:	e8 c0 fe ff ff       	call   c002af97 <sdiv64>
c002b0d7:	83 c4 10             	add    $0x10,%esp
}
c002b0da:	c9                   	leave  
c002b0db:	c3                   	ret    

c002b0dc <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c002b0dc:	55                   	push   %ebp
c002b0dd:	89 e5                	mov    %esp,%ebp
c002b0df:	83 ec 10             	sub    $0x10,%esp
c002b0e2:	e8 41 63 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b0e7:	05 91 f2 00 00       	add    $0xf291,%eax
c002b0ec:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002b0f2:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b0f5:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002b0f8:	8b 45 10             	mov    0x10(%ebp),%eax
c002b0fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b0fe:	8b 45 14             	mov    0x14(%ebp),%eax
c002b101:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return smod64 (n, d);
c002b104:	ff 75 f4             	push   -0xc(%ebp)
c002b107:	ff 75 f0             	push   -0x10(%ebp)
c002b10a:	ff 75 fc             	push   -0x4(%ebp)
c002b10d:	ff 75 f8             	push   -0x8(%ebp)
c002b110:	e8 38 ff ff ff       	call   c002b04d <smod64>
c002b115:	83 c4 10             	add    $0x10,%esp
c002b118:	99                   	cltd   
}
c002b119:	c9                   	leave  
c002b11a:	c3                   	ret    

c002b11b <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c002b11b:	55                   	push   %ebp
c002b11c:	89 e5                	mov    %esp,%ebp
c002b11e:	83 ec 10             	sub    $0x10,%esp
c002b121:	e8 02 63 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b126:	05 52 f2 00 00       	add    $0xf252,%eax
c002b12b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b12e:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002b131:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b134:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002b137:	8b 45 10             	mov    0x10(%ebp),%eax
c002b13a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b13d:	8b 45 14             	mov    0x14(%ebp),%eax
c002b140:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return udiv64 (n, d);
c002b143:	ff 75 f4             	push   -0xc(%ebp)
c002b146:	ff 75 f0             	push   -0x10(%ebp)
c002b149:	ff 75 fc             	push   -0x4(%ebp)
c002b14c:	ff 75 f8             	push   -0x8(%ebp)
c002b14f:	e8 19 fc ff ff       	call   c002ad6d <udiv64>
c002b154:	83 c4 10             	add    $0x10,%esp
}
c002b157:	c9                   	leave  
c002b158:	c3                   	ret    

c002b159 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c002b159:	55                   	push   %ebp
c002b15a:	89 e5                	mov    %esp,%ebp
c002b15c:	83 ec 10             	sub    $0x10,%esp
c002b15f:	e8 c4 62 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b164:	05 14 f2 00 00       	add    $0xf214,%eax
c002b169:	8b 45 08             	mov    0x8(%ebp),%eax
c002b16c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002b16f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b172:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002b175:	8b 45 10             	mov    0x10(%ebp),%eax
c002b178:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b17b:	8b 45 14             	mov    0x14(%ebp),%eax
c002b17e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return umod64 (n, d);
c002b181:	ff 75 f4             	push   -0xc(%ebp)
c002b184:	ff 75 f0             	push   -0x10(%ebp)
c002b187:	ff 75 fc             	push   -0x4(%ebp)
c002b18a:	ff 75 f8             	push   -0x8(%ebp)
c002b18d:	e8 b4 fd ff ff       	call   c002af46 <umod64>
c002b192:	83 c4 10             	add    $0x10,%esp
c002b195:	ba 00 00 00 00       	mov    $0x0,%edx
}
c002b19a:	c9                   	leave  
c002b19b:	c3                   	ret    

c002b19c <calculate_chksum>:
PACKED;

/* Returns the checksum for the given ustar format HEADER. */
static unsigned int
calculate_chksum (const struct ustar_header *h)
{
c002b19c:	55                   	push   %ebp
c002b19d:	89 e5                	mov    %esp,%ebp
c002b19f:	83 ec 20             	sub    $0x20,%esp
c002b1a2:	e8 81 62 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b1a7:	05 d1 f1 00 00       	add    $0xf1d1,%eax
  const uint8_t *header = (const uint8_t *) h;
c002b1ac:	8b 45 08             	mov    0x8(%ebp),%eax
c002b1af:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int chksum;
  size_t i;

  chksum = 0;
c002b1b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c002b1b9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c002b1c0:	eb 5a                	jmp    c002b21c <calculate_chksum+0x80>
    {
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
c002b1c2:	c7 45 f0 94 00 00 00 	movl   $0x94,-0x10(%ebp)
      const size_t chksum_end = chksum_start + sizeof h->chksum;
c002b1c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b1cc:	83 c0 08             	add    $0x8,%eax
c002b1cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
c002b1d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002b1d5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b1d8:	72 0f                	jb     c002b1e9 <calculate_chksum+0x4d>
c002b1da:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002b1dd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002b1e0:	73 07                	jae    c002b1e9 <calculate_chksum+0x4d>
c002b1e2:	b8 01 00 00 00       	mov    $0x1,%eax
c002b1e7:	eb 05                	jmp    c002b1ee <calculate_chksum+0x52>
c002b1e9:	b8 00 00 00 00       	mov    $0x0,%eax
c002b1ee:	88 45 eb             	mov    %al,-0x15(%ebp)
c002b1f1:	80 65 eb 01          	andb   $0x1,-0x15(%ebp)
      chksum += in_chksum_field ? ' ' : header[i];
c002b1f5:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002b1f9:	83 f0 01             	xor    $0x1,%eax
c002b1fc:	84 c0                	test   %al,%al
c002b1fe:	74 10                	je     c002b210 <calculate_chksum+0x74>
c002b200:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b203:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002b206:	01 d0                	add    %edx,%eax
c002b208:	0f b6 00             	movzbl (%eax),%eax
c002b20b:	0f b6 c0             	movzbl %al,%eax
c002b20e:	eb 05                	jmp    c002b215 <calculate_chksum+0x79>
c002b210:	b8 20 00 00 00       	mov    $0x20,%eax
c002b215:	01 45 fc             	add    %eax,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c002b218:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c002b21c:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
c002b223:	76 9d                	jbe    c002b1c2 <calculate_chksum+0x26>
    }
  return chksum;
c002b225:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002b228:	c9                   	leave  
c002b229:	c3                   	ret    

c002b22a <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c002b22a:	55                   	push   %ebp
c002b22b:	89 e5                	mov    %esp,%ebp
c002b22d:	53                   	push   %ebx
c002b22e:	83 ec 04             	sub    $0x4,%esp
c002b231:	e8 f6 61 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002b236:	81 c3 42 f1 00 00    	add    $0xf142,%ebx
  while (*file_name == '/'
c002b23c:	eb 16                	jmp    c002b254 <strip_antisocial_prefixes+0x2a>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c002b23e:	83 ec 08             	sub    $0x8,%esp
c002b241:	6a 2f                	push   $0x2f
c002b243:	ff 75 08             	push   0x8(%ebp)
c002b246:	e8 42 f4 ff ff       	call   c002a68d <strchr>
c002b24b:	83 c4 10             	add    $0x10,%esp
c002b24e:	83 c0 01             	add    $0x1,%eax
c002b251:	89 45 08             	mov    %eax,0x8(%ebp)
  while (*file_name == '/'
c002b254:	8b 45 08             	mov    0x8(%ebp),%eax
c002b257:	0f b6 00             	movzbl (%eax),%eax
         || !memcmp (file_name, "../", 3))
c002b25a:	3c 2f                	cmp    $0x2f,%al
c002b25c:	74 e0                	je     c002b23e <strip_antisocial_prefixes+0x14>
         || !memcmp (file_name, "./", 2)
c002b25e:	83 ec 04             	sub    $0x4,%esp
c002b261:	6a 02                	push   $0x2
c002b263:	8d 83 68 95 ff ff    	lea    -0x6a98(%ebx),%eax
c002b269:	50                   	push   %eax
c002b26a:	ff 75 08             	push   0x8(%ebp)
c002b26d:	e8 02 f2 ff ff       	call   c002a474 <memcmp>
c002b272:	83 c4 10             	add    $0x10,%esp
c002b275:	85 c0                	test   %eax,%eax
c002b277:	74 c5                	je     c002b23e <strip_antisocial_prefixes+0x14>
         || !memcmp (file_name, "../", 3))
c002b279:	83 ec 04             	sub    $0x4,%esp
c002b27c:	6a 03                	push   $0x3
c002b27e:	8d 83 6b 95 ff ff    	lea    -0x6a95(%ebx),%eax
c002b284:	50                   	push   %eax
c002b285:	ff 75 08             	push   0x8(%ebp)
c002b288:	e8 e7 f1 ff ff       	call   c002a474 <memcmp>
c002b28d:	83 c4 10             	add    $0x10,%esp
c002b290:	85 c0                	test   %eax,%eax
c002b292:	74 aa                	je     c002b23e <strip_antisocial_prefixes+0x14>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c002b294:	8b 45 08             	mov    0x8(%ebp),%eax
c002b297:	0f b6 00             	movzbl (%eax),%eax
c002b29a:	84 c0                	test   %al,%al
c002b29c:	74 1e                	je     c002b2bc <strip_antisocial_prefixes+0x92>
c002b29e:	83 ec 08             	sub    $0x8,%esp
c002b2a1:	8d 83 6f 95 ff ff    	lea    -0x6a91(%ebx),%eax
c002b2a7:	50                   	push   %eax
c002b2a8:	ff 75 08             	push   0x8(%ebp)
c002b2ab:	e8 96 f2 ff ff       	call   c002a546 <strcmp>
c002b2b0:	83 c4 10             	add    $0x10,%esp
c002b2b3:	85 c0                	test   %eax,%eax
c002b2b5:	74 05                	je     c002b2bc <strip_antisocial_prefixes+0x92>
c002b2b7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2ba:	eb 06                	jmp    c002b2c2 <strip_antisocial_prefixes+0x98>
c002b2bc:	8d 83 72 95 ff ff    	lea    -0x6a8e(%ebx),%eax
}
c002b2c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b2c5:	c9                   	leave  
c002b2c6:	c3                   	ret    

c002b2c7 <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c002b2c7:	55                   	push   %ebp
c002b2c8:	89 e5                	mov    %esp,%ebp
c002b2ca:	53                   	push   %ebx
c002b2cb:	83 ec 14             	sub    $0x14,%esp
c002b2ce:	e8 59 61 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002b2d3:	81 c3 a5 f0 00 00    	add    $0xf0a5,%ebx
  struct ustar_header *h = (struct ustar_header *) header;
c002b2d9:	8b 45 14             	mov    0x14(%ebp),%eax
c002b2dc:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c002b2df:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c002b2e3:	74 2c                	je     c002b311 <ustar_make_header+0x4a>
c002b2e5:	83 7d 0c 35          	cmpl   $0x35,0xc(%ebp)
c002b2e9:	74 26                	je     c002b311 <ustar_make_header+0x4a>
c002b2eb:	83 ec 0c             	sub    $0xc,%esp
c002b2ee:	8d 83 74 95 ff ff    	lea    -0x6a8c(%ebx),%eax
c002b2f4:	50                   	push   %eax
c002b2f5:	8d 83 a5 95 ff ff    	lea    -0x6a5b(%ebx),%eax
c002b2fb:	50                   	push   %eax
c002b2fc:	8d 83 a8 96 ff ff    	lea    -0x6958(%ebx),%eax
c002b302:	50                   	push   %eax
c002b303:	6a 59                	push   $0x59
c002b305:	8d 83 bc 95 ff ff    	lea    -0x6a44(%ebx),%eax
c002b30b:	50                   	push   %eax
c002b30c:	e8 53 04 00 00       	call   c002b764 <debug_panic>

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c002b311:	83 ec 0c             	sub    $0xc,%esp
c002b314:	ff 75 08             	push   0x8(%ebp)
c002b317:	e8 0e ff ff ff       	call   c002b22a <strip_antisocial_prefixes>
c002b31c:	83 c4 10             	add    $0x10,%esp
c002b31f:	89 45 08             	mov    %eax,0x8(%ebp)
  if (strlen (file_name) > 99)
c002b322:	83 ec 0c             	sub    $0xc,%esp
c002b325:	ff 75 08             	push   0x8(%ebp)
c002b328:	e8 38 f7 ff ff       	call   c002aa65 <strlen>
c002b32d:	83 c4 10             	add    $0x10,%esp
c002b330:	83 f8 63             	cmp    $0x63,%eax
c002b333:	76 1f                	jbe    c002b354 <ustar_make_header+0x8d>
    {
      printf ("%s: file name too long\n", file_name);
c002b335:	83 ec 08             	sub    $0x8,%esp
c002b338:	ff 75 08             	push   0x8(%ebp)
c002b33b:	8d 83 ce 95 ff ff    	lea    -0x6a32(%ebx),%eax
c002b341:	50                   	push   %eax
c002b342:	e8 9e db ff ff       	call   c0028ee5 <printf>
c002b347:	83 c4 10             	add    $0x10,%esp
      return false;
c002b34a:	b8 00 00 00 00       	mov    $0x0,%eax
c002b34f:	e9 79 01 00 00       	jmp    c002b4cd <ustar_make_header+0x206>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c002b354:	83 ec 04             	sub    $0x4,%esp
c002b357:	68 00 02 00 00       	push   $0x200
c002b35c:	6a 00                	push   $0x0
c002b35e:	ff 75 f4             	push   -0xc(%ebp)
c002b361:	e8 8e f6 ff ff       	call   c002a9f4 <memset>
c002b366:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->name, file_name, sizeof h->name);
c002b369:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b36c:	83 ec 04             	sub    $0x4,%esp
c002b36f:	6a 64                	push   $0x64
c002b371:	ff 75 08             	push   0x8(%ebp)
c002b374:	50                   	push   %eax
c002b375:	e8 89 f7 ff ff       	call   c002ab03 <strlcpy>
c002b37a:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c002b37d:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c002b381:	75 07                	jne    c002b38a <ustar_make_header+0xc3>
c002b383:	b9 a4 01 00 00       	mov    $0x1a4,%ecx
c002b388:	eb 05                	jmp    c002b38f <ustar_make_header+0xc8>
c002b38a:	b9 ed 01 00 00       	mov    $0x1ed,%ecx
c002b38f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b392:	8d 50 64             	lea    0x64(%eax),%edx
c002b395:	51                   	push   %ecx
c002b396:	8d 83 e6 95 ff ff    	lea    -0x6a1a(%ebx),%eax
c002b39c:	50                   	push   %eax
c002b39d:	6a 08                	push   $0x8
c002b39f:	52                   	push   %edx
c002b3a0:	e8 0d db ff ff       	call   c0028eb2 <snprintf>
c002b3a5:	83 c4 10             	add    $0x10,%esp
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c002b3a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b3ab:	8d 50 6c             	lea    0x6c(%eax),%edx
c002b3ae:	83 ec 04             	sub    $0x4,%esp
c002b3b1:	6a 08                	push   $0x8
c002b3b3:	8d 83 eb 95 ff ff    	lea    -0x6a15(%ebx),%eax
c002b3b9:	50                   	push   %eax
c002b3ba:	52                   	push   %edx
c002b3bb:	e8 43 f7 ff ff       	call   c002ab03 <strlcpy>
c002b3c0:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->gid, "0000000", sizeof h->gid);
c002b3c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b3c6:	8d 50 74             	lea    0x74(%eax),%edx
c002b3c9:	83 ec 04             	sub    $0x4,%esp
c002b3cc:	6a 08                	push   $0x8
c002b3ce:	8d 83 eb 95 ff ff    	lea    -0x6a15(%ebx),%eax
c002b3d4:	50                   	push   %eax
c002b3d5:	52                   	push   %edx
c002b3d6:	e8 28 f7 ff ff       	call   c002ab03 <strlcpy>
c002b3db:	83 c4 10             	add    $0x10,%esp
  snprintf (h->size, sizeof h->size, "%011o", size);
c002b3de:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b3e1:	8d 50 7c             	lea    0x7c(%eax),%edx
c002b3e4:	ff 75 10             	push   0x10(%ebp)
c002b3e7:	8d 83 f3 95 ff ff    	lea    -0x6a0d(%ebx),%eax
c002b3ed:	50                   	push   %eax
c002b3ee:	6a 0c                	push   $0xc
c002b3f0:	52                   	push   %edx
c002b3f1:	e8 bc da ff ff       	call   c0028eb2 <snprintf>
c002b3f6:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c002b3f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b3fc:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
c002b402:	68 00 8c b7 43       	push   $0x43b78c00
c002b407:	8d 83 f3 95 ff ff    	lea    -0x6a0d(%ebx),%eax
c002b40d:	50                   	push   %eax
c002b40e:	6a 0c                	push   $0xc
c002b410:	52                   	push   %edx
c002b411:	e8 9c da ff ff       	call   c0028eb2 <snprintf>
c002b416:	83 c4 10             	add    $0x10,%esp
  h->typeflag = type;
c002b419:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b41c:	89 c2                	mov    %eax,%edx
c002b41e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b421:	88 90 9c 00 00 00    	mov    %dl,0x9c(%eax)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c002b427:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b42a:	8d 90 01 01 00 00    	lea    0x101(%eax),%edx
c002b430:	83 ec 04             	sub    $0x4,%esp
c002b433:	6a 06                	push   $0x6
c002b435:	8d 83 f9 95 ff ff    	lea    -0x6a07(%ebx),%eax
c002b43b:	50                   	push   %eax
c002b43c:	52                   	push   %edx
c002b43d:	e8 c1 f6 ff ff       	call   c002ab03 <strlcpy>
c002b442:	83 c4 10             	add    $0x10,%esp
  h->version[0] = h->version[1] = '0';
c002b445:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b448:	c6 80 08 01 00 00 30 	movb   $0x30,0x108(%eax)
c002b44f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b452:	0f b6 90 08 01 00 00 	movzbl 0x108(%eax),%edx
c002b459:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b45c:	88 90 07 01 00 00    	mov    %dl,0x107(%eax)
  strlcpy (h->gname, "root", sizeof h->gname);
c002b462:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b465:	8d 90 29 01 00 00    	lea    0x129(%eax),%edx
c002b46b:	83 ec 04             	sub    $0x4,%esp
c002b46e:	6a 20                	push   $0x20
c002b470:	8d 83 ff 95 ff ff    	lea    -0x6a01(%ebx),%eax
c002b476:	50                   	push   %eax
c002b477:	52                   	push   %edx
c002b478:	e8 86 f6 ff ff       	call   c002ab03 <strlcpy>
c002b47d:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->uname, "root", sizeof h->uname);
c002b480:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b483:	8d 90 09 01 00 00    	lea    0x109(%eax),%edx
c002b489:	83 ec 04             	sub    $0x4,%esp
c002b48c:	6a 20                	push   $0x20
c002b48e:	8d 83 ff 95 ff ff    	lea    -0x6a01(%ebx),%eax
c002b494:	50                   	push   %eax
c002b495:	52                   	push   %edx
c002b496:	e8 68 f6 ff ff       	call   c002ab03 <strlcpy>
c002b49b:	83 c4 10             	add    $0x10,%esp

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c002b49e:	83 ec 0c             	sub    $0xc,%esp
c002b4a1:	ff 75 f4             	push   -0xc(%ebp)
c002b4a4:	e8 f3 fc ff ff       	call   c002b19c <calculate_chksum>
c002b4a9:	83 c4 10             	add    $0x10,%esp
c002b4ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b4af:	81 c2 94 00 00 00    	add    $0x94,%edx
c002b4b5:	50                   	push   %eax
c002b4b6:	8d 83 e6 95 ff ff    	lea    -0x6a1a(%ebx),%eax
c002b4bc:	50                   	push   %eax
c002b4bd:	6a 08                	push   $0x8
c002b4bf:	52                   	push   %edx
c002b4c0:	e8 ed d9 ff ff       	call   c0028eb2 <snprintf>
c002b4c5:	83 c4 10             	add    $0x10,%esp

  return true;
c002b4c8:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002b4cd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b4d0:	c9                   	leave  
c002b4d1:	c3                   	ret    

c002b4d2 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c002b4d2:	55                   	push   %ebp
c002b4d3:	89 e5                	mov    %esp,%ebp
c002b4d5:	83 ec 10             	sub    $0x10,%esp
c002b4d8:	e8 4b 5f 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b4dd:	05 9b ee 00 00       	add    $0xee9b,%eax
  size_t ofs;

  *value = 0;
c002b4e2:	8b 45 10             	mov    0x10(%ebp),%eax
c002b4e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c002b4eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002b4f2:	eb 65                	jmp    c002b559 <parse_octal_field+0x87>
    {
      char c = s[ofs];
c002b4f4:	8b 55 08             	mov    0x8(%ebp),%edx
c002b4f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002b4fa:	01 d0                	add    %edx,%eax
c002b4fc:	0f b6 00             	movzbl (%eax),%eax
c002b4ff:	88 45 fb             	mov    %al,-0x5(%ebp)
      if (c >= '0' && c <= '7')
c002b502:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
c002b506:	7e 35                	jle    c002b53d <parse_octal_field+0x6b>
c002b508:	80 7d fb 37          	cmpb   $0x37,-0x5(%ebp)
c002b50c:	7f 2f                	jg     c002b53d <parse_octal_field+0x6b>
        {
          if (*value > ULONG_MAX / 8)
c002b50e:	8b 45 10             	mov    0x10(%ebp),%eax
c002b511:	8b 00                	mov    (%eax),%eax
c002b513:	3d ff ff ff 1f       	cmp    $0x1fffffff,%eax
c002b518:	76 07                	jbe    c002b521 <parse_octal_field+0x4f>
            {
              /* Overflow. */
              return false;
c002b51a:	b8 00 00 00 00       	mov    $0x0,%eax
c002b51f:	eb 45                	jmp    c002b566 <parse_octal_field+0x94>
            }
          *value = c - '0' + *value * 8;
c002b521:	0f be 55 fb          	movsbl -0x5(%ebp),%edx
c002b525:	8b 45 10             	mov    0x10(%ebp),%eax
c002b528:	8b 00                	mov    (%eax),%eax
c002b52a:	c1 e0 03             	shl    $0x3,%eax
c002b52d:	01 d0                	add    %edx,%eax
c002b52f:	8d 50 d0             	lea    -0x30(%eax),%edx
c002b532:	8b 45 10             	mov    0x10(%ebp),%eax
c002b535:	89 10                	mov    %edx,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c002b537:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c002b53b:	eb 1c                	jmp    c002b559 <parse_octal_field+0x87>
        }
      else if (c == ' ' || c == '\0')
c002b53d:	80 7d fb 20          	cmpb   $0x20,-0x5(%ebp)
c002b541:	74 06                	je     c002b549 <parse_octal_field+0x77>
c002b543:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c002b547:	75 09                	jne    c002b552 <parse_octal_field+0x80>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c002b549:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c002b54d:	0f 95 c0             	setne  %al
c002b550:	eb 14                	jmp    c002b566 <parse_octal_field+0x94>
        }
      else
        {
          /* Bad character. */
          return false;
c002b552:	b8 00 00 00 00       	mov    $0x0,%eax
c002b557:	eb 0d                	jmp    c002b566 <parse_octal_field+0x94>
  for (ofs = 0; ofs < size; ofs++)
c002b559:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002b55c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b55f:	72 93                	jb     c002b4f4 <parse_octal_field+0x22>
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c002b561:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b566:	c9                   	leave  
c002b567:	c3                   	ret    

c002b568 <is_all_zeros>:

/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
c002b568:	55                   	push   %ebp
c002b569:	89 e5                	mov    %esp,%ebp
c002b56b:	e8 b8 5e 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b570:	05 08 ee 00 00       	add    $0xee08,%eax
  while (cnt-- > 0)
c002b575:	eb 17                	jmp    c002b58e <is_all_zeros+0x26>
    if (*block++ != 0)
c002b577:	8b 45 08             	mov    0x8(%ebp),%eax
c002b57a:	8d 50 01             	lea    0x1(%eax),%edx
c002b57d:	89 55 08             	mov    %edx,0x8(%ebp)
c002b580:	0f b6 00             	movzbl (%eax),%eax
c002b583:	84 c0                	test   %al,%al
c002b585:	74 07                	je     c002b58e <is_all_zeros+0x26>
      return false;
c002b587:	b8 00 00 00 00       	mov    $0x0,%eax
c002b58c:	eb 12                	jmp    c002b5a0 <is_all_zeros+0x38>
  while (cnt-- > 0)
c002b58e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b591:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b594:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b597:	85 c0                	test   %eax,%eax
c002b599:	75 dc                	jne    c002b577 <is_all_zeros+0xf>
  return true;
c002b59b:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002b5a0:	5d                   	pop    %ebp
c002b5a1:	c3                   	ret    

c002b5a2 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c002b5a2:	55                   	push   %ebp
c002b5a3:	89 e5                	mov    %esp,%ebp
c002b5a5:	53                   	push   %ebx
c002b5a6:	83 ec 14             	sub    $0x14,%esp
c002b5a9:	e8 7e 5e 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002b5ae:	81 c3 ca ed 00 00    	add    $0xedca,%ebx
  const struct ustar_header *h = (const struct ustar_header *) header;
c002b5b4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b5b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned long int chksum, size_ul;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
c002b5ba:	68 00 02 00 00       	push   $0x200
c002b5bf:	ff 75 08             	push   0x8(%ebp)
c002b5c2:	e8 a1 ff ff ff       	call   c002b568 <is_all_zeros>
c002b5c7:	83 c4 08             	add    $0x8,%esp
c002b5ca:	84 c0                	test   %al,%al
c002b5cc:	74 25                	je     c002b5f3 <ustar_parse_header+0x51>
    {
      *file_name = NULL;
c002b5ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b5d1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c002b5d7:	8b 45 10             	mov    0x10(%ebp),%eax
c002b5da:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c002b5e0:	8b 45 14             	mov    0x14(%ebp),%eax
c002b5e3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c002b5e9:	b8 00 00 00 00       	mov    $0x0,%eax
c002b5ee:	e9 6c 01 00 00       	jmp    c002b75f <ustar_parse_header+0x1bd>
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c002b5f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b5f6:	8d 90 01 01 00 00    	lea    0x101(%eax),%edx
c002b5fc:	83 ec 04             	sub    $0x4,%esp
c002b5ff:	6a 06                	push   $0x6
c002b601:	8d 83 f9 95 ff ff    	lea    -0x6a07(%ebx),%eax
c002b607:	50                   	push   %eax
c002b608:	52                   	push   %edx
c002b609:	e8 66 ee ff ff       	call   c002a474 <memcmp>
c002b60e:	83 c4 10             	add    $0x10,%esp
c002b611:	85 c0                	test   %eax,%eax
c002b613:	74 0b                	je     c002b620 <ustar_parse_header+0x7e>
    return "not a ustar archive";
c002b615:	8d 83 04 96 ff ff    	lea    -0x69fc(%ebx),%eax
c002b61b:	e9 3f 01 00 00       	jmp    c002b75f <ustar_parse_header+0x1bd>
  else if (h->version[0] != '0' || h->version[1] != '0')
c002b620:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b623:	0f b6 80 07 01 00 00 	movzbl 0x107(%eax),%eax
c002b62a:	3c 30                	cmp    $0x30,%al
c002b62c:	75 0e                	jne    c002b63c <ustar_parse_header+0x9a>
c002b62e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b631:	0f b6 80 08 01 00 00 	movzbl 0x108(%eax),%eax
c002b638:	3c 30                	cmp    $0x30,%al
c002b63a:	74 0b                	je     c002b647 <ustar_parse_header+0xa5>
    return "invalid ustar version";
c002b63c:	8d 83 18 96 ff ff    	lea    -0x69e8(%ebx),%eax
c002b642:	e9 18 01 00 00       	jmp    c002b75f <ustar_parse_header+0x1bd>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c002b647:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b64a:	8d 90 94 00 00 00    	lea    0x94(%eax),%edx
c002b650:	83 ec 04             	sub    $0x4,%esp
c002b653:	8d 45 f0             	lea    -0x10(%ebp),%eax
c002b656:	50                   	push   %eax
c002b657:	6a 08                	push   $0x8
c002b659:	52                   	push   %edx
c002b65a:	e8 73 fe ff ff       	call   c002b4d2 <parse_octal_field>
c002b65f:	83 c4 10             	add    $0x10,%esp
c002b662:	83 f0 01             	xor    $0x1,%eax
c002b665:	84 c0                	test   %al,%al
c002b667:	74 0b                	je     c002b674 <ustar_parse_header+0xd2>
    return "corrupt chksum field";
c002b669:	8d 83 2e 96 ff ff    	lea    -0x69d2(%ebx),%eax
c002b66f:	e9 eb 00 00 00       	jmp    c002b75f <ustar_parse_header+0x1bd>
  else if (chksum != calculate_chksum (h))
c002b674:	83 ec 0c             	sub    $0xc,%esp
c002b677:	ff 75 f4             	push   -0xc(%ebp)
c002b67a:	e8 1d fb ff ff       	call   c002b19c <calculate_chksum>
c002b67f:	83 c4 10             	add    $0x10,%esp
c002b682:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b685:	39 d0                	cmp    %edx,%eax
c002b687:	74 0b                	je     c002b694 <ustar_parse_header+0xf2>
    return "checksum mismatch";
c002b689:	8d 83 43 96 ff ff    	lea    -0x69bd(%ebx),%eax
c002b68f:	e9 cb 00 00 00       	jmp    c002b75f <ustar_parse_header+0x1bd>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c002b694:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b697:	0f b6 40 63          	movzbl 0x63(%eax),%eax
c002b69b:	84 c0                	test   %al,%al
c002b69d:	75 0e                	jne    c002b6ad <ustar_parse_header+0x10b>
c002b69f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b6a2:	0f b6 80 59 01 00 00 	movzbl 0x159(%eax),%eax
c002b6a9:	84 c0                	test   %al,%al
c002b6ab:	74 0b                	je     c002b6b8 <ustar_parse_header+0x116>
    return "file name too long";
c002b6ad:	8d 83 55 96 ff ff    	lea    -0x69ab(%ebx),%eax
c002b6b3:	e9 a7 00 00 00       	jmp    c002b75f <ustar_parse_header+0x1bd>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c002b6b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b6bb:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c002b6c2:	3c 30                	cmp    $0x30,%al
c002b6c4:	74 19                	je     c002b6df <ustar_parse_header+0x13d>
c002b6c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b6c9:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c002b6d0:	3c 35                	cmp    $0x35,%al
c002b6d2:	74 0b                	je     c002b6df <ustar_parse_header+0x13d>
    return "unimplemented file type";
c002b6d4:	8d 83 68 96 ff ff    	lea    -0x6998(%ebx),%eax
c002b6da:	e9 80 00 00 00       	jmp    c002b75f <ustar_parse_header+0x1bd>
  if (h->typeflag == USTAR_REGULAR)
c002b6df:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b6e2:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c002b6e9:	3c 30                	cmp    $0x30,%al
c002b6eb:	75 36                	jne    c002b723 <ustar_parse_header+0x181>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c002b6ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b6f0:	8d 50 7c             	lea    0x7c(%eax),%edx
c002b6f3:	83 ec 04             	sub    $0x4,%esp
c002b6f6:	8d 45 ec             	lea    -0x14(%ebp),%eax
c002b6f9:	50                   	push   %eax
c002b6fa:	6a 0c                	push   $0xc
c002b6fc:	52                   	push   %edx
c002b6fd:	e8 d0 fd ff ff       	call   c002b4d2 <parse_octal_field>
c002b702:	83 c4 10             	add    $0x10,%esp
c002b705:	83 f0 01             	xor    $0x1,%eax
c002b708:	84 c0                	test   %al,%al
c002b70a:	74 08                	je     c002b714 <ustar_parse_header+0x172>
        return "corrupt file size field";
c002b70c:	8d 83 80 96 ff ff    	lea    -0x6980(%ebx),%eax
c002b712:	eb 4b                	jmp    c002b75f <ustar_parse_header+0x1bd>
      else if (size_ul > INT_MAX)
c002b714:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b717:	85 c0                	test   %eax,%eax
c002b719:	79 0f                	jns    c002b72a <ustar_parse_header+0x188>
        return "file too large";
c002b71b:	8d 83 98 96 ff ff    	lea    -0x6968(%ebx),%eax
c002b721:	eb 3c                	jmp    c002b75f <ustar_parse_header+0x1bd>
    }
  else
    size_ul = 0;
c002b723:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c002b72a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b72d:	83 ec 0c             	sub    $0xc,%esp
c002b730:	50                   	push   %eax
c002b731:	e8 f4 fa ff ff       	call   c002b22a <strip_antisocial_prefixes>
c002b736:	83 c4 10             	add    $0x10,%esp
c002b739:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b73c:	89 02                	mov    %eax,(%edx)
  *type = h->typeflag;
c002b73e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b741:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c002b748:	0f be d0             	movsbl %al,%edx
c002b74b:	8b 45 10             	mov    0x10(%ebp),%eax
c002b74e:	89 10                	mov    %edx,(%eax)
  *size = size_ul;
c002b750:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b753:	89 c2                	mov    %eax,%edx
c002b755:	8b 45 14             	mov    0x14(%ebp),%eax
c002b758:	89 10                	mov    %edx,(%eax)
  return NULL;
c002b75a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b75f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b762:	c9                   	leave  
c002b763:	c3                   	ret    

c002b764 <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c002b764:	55                   	push   %ebp
c002b765:	89 e5                	mov    %esp,%ebp
c002b767:	53                   	push   %ebx
c002b768:	83 ec 14             	sub    $0x14,%esp
c002b76b:	e8 bc 5c 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002b770:	81 c3 08 ec 00 00    	add    $0xec08,%ebx
  static int level;
  va_list args;

  intr_disable ();
c002b776:	e8 6b 67 ff ff       	call   c0021ee6 <intr_disable>
  console_panic ();
c002b77b:	e8 c0 26 00 00       	call   c002de40 <console_panic>

  level++;
c002b780:	8b 83 6c 22 00 00    	mov    0x226c(%ebx),%eax
c002b786:	83 c0 01             	add    $0x1,%eax
c002b789:	89 83 6c 22 00 00    	mov    %eax,0x226c(%ebx)
  if (level == 1) 
c002b78f:	8b 83 6c 22 00 00    	mov    0x226c(%ebx),%eax
c002b795:	83 f8 01             	cmp    $0x1,%eax
c002b798:	75 44                	jne    c002b7de <debug_panic+0x7a>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c002b79a:	ff 75 10             	push   0x10(%ebp)
c002b79d:	ff 75 0c             	push   0xc(%ebp)
c002b7a0:	ff 75 08             	push   0x8(%ebp)
c002b7a3:	8d 83 bc 96 ff ff    	lea    -0x6944(%ebx),%eax
c002b7a9:	50                   	push   %eax
c002b7aa:	e8 36 d7 ff ff       	call   c0028ee5 <printf>
c002b7af:	83 c4 10             	add    $0x10,%esp

      va_start (args, message);
c002b7b2:	8d 45 18             	lea    0x18(%ebp),%eax
c002b7b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
      vprintf (message, args);
c002b7b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b7bb:	83 ec 08             	sub    $0x8,%esp
c002b7be:	50                   	push   %eax
c002b7bf:	ff 75 14             	push   0x14(%ebp)
c002b7c2:	e8 e1 27 00 00       	call   c002dfa8 <vprintf>
c002b7c7:	83 c4 10             	add    $0x10,%esp
      printf ("\n");
c002b7ca:	83 ec 0c             	sub    $0xc,%esp
c002b7cd:	6a 0a                	push   $0xa
c002b7cf:	e8 b4 28 00 00       	call   c002e088 <putchar>
c002b7d4:	83 c4 10             	add    $0x10,%esp
      va_end (args);

      debug_backtrace ();
c002b7d7:	e8 2e d3 ff ff       	call   c0028b0a <debug_backtrace>
c002b7dc:	eb 23                	jmp    c002b801 <debug_panic+0x9d>
    }
  else if (level == 2)
c002b7de:	8b 83 6c 22 00 00    	mov    0x226c(%ebx),%eax
c002b7e4:	83 f8 02             	cmp    $0x2,%eax
c002b7e7:	75 18                	jne    c002b801 <debug_panic+0x9d>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c002b7e9:	ff 75 10             	push   0x10(%ebp)
c002b7ec:	ff 75 0c             	push   0xc(%ebp)
c002b7ef:	ff 75 08             	push   0x8(%ebp)
c002b7f2:	8d 83 dc 96 ff ff    	lea    -0x6924(%ebx),%eax
c002b7f8:	50                   	push   %eax
c002b7f9:	e8 e7 d6 ff ff       	call   c0028ee5 <printf>
c002b7fe:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c002b801:	e8 77 a9 ff ff       	call   c002617d <serial_flush>
  shutdown ();
c002b806:	e8 e5 cf ff ff       	call   c00287f0 <shutdown>
  for (;;);
c002b80b:	eb fe                	jmp    c002b80b <debug_panic+0xa7>

c002b80d <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c002b80d:	55                   	push   %ebp
c002b80e:	89 e5                	mov    %esp,%ebp
c002b810:	53                   	push   %ebx
c002b811:	83 ec 14             	sub    $0x14,%esp
c002b814:	e8 13 5c 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002b819:	81 c3 5f eb 00 00    	add    $0xeb5f,%ebx
  void *retaddr = NULL, **frame = NULL;
c002b81f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b826:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  const char *status = "UNKNOWN";
c002b82d:	8d 83 06 97 ff ff    	lea    -0x68fa(%ebx),%eax
c002b833:	89 45 ec             	mov    %eax,-0x14(%ebp)

  switch (t->status) {
c002b836:	8b 45 08             	mov    0x8(%ebp),%eax
c002b839:	8b 40 04             	mov    0x4(%eax),%eax
c002b83c:	83 f8 02             	cmp    $0x2,%eax
c002b83f:	74 26                	je     c002b867 <print_stacktrace+0x5a>
c002b841:	83 f8 02             	cmp    $0x2,%eax
c002b844:	77 2c                	ja     c002b872 <print_stacktrace+0x65>
c002b846:	85 c0                	test   %eax,%eax
c002b848:	74 07                	je     c002b851 <print_stacktrace+0x44>
c002b84a:	83 f8 01             	cmp    $0x1,%eax
c002b84d:	74 0d                	je     c002b85c <print_stacktrace+0x4f>
    case THREAD_BLOCKED:  
      status = "BLOCKED";
      break;

    default:
      break;
c002b84f:	eb 21                	jmp    c002b872 <print_stacktrace+0x65>
      status = "RUNNING";
c002b851:	8d 83 0e 97 ff ff    	lea    -0x68f2(%ebx),%eax
c002b857:	89 45 ec             	mov    %eax,-0x14(%ebp)
      break;
c002b85a:	eb 17                	jmp    c002b873 <print_stacktrace+0x66>
      status = "READY";
c002b85c:	8d 83 16 97 ff ff    	lea    -0x68ea(%ebx),%eax
c002b862:	89 45 ec             	mov    %eax,-0x14(%ebp)
      break;
c002b865:	eb 0c                	jmp    c002b873 <print_stacktrace+0x66>
      status = "BLOCKED";
c002b867:	8d 83 1c 97 ff ff    	lea    -0x68e4(%ebx),%eax
c002b86d:	89 45 ec             	mov    %eax,-0x14(%ebp)
      break;
c002b870:	eb 01                	jmp    c002b873 <print_stacktrace+0x66>
      break;
c002b872:	90                   	nop
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c002b873:	8b 45 08             	mov    0x8(%ebp),%eax
c002b876:	83 c0 08             	add    $0x8,%eax
c002b879:	83 ec 04             	sub    $0x4,%esp
c002b87c:	ff 75 ec             	push   -0x14(%ebp)
c002b87f:	50                   	push   %eax
c002b880:	8d 83 24 97 ff ff    	lea    -0x68dc(%ebx),%eax
c002b886:	50                   	push   %eax
c002b887:	e8 59 d6 ff ff       	call   c0028ee5 <printf>
c002b88c:	83 c4 10             	add    $0x10,%esp

  if (t == thread_current()) 
c002b88f:	e8 ed 5a ff ff       	call   c0021381 <thread_current>
c002b894:	39 45 08             	cmp    %eax,0x8(%ebp)
c002b897:	75 0e                	jne    c002b8a7 <print_stacktrace+0x9a>
    {
      frame = __builtin_frame_address (1);
c002b899:	8b 45 00             	mov    0x0(%ebp),%eax
c002b89c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = __builtin_return_address (0);
c002b89f:	8b 45 04             	mov    0x4(%ebp),%eax
c002b8a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b8a5:	eb 52                	jmp    c002b8f9 <print_stacktrace+0xec>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c002b8a7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8aa:	8b 40 18             	mov    0x18(%eax),%eax
c002b8ad:	89 45 e8             	mov    %eax,-0x18(%ebp)
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c002b8b0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8b3:	8b 40 18             	mov    0x18(%eax),%eax
c002b8b6:	8b 55 08             	mov    0x8(%ebp),%edx
c002b8b9:	81 c2 00 10 00 00    	add    $0x1000,%edx
c002b8bf:	39 d0                	cmp    %edx,%eax
c002b8c1:	74 10                	je     c002b8d3 <print_stacktrace+0xc6>
c002b8c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b8c6:	8b 40 10             	mov    0x10(%eax),%eax
c002b8c9:	c7 c2 15 1e 02 c0    	mov    $0xc0021e15,%edx
c002b8cf:	39 d0                	cmp    %edx,%eax
c002b8d1:	75 14                	jne    c002b8e7 <print_stacktrace+0xda>
        {
          printf (" thread was never scheduled.\n");
c002b8d3:	83 ec 0c             	sub    $0xc,%esp
c002b8d6:	8d 83 4b 97 ff ff    	lea    -0x68b5(%ebx),%eax
c002b8dc:	50                   	push   %eax
c002b8dd:	e8 0a 27 00 00       	call   c002dfec <puts>
c002b8e2:	83 c4 10             	add    $0x10,%esp
          return;
c002b8e5:	eb 71                	jmp    c002b958 <print_stacktrace+0x14b>
        }

      frame = (void **) saved_frame->ebp;
c002b8e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b8ea:	8b 40 08             	mov    0x8(%eax),%eax
c002b8ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = (void *) saved_frame->eip;
c002b8f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b8f3:	8b 40 10             	mov    0x10(%eax),%eax
c002b8f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

  printf (" %p", retaddr);
c002b8f9:	83 ec 08             	sub    $0x8,%esp
c002b8fc:	ff 75 f4             	push   -0xc(%ebp)
c002b8ff:	8d 83 68 97 ff ff    	lea    -0x6898(%ebx),%eax
c002b905:	50                   	push   %eax
c002b906:	e8 da d5 ff ff       	call   c0028ee5 <printf>
c002b90b:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c002b90e:	eb 23                	jmp    c002b933 <print_stacktrace+0x126>
    printf (" %p", frame[1]);
c002b910:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b913:	83 c0 04             	add    $0x4,%eax
c002b916:	8b 00                	mov    (%eax),%eax
c002b918:	83 ec 08             	sub    $0x8,%esp
c002b91b:	50                   	push   %eax
c002b91c:	8d 83 68 97 ff ff    	lea    -0x6898(%ebx),%eax
c002b922:	50                   	push   %eax
c002b923:	e8 bd d5 ff ff       	call   c0028ee5 <printf>
c002b928:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c002b92b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b92e:	8b 00                	mov    (%eax),%eax
c002b930:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b933:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b936:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002b93b:	76 09                	jbe    c002b946 <print_stacktrace+0x139>
c002b93d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b940:	8b 00                	mov    (%eax),%eax
c002b942:	85 c0                	test   %eax,%eax
c002b944:	75 ca                	jne    c002b910 <print_stacktrace+0x103>
  printf (".\n");
c002b946:	83 ec 0c             	sub    $0xc,%esp
c002b949:	8d 83 6c 97 ff ff    	lea    -0x6894(%ebx),%eax
c002b94f:	50                   	push   %eax
c002b950:	e8 97 26 00 00       	call   c002dfec <puts>
c002b955:	83 c4 10             	add    $0x10,%esp
}
c002b958:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b95b:	c9                   	leave  
c002b95c:	c3                   	ret    

c002b95d <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c002b95d:	55                   	push   %ebp
c002b95e:	89 e5                	mov    %esp,%ebp
c002b960:	53                   	push   %ebx
c002b961:	83 ec 14             	sub    $0x14,%esp
c002b964:	e8 c3 5a 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002b969:	81 c3 0f ea 00 00    	add    $0xea0f,%ebx
  enum intr_level oldlevel = intr_disable ();
c002b96f:	e8 72 65 ff ff       	call   c0021ee6 <intr_disable>
c002b974:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_foreach (print_stacktrace, 0);
c002b977:	83 ec 08             	sub    $0x8,%esp
c002b97a:	6a 00                	push   $0x0
c002b97c:	8d 83 95 14 ff ff    	lea    -0xeb6b(%ebx),%eax
c002b982:	50                   	push   %eax
c002b983:	e8 eb 5b ff ff       	call   c0021573 <thread_foreach>
c002b988:	83 c4 10             	add    $0x10,%esp
  intr_set_level (oldlevel);
c002b98b:	83 ec 0c             	sub    $0xc,%esp
c002b98e:	ff 75 f4             	push   -0xc(%ebp)
c002b991:	e8 d7 64 ff ff       	call   c0021e6d <intr_set_level>
c002b996:	83 c4 10             	add    $0x10,%esp
}
c002b999:	90                   	nop
c002b99a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b99d:	c9                   	leave  
c002b99e:	c3                   	ret    

c002b99f <is_head>:
                       list_less_func *less, void *aux) UNUSED;

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
c002b99f:	55                   	push   %ebp
c002b9a0:	89 e5                	mov    %esp,%ebp
c002b9a2:	e8 81 5a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b9a7:	05 d1 e9 00 00       	add    $0xe9d1,%eax
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c002b9ac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b9b0:	74 1a                	je     c002b9cc <is_head+0x2d>
c002b9b2:	8b 45 08             	mov    0x8(%ebp),%eax
c002b9b5:	8b 00                	mov    (%eax),%eax
c002b9b7:	85 c0                	test   %eax,%eax
c002b9b9:	75 11                	jne    c002b9cc <is_head+0x2d>
c002b9bb:	8b 45 08             	mov    0x8(%ebp),%eax
c002b9be:	8b 40 04             	mov    0x4(%eax),%eax
c002b9c1:	85 c0                	test   %eax,%eax
c002b9c3:	74 07                	je     c002b9cc <is_head+0x2d>
c002b9c5:	b8 01 00 00 00       	mov    $0x1,%eax
c002b9ca:	eb 05                	jmp    c002b9d1 <is_head+0x32>
c002b9cc:	b8 00 00 00 00       	mov    $0x0,%eax
c002b9d1:	83 e0 01             	and    $0x1,%eax
}
c002b9d4:	5d                   	pop    %ebp
c002b9d5:	c3                   	ret    

c002b9d6 <is_interior>:

/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
c002b9d6:	55                   	push   %ebp
c002b9d7:	89 e5                	mov    %esp,%ebp
c002b9d9:	e8 4a 5a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002b9de:	05 9a e9 00 00       	add    $0xe99a,%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002b9e3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b9e7:	74 1a                	je     c002ba03 <is_interior+0x2d>
c002b9e9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b9ec:	8b 00                	mov    (%eax),%eax
c002b9ee:	85 c0                	test   %eax,%eax
c002b9f0:	74 11                	je     c002ba03 <is_interior+0x2d>
c002b9f2:	8b 45 08             	mov    0x8(%ebp),%eax
c002b9f5:	8b 40 04             	mov    0x4(%eax),%eax
c002b9f8:	85 c0                	test   %eax,%eax
c002b9fa:	74 07                	je     c002ba03 <is_interior+0x2d>
c002b9fc:	b8 01 00 00 00       	mov    $0x1,%eax
c002ba01:	eb 05                	jmp    c002ba08 <is_interior+0x32>
c002ba03:	b8 00 00 00 00       	mov    $0x0,%eax
c002ba08:	83 e0 01             	and    $0x1,%eax
}
c002ba0b:	5d                   	pop    %ebp
c002ba0c:	c3                   	ret    

c002ba0d <is_tail>:

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
c002ba0d:	55                   	push   %ebp
c002ba0e:	89 e5                	mov    %esp,%ebp
c002ba10:	e8 13 5a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002ba15:	05 63 e9 00 00       	add    $0xe963,%eax
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002ba1a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ba1e:	74 1a                	je     c002ba3a <is_tail+0x2d>
c002ba20:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba23:	8b 00                	mov    (%eax),%eax
c002ba25:	85 c0                	test   %eax,%eax
c002ba27:	74 11                	je     c002ba3a <is_tail+0x2d>
c002ba29:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba2c:	8b 40 04             	mov    0x4(%eax),%eax
c002ba2f:	85 c0                	test   %eax,%eax
c002ba31:	75 07                	jne    c002ba3a <is_tail+0x2d>
c002ba33:	b8 01 00 00 00       	mov    $0x1,%eax
c002ba38:	eb 05                	jmp    c002ba3f <is_tail+0x32>
c002ba3a:	b8 00 00 00 00       	mov    $0x0,%eax
c002ba3f:	83 e0 01             	and    $0x1,%eax
}
c002ba42:	5d                   	pop    %ebp
c002ba43:	c3                   	ret    

c002ba44 <list_init>:

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c002ba44:	55                   	push   %ebp
c002ba45:	89 e5                	mov    %esp,%ebp
c002ba47:	53                   	push   %ebx
c002ba48:	83 ec 04             	sub    $0x4,%esp
c002ba4b:	e8 d8 59 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002ba50:	05 28 e9 00 00       	add    $0xe928,%eax
  ASSERT (list != NULL);
c002ba55:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ba59:	75 28                	jne    c002ba83 <list_init+0x3f>
c002ba5b:	83 ec 0c             	sub    $0xc,%esp
c002ba5e:	8d 90 70 97 ff ff    	lea    -0x6890(%eax),%edx
c002ba64:	52                   	push   %edx
c002ba65:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002ba6b:	52                   	push   %edx
c002ba6c:	8d 90 48 99 ff ff    	lea    -0x66b8(%eax),%edx
c002ba72:	52                   	push   %edx
c002ba73:	6a 3f                	push   $0x3f
c002ba75:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002ba7b:	52                   	push   %edx
c002ba7c:	89 c3                	mov    %eax,%ebx
c002ba7e:	e8 e1 fc ff ff       	call   c002b764 <debug_panic>
  list->head.prev = NULL;
c002ba83:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba86:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c002ba8c:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba8f:	8d 50 08             	lea    0x8(%eax),%edx
c002ba92:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba95:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c002ba98:	8b 55 08             	mov    0x8(%ebp),%edx
c002ba9b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba9e:	89 50 08             	mov    %edx,0x8(%eax)
  list->tail.next = NULL;
c002baa1:	8b 45 08             	mov    0x8(%ebp),%eax
c002baa4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c002baab:	90                   	nop
c002baac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002baaf:	c9                   	leave  
c002bab0:	c3                   	ret    

c002bab1 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c002bab1:	55                   	push   %ebp
c002bab2:	89 e5                	mov    %esp,%ebp
c002bab4:	53                   	push   %ebx
c002bab5:	83 ec 04             	sub    $0x4,%esp
c002bab8:	e8 6b 59 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002babd:	05 bb e8 00 00       	add    $0xe8bb,%eax
  ASSERT (list != NULL);
c002bac2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bac6:	75 28                	jne    c002baf0 <list_begin+0x3f>
c002bac8:	83 ec 0c             	sub    $0xc,%esp
c002bacb:	8d 90 70 97 ff ff    	lea    -0x6890(%eax),%edx
c002bad1:	52                   	push   %edx
c002bad2:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002bad8:	52                   	push   %edx
c002bad9:	8d 90 54 99 ff ff    	lea    -0x66ac(%eax),%edx
c002badf:	52                   	push   %edx
c002bae0:	6a 4a                	push   $0x4a
c002bae2:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002bae8:	52                   	push   %edx
c002bae9:	89 c3                	mov    %eax,%ebx
c002baeb:	e8 74 fc ff ff       	call   c002b764 <debug_panic>
  return list->head.next;
c002baf0:	8b 45 08             	mov    0x8(%ebp),%eax
c002baf3:	8b 40 04             	mov    0x4(%eax),%eax
}
c002baf6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002baf9:	c9                   	leave  
c002bafa:	c3                   	ret    

c002bafb <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c002bafb:	55                   	push   %ebp
c002bafc:	89 e5                	mov    %esp,%ebp
c002bafe:	53                   	push   %ebx
c002baff:	83 ec 04             	sub    $0x4,%esp
c002bb02:	e8 25 59 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002bb07:	81 c3 71 e8 00 00    	add    $0xe871,%ebx
  ASSERT (is_head (elem) || is_interior (elem));
c002bb0d:	ff 75 08             	push   0x8(%ebp)
c002bb10:	e8 8a fe ff ff       	call   c002b99f <is_head>
c002bb15:	83 c4 04             	add    $0x4,%esp
c002bb18:	84 c0                	test   %al,%al
c002bb1a:	75 35                	jne    c002bb51 <list_next+0x56>
c002bb1c:	ff 75 08             	push   0x8(%ebp)
c002bb1f:	e8 b2 fe ff ff       	call   c002b9d6 <is_interior>
c002bb24:	83 c4 04             	add    $0x4,%esp
c002bb27:	84 c0                	test   %al,%al
c002bb29:	75 26                	jne    c002bb51 <list_next+0x56>
c002bb2b:	83 ec 0c             	sub    $0xc,%esp
c002bb2e:	8d 83 ac 97 ff ff    	lea    -0x6854(%ebx),%eax
c002bb34:	50                   	push   %eax
c002bb35:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002bb3b:	50                   	push   %eax
c002bb3c:	8d 83 60 99 ff ff    	lea    -0x66a0(%ebx),%eax
c002bb42:	50                   	push   %eax
c002bb43:	6a 54                	push   $0x54
c002bb45:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002bb4b:	50                   	push   %eax
c002bb4c:	e8 13 fc ff ff       	call   c002b764 <debug_panic>
  return elem->next;
c002bb51:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb54:	8b 40 04             	mov    0x4(%eax),%eax
}
c002bb57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bb5a:	c9                   	leave  
c002bb5b:	c3                   	ret    

c002bb5c <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c002bb5c:	55                   	push   %ebp
c002bb5d:	89 e5                	mov    %esp,%ebp
c002bb5f:	53                   	push   %ebx
c002bb60:	83 ec 04             	sub    $0x4,%esp
c002bb63:	e8 c0 58 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002bb68:	05 10 e8 00 00       	add    $0xe810,%eax
  ASSERT (list != NULL);
c002bb6d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bb71:	75 28                	jne    c002bb9b <list_end+0x3f>
c002bb73:	83 ec 0c             	sub    $0xc,%esp
c002bb76:	8d 90 70 97 ff ff    	lea    -0x6890(%eax),%edx
c002bb7c:	52                   	push   %edx
c002bb7d:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002bb83:	52                   	push   %edx
c002bb84:	8d 90 6c 99 ff ff    	lea    -0x6694(%eax),%edx
c002bb8a:	52                   	push   %edx
c002bb8b:	6a 60                	push   $0x60
c002bb8d:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002bb93:	52                   	push   %edx
c002bb94:	89 c3                	mov    %eax,%ebx
c002bb96:	e8 c9 fb ff ff       	call   c002b764 <debug_panic>
  return &list->tail;
c002bb9b:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb9e:	83 c0 08             	add    $0x8,%eax
}
c002bba1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bba4:	c9                   	leave  
c002bba5:	c3                   	ret    

c002bba6 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c002bba6:	55                   	push   %ebp
c002bba7:	89 e5                	mov    %esp,%ebp
c002bba9:	53                   	push   %ebx
c002bbaa:	83 ec 04             	sub    $0x4,%esp
c002bbad:	e8 76 58 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002bbb2:	05 c6 e7 00 00       	add    $0xe7c6,%eax
  ASSERT (list != NULL);
c002bbb7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bbbb:	75 28                	jne    c002bbe5 <list_rbegin+0x3f>
c002bbbd:	83 ec 0c             	sub    $0xc,%esp
c002bbc0:	8d 90 70 97 ff ff    	lea    -0x6890(%eax),%edx
c002bbc6:	52                   	push   %edx
c002bbc7:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002bbcd:	52                   	push   %edx
c002bbce:	8d 90 78 99 ff ff    	lea    -0x6688(%eax),%edx
c002bbd4:	52                   	push   %edx
c002bbd5:	6a 69                	push   $0x69
c002bbd7:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002bbdd:	52                   	push   %edx
c002bbde:	89 c3                	mov    %eax,%ebx
c002bbe0:	e8 7f fb ff ff       	call   c002b764 <debug_panic>
  return list->tail.prev;
c002bbe5:	8b 45 08             	mov    0x8(%ebp),%eax
c002bbe8:	8b 40 08             	mov    0x8(%eax),%eax
}
c002bbeb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bbee:	c9                   	leave  
c002bbef:	c3                   	ret    

c002bbf0 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c002bbf0:	55                   	push   %ebp
c002bbf1:	89 e5                	mov    %esp,%ebp
c002bbf3:	53                   	push   %ebx
c002bbf4:	83 ec 04             	sub    $0x4,%esp
c002bbf7:	e8 30 58 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002bbfc:	81 c3 7c e7 00 00    	add    $0xe77c,%ebx
  ASSERT (is_interior (elem) || is_tail (elem));
c002bc02:	ff 75 08             	push   0x8(%ebp)
c002bc05:	e8 cc fd ff ff       	call   c002b9d6 <is_interior>
c002bc0a:	83 c4 04             	add    $0x4,%esp
c002bc0d:	84 c0                	test   %al,%al
c002bc0f:	75 35                	jne    c002bc46 <list_prev+0x56>
c002bc11:	ff 75 08             	push   0x8(%ebp)
c002bc14:	e8 f4 fd ff ff       	call   c002ba0d <is_tail>
c002bc19:	83 c4 04             	add    $0x4,%esp
c002bc1c:	84 c0                	test   %al,%al
c002bc1e:	75 26                	jne    c002bc46 <list_prev+0x56>
c002bc20:	83 ec 0c             	sub    $0xc,%esp
c002bc23:	8d 83 d4 97 ff ff    	lea    -0x682c(%ebx),%eax
c002bc29:	50                   	push   %eax
c002bc2a:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002bc30:	50                   	push   %eax
c002bc31:	8d 83 84 99 ff ff    	lea    -0x667c(%ebx),%eax
c002bc37:	50                   	push   %eax
c002bc38:	6a 73                	push   $0x73
c002bc3a:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002bc40:	50                   	push   %eax
c002bc41:	e8 1e fb ff ff       	call   c002b764 <debug_panic>
  return elem->prev;
c002bc46:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc49:	8b 00                	mov    (%eax),%eax
}
c002bc4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bc4e:	c9                   	leave  
c002bc4f:	c3                   	ret    

c002bc50 <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c002bc50:	55                   	push   %ebp
c002bc51:	89 e5                	mov    %esp,%ebp
c002bc53:	53                   	push   %ebx
c002bc54:	83 ec 04             	sub    $0x4,%esp
c002bc57:	e8 cc 57 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002bc5c:	05 1c e7 00 00       	add    $0xe71c,%eax
  ASSERT (list != NULL);
c002bc61:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bc65:	75 2b                	jne    c002bc92 <list_rend+0x42>
c002bc67:	83 ec 0c             	sub    $0xc,%esp
c002bc6a:	8d 90 70 97 ff ff    	lea    -0x6890(%eax),%edx
c002bc70:	52                   	push   %edx
c002bc71:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002bc77:	52                   	push   %edx
c002bc78:	8d 90 90 99 ff ff    	lea    -0x6670(%eax),%edx
c002bc7e:	52                   	push   %edx
c002bc7f:	68 87 00 00 00       	push   $0x87
c002bc84:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002bc8a:	52                   	push   %edx
c002bc8b:	89 c3                	mov    %eax,%ebx
c002bc8d:	e8 d2 fa ff ff       	call   c002b764 <debug_panic>
  return &list->head;
c002bc92:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002bc95:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bc98:	c9                   	leave  
c002bc99:	c3                   	ret    

c002bc9a <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c002bc9a:	55                   	push   %ebp
c002bc9b:	89 e5                	mov    %esp,%ebp
c002bc9d:	53                   	push   %ebx
c002bc9e:	83 ec 04             	sub    $0x4,%esp
c002bca1:	e8 82 57 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002bca6:	05 d2 e6 00 00       	add    $0xe6d2,%eax
  ASSERT (list != NULL);
c002bcab:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bcaf:	75 2b                	jne    c002bcdc <list_head+0x42>
c002bcb1:	83 ec 0c             	sub    $0xc,%esp
c002bcb4:	8d 90 70 97 ff ff    	lea    -0x6890(%eax),%edx
c002bcba:	52                   	push   %edx
c002bcbb:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002bcc1:	52                   	push   %edx
c002bcc2:	8d 90 9c 99 ff ff    	lea    -0x6664(%eax),%edx
c002bcc8:	52                   	push   %edx
c002bcc9:	68 99 00 00 00       	push   $0x99
c002bcce:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002bcd4:	52                   	push   %edx
c002bcd5:	89 c3                	mov    %eax,%ebx
c002bcd7:	e8 88 fa ff ff       	call   c002b764 <debug_panic>
  return &list->head;
c002bcdc:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002bcdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bce2:	c9                   	leave  
c002bce3:	c3                   	ret    

c002bce4 <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c002bce4:	55                   	push   %ebp
c002bce5:	89 e5                	mov    %esp,%ebp
c002bce7:	53                   	push   %ebx
c002bce8:	83 ec 04             	sub    $0x4,%esp
c002bceb:	e8 38 57 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002bcf0:	05 88 e6 00 00       	add    $0xe688,%eax
  ASSERT (list != NULL);
c002bcf5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bcf9:	75 2b                	jne    c002bd26 <list_tail+0x42>
c002bcfb:	83 ec 0c             	sub    $0xc,%esp
c002bcfe:	8d 90 70 97 ff ff    	lea    -0x6890(%eax),%edx
c002bd04:	52                   	push   %edx
c002bd05:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002bd0b:	52                   	push   %edx
c002bd0c:	8d 90 a8 99 ff ff    	lea    -0x6658(%eax),%edx
c002bd12:	52                   	push   %edx
c002bd13:	68 a1 00 00 00       	push   $0xa1
c002bd18:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002bd1e:	52                   	push   %edx
c002bd1f:	89 c3                	mov    %eax,%ebx
c002bd21:	e8 3e fa ff ff       	call   c002b764 <debug_panic>
  return &list->tail;
c002bd26:	8b 45 08             	mov    0x8(%ebp),%eax
c002bd29:	83 c0 08             	add    $0x8,%eax
}
c002bd2c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bd2f:	c9                   	leave  
c002bd30:	c3                   	ret    

c002bd31 <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c002bd31:	55                   	push   %ebp
c002bd32:	89 e5                	mov    %esp,%ebp
c002bd34:	53                   	push   %ebx
c002bd35:	83 ec 04             	sub    $0x4,%esp
c002bd38:	e8 ef 56 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002bd3d:	81 c3 3b e6 00 00    	add    $0xe63b,%ebx
  ASSERT (is_interior (before) || is_tail (before));
c002bd43:	ff 75 08             	push   0x8(%ebp)
c002bd46:	e8 8b fc ff ff       	call   c002b9d6 <is_interior>
c002bd4b:	83 c4 04             	add    $0x4,%esp
c002bd4e:	84 c0                	test   %al,%al
c002bd50:	75 38                	jne    c002bd8a <list_insert+0x59>
c002bd52:	ff 75 08             	push   0x8(%ebp)
c002bd55:	e8 b3 fc ff ff       	call   c002ba0d <is_tail>
c002bd5a:	83 c4 04             	add    $0x4,%esp
c002bd5d:	84 c0                	test   %al,%al
c002bd5f:	75 29                	jne    c002bd8a <list_insert+0x59>
c002bd61:	83 ec 0c             	sub    $0xc,%esp
c002bd64:	8d 83 fc 97 ff ff    	lea    -0x6804(%ebx),%eax
c002bd6a:	50                   	push   %eax
c002bd6b:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002bd71:	50                   	push   %eax
c002bd72:	8d 83 b4 99 ff ff    	lea    -0x664c(%ebx),%eax
c002bd78:	50                   	push   %eax
c002bd79:	68 ab 00 00 00       	push   $0xab
c002bd7e:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002bd84:	50                   	push   %eax
c002bd85:	e8 da f9 ff ff       	call   c002b764 <debug_panic>
  ASSERT (elem != NULL);
c002bd8a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002bd8e:	75 29                	jne    c002bdb9 <list_insert+0x88>
c002bd90:	83 ec 0c             	sub    $0xc,%esp
c002bd93:	8d 83 25 98 ff ff    	lea    -0x67db(%ebx),%eax
c002bd99:	50                   	push   %eax
c002bd9a:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002bda0:	50                   	push   %eax
c002bda1:	8d 83 b4 99 ff ff    	lea    -0x664c(%ebx),%eax
c002bda7:	50                   	push   %eax
c002bda8:	68 ac 00 00 00       	push   $0xac
c002bdad:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002bdb3:	50                   	push   %eax
c002bdb4:	e8 ab f9 ff ff       	call   c002b764 <debug_panic>

  elem->prev = before->prev;
c002bdb9:	8b 45 08             	mov    0x8(%ebp),%eax
c002bdbc:	8b 10                	mov    (%eax),%edx
c002bdbe:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bdc1:	89 10                	mov    %edx,(%eax)
  elem->next = before;
c002bdc3:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bdc6:	8b 55 08             	mov    0x8(%ebp),%edx
c002bdc9:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = elem;
c002bdcc:	8b 45 08             	mov    0x8(%ebp),%eax
c002bdcf:	8b 00                	mov    (%eax),%eax
c002bdd1:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bdd4:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = elem;
c002bdd7:	8b 45 08             	mov    0x8(%ebp),%eax
c002bdda:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bddd:	89 10                	mov    %edx,(%eax)
}
c002bddf:	90                   	nop
c002bde0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bde3:	c9                   	leave  
c002bde4:	c3                   	ret    

c002bde5 <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c002bde5:	55                   	push   %ebp
c002bde6:	89 e5                	mov    %esp,%ebp
c002bde8:	53                   	push   %ebx
c002bde9:	83 ec 04             	sub    $0x4,%esp
c002bdec:	e8 3b 56 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002bdf1:	81 c3 87 e5 00 00    	add    $0xe587,%ebx
  ASSERT (is_interior (before) || is_tail (before));
c002bdf7:	ff 75 08             	push   0x8(%ebp)
c002bdfa:	e8 d7 fb ff ff       	call   c002b9d6 <is_interior>
c002bdff:	83 c4 04             	add    $0x4,%esp
c002be02:	84 c0                	test   %al,%al
c002be04:	75 38                	jne    c002be3e <list_splice+0x59>
c002be06:	ff 75 08             	push   0x8(%ebp)
c002be09:	e8 ff fb ff ff       	call   c002ba0d <is_tail>
c002be0e:	83 c4 04             	add    $0x4,%esp
c002be11:	84 c0                	test   %al,%al
c002be13:	75 29                	jne    c002be3e <list_splice+0x59>
c002be15:	83 ec 0c             	sub    $0xc,%esp
c002be18:	8d 83 fc 97 ff ff    	lea    -0x6804(%ebx),%eax
c002be1e:	50                   	push   %eax
c002be1f:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002be25:	50                   	push   %eax
c002be26:	8d 83 c0 99 ff ff    	lea    -0x6640(%ebx),%eax
c002be2c:	50                   	push   %eax
c002be2d:	68 bb 00 00 00       	push   $0xbb
c002be32:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002be38:	50                   	push   %eax
c002be39:	e8 26 f9 ff ff       	call   c002b764 <debug_panic>
  if (first == last)
c002be3e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002be41:	3b 45 10             	cmp    0x10(%ebp),%eax
c002be44:	0f 84 ca 00 00 00    	je     c002bf14 <list_splice+0x12f>
    return;
  last = list_prev (last);
c002be4a:	83 ec 0c             	sub    $0xc,%esp
c002be4d:	ff 75 10             	push   0x10(%ebp)
c002be50:	e8 9b fd ff ff       	call   c002bbf0 <list_prev>
c002be55:	83 c4 10             	add    $0x10,%esp
c002be58:	89 45 10             	mov    %eax,0x10(%ebp)

  ASSERT (is_interior (first));
c002be5b:	83 ec 0c             	sub    $0xc,%esp
c002be5e:	ff 75 0c             	push   0xc(%ebp)
c002be61:	e8 70 fb ff ff       	call   c002b9d6 <is_interior>
c002be66:	83 c4 10             	add    $0x10,%esp
c002be69:	84 c0                	test   %al,%al
c002be6b:	75 29                	jne    c002be96 <list_splice+0xb1>
c002be6d:	83 ec 0c             	sub    $0xc,%esp
c002be70:	8d 83 32 98 ff ff    	lea    -0x67ce(%ebx),%eax
c002be76:	50                   	push   %eax
c002be77:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002be7d:	50                   	push   %eax
c002be7e:	8d 83 c0 99 ff ff    	lea    -0x6640(%ebx),%eax
c002be84:	50                   	push   %eax
c002be85:	68 c0 00 00 00       	push   $0xc0
c002be8a:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002be90:	50                   	push   %eax
c002be91:	e8 ce f8 ff ff       	call   c002b764 <debug_panic>
  ASSERT (is_interior (last));
c002be96:	83 ec 0c             	sub    $0xc,%esp
c002be99:	ff 75 10             	push   0x10(%ebp)
c002be9c:	e8 35 fb ff ff       	call   c002b9d6 <is_interior>
c002bea1:	83 c4 10             	add    $0x10,%esp
c002bea4:	84 c0                	test   %al,%al
c002bea6:	75 29                	jne    c002bed1 <list_splice+0xec>
c002bea8:	83 ec 0c             	sub    $0xc,%esp
c002beab:	8d 83 46 98 ff ff    	lea    -0x67ba(%ebx),%eax
c002beb1:	50                   	push   %eax
c002beb2:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002beb8:	50                   	push   %eax
c002beb9:	8d 83 c0 99 ff ff    	lea    -0x6640(%ebx),%eax
c002bebf:	50                   	push   %eax
c002bec0:	68 c1 00 00 00       	push   $0xc1
c002bec5:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002becb:	50                   	push   %eax
c002becc:	e8 93 f8 ff ff       	call   c002b764 <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c002bed1:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bed4:	8b 00                	mov    (%eax),%eax
c002bed6:	8b 55 10             	mov    0x10(%ebp),%edx
c002bed9:	8b 52 04             	mov    0x4(%edx),%edx
c002bedc:	89 50 04             	mov    %edx,0x4(%eax)
  last->next->prev = first->prev;
c002bedf:	8b 45 10             	mov    0x10(%ebp),%eax
c002bee2:	8b 40 04             	mov    0x4(%eax),%eax
c002bee5:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bee8:	8b 12                	mov    (%edx),%edx
c002beea:	89 10                	mov    %edx,(%eax)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c002beec:	8b 45 08             	mov    0x8(%ebp),%eax
c002beef:	8b 10                	mov    (%eax),%edx
c002bef1:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bef4:	89 10                	mov    %edx,(%eax)
  last->next = before;
c002bef6:	8b 45 10             	mov    0x10(%ebp),%eax
c002bef9:	8b 55 08             	mov    0x8(%ebp),%edx
c002befc:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = first;
c002beff:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf02:	8b 00                	mov    (%eax),%eax
c002bf04:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bf07:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = last;
c002bf0a:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf0d:	8b 55 10             	mov    0x10(%ebp),%edx
c002bf10:	89 10                	mov    %edx,(%eax)
c002bf12:	eb 01                	jmp    c002bf15 <list_splice+0x130>
    return;
c002bf14:	90                   	nop
}
c002bf15:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bf18:	c9                   	leave  
c002bf19:	c3                   	ret    

c002bf1a <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c002bf1a:	55                   	push   %ebp
c002bf1b:	89 e5                	mov    %esp,%ebp
c002bf1d:	83 ec 08             	sub    $0x8,%esp
c002bf20:	e8 03 55 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002bf25:	05 53 e4 00 00       	add    $0xe453,%eax
  list_insert (list_begin (list), elem);
c002bf2a:	83 ec 0c             	sub    $0xc,%esp
c002bf2d:	ff 75 08             	push   0x8(%ebp)
c002bf30:	e8 7c fb ff ff       	call   c002bab1 <list_begin>
c002bf35:	83 c4 10             	add    $0x10,%esp
c002bf38:	83 ec 08             	sub    $0x8,%esp
c002bf3b:	ff 75 0c             	push   0xc(%ebp)
c002bf3e:	50                   	push   %eax
c002bf3f:	e8 ed fd ff ff       	call   c002bd31 <list_insert>
c002bf44:	83 c4 10             	add    $0x10,%esp
}
c002bf47:	90                   	nop
c002bf48:	c9                   	leave  
c002bf49:	c3                   	ret    

c002bf4a <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c002bf4a:	55                   	push   %ebp
c002bf4b:	89 e5                	mov    %esp,%ebp
c002bf4d:	83 ec 08             	sub    $0x8,%esp
c002bf50:	e8 d3 54 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002bf55:	05 23 e4 00 00       	add    $0xe423,%eax
  list_insert (list_end (list), elem);
c002bf5a:	83 ec 0c             	sub    $0xc,%esp
c002bf5d:	ff 75 08             	push   0x8(%ebp)
c002bf60:	e8 f7 fb ff ff       	call   c002bb5c <list_end>
c002bf65:	83 c4 10             	add    $0x10,%esp
c002bf68:	83 ec 08             	sub    $0x8,%esp
c002bf6b:	ff 75 0c             	push   0xc(%ebp)
c002bf6e:	50                   	push   %eax
c002bf6f:	e8 bd fd ff ff       	call   c002bd31 <list_insert>
c002bf74:	83 c4 10             	add    $0x10,%esp
}
c002bf77:	90                   	nop
c002bf78:	c9                   	leave  
c002bf79:	c3                   	ret    

c002bf7a <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c002bf7a:	55                   	push   %ebp
c002bf7b:	89 e5                	mov    %esp,%ebp
c002bf7d:	53                   	push   %ebx
c002bf7e:	83 ec 04             	sub    $0x4,%esp
c002bf81:	e8 a6 54 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002bf86:	81 c3 f2 e3 00 00    	add    $0xe3f2,%ebx
  ASSERT (is_interior (elem));
c002bf8c:	ff 75 08             	push   0x8(%ebp)
c002bf8f:	e8 42 fa ff ff       	call   c002b9d6 <is_interior>
c002bf94:	83 c4 04             	add    $0x4,%esp
c002bf97:	84 c0                	test   %al,%al
c002bf99:	75 29                	jne    c002bfc4 <list_remove+0x4a>
c002bf9b:	83 ec 0c             	sub    $0xc,%esp
c002bf9e:	8d 83 59 98 ff ff    	lea    -0x67a7(%ebx),%eax
c002bfa4:	50                   	push   %eax
c002bfa5:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002bfab:	50                   	push   %eax
c002bfac:	8d 83 cc 99 ff ff    	lea    -0x6634(%ebx),%eax
c002bfb2:	50                   	push   %eax
c002bfb3:	68 fb 00 00 00       	push   $0xfb
c002bfb8:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002bfbe:	50                   	push   %eax
c002bfbf:	e8 a0 f7 ff ff       	call   c002b764 <debug_panic>
  elem->prev->next = elem->next;
c002bfc4:	8b 45 08             	mov    0x8(%ebp),%eax
c002bfc7:	8b 00                	mov    (%eax),%eax
c002bfc9:	8b 55 08             	mov    0x8(%ebp),%edx
c002bfcc:	8b 52 04             	mov    0x4(%edx),%edx
c002bfcf:	89 50 04             	mov    %edx,0x4(%eax)
  elem->next->prev = elem->prev;
c002bfd2:	8b 45 08             	mov    0x8(%ebp),%eax
c002bfd5:	8b 40 04             	mov    0x4(%eax),%eax
c002bfd8:	8b 55 08             	mov    0x8(%ebp),%edx
c002bfdb:	8b 12                	mov    (%edx),%edx
c002bfdd:	89 10                	mov    %edx,(%eax)
  return elem->next;
c002bfdf:	8b 45 08             	mov    0x8(%ebp),%eax
c002bfe2:	8b 40 04             	mov    0x4(%eax),%eax
}
c002bfe5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bfe8:	c9                   	leave  
c002bfe9:	c3                   	ret    

c002bfea <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c002bfea:	55                   	push   %ebp
c002bfeb:	89 e5                	mov    %esp,%ebp
c002bfed:	83 ec 18             	sub    $0x18,%esp
c002bff0:	e8 33 54 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002bff5:	05 83 e3 00 00       	add    $0xe383,%eax
  struct list_elem *front = list_front (list);
c002bffa:	83 ec 0c             	sub    $0xc,%esp
c002bffd:	ff 75 08             	push   0x8(%ebp)
c002c000:	e8 4d 00 00 00       	call   c002c052 <list_front>
c002c005:	83 c4 10             	add    $0x10,%esp
c002c008:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (front);
c002c00b:	83 ec 0c             	sub    $0xc,%esp
c002c00e:	ff 75 f4             	push   -0xc(%ebp)
c002c011:	e8 64 ff ff ff       	call   c002bf7a <list_remove>
c002c016:	83 c4 10             	add    $0x10,%esp
  return front;
c002c019:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002c01c:	c9                   	leave  
c002c01d:	c3                   	ret    

c002c01e <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c002c01e:	55                   	push   %ebp
c002c01f:	89 e5                	mov    %esp,%ebp
c002c021:	83 ec 18             	sub    $0x18,%esp
c002c024:	e8 ff 53 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c029:	05 4f e3 00 00       	add    $0xe34f,%eax
  struct list_elem *back = list_back (list);
c002c02e:	83 ec 0c             	sub    $0xc,%esp
c002c031:	ff 75 08             	push   0x8(%ebp)
c002c034:	e8 74 00 00 00       	call   c002c0ad <list_back>
c002c039:	83 c4 10             	add    $0x10,%esp
c002c03c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (back);
c002c03f:	83 ec 0c             	sub    $0xc,%esp
c002c042:	ff 75 f4             	push   -0xc(%ebp)
c002c045:	e8 30 ff ff ff       	call   c002bf7a <list_remove>
c002c04a:	83 c4 10             	add    $0x10,%esp
  return back;
c002c04d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002c050:	c9                   	leave  
c002c051:	c3                   	ret    

c002c052 <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c002c052:	55                   	push   %ebp
c002c053:	89 e5                	mov    %esp,%ebp
c002c055:	53                   	push   %ebx
c002c056:	83 ec 04             	sub    $0x4,%esp
c002c059:	e8 ce 53 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002c05e:	81 c3 1a e3 00 00    	add    $0xe31a,%ebx
  ASSERT (!list_empty (list));
c002c064:	83 ec 0c             	sub    $0xc,%esp
c002c067:	ff 75 08             	push   0x8(%ebp)
c002c06a:	e8 f0 00 00 00       	call   c002c15f <list_empty>
c002c06f:	83 c4 10             	add    $0x10,%esp
c002c072:	83 f0 01             	xor    $0x1,%eax
c002c075:	84 c0                	test   %al,%al
c002c077:	75 29                	jne    c002c0a2 <list_front+0x50>
c002c079:	83 ec 0c             	sub    $0xc,%esp
c002c07c:	8d 83 6c 98 ff ff    	lea    -0x6794(%ebx),%eax
c002c082:	50                   	push   %eax
c002c083:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c089:	50                   	push   %eax
c002c08a:	8d 83 d8 99 ff ff    	lea    -0x6628(%ebx),%eax
c002c090:	50                   	push   %eax
c002c091:	68 1a 01 00 00       	push   $0x11a
c002c096:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c09c:	50                   	push   %eax
c002c09d:	e8 c2 f6 ff ff       	call   c002b764 <debug_panic>
  return list->head.next;
c002c0a2:	8b 45 08             	mov    0x8(%ebp),%eax
c002c0a5:	8b 40 04             	mov    0x4(%eax),%eax
}
c002c0a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c0ab:	c9                   	leave  
c002c0ac:	c3                   	ret    

c002c0ad <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c002c0ad:	55                   	push   %ebp
c002c0ae:	89 e5                	mov    %esp,%ebp
c002c0b0:	53                   	push   %ebx
c002c0b1:	83 ec 04             	sub    $0x4,%esp
c002c0b4:	e8 73 53 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002c0b9:	81 c3 bf e2 00 00    	add    $0xe2bf,%ebx
  ASSERT (!list_empty (list));
c002c0bf:	83 ec 0c             	sub    $0xc,%esp
c002c0c2:	ff 75 08             	push   0x8(%ebp)
c002c0c5:	e8 95 00 00 00       	call   c002c15f <list_empty>
c002c0ca:	83 c4 10             	add    $0x10,%esp
c002c0cd:	83 f0 01             	xor    $0x1,%eax
c002c0d0:	84 c0                	test   %al,%al
c002c0d2:	75 29                	jne    c002c0fd <list_back+0x50>
c002c0d4:	83 ec 0c             	sub    $0xc,%esp
c002c0d7:	8d 83 6c 98 ff ff    	lea    -0x6794(%ebx),%eax
c002c0dd:	50                   	push   %eax
c002c0de:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c0e4:	50                   	push   %eax
c002c0e5:	8d 83 e4 99 ff ff    	lea    -0x661c(%ebx),%eax
c002c0eb:	50                   	push   %eax
c002c0ec:	68 23 01 00 00       	push   $0x123
c002c0f1:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c0f7:	50                   	push   %eax
c002c0f8:	e8 67 f6 ff ff       	call   c002b764 <debug_panic>
  return list->tail.prev;
c002c0fd:	8b 45 08             	mov    0x8(%ebp),%eax
c002c100:	8b 40 08             	mov    0x8(%eax),%eax
}
c002c103:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c106:	c9                   	leave  
c002c107:	c3                   	ret    

c002c108 <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c002c108:	55                   	push   %ebp
c002c109:	89 e5                	mov    %esp,%ebp
c002c10b:	83 ec 18             	sub    $0x18,%esp
c002c10e:	e8 15 53 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c113:	05 65 e2 00 00       	add    $0xe265,%eax
  struct list_elem *e;
  size_t cnt = 0;
c002c118:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002c11f:	83 ec 0c             	sub    $0xc,%esp
c002c122:	ff 75 08             	push   0x8(%ebp)
c002c125:	e8 87 f9 ff ff       	call   c002bab1 <list_begin>
c002c12a:	83 c4 10             	add    $0x10,%esp
c002c12d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002c130:	eb 15                	jmp    c002c147 <list_size+0x3f>
    cnt++;
c002c132:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002c136:	83 ec 0c             	sub    $0xc,%esp
c002c139:	ff 75 f4             	push   -0xc(%ebp)
c002c13c:	e8 ba f9 ff ff       	call   c002bafb <list_next>
c002c141:	83 c4 10             	add    $0x10,%esp
c002c144:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002c147:	83 ec 0c             	sub    $0xc,%esp
c002c14a:	ff 75 08             	push   0x8(%ebp)
c002c14d:	e8 0a fa ff ff       	call   c002bb5c <list_end>
c002c152:	83 c4 10             	add    $0x10,%esp
c002c155:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002c158:	75 d8                	jne    c002c132 <list_size+0x2a>
  return cnt;
c002c15a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002c15d:	c9                   	leave  
c002c15e:	c3                   	ret    

c002c15f <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c002c15f:	55                   	push   %ebp
c002c160:	89 e5                	mov    %esp,%ebp
c002c162:	53                   	push   %ebx
c002c163:	83 ec 04             	sub    $0x4,%esp
c002c166:	e8 bd 52 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c16b:	05 0d e2 00 00       	add    $0xe20d,%eax
  return list_begin (list) == list_end (list);
c002c170:	83 ec 0c             	sub    $0xc,%esp
c002c173:	ff 75 08             	push   0x8(%ebp)
c002c176:	e8 36 f9 ff ff       	call   c002bab1 <list_begin>
c002c17b:	83 c4 10             	add    $0x10,%esp
c002c17e:	89 c3                	mov    %eax,%ebx
c002c180:	83 ec 0c             	sub    $0xc,%esp
c002c183:	ff 75 08             	push   0x8(%ebp)
c002c186:	e8 d1 f9 ff ff       	call   c002bb5c <list_end>
c002c18b:	83 c4 10             	add    $0x10,%esp
c002c18e:	39 c3                	cmp    %eax,%ebx
c002c190:	0f 94 c0             	sete   %al
}
c002c193:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c196:	c9                   	leave  
c002c197:	c3                   	ret    

c002c198 <swap>:

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
c002c198:	55                   	push   %ebp
c002c199:	89 e5                	mov    %esp,%ebp
c002c19b:	83 ec 10             	sub    $0x10,%esp
c002c19e:	e8 85 52 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c1a3:	05 d5 e1 00 00       	add    $0xe1d5,%eax
  struct list_elem *t = *a;
c002c1a8:	8b 45 08             	mov    0x8(%ebp),%eax
c002c1ab:	8b 00                	mov    (%eax),%eax
c002c1ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *a = *b;
c002c1b0:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c1b3:	8b 10                	mov    (%eax),%edx
c002c1b5:	8b 45 08             	mov    0x8(%ebp),%eax
c002c1b8:	89 10                	mov    %edx,(%eax)
  *b = t;
c002c1ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c1bd:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002c1c0:	89 10                	mov    %edx,(%eax)
}
c002c1c2:	90                   	nop
c002c1c3:	c9                   	leave  
c002c1c4:	c3                   	ret    

c002c1c5 <list_reverse>:

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c002c1c5:	55                   	push   %ebp
c002c1c6:	89 e5                	mov    %esp,%ebp
c002c1c8:	83 ec 18             	sub    $0x18,%esp
c002c1cb:	e8 58 52 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c1d0:	05 a8 e1 00 00       	add    $0xe1a8,%eax
  if (!list_empty (list)) 
c002c1d5:	83 ec 0c             	sub    $0xc,%esp
c002c1d8:	ff 75 08             	push   0x8(%ebp)
c002c1db:	e8 7f ff ff ff       	call   c002c15f <list_empty>
c002c1e0:	83 c4 10             	add    $0x10,%esp
c002c1e3:	83 f0 01             	xor    $0x1,%eax
c002c1e6:	84 c0                	test   %al,%al
c002c1e8:	74 79                	je     c002c263 <list_reverse+0x9e>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002c1ea:	83 ec 0c             	sub    $0xc,%esp
c002c1ed:	ff 75 08             	push   0x8(%ebp)
c002c1f0:	e8 bc f8 ff ff       	call   c002bab1 <list_begin>
c002c1f5:	83 c4 10             	add    $0x10,%esp
c002c1f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002c1fb:	eb 1e                	jmp    c002c21b <list_reverse+0x56>
        swap (&e->prev, &e->next);
c002c1fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c200:	8d 50 04             	lea    0x4(%eax),%edx
c002c203:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c206:	83 ec 08             	sub    $0x8,%esp
c002c209:	52                   	push   %edx
c002c20a:	50                   	push   %eax
c002c20b:	e8 88 ff ff ff       	call   c002c198 <swap>
c002c210:	83 c4 10             	add    $0x10,%esp
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002c213:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c216:	8b 00                	mov    (%eax),%eax
c002c218:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002c21b:	83 ec 0c             	sub    $0xc,%esp
c002c21e:	ff 75 08             	push   0x8(%ebp)
c002c221:	e8 36 f9 ff ff       	call   c002bb5c <list_end>
c002c226:	83 c4 10             	add    $0x10,%esp
c002c229:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002c22c:	75 cf                	jne    c002c1fd <list_reverse+0x38>
      swap (&list->head.next, &list->tail.prev);
c002c22e:	8b 45 08             	mov    0x8(%ebp),%eax
c002c231:	8d 50 08             	lea    0x8(%eax),%edx
c002c234:	8b 45 08             	mov    0x8(%ebp),%eax
c002c237:	83 c0 04             	add    $0x4,%eax
c002c23a:	83 ec 08             	sub    $0x8,%esp
c002c23d:	52                   	push   %edx
c002c23e:	50                   	push   %eax
c002c23f:	e8 54 ff ff ff       	call   c002c198 <swap>
c002c244:	83 c4 10             	add    $0x10,%esp
      swap (&list->head.next->prev, &list->tail.prev->next);
c002c247:	8b 45 08             	mov    0x8(%ebp),%eax
c002c24a:	8b 40 08             	mov    0x8(%eax),%eax
c002c24d:	8d 50 04             	lea    0x4(%eax),%edx
c002c250:	8b 45 08             	mov    0x8(%ebp),%eax
c002c253:	8b 40 04             	mov    0x4(%eax),%eax
c002c256:	83 ec 08             	sub    $0x8,%esp
c002c259:	52                   	push   %edx
c002c25a:	50                   	push   %eax
c002c25b:	e8 38 ff ff ff       	call   c002c198 <swap>
c002c260:	83 c4 10             	add    $0x10,%esp
    }
}
c002c263:	90                   	nop
c002c264:	c9                   	leave  
c002c265:	c3                   	ret    

c002c266 <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c002c266:	55                   	push   %ebp
c002c267:	89 e5                	mov    %esp,%ebp
c002c269:	83 ec 08             	sub    $0x8,%esp
c002c26c:	e8 b7 51 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c271:	05 07 e1 00 00       	add    $0xe107,%eax
  if (a != b)
c002c276:	8b 45 08             	mov    0x8(%ebp),%eax
c002c279:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002c27c:	74 46                	je     c002c2c4 <is_sorted+0x5e>
    while ((a = list_next (a)) != b) 
c002c27e:	eb 2b                	jmp    c002c2ab <is_sorted+0x45>
      if (less (a, list_prev (a), aux))
c002c280:	83 ec 0c             	sub    $0xc,%esp
c002c283:	ff 75 08             	push   0x8(%ebp)
c002c286:	e8 65 f9 ff ff       	call   c002bbf0 <list_prev>
c002c28b:	83 c4 10             	add    $0x10,%esp
c002c28e:	83 ec 04             	sub    $0x4,%esp
c002c291:	ff 75 14             	push   0x14(%ebp)
c002c294:	50                   	push   %eax
c002c295:	ff 75 08             	push   0x8(%ebp)
c002c298:	8b 45 10             	mov    0x10(%ebp),%eax
c002c29b:	ff d0                	call   *%eax
c002c29d:	83 c4 10             	add    $0x10,%esp
c002c2a0:	84 c0                	test   %al,%al
c002c2a2:	74 07                	je     c002c2ab <is_sorted+0x45>
        return false;
c002c2a4:	b8 00 00 00 00       	mov    $0x0,%eax
c002c2a9:	eb 1e                	jmp    c002c2c9 <is_sorted+0x63>
    while ((a = list_next (a)) != b) 
c002c2ab:	83 ec 0c             	sub    $0xc,%esp
c002c2ae:	ff 75 08             	push   0x8(%ebp)
c002c2b1:	e8 45 f8 ff ff       	call   c002bafb <list_next>
c002c2b6:	83 c4 10             	add    $0x10,%esp
c002c2b9:	89 45 08             	mov    %eax,0x8(%ebp)
c002c2bc:	8b 45 08             	mov    0x8(%ebp),%eax
c002c2bf:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002c2c2:	75 bc                	jne    c002c280 <is_sorted+0x1a>
  return true;
c002c2c4:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002c2c9:	c9                   	leave  
c002c2ca:	c3                   	ret    

c002c2cb <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c002c2cb:	55                   	push   %ebp
c002c2cc:	89 e5                	mov    %esp,%ebp
c002c2ce:	53                   	push   %ebx
c002c2cf:	83 ec 04             	sub    $0x4,%esp
c002c2d2:	e8 51 51 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c2d7:	05 a1 e0 00 00       	add    $0xe0a1,%eax
  ASSERT (a != NULL);
c002c2dc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002c2e0:	75 2b                	jne    c002c30d <find_end_of_run+0x42>
c002c2e2:	83 ec 0c             	sub    $0xc,%esp
c002c2e5:	8d 90 7f 98 ff ff    	lea    -0x6781(%eax),%edx
c002c2eb:	52                   	push   %edx
c002c2ec:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002c2f2:	52                   	push   %edx
c002c2f3:	8d 90 f0 99 ff ff    	lea    -0x6610(%eax),%edx
c002c2f9:	52                   	push   %edx
c002c2fa:	68 69 01 00 00       	push   $0x169
c002c2ff:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002c305:	52                   	push   %edx
c002c306:	89 c3                	mov    %eax,%ebx
c002c308:	e8 57 f4 ff ff       	call   c002b764 <debug_panic>
  ASSERT (b != NULL);
c002c30d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002c311:	75 2b                	jne    c002c33e <find_end_of_run+0x73>
c002c313:	83 ec 0c             	sub    $0xc,%esp
c002c316:	8d 90 89 98 ff ff    	lea    -0x6777(%eax),%edx
c002c31c:	52                   	push   %edx
c002c31d:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002c323:	52                   	push   %edx
c002c324:	8d 90 f0 99 ff ff    	lea    -0x6610(%eax),%edx
c002c32a:	52                   	push   %edx
c002c32b:	68 6a 01 00 00       	push   $0x16a
c002c330:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002c336:	52                   	push   %edx
c002c337:	89 c3                	mov    %eax,%ebx
c002c339:	e8 26 f4 ff ff       	call   c002b764 <debug_panic>
  ASSERT (less != NULL);
c002c33e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002c342:	75 2b                	jne    c002c36f <find_end_of_run+0xa4>
c002c344:	83 ec 0c             	sub    $0xc,%esp
c002c347:	8d 90 93 98 ff ff    	lea    -0x676d(%eax),%edx
c002c34d:	52                   	push   %edx
c002c34e:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002c354:	52                   	push   %edx
c002c355:	8d 90 f0 99 ff ff    	lea    -0x6610(%eax),%edx
c002c35b:	52                   	push   %edx
c002c35c:	68 6b 01 00 00       	push   $0x16b
c002c361:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002c367:	52                   	push   %edx
c002c368:	89 c3                	mov    %eax,%ebx
c002c36a:	e8 f5 f3 ff ff       	call   c002b764 <debug_panic>
  ASSERT (a != b);
c002c36f:	8b 55 08             	mov    0x8(%ebp),%edx
c002c372:	3b 55 0c             	cmp    0xc(%ebp),%edx
c002c375:	75 2b                	jne    c002c3a2 <find_end_of_run+0xd7>
c002c377:	83 ec 0c             	sub    $0xc,%esp
c002c37a:	8d 90 a0 98 ff ff    	lea    -0x6760(%eax),%edx
c002c380:	52                   	push   %edx
c002c381:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002c387:	52                   	push   %edx
c002c388:	8d 90 f0 99 ff ff    	lea    -0x6610(%eax),%edx
c002c38e:	52                   	push   %edx
c002c38f:	68 6c 01 00 00       	push   $0x16c
c002c394:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002c39a:	52                   	push   %edx
c002c39b:	89 c3                	mov    %eax,%ebx
c002c39d:	e8 c2 f3 ff ff       	call   c002b764 <debug_panic>
  
  do 
    {
      a = list_next (a);
c002c3a2:	83 ec 0c             	sub    $0xc,%esp
c002c3a5:	ff 75 08             	push   0x8(%ebp)
c002c3a8:	e8 4e f7 ff ff       	call   c002bafb <list_next>
c002c3ad:	83 c4 10             	add    $0x10,%esp
c002c3b0:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  while (a != b && !less (a, list_prev (a), aux));
c002c3b3:	8b 45 08             	mov    0x8(%ebp),%eax
c002c3b6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002c3b9:	74 27                	je     c002c3e2 <find_end_of_run+0x117>
c002c3bb:	83 ec 0c             	sub    $0xc,%esp
c002c3be:	ff 75 08             	push   0x8(%ebp)
c002c3c1:	e8 2a f8 ff ff       	call   c002bbf0 <list_prev>
c002c3c6:	83 c4 10             	add    $0x10,%esp
c002c3c9:	83 ec 04             	sub    $0x4,%esp
c002c3cc:	ff 75 14             	push   0x14(%ebp)
c002c3cf:	50                   	push   %eax
c002c3d0:	ff 75 08             	push   0x8(%ebp)
c002c3d3:	8b 45 10             	mov    0x10(%ebp),%eax
c002c3d6:	ff d0                	call   *%eax
c002c3d8:	83 c4 10             	add    $0x10,%esp
c002c3db:	83 f0 01             	xor    $0x1,%eax
c002c3de:	84 c0                	test   %al,%al
c002c3e0:	75 c0                	jne    c002c3a2 <find_end_of_run+0xd7>
  return a;
c002c3e2:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002c3e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c3e8:	c9                   	leave  
c002c3e9:	c3                   	ret    

c002c3ea <inplace_merge>:
   AUX.  The output range will be sorted the same way. */
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
c002c3ea:	55                   	push   %ebp
c002c3eb:	89 e5                	mov    %esp,%ebp
c002c3ed:	53                   	push   %ebx
c002c3ee:	83 ec 04             	sub    $0x4,%esp
c002c3f1:	e8 36 50 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002c3f6:	81 c3 82 df 00 00    	add    $0xdf82,%ebx
  ASSERT (a0 != NULL);
c002c3fc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002c400:	75 29                	jne    c002c42b <inplace_merge+0x41>
c002c402:	83 ec 0c             	sub    $0xc,%esp
c002c405:	8d 83 a7 98 ff ff    	lea    -0x6759(%ebx),%eax
c002c40b:	50                   	push   %eax
c002c40c:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c412:	50                   	push   %eax
c002c413:	8d 83 00 9a ff ff    	lea    -0x6600(%ebx),%eax
c002c419:	50                   	push   %eax
c002c41a:	68 80 01 00 00       	push   $0x180
c002c41f:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c425:	50                   	push   %eax
c002c426:	e8 39 f3 ff ff       	call   c002b764 <debug_panic>
  ASSERT (a1b0 != NULL);
c002c42b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002c42f:	75 29                	jne    c002c45a <inplace_merge+0x70>
c002c431:	83 ec 0c             	sub    $0xc,%esp
c002c434:	8d 83 b2 98 ff ff    	lea    -0x674e(%ebx),%eax
c002c43a:	50                   	push   %eax
c002c43b:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c441:	50                   	push   %eax
c002c442:	8d 83 00 9a ff ff    	lea    -0x6600(%ebx),%eax
c002c448:	50                   	push   %eax
c002c449:	68 81 01 00 00       	push   $0x181
c002c44e:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c454:	50                   	push   %eax
c002c455:	e8 0a f3 ff ff       	call   c002b764 <debug_panic>
  ASSERT (b1 != NULL);
c002c45a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002c45e:	75 29                	jne    c002c489 <inplace_merge+0x9f>
c002c460:	83 ec 0c             	sub    $0xc,%esp
c002c463:	8d 83 bf 98 ff ff    	lea    -0x6741(%ebx),%eax
c002c469:	50                   	push   %eax
c002c46a:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c470:	50                   	push   %eax
c002c471:	8d 83 00 9a ff ff    	lea    -0x6600(%ebx),%eax
c002c477:	50                   	push   %eax
c002c478:	68 82 01 00 00       	push   $0x182
c002c47d:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c483:	50                   	push   %eax
c002c484:	e8 db f2 ff ff       	call   c002b764 <debug_panic>
  ASSERT (less != NULL);
c002c489:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002c48d:	75 29                	jne    c002c4b8 <inplace_merge+0xce>
c002c48f:	83 ec 0c             	sub    $0xc,%esp
c002c492:	8d 83 93 98 ff ff    	lea    -0x676d(%ebx),%eax
c002c498:	50                   	push   %eax
c002c499:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c49f:	50                   	push   %eax
c002c4a0:	8d 83 00 9a ff ff    	lea    -0x6600(%ebx),%eax
c002c4a6:	50                   	push   %eax
c002c4a7:	68 83 01 00 00       	push   $0x183
c002c4ac:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c4b2:	50                   	push   %eax
c002c4b3:	e8 ac f2 ff ff       	call   c002b764 <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c002c4b8:	ff 75 18             	push   0x18(%ebp)
c002c4bb:	ff 75 14             	push   0x14(%ebp)
c002c4be:	ff 75 0c             	push   0xc(%ebp)
c002c4c1:	ff 75 08             	push   0x8(%ebp)
c002c4c4:	e8 9d fd ff ff       	call   c002c266 <is_sorted>
c002c4c9:	83 c4 10             	add    $0x10,%esp
c002c4cc:	84 c0                	test   %al,%al
c002c4ce:	75 29                	jne    c002c4f9 <inplace_merge+0x10f>
c002c4d0:	83 ec 0c             	sub    $0xc,%esp
c002c4d3:	8d 83 cc 98 ff ff    	lea    -0x6734(%ebx),%eax
c002c4d9:	50                   	push   %eax
c002c4da:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c4e0:	50                   	push   %eax
c002c4e1:	8d 83 00 9a ff ff    	lea    -0x6600(%ebx),%eax
c002c4e7:	50                   	push   %eax
c002c4e8:	68 84 01 00 00       	push   $0x184
c002c4ed:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c4f3:	50                   	push   %eax
c002c4f4:	e8 6b f2 ff ff       	call   c002b764 <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c002c4f9:	ff 75 18             	push   0x18(%ebp)
c002c4fc:	ff 75 14             	push   0x14(%ebp)
c002c4ff:	ff 75 10             	push   0x10(%ebp)
c002c502:	ff 75 0c             	push   0xc(%ebp)
c002c505:	e8 5c fd ff ff       	call   c002c266 <is_sorted>
c002c50a:	83 c4 10             	add    $0x10,%esp
c002c50d:	84 c0                	test   %al,%al
c002c50f:	0f 85 88 00 00 00    	jne    c002c59d <inplace_merge+0x1b3>
c002c515:	83 ec 0c             	sub    $0xc,%esp
c002c518:	8d 83 ec 98 ff ff    	lea    -0x6714(%ebx),%eax
c002c51e:	50                   	push   %eax
c002c51f:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c525:	50                   	push   %eax
c002c526:	8d 83 00 9a ff ff    	lea    -0x6600(%ebx),%eax
c002c52c:	50                   	push   %eax
c002c52d:	68 85 01 00 00       	push   $0x185
c002c532:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c538:	50                   	push   %eax
c002c539:	e8 26 f2 ff ff       	call   c002b764 <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002c53e:	83 ec 04             	sub    $0x4,%esp
c002c541:	ff 75 18             	push   0x18(%ebp)
c002c544:	ff 75 08             	push   0x8(%ebp)
c002c547:	ff 75 0c             	push   0xc(%ebp)
c002c54a:	8b 45 14             	mov    0x14(%ebp),%eax
c002c54d:	ff d0                	call   *%eax
c002c54f:	83 c4 10             	add    $0x10,%esp
c002c552:	83 f0 01             	xor    $0x1,%eax
c002c555:	84 c0                	test   %al,%al
c002c557:	74 13                	je     c002c56c <inplace_merge+0x182>
      a0 = list_next (a0);
c002c559:	83 ec 0c             	sub    $0xc,%esp
c002c55c:	ff 75 08             	push   0x8(%ebp)
c002c55f:	e8 97 f5 ff ff       	call   c002bafb <list_next>
c002c564:	83 c4 10             	add    $0x10,%esp
c002c567:	89 45 08             	mov    %eax,0x8(%ebp)
c002c56a:	eb 31                	jmp    c002c59d <inplace_merge+0x1b3>
    else 
      {
        a1b0 = list_next (a1b0);
c002c56c:	83 ec 0c             	sub    $0xc,%esp
c002c56f:	ff 75 0c             	push   0xc(%ebp)
c002c572:	e8 84 f5 ff ff       	call   c002bafb <list_next>
c002c577:	83 c4 10             	add    $0x10,%esp
c002c57a:	89 45 0c             	mov    %eax,0xc(%ebp)
        list_splice (a0, list_prev (a1b0), a1b0);
c002c57d:	83 ec 0c             	sub    $0xc,%esp
c002c580:	ff 75 0c             	push   0xc(%ebp)
c002c583:	e8 68 f6 ff ff       	call   c002bbf0 <list_prev>
c002c588:	83 c4 10             	add    $0x10,%esp
c002c58b:	83 ec 04             	sub    $0x4,%esp
c002c58e:	ff 75 0c             	push   0xc(%ebp)
c002c591:	50                   	push   %eax
c002c592:	ff 75 08             	push   0x8(%ebp)
c002c595:	e8 4b f8 ff ff       	call   c002bde5 <list_splice>
c002c59a:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c002c59d:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5a0:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002c5a3:	74 08                	je     c002c5ad <inplace_merge+0x1c3>
c002c5a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c5a8:	3b 45 10             	cmp    0x10(%ebp),%eax
c002c5ab:	75 91                	jne    c002c53e <inplace_merge+0x154>
      }
}
c002c5ad:	90                   	nop
c002c5ae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c5b1:	c9                   	leave  
c002c5b2:	c3                   	ret    

c002c5b3 <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c002c5b3:	55                   	push   %ebp
c002c5b4:	89 e5                	mov    %esp,%ebp
c002c5b6:	56                   	push   %esi
c002c5b7:	53                   	push   %ebx
c002c5b8:	83 ec 10             	sub    $0x10,%esp
c002c5bb:	e8 6c 4e 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002c5c0:	81 c3 b8 dd 00 00    	add    $0xddb8,%ebx
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002c5c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002c5ca:	75 29                	jne    c002c5f5 <list_sort+0x42>
c002c5cc:	83 ec 0c             	sub    $0xc,%esp
c002c5cf:	8d 83 70 97 ff ff    	lea    -0x6890(%ebx),%eax
c002c5d5:	50                   	push   %eax
c002c5d6:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c5dc:	50                   	push   %eax
c002c5dd:	8d 83 10 9a ff ff    	lea    -0x65f0(%ebx),%eax
c002c5e3:	50                   	push   %eax
c002c5e4:	68 99 01 00 00       	push   $0x199
c002c5e9:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c5ef:	50                   	push   %eax
c002c5f0:	e8 6f f1 ff ff       	call   c002b764 <debug_panic>
  ASSERT (less != NULL);
c002c5f5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002c5f9:	75 29                	jne    c002c624 <list_sort+0x71>
c002c5fb:	83 ec 0c             	sub    $0xc,%esp
c002c5fe:	8d 83 93 98 ff ff    	lea    -0x676d(%ebx),%eax
c002c604:	50                   	push   %eax
c002c605:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c60b:	50                   	push   %eax
c002c60c:	8d 83 10 9a ff ff    	lea    -0x65f0(%ebx),%eax
c002c612:	50                   	push   %eax
c002c613:	68 9a 01 00 00       	push   $0x19a
c002c618:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c61e:	50                   	push   %eax
c002c61f:	e8 40 f1 ff ff       	call   c002b764 <debug_panic>
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c002c624:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002c62b:	83 ec 0c             	sub    $0xc,%esp
c002c62e:	ff 75 08             	push   0x8(%ebp)
c002c631:	e8 7b f4 ff ff       	call   c002bab1 <list_begin>
c002c636:	83 c4 10             	add    $0x10,%esp
c002c639:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c63c:	eb 7d                	jmp    c002c6bb <list_sort+0x108>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c002c63e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002c642:	83 ec 0c             	sub    $0xc,%esp
c002c645:	ff 75 08             	push   0x8(%ebp)
c002c648:	e8 0f f5 ff ff       	call   c002bb5c <list_end>
c002c64d:	83 c4 10             	add    $0x10,%esp
c002c650:	ff 75 10             	push   0x10(%ebp)
c002c653:	ff 75 0c             	push   0xc(%ebp)
c002c656:	50                   	push   %eax
c002c657:	ff 75 f0             	push   -0x10(%ebp)
c002c65a:	e8 6c fc ff ff       	call   c002c2cb <find_end_of_run>
c002c65f:	83 c4 10             	add    $0x10,%esp
c002c662:	89 45 ec             	mov    %eax,-0x14(%ebp)
          if (a1b0 == list_end (list))
c002c665:	83 ec 0c             	sub    $0xc,%esp
c002c668:	ff 75 08             	push   0x8(%ebp)
c002c66b:	e8 ec f4 ff ff       	call   c002bb5c <list_end>
c002c670:	83 c4 10             	add    $0x10,%esp
c002c673:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c002c676:	74 5c                	je     c002c6d4 <list_sort+0x121>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c002c678:	83 ec 0c             	sub    $0xc,%esp
c002c67b:	ff 75 08             	push   0x8(%ebp)
c002c67e:	e8 d9 f4 ff ff       	call   c002bb5c <list_end>
c002c683:	83 c4 10             	add    $0x10,%esp
c002c686:	ff 75 10             	push   0x10(%ebp)
c002c689:	ff 75 0c             	push   0xc(%ebp)
c002c68c:	50                   	push   %eax
c002c68d:	ff 75 ec             	push   -0x14(%ebp)
c002c690:	e8 36 fc ff ff       	call   c002c2cb <find_end_of_run>
c002c695:	83 c4 10             	add    $0x10,%esp
c002c698:	89 45 e8             	mov    %eax,-0x18(%ebp)

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
c002c69b:	83 ec 0c             	sub    $0xc,%esp
c002c69e:	ff 75 10             	push   0x10(%ebp)
c002c6a1:	ff 75 0c             	push   0xc(%ebp)
c002c6a4:	ff 75 e8             	push   -0x18(%ebp)
c002c6a7:	ff 75 ec             	push   -0x14(%ebp)
c002c6aa:	ff 75 f0             	push   -0x10(%ebp)
c002c6ad:	e8 38 fd ff ff       	call   c002c3ea <inplace_merge>
c002c6b2:	83 c4 20             	add    $0x20,%esp
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002c6b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c6b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c6bb:	83 ec 0c             	sub    $0xc,%esp
c002c6be:	ff 75 08             	push   0x8(%ebp)
c002c6c1:	e8 96 f4 ff ff       	call   c002bb5c <list_end>
c002c6c6:	83 c4 10             	add    $0x10,%esp
c002c6c9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002c6cc:	0f 85 6c ff ff ff    	jne    c002c63e <list_sort+0x8b>
c002c6d2:	eb 01                	jmp    c002c6d5 <list_sort+0x122>
            break;
c002c6d4:	90                   	nop
        }
    }
  while (output_run_cnt > 1);
c002c6d5:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002c6d9:	0f 87 45 ff ff ff    	ja     c002c624 <list_sort+0x71>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002c6df:	83 ec 0c             	sub    $0xc,%esp
c002c6e2:	ff 75 08             	push   0x8(%ebp)
c002c6e5:	e8 72 f4 ff ff       	call   c002bb5c <list_end>
c002c6ea:	83 c4 10             	add    $0x10,%esp
c002c6ed:	89 c6                	mov    %eax,%esi
c002c6ef:	83 ec 0c             	sub    $0xc,%esp
c002c6f2:	ff 75 08             	push   0x8(%ebp)
c002c6f5:	e8 b7 f3 ff ff       	call   c002bab1 <list_begin>
c002c6fa:	83 c4 10             	add    $0x10,%esp
c002c6fd:	ff 75 10             	push   0x10(%ebp)
c002c700:	ff 75 0c             	push   0xc(%ebp)
c002c703:	56                   	push   %esi
c002c704:	50                   	push   %eax
c002c705:	e8 5c fb ff ff       	call   c002c266 <is_sorted>
c002c70a:	83 c4 10             	add    $0x10,%esp
c002c70d:	84 c0                	test   %al,%al
c002c70f:	75 29                	jne    c002c73a <list_sort+0x187>
c002c711:	83 ec 0c             	sub    $0xc,%esp
c002c714:	8d 83 0c 99 ff ff    	lea    -0x66f4(%ebx),%eax
c002c71a:	50                   	push   %eax
c002c71b:	8d 83 7d 97 ff ff    	lea    -0x6883(%ebx),%eax
c002c721:	50                   	push   %eax
c002c722:	8d 83 10 9a ff ff    	lea    -0x65f0(%ebx),%eax
c002c728:	50                   	push   %eax
c002c729:	68 b7 01 00 00       	push   $0x1b7
c002c72e:	8d 83 94 97 ff ff    	lea    -0x686c(%ebx),%eax
c002c734:	50                   	push   %eax
c002c735:	e8 2a f0 ff ff       	call   c002b764 <debug_panic>
}
c002c73a:	90                   	nop
c002c73b:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002c73e:	5b                   	pop    %ebx
c002c73f:	5e                   	pop    %esi
c002c740:	5d                   	pop    %ebp
c002c741:	c3                   	ret    

c002c742 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c002c742:	55                   	push   %ebp
c002c743:	89 e5                	mov    %esp,%ebp
c002c745:	53                   	push   %ebx
c002c746:	83 ec 14             	sub    $0x14,%esp
c002c749:	e8 da 4c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c74e:	05 2a dc 00 00       	add    $0xdc2a,%eax
  struct list_elem *e;

  ASSERT (list != NULL);
c002c753:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002c757:	75 2b                	jne    c002c784 <list_insert_ordered+0x42>
c002c759:	83 ec 0c             	sub    $0xc,%esp
c002c75c:	8d 90 70 97 ff ff    	lea    -0x6890(%eax),%edx
c002c762:	52                   	push   %edx
c002c763:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002c769:	52                   	push   %edx
c002c76a:	8d 90 1c 9a ff ff    	lea    -0x65e4(%eax),%edx
c002c770:	52                   	push   %edx
c002c771:	68 c3 01 00 00       	push   $0x1c3
c002c776:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002c77c:	52                   	push   %edx
c002c77d:	89 c3                	mov    %eax,%ebx
c002c77f:	e8 e0 ef ff ff       	call   c002b764 <debug_panic>
  ASSERT (elem != NULL);
c002c784:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002c788:	75 2b                	jne    c002c7b5 <list_insert_ordered+0x73>
c002c78a:	83 ec 0c             	sub    $0xc,%esp
c002c78d:	8d 90 25 98 ff ff    	lea    -0x67db(%eax),%edx
c002c793:	52                   	push   %edx
c002c794:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002c79a:	52                   	push   %edx
c002c79b:	8d 90 1c 9a ff ff    	lea    -0x65e4(%eax),%edx
c002c7a1:	52                   	push   %edx
c002c7a2:	68 c4 01 00 00       	push   $0x1c4
c002c7a7:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002c7ad:	52                   	push   %edx
c002c7ae:	89 c3                	mov    %eax,%ebx
c002c7b0:	e8 af ef ff ff       	call   c002b764 <debug_panic>
  ASSERT (less != NULL);
c002c7b5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002c7b9:	75 2b                	jne    c002c7e6 <list_insert_ordered+0xa4>
c002c7bb:	83 ec 0c             	sub    $0xc,%esp
c002c7be:	8d 90 93 98 ff ff    	lea    -0x676d(%eax),%edx
c002c7c4:	52                   	push   %edx
c002c7c5:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002c7cb:	52                   	push   %edx
c002c7cc:	8d 90 1c 9a ff ff    	lea    -0x65e4(%eax),%edx
c002c7d2:	52                   	push   %edx
c002c7d3:	68 c5 01 00 00       	push   $0x1c5
c002c7d8:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002c7de:	52                   	push   %edx
c002c7df:	89 c3                	mov    %eax,%ebx
c002c7e1:	e8 7e ef ff ff       	call   c002b764 <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002c7e6:	83 ec 0c             	sub    $0xc,%esp
c002c7e9:	ff 75 08             	push   0x8(%ebp)
c002c7ec:	e8 c0 f2 ff ff       	call   c002bab1 <list_begin>
c002c7f1:	83 c4 10             	add    $0x10,%esp
c002c7f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002c7f7:	eb 29                	jmp    c002c822 <list_insert_ordered+0xe0>
    if (less (elem, e, aux))
c002c7f9:	83 ec 04             	sub    $0x4,%esp
c002c7fc:	ff 75 14             	push   0x14(%ebp)
c002c7ff:	ff 75 f4             	push   -0xc(%ebp)
c002c802:	ff 75 0c             	push   0xc(%ebp)
c002c805:	8b 45 10             	mov    0x10(%ebp),%eax
c002c808:	ff d0                	call   *%eax
c002c80a:	83 c4 10             	add    $0x10,%esp
c002c80d:	84 c0                	test   %al,%al
c002c80f:	75 26                	jne    c002c837 <list_insert_ordered+0xf5>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002c811:	83 ec 0c             	sub    $0xc,%esp
c002c814:	ff 75 f4             	push   -0xc(%ebp)
c002c817:	e8 df f2 ff ff       	call   c002bafb <list_next>
c002c81c:	83 c4 10             	add    $0x10,%esp
c002c81f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002c822:	83 ec 0c             	sub    $0xc,%esp
c002c825:	ff 75 08             	push   0x8(%ebp)
c002c828:	e8 2f f3 ff ff       	call   c002bb5c <list_end>
c002c82d:	83 c4 10             	add    $0x10,%esp
c002c830:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002c833:	75 c4                	jne    c002c7f9 <list_insert_ordered+0xb7>
c002c835:	eb 01                	jmp    c002c838 <list_insert_ordered+0xf6>
      break;
c002c837:	90                   	nop
  return list_insert (e, elem);
c002c838:	83 ec 08             	sub    $0x8,%esp
c002c83b:	ff 75 0c             	push   0xc(%ebp)
c002c83e:	ff 75 f4             	push   -0xc(%ebp)
c002c841:	e8 eb f4 ff ff       	call   c002bd31 <list_insert>
c002c846:	83 c4 10             	add    $0x10,%esp
}
c002c849:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c84c:	c9                   	leave  
c002c84d:	c3                   	ret    

c002c84e <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c002c84e:	55                   	push   %ebp
c002c84f:	89 e5                	mov    %esp,%ebp
c002c851:	53                   	push   %ebx
c002c852:	83 ec 14             	sub    $0x14,%esp
c002c855:	e8 ce 4b 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c85a:	05 1e db 00 00       	add    $0xdb1e,%eax
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c002c85f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002c863:	75 2b                	jne    c002c890 <list_unique+0x42>
c002c865:	83 ec 0c             	sub    $0xc,%esp
c002c868:	8d 90 70 97 ff ff    	lea    -0x6890(%eax),%edx
c002c86e:	52                   	push   %edx
c002c86f:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002c875:	52                   	push   %edx
c002c876:	8d 90 30 9a ff ff    	lea    -0x65d0(%eax),%edx
c002c87c:	52                   	push   %edx
c002c87d:	68 d7 01 00 00       	push   $0x1d7
c002c882:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002c888:	52                   	push   %edx
c002c889:	89 c3                	mov    %eax,%ebx
c002c88b:	e8 d4 ee ff ff       	call   c002b764 <debug_panic>
  ASSERT (less != NULL);
c002c890:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002c894:	75 2b                	jne    c002c8c1 <list_unique+0x73>
c002c896:	83 ec 0c             	sub    $0xc,%esp
c002c899:	8d 90 93 98 ff ff    	lea    -0x676d(%eax),%edx
c002c89f:	52                   	push   %edx
c002c8a0:	8d 90 7d 97 ff ff    	lea    -0x6883(%eax),%edx
c002c8a6:	52                   	push   %edx
c002c8a7:	8d 90 30 9a ff ff    	lea    -0x65d0(%eax),%edx
c002c8ad:	52                   	push   %edx
c002c8ae:	68 d8 01 00 00       	push   $0x1d8
c002c8b3:	8d 90 94 97 ff ff    	lea    -0x686c(%eax),%edx
c002c8b9:	52                   	push   %edx
c002c8ba:	89 c3                	mov    %eax,%ebx
c002c8bc:	e8 a3 ee ff ff       	call   c002b764 <debug_panic>
  if (list_empty (list))
c002c8c1:	83 ec 0c             	sub    $0xc,%esp
c002c8c4:	ff 75 08             	push   0x8(%ebp)
c002c8c7:	e8 93 f8 ff ff       	call   c002c15f <list_empty>
c002c8cc:	83 c4 10             	add    $0x10,%esp
c002c8cf:	84 c0                	test   %al,%al
c002c8d1:	0f 85 a0 00 00 00    	jne    c002c977 <list_unique+0x129>
    return;

  elem = list_begin (list);
c002c8d7:	83 ec 0c             	sub    $0xc,%esp
c002c8da:	ff 75 08             	push   0x8(%ebp)
c002c8dd:	e8 cf f1 ff ff       	call   c002bab1 <list_begin>
c002c8e2:	83 c4 10             	add    $0x10,%esp
c002c8e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002c8e8:	eb 63                	jmp    c002c94d <list_unique+0xff>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002c8ea:	83 ec 04             	sub    $0x4,%esp
c002c8ed:	ff 75 14             	push   0x14(%ebp)
c002c8f0:	ff 75 f0             	push   -0x10(%ebp)
c002c8f3:	ff 75 f4             	push   -0xc(%ebp)
c002c8f6:	8b 45 10             	mov    0x10(%ebp),%eax
c002c8f9:	ff d0                	call   *%eax
c002c8fb:	83 c4 10             	add    $0x10,%esp
c002c8fe:	83 f0 01             	xor    $0x1,%eax
c002c901:	84 c0                	test   %al,%al
c002c903:	74 42                	je     c002c947 <list_unique+0xf9>
c002c905:	83 ec 04             	sub    $0x4,%esp
c002c908:	ff 75 14             	push   0x14(%ebp)
c002c90b:	ff 75 f4             	push   -0xc(%ebp)
c002c90e:	ff 75 f0             	push   -0x10(%ebp)
c002c911:	8b 45 10             	mov    0x10(%ebp),%eax
c002c914:	ff d0                	call   *%eax
c002c916:	83 c4 10             	add    $0x10,%esp
c002c919:	83 f0 01             	xor    $0x1,%eax
c002c91c:	84 c0                	test   %al,%al
c002c91e:	74 27                	je     c002c947 <list_unique+0xf9>
      {
        list_remove (next);
c002c920:	83 ec 0c             	sub    $0xc,%esp
c002c923:	ff 75 f0             	push   -0x10(%ebp)
c002c926:	e8 4f f6 ff ff       	call   c002bf7a <list_remove>
c002c92b:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002c92e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002c932:	74 19                	je     c002c94d <list_unique+0xff>
          list_push_back (duplicates, next);
c002c934:	83 ec 08             	sub    $0x8,%esp
c002c937:	ff 75 f0             	push   -0x10(%ebp)
c002c93a:	ff 75 0c             	push   0xc(%ebp)
c002c93d:	e8 08 f6 ff ff       	call   c002bf4a <list_push_back>
c002c942:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002c945:	eb 06                	jmp    c002c94d <list_unique+0xff>
      }
    else
      elem = next;
c002c947:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c94a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002c94d:	83 ec 0c             	sub    $0xc,%esp
c002c950:	ff 75 f4             	push   -0xc(%ebp)
c002c953:	e8 a3 f1 ff ff       	call   c002bafb <list_next>
c002c958:	83 c4 10             	add    $0x10,%esp
c002c95b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c95e:	83 ec 0c             	sub    $0xc,%esp
c002c961:	ff 75 08             	push   0x8(%ebp)
c002c964:	e8 f3 f1 ff ff       	call   c002bb5c <list_end>
c002c969:	83 c4 10             	add    $0x10,%esp
c002c96c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002c96f:	0f 85 75 ff ff ff    	jne    c002c8ea <list_unique+0x9c>
c002c975:	eb 01                	jmp    c002c978 <list_unique+0x12a>
    return;
c002c977:	90                   	nop
}
c002c978:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c97b:	c9                   	leave  
c002c97c:	c3                   	ret    

c002c97d <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002c97d:	55                   	push   %ebp
c002c97e:	89 e5                	mov    %esp,%ebp
c002c980:	83 ec 18             	sub    $0x18,%esp
c002c983:	e8 a0 4a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002c988:	05 f0 d9 00 00       	add    $0xd9f0,%eax
  struct list_elem *max = list_begin (list);
c002c98d:	83 ec 0c             	sub    $0xc,%esp
c002c990:	ff 75 08             	push   0x8(%ebp)
c002c993:	e8 19 f1 ff ff       	call   c002bab1 <list_begin>
c002c998:	83 c4 10             	add    $0x10,%esp
c002c99b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (max != list_end (list)) 
c002c99e:	83 ec 0c             	sub    $0xc,%esp
c002c9a1:	ff 75 08             	push   0x8(%ebp)
c002c9a4:	e8 b3 f1 ff ff       	call   c002bb5c <list_end>
c002c9a9:	83 c4 10             	add    $0x10,%esp
c002c9ac:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002c9af:	74 55                	je     c002ca06 <list_max+0x89>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002c9b1:	83 ec 0c             	sub    $0xc,%esp
c002c9b4:	ff 75 f4             	push   -0xc(%ebp)
c002c9b7:	e8 3f f1 ff ff       	call   c002bafb <list_next>
c002c9bc:	83 c4 10             	add    $0x10,%esp
c002c9bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c9c2:	eb 2f                	jmp    c002c9f3 <list_max+0x76>
        if (less (max, e, aux))
c002c9c4:	83 ec 04             	sub    $0x4,%esp
c002c9c7:	ff 75 10             	push   0x10(%ebp)
c002c9ca:	ff 75 f0             	push   -0x10(%ebp)
c002c9cd:	ff 75 f4             	push   -0xc(%ebp)
c002c9d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c9d3:	ff d0                	call   *%eax
c002c9d5:	83 c4 10             	add    $0x10,%esp
c002c9d8:	84 c0                	test   %al,%al
c002c9da:	74 06                	je     c002c9e2 <list_max+0x65>
          max = e; 
c002c9dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c9df:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002c9e2:	83 ec 0c             	sub    $0xc,%esp
c002c9e5:	ff 75 f0             	push   -0x10(%ebp)
c002c9e8:	e8 0e f1 ff ff       	call   c002bafb <list_next>
c002c9ed:	83 c4 10             	add    $0x10,%esp
c002c9f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c9f3:	83 ec 0c             	sub    $0xc,%esp
c002c9f6:	ff 75 08             	push   0x8(%ebp)
c002c9f9:	e8 5e f1 ff ff       	call   c002bb5c <list_end>
c002c9fe:	83 c4 10             	add    $0x10,%esp
c002ca01:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002ca04:	75 be                	jne    c002c9c4 <list_max+0x47>
    }
  return max;
c002ca06:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ca09:	c9                   	leave  
c002ca0a:	c3                   	ret    

c002ca0b <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002ca0b:	55                   	push   %ebp
c002ca0c:	89 e5                	mov    %esp,%ebp
c002ca0e:	83 ec 18             	sub    $0x18,%esp
c002ca11:	e8 12 4a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002ca16:	05 62 d9 00 00       	add    $0xd962,%eax
  struct list_elem *min = list_begin (list);
c002ca1b:	83 ec 0c             	sub    $0xc,%esp
c002ca1e:	ff 75 08             	push   0x8(%ebp)
c002ca21:	e8 8b f0 ff ff       	call   c002bab1 <list_begin>
c002ca26:	83 c4 10             	add    $0x10,%esp
c002ca29:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (min != list_end (list)) 
c002ca2c:	83 ec 0c             	sub    $0xc,%esp
c002ca2f:	ff 75 08             	push   0x8(%ebp)
c002ca32:	e8 25 f1 ff ff       	call   c002bb5c <list_end>
c002ca37:	83 c4 10             	add    $0x10,%esp
c002ca3a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002ca3d:	74 55                	je     c002ca94 <list_min+0x89>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002ca3f:	83 ec 0c             	sub    $0xc,%esp
c002ca42:	ff 75 f4             	push   -0xc(%ebp)
c002ca45:	e8 b1 f0 ff ff       	call   c002bafb <list_next>
c002ca4a:	83 c4 10             	add    $0x10,%esp
c002ca4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ca50:	eb 2f                	jmp    c002ca81 <list_min+0x76>
        if (less (e, min, aux))
c002ca52:	83 ec 04             	sub    $0x4,%esp
c002ca55:	ff 75 10             	push   0x10(%ebp)
c002ca58:	ff 75 f4             	push   -0xc(%ebp)
c002ca5b:	ff 75 f0             	push   -0x10(%ebp)
c002ca5e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ca61:	ff d0                	call   *%eax
c002ca63:	83 c4 10             	add    $0x10,%esp
c002ca66:	84 c0                	test   %al,%al
c002ca68:	74 06                	je     c002ca70 <list_min+0x65>
          min = e; 
c002ca6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ca6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002ca70:	83 ec 0c             	sub    $0xc,%esp
c002ca73:	ff 75 f0             	push   -0x10(%ebp)
c002ca76:	e8 80 f0 ff ff       	call   c002bafb <list_next>
c002ca7b:	83 c4 10             	add    $0x10,%esp
c002ca7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ca81:	83 ec 0c             	sub    $0xc,%esp
c002ca84:	ff 75 08             	push   0x8(%ebp)
c002ca87:	e8 d0 f0 ff ff       	call   c002bb5c <list_end>
c002ca8c:	83 c4 10             	add    $0x10,%esp
c002ca8f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002ca92:	75 be                	jne    c002ca52 <list_min+0x47>
    }
  return min;
c002ca94:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ca97:	c9                   	leave  
c002ca98:	c3                   	ret    

c002ca99 <elem_idx>:

/* Returns the index of the element that contains the bit
   numbered BIT_IDX. */
static inline size_t
elem_idx (size_t bit_idx) 
{
c002ca99:	55                   	push   %ebp
c002ca9a:	89 e5                	mov    %esp,%ebp
c002ca9c:	e8 87 49 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002caa1:	05 d7 d8 00 00       	add    $0xd8d7,%eax
  return bit_idx / ELEM_BITS;
c002caa6:	8b 45 08             	mov    0x8(%ebp),%eax
c002caa9:	c1 e8 05             	shr    $0x5,%eax
}
c002caac:	5d                   	pop    %ebp
c002caad:	c3                   	ret    

c002caae <bit_mask>:

/* Returns an elem_type where only the bit corresponding to
   BIT_IDX is turned on. */
static inline elem_type
bit_mask (size_t bit_idx) 
{
c002caae:	55                   	push   %ebp
c002caaf:	89 e5                	mov    %esp,%ebp
c002cab1:	e8 72 49 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cab6:	05 c2 d8 00 00       	add    $0xd8c2,%eax
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002cabb:	8b 45 08             	mov    0x8(%ebp),%eax
c002cabe:	83 e0 1f             	and    $0x1f,%eax
c002cac1:	ba 01 00 00 00       	mov    $0x1,%edx
c002cac6:	89 c1                	mov    %eax,%ecx
c002cac8:	d3 e2                	shl    %cl,%edx
c002caca:	89 d0                	mov    %edx,%eax
}
c002cacc:	5d                   	pop    %ebp
c002cacd:	c3                   	ret    

c002cace <elem_cnt>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
c002cace:	55                   	push   %ebp
c002cacf:	89 e5                	mov    %esp,%ebp
c002cad1:	e8 52 49 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cad6:	05 a2 d8 00 00       	add    $0xd8a2,%eax
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002cadb:	8b 45 08             	mov    0x8(%ebp),%eax
c002cade:	83 c0 1f             	add    $0x1f,%eax
c002cae1:	c1 e8 05             	shr    $0x5,%eax
}
c002cae4:	5d                   	pop    %ebp
c002cae5:	c3                   	ret    

c002cae6 <byte_cnt>:

/* Returns the number of bytes required for BIT_CNT bits. */
static inline size_t
byte_cnt (size_t bit_cnt)
{
c002cae6:	55                   	push   %ebp
c002cae7:	89 e5                	mov    %esp,%ebp
c002cae9:	e8 3a 49 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002caee:	05 8a d8 00 00       	add    $0xd88a,%eax
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002caf3:	ff 75 08             	push   0x8(%ebp)
c002caf6:	e8 d3 ff ff ff       	call   c002cace <elem_cnt>
c002cafb:	83 c4 04             	add    $0x4,%esp
c002cafe:	c1 e0 02             	shl    $0x2,%eax
}
c002cb01:	c9                   	leave  
c002cb02:	c3                   	ret    

c002cb03 <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c002cb03:	55                   	push   %ebp
c002cb04:	89 e5                	mov    %esp,%ebp
c002cb06:	53                   	push   %ebx
c002cb07:	83 ec 14             	sub    $0x14,%esp
c002cb0a:	e8 1d 49 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002cb0f:	81 c3 69 d8 00 00    	add    $0xd869,%ebx
  struct bitmap *b = malloc (sizeof *b);
c002cb15:	83 ec 0c             	sub    $0xc,%esp
c002cb18:	6a 08                	push   $0x8
c002cb1a:	e8 f4 7b ff ff       	call   c0024713 <malloc>
c002cb1f:	83 c4 10             	add    $0x10,%esp
c002cb22:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (b != NULL)
c002cb25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002cb29:	74 5d                	je     c002cb88 <bitmap_create+0x85>
    {
      b->bit_cnt = bit_cnt;
c002cb2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb2e:	8b 55 08             	mov    0x8(%ebp),%edx
c002cb31:	89 10                	mov    %edx,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002cb33:	83 ec 0c             	sub    $0xc,%esp
c002cb36:	ff 75 08             	push   0x8(%ebp)
c002cb39:	e8 a8 ff ff ff       	call   c002cae6 <byte_cnt>
c002cb3e:	83 c4 10             	add    $0x10,%esp
c002cb41:	83 ec 0c             	sub    $0xc,%esp
c002cb44:	50                   	push   %eax
c002cb45:	e8 c9 7b ff ff       	call   c0024713 <malloc>
c002cb4a:	83 c4 10             	add    $0x10,%esp
c002cb4d:	89 c2                	mov    %eax,%edx
c002cb4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb52:	89 50 04             	mov    %edx,0x4(%eax)
      if (b->bits != NULL || bit_cnt == 0)
c002cb55:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb58:	8b 40 04             	mov    0x4(%eax),%eax
c002cb5b:	85 c0                	test   %eax,%eax
c002cb5d:	75 06                	jne    c002cb65 <bitmap_create+0x62>
c002cb5f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002cb63:	75 15                	jne    c002cb7a <bitmap_create+0x77>
        {
          bitmap_set_all (b, false);
c002cb65:	83 ec 08             	sub    $0x8,%esp
c002cb68:	6a 00                	push   $0x0
c002cb6a:	ff 75 f4             	push   -0xc(%ebp)
c002cb6d:	e8 2d 03 00 00       	call   c002ce9f <bitmap_set_all>
c002cb72:	83 c4 10             	add    $0x10,%esp
          return b;
c002cb75:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb78:	eb 13                	jmp    c002cb8d <bitmap_create+0x8a>
        }
      free (b);
c002cb7a:	83 ec 0c             	sub    $0xc,%esp
c002cb7d:	ff 75 f4             	push   -0xc(%ebp)
c002cb80:	e8 cd 7e ff ff       	call   c0024a52 <free>
c002cb85:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c002cb88:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002cb8d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002cb90:	c9                   	leave  
c002cb91:	c3                   	ret    

c002cb92 <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c002cb92:	55                   	push   %ebp
c002cb93:	89 e5                	mov    %esp,%ebp
c002cb95:	53                   	push   %ebx
c002cb96:	83 ec 14             	sub    $0x14,%esp
c002cb99:	e8 8e 48 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002cb9e:	81 c3 da d7 00 00    	add    $0xd7da,%ebx
  struct bitmap *b = block;
c002cba4:	8b 45 0c             	mov    0xc(%ebp),%eax
c002cba7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002cbaa:	83 ec 0c             	sub    $0xc,%esp
c002cbad:	ff 75 08             	push   0x8(%ebp)
c002cbb0:	e8 5a 00 00 00       	call   c002cc0f <bitmap_buf_size>
c002cbb5:	83 c4 10             	add    $0x10,%esp
c002cbb8:	39 45 10             	cmp    %eax,0x10(%ebp)
c002cbbb:	73 26                	jae    c002cbe3 <bitmap_create_in_buf+0x51>
c002cbbd:	83 ec 0c             	sub    $0xc,%esp
c002cbc0:	8d 83 3c 9a ff ff    	lea    -0x65c4(%ebx),%eax
c002cbc6:	50                   	push   %eax
c002cbc7:	8d 83 64 9a ff ff    	lea    -0x659c(%ebx),%eax
c002cbcd:	50                   	push   %eax
c002cbce:	8d 83 e0 9a ff ff    	lea    -0x6520(%ebx),%eax
c002cbd4:	50                   	push   %eax
c002cbd5:	6a 68                	push   $0x68
c002cbd7:	8d 83 7b 9a ff ff    	lea    -0x6585(%ebx),%eax
c002cbdd:	50                   	push   %eax
c002cbde:	e8 81 eb ff ff       	call   c002b764 <debug_panic>

  b->bit_cnt = bit_cnt;
c002cbe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbe6:	8b 55 08             	mov    0x8(%ebp),%edx
c002cbe9:	89 10                	mov    %edx,(%eax)
  b->bits = (elem_type *) (b + 1);
c002cbeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbee:	8d 50 08             	lea    0x8(%eax),%edx
c002cbf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbf4:	89 50 04             	mov    %edx,0x4(%eax)
  bitmap_set_all (b, false);
c002cbf7:	83 ec 08             	sub    $0x8,%esp
c002cbfa:	6a 00                	push   $0x0
c002cbfc:	ff 75 f4             	push   -0xc(%ebp)
c002cbff:	e8 9b 02 00 00       	call   c002ce9f <bitmap_set_all>
c002cc04:	83 c4 10             	add    $0x10,%esp
  return b;
c002cc07:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002cc0a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002cc0d:	c9                   	leave  
c002cc0e:	c3                   	ret    

c002cc0f <bitmap_buf_size>:

/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
c002cc0f:	55                   	push   %ebp
c002cc10:	89 e5                	mov    %esp,%ebp
c002cc12:	e8 11 48 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cc17:	05 61 d7 00 00       	add    $0xd761,%eax
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002cc1c:	ff 75 08             	push   0x8(%ebp)
c002cc1f:	e8 c2 fe ff ff       	call   c002cae6 <byte_cnt>
c002cc24:	83 c4 04             	add    $0x4,%esp
c002cc27:	83 c0 08             	add    $0x8,%eax
}
c002cc2a:	c9                   	leave  
c002cc2b:	c3                   	ret    

c002cc2c <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002cc2c:	55                   	push   %ebp
c002cc2d:	89 e5                	mov    %esp,%ebp
c002cc2f:	53                   	push   %ebx
c002cc30:	83 ec 04             	sub    $0x4,%esp
c002cc33:	e8 f4 47 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002cc38:	81 c3 40 d7 00 00    	add    $0xd740,%ebx
  if (b != NULL) 
c002cc3e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002cc42:	74 20                	je     c002cc64 <bitmap_destroy+0x38>
    {
      free (b->bits);
c002cc44:	8b 45 08             	mov    0x8(%ebp),%eax
c002cc47:	8b 40 04             	mov    0x4(%eax),%eax
c002cc4a:	83 ec 0c             	sub    $0xc,%esp
c002cc4d:	50                   	push   %eax
c002cc4e:	e8 ff 7d ff ff       	call   c0024a52 <free>
c002cc53:	83 c4 10             	add    $0x10,%esp
      free (b);
c002cc56:	83 ec 0c             	sub    $0xc,%esp
c002cc59:	ff 75 08             	push   0x8(%ebp)
c002cc5c:	e8 f1 7d ff ff       	call   c0024a52 <free>
c002cc61:	83 c4 10             	add    $0x10,%esp
    }
}
c002cc64:	90                   	nop
c002cc65:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002cc68:	c9                   	leave  
c002cc69:	c3                   	ret    

c002cc6a <bitmap_size>:
/* Bitmap size. */

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
c002cc6a:	55                   	push   %ebp
c002cc6b:	89 e5                	mov    %esp,%ebp
c002cc6d:	e8 b6 47 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cc72:	05 06 d7 00 00       	add    $0xd706,%eax
  return b->bit_cnt;
c002cc77:	8b 45 08             	mov    0x8(%ebp),%eax
c002cc7a:	8b 00                	mov    (%eax),%eax
}
c002cc7c:	5d                   	pop    %ebp
c002cc7d:	c3                   	ret    

c002cc7e <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002cc7e:	55                   	push   %ebp
c002cc7f:	89 e5                	mov    %esp,%ebp
c002cc81:	53                   	push   %ebx
c002cc82:	83 ec 14             	sub    $0x14,%esp
c002cc85:	e8 9e 47 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cc8a:	05 ee d6 00 00       	add    $0xd6ee,%eax
c002cc8f:	8b 55 10             	mov    0x10(%ebp),%edx
c002cc92:	88 55 f4             	mov    %dl,-0xc(%ebp)
  ASSERT (b != NULL);
c002cc95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002cc99:	75 2b                	jne    c002ccc6 <bitmap_set+0x48>
c002cc9b:	83 ec 0c             	sub    $0xc,%esp
c002cc9e:	8d 90 95 9a ff ff    	lea    -0x656b(%eax),%edx
c002cca4:	52                   	push   %edx
c002cca5:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002ccab:	52                   	push   %edx
c002ccac:	8d 90 f8 9a ff ff    	lea    -0x6508(%eax),%edx
c002ccb2:	52                   	push   %edx
c002ccb3:	68 93 00 00 00       	push   $0x93
c002ccb8:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002ccbe:	52                   	push   %edx
c002ccbf:	89 c3                	mov    %eax,%ebx
c002ccc1:	e8 9e ea ff ff       	call   c002b764 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002ccc6:	8b 55 08             	mov    0x8(%ebp),%edx
c002ccc9:	8b 12                	mov    (%edx),%edx
c002cccb:	39 55 0c             	cmp    %edx,0xc(%ebp)
c002ccce:	72 2b                	jb     c002ccfb <bitmap_set+0x7d>
c002ccd0:	83 ec 0c             	sub    $0xc,%esp
c002ccd3:	8d 90 9f 9a ff ff    	lea    -0x6561(%eax),%edx
c002ccd9:	52                   	push   %edx
c002ccda:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002cce0:	52                   	push   %edx
c002cce1:	8d 90 f8 9a ff ff    	lea    -0x6508(%eax),%edx
c002cce7:	52                   	push   %edx
c002cce8:	68 94 00 00 00       	push   $0x94
c002cced:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002ccf3:	52                   	push   %edx
c002ccf4:	89 c3                	mov    %eax,%ebx
c002ccf6:	e8 69 ea ff ff       	call   c002b764 <debug_panic>
  if (value)
c002ccfb:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002ccff:	74 13                	je     c002cd14 <bitmap_set+0x96>
    bitmap_mark (b, idx);
c002cd01:	83 ec 08             	sub    $0x8,%esp
c002cd04:	ff 75 0c             	push   0xc(%ebp)
c002cd07:	ff 75 08             	push   0x8(%ebp)
c002cd0a:	e8 1c 00 00 00       	call   c002cd2b <bitmap_mark>
c002cd0f:	83 c4 10             	add    $0x10,%esp
  else
    bitmap_reset (b, idx);
}
c002cd12:	eb 11                	jmp    c002cd25 <bitmap_set+0xa7>
    bitmap_reset (b, idx);
c002cd14:	83 ec 08             	sub    $0x8,%esp
c002cd17:	ff 75 0c             	push   0xc(%ebp)
c002cd1a:	ff 75 08             	push   0x8(%ebp)
c002cd1d:	e8 4b 00 00 00       	call   c002cd6d <bitmap_reset>
c002cd22:	83 c4 10             	add    $0x10,%esp
}
c002cd25:	90                   	nop
c002cd26:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002cd29:	c9                   	leave  
c002cd2a:	c3                   	ret    

c002cd2b <bitmap_mark>:

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002cd2b:	55                   	push   %ebp
c002cd2c:	89 e5                	mov    %esp,%ebp
c002cd2e:	83 ec 10             	sub    $0x10,%esp
c002cd31:	e8 f2 46 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cd36:	05 42 d6 00 00       	add    $0xd642,%eax
  size_t idx = elem_idx (bit_idx);
c002cd3b:	ff 75 0c             	push   0xc(%ebp)
c002cd3e:	e8 56 fd ff ff       	call   c002ca99 <elem_idx>
c002cd43:	83 c4 04             	add    $0x4,%esp
c002cd46:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002cd49:	ff 75 0c             	push   0xc(%ebp)
c002cd4c:	e8 5d fd ff ff       	call   c002caae <bit_mask>
c002cd51:	83 c4 04             	add    $0x4,%esp
c002cd54:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002cd57:	8b 45 08             	mov    0x8(%ebp),%eax
c002cd5a:	8b 50 04             	mov    0x4(%eax),%edx
c002cd5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002cd60:	c1 e0 02             	shl    $0x2,%eax
c002cd63:	01 c2                	add    %eax,%edx
c002cd65:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002cd68:	09 02                	or     %eax,(%edx)
}
c002cd6a:	90                   	nop
c002cd6b:	c9                   	leave  
c002cd6c:	c3                   	ret    

c002cd6d <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002cd6d:	55                   	push   %ebp
c002cd6e:	89 e5                	mov    %esp,%ebp
c002cd70:	83 ec 10             	sub    $0x10,%esp
c002cd73:	e8 b0 46 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cd78:	05 00 d6 00 00       	add    $0xd600,%eax
  size_t idx = elem_idx (bit_idx);
c002cd7d:	ff 75 0c             	push   0xc(%ebp)
c002cd80:	e8 14 fd ff ff       	call   c002ca99 <elem_idx>
c002cd85:	83 c4 04             	add    $0x4,%esp
c002cd88:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002cd8b:	ff 75 0c             	push   0xc(%ebp)
c002cd8e:	e8 1b fd ff ff       	call   c002caae <bit_mask>
c002cd93:	83 c4 04             	add    $0x4,%esp
c002cd96:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002cd99:	8b 45 08             	mov    0x8(%ebp),%eax
c002cd9c:	8b 50 04             	mov    0x4(%eax),%edx
c002cd9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002cda2:	c1 e0 02             	shl    $0x2,%eax
c002cda5:	01 d0                	add    %edx,%eax
c002cda7:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002cdaa:	f7 d2                	not    %edx
c002cdac:	21 10                	and    %edx,(%eax)
}
c002cdae:	90                   	nop
c002cdaf:	c9                   	leave  
c002cdb0:	c3                   	ret    

c002cdb1 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002cdb1:	55                   	push   %ebp
c002cdb2:	89 e5                	mov    %esp,%ebp
c002cdb4:	83 ec 10             	sub    $0x10,%esp
c002cdb7:	e8 6c 46 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cdbc:	05 bc d5 00 00       	add    $0xd5bc,%eax
  size_t idx = elem_idx (bit_idx);
c002cdc1:	ff 75 0c             	push   0xc(%ebp)
c002cdc4:	e8 d0 fc ff ff       	call   c002ca99 <elem_idx>
c002cdc9:	83 c4 04             	add    $0x4,%esp
c002cdcc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002cdcf:	ff 75 0c             	push   0xc(%ebp)
c002cdd2:	e8 d7 fc ff ff       	call   c002caae <bit_mask>
c002cdd7:	83 c4 04             	add    $0x4,%esp
c002cdda:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002cddd:	8b 45 08             	mov    0x8(%ebp),%eax
c002cde0:	8b 50 04             	mov    0x4(%eax),%edx
c002cde3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002cde6:	c1 e0 02             	shl    $0x2,%eax
c002cde9:	01 c2                	add    %eax,%edx
c002cdeb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002cdee:	31 02                	xor    %eax,(%edx)
}
c002cdf0:	90                   	nop
c002cdf1:	c9                   	leave  
c002cdf2:	c3                   	ret    

c002cdf3 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002cdf3:	55                   	push   %ebp
c002cdf4:	89 e5                	mov    %esp,%ebp
c002cdf6:	53                   	push   %ebx
c002cdf7:	83 ec 04             	sub    $0x4,%esp
c002cdfa:	e8 29 46 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cdff:	05 79 d5 00 00       	add    $0xd579,%eax
  ASSERT (b != NULL);
c002ce04:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ce08:	75 2b                	jne    c002ce35 <bitmap_test+0x42>
c002ce0a:	83 ec 0c             	sub    $0xc,%esp
c002ce0d:	8d 90 95 9a ff ff    	lea    -0x656b(%eax),%edx
c002ce13:	52                   	push   %edx
c002ce14:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002ce1a:	52                   	push   %edx
c002ce1b:	8d 90 04 9b ff ff    	lea    -0x64fc(%eax),%edx
c002ce21:	52                   	push   %edx
c002ce22:	68 c8 00 00 00       	push   $0xc8
c002ce27:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002ce2d:	52                   	push   %edx
c002ce2e:	89 c3                	mov    %eax,%ebx
c002ce30:	e8 2f e9 ff ff       	call   c002b764 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002ce35:	8b 55 08             	mov    0x8(%ebp),%edx
c002ce38:	8b 12                	mov    (%edx),%edx
c002ce3a:	39 55 0c             	cmp    %edx,0xc(%ebp)
c002ce3d:	72 2b                	jb     c002ce6a <bitmap_test+0x77>
c002ce3f:	83 ec 0c             	sub    $0xc,%esp
c002ce42:	8d 90 9f 9a ff ff    	lea    -0x6561(%eax),%edx
c002ce48:	52                   	push   %edx
c002ce49:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002ce4f:	52                   	push   %edx
c002ce50:	8d 90 04 9b ff ff    	lea    -0x64fc(%eax),%edx
c002ce56:	52                   	push   %edx
c002ce57:	68 c9 00 00 00       	push   $0xc9
c002ce5c:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002ce62:	52                   	push   %edx
c002ce63:	89 c3                	mov    %eax,%ebx
c002ce65:	e8 fa e8 ff ff       	call   c002b764 <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002ce6a:	8b 45 08             	mov    0x8(%ebp),%eax
c002ce6d:	8b 58 04             	mov    0x4(%eax),%ebx
c002ce70:	83 ec 0c             	sub    $0xc,%esp
c002ce73:	ff 75 0c             	push   0xc(%ebp)
c002ce76:	e8 1e fc ff ff       	call   c002ca99 <elem_idx>
c002ce7b:	83 c4 10             	add    $0x10,%esp
c002ce7e:	c1 e0 02             	shl    $0x2,%eax
c002ce81:	01 d8                	add    %ebx,%eax
c002ce83:	8b 18                	mov    (%eax),%ebx
c002ce85:	83 ec 0c             	sub    $0xc,%esp
c002ce88:	ff 75 0c             	push   0xc(%ebp)
c002ce8b:	e8 1e fc ff ff       	call   c002caae <bit_mask>
c002ce90:	83 c4 10             	add    $0x10,%esp
c002ce93:	21 d8                	and    %ebx,%eax
c002ce95:	85 c0                	test   %eax,%eax
c002ce97:	0f 95 c0             	setne  %al
}
c002ce9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ce9d:	c9                   	leave  
c002ce9e:	c3                   	ret    

c002ce9f <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c002ce9f:	55                   	push   %ebp
c002cea0:	89 e5                	mov    %esp,%ebp
c002cea2:	53                   	push   %ebx
c002cea3:	83 ec 14             	sub    $0x14,%esp
c002cea6:	e8 7d 45 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002ceab:	05 cd d4 00 00       	add    $0xd4cd,%eax
c002ceb0:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ceb3:	88 55 f4             	mov    %dl,-0xc(%ebp)
  ASSERT (b != NULL);
c002ceb6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ceba:	75 2b                	jne    c002cee7 <bitmap_set_all+0x48>
c002cebc:	83 ec 0c             	sub    $0xc,%esp
c002cebf:	8d 90 95 9a ff ff    	lea    -0x656b(%eax),%edx
c002cec5:	52                   	push   %edx
c002cec6:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002cecc:	52                   	push   %edx
c002cecd:	8d 90 10 9b ff ff    	lea    -0x64f0(%eax),%edx
c002ced3:	52                   	push   %edx
c002ced4:	68 d3 00 00 00       	push   $0xd3
c002ced9:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002cedf:	52                   	push   %edx
c002cee0:	89 c3                	mov    %eax,%ebx
c002cee2:	e8 7d e8 ff ff       	call   c002b764 <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002cee7:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002ceeb:	83 ec 0c             	sub    $0xc,%esp
c002ceee:	ff 75 08             	push   0x8(%ebp)
c002cef1:	e8 74 fd ff ff       	call   c002cc6a <bitmap_size>
c002cef6:	83 c4 10             	add    $0x10,%esp
c002cef9:	53                   	push   %ebx
c002cefa:	50                   	push   %eax
c002cefb:	6a 00                	push   $0x0
c002cefd:	ff 75 08             	push   0x8(%ebp)
c002cf00:	e8 09 00 00 00       	call   c002cf0e <bitmap_set_multiple>
c002cf05:	83 c4 10             	add    $0x10,%esp
}
c002cf08:	90                   	nop
c002cf09:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002cf0c:	c9                   	leave  
c002cf0d:	c3                   	ret    

c002cf0e <bitmap_set_multiple>:

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002cf0e:	55                   	push   %ebp
c002cf0f:	89 e5                	mov    %esp,%ebp
c002cf11:	53                   	push   %ebx
c002cf12:	83 ec 24             	sub    $0x24,%esp
c002cf15:	e8 0e 45 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002cf1a:	05 5e d4 00 00       	add    $0xd45e,%eax
c002cf1f:	8b 55 14             	mov    0x14(%ebp),%edx
c002cf22:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002cf25:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002cf29:	75 2b                	jne    c002cf56 <bitmap_set_multiple+0x48>
c002cf2b:	83 ec 0c             	sub    $0xc,%esp
c002cf2e:	8d 90 95 9a ff ff    	lea    -0x656b(%eax),%edx
c002cf34:	52                   	push   %edx
c002cf35:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002cf3b:	52                   	push   %edx
c002cf3c:	8d 90 20 9b ff ff    	lea    -0x64e0(%eax),%edx
c002cf42:	52                   	push   %edx
c002cf43:	68 de 00 00 00       	push   $0xde
c002cf48:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002cf4e:	52                   	push   %edx
c002cf4f:	89 c3                	mov    %eax,%ebx
c002cf51:	e8 0e e8 ff ff       	call   c002b764 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002cf56:	8b 55 08             	mov    0x8(%ebp),%edx
c002cf59:	8b 12                	mov    (%edx),%edx
c002cf5b:	39 55 0c             	cmp    %edx,0xc(%ebp)
c002cf5e:	76 2b                	jbe    c002cf8b <bitmap_set_multiple+0x7d>
c002cf60:	83 ec 0c             	sub    $0xc,%esp
c002cf63:	8d 90 b0 9a ff ff    	lea    -0x6550(%eax),%edx
c002cf69:	52                   	push   %edx
c002cf6a:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002cf70:	52                   	push   %edx
c002cf71:	8d 90 20 9b ff ff    	lea    -0x64e0(%eax),%edx
c002cf77:	52                   	push   %edx
c002cf78:	68 df 00 00 00       	push   $0xdf
c002cf7d:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002cf83:	52                   	push   %edx
c002cf84:	89 c3                	mov    %eax,%ebx
c002cf86:	e8 d9 e7 ff ff       	call   c002b764 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002cf8b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002cf8e:	8b 55 10             	mov    0x10(%ebp),%edx
c002cf91:	01 d1                	add    %edx,%ecx
c002cf93:	8b 55 08             	mov    0x8(%ebp),%edx
c002cf96:	8b 12                	mov    (%edx),%edx
c002cf98:	39 d1                	cmp    %edx,%ecx
c002cf9a:	76 2b                	jbe    c002cfc7 <bitmap_set_multiple+0xb9>
c002cf9c:	83 ec 0c             	sub    $0xc,%esp
c002cf9f:	8d 90 c4 9a ff ff    	lea    -0x653c(%eax),%edx
c002cfa5:	52                   	push   %edx
c002cfa6:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002cfac:	52                   	push   %edx
c002cfad:	8d 90 20 9b ff ff    	lea    -0x64e0(%eax),%edx
c002cfb3:	52                   	push   %edx
c002cfb4:	68 e0 00 00 00       	push   $0xe0
c002cfb9:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002cfbf:	52                   	push   %edx
c002cfc0:	89 c3                	mov    %eax,%ebx
c002cfc2:	e8 9d e7 ff ff       	call   c002b764 <debug_panic>

  for (i = 0; i < cnt; i++)
c002cfc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002cfce:	eb 20                	jmp    c002cff0 <bitmap_set_multiple+0xe2>
    bitmap_set (b, start + i, value);
c002cfd0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002cfd4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002cfd7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002cfda:	01 ca                	add    %ecx,%edx
c002cfdc:	83 ec 04             	sub    $0x4,%esp
c002cfdf:	50                   	push   %eax
c002cfe0:	52                   	push   %edx
c002cfe1:	ff 75 08             	push   0x8(%ebp)
c002cfe4:	e8 95 fc ff ff       	call   c002cc7e <bitmap_set>
c002cfe9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < cnt; i++)
c002cfec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002cff0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cff3:	3b 45 10             	cmp    0x10(%ebp),%eax
c002cff6:	72 d8                	jb     c002cfd0 <bitmap_set_multiple+0xc2>
}
c002cff8:	90                   	nop
c002cff9:	90                   	nop
c002cffa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002cffd:	c9                   	leave  
c002cffe:	c3                   	ret    

c002cfff <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002cfff:	55                   	push   %ebp
c002d000:	89 e5                	mov    %esp,%ebp
c002d002:	53                   	push   %ebx
c002d003:	83 ec 24             	sub    $0x24,%esp
c002d006:	e8 1d 44 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d00b:	05 6d d3 00 00       	add    $0xd36d,%eax
c002d010:	8b 55 14             	mov    0x14(%ebp),%edx
c002d013:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002d016:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002d01a:	75 2b                	jne    c002d047 <bitmap_count+0x48>
c002d01c:	83 ec 0c             	sub    $0xc,%esp
c002d01f:	8d 90 95 9a ff ff    	lea    -0x656b(%eax),%edx
c002d025:	52                   	push   %edx
c002d026:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002d02c:	52                   	push   %edx
c002d02d:	8d 90 34 9b ff ff    	lea    -0x64cc(%eax),%edx
c002d033:	52                   	push   %edx
c002d034:	68 ed 00 00 00       	push   $0xed
c002d039:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002d03f:	52                   	push   %edx
c002d040:	89 c3                	mov    %eax,%ebx
c002d042:	e8 1d e7 ff ff       	call   c002b764 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002d047:	8b 55 08             	mov    0x8(%ebp),%edx
c002d04a:	8b 12                	mov    (%edx),%edx
c002d04c:	39 55 0c             	cmp    %edx,0xc(%ebp)
c002d04f:	76 2b                	jbe    c002d07c <bitmap_count+0x7d>
c002d051:	83 ec 0c             	sub    $0xc,%esp
c002d054:	8d 90 b0 9a ff ff    	lea    -0x6550(%eax),%edx
c002d05a:	52                   	push   %edx
c002d05b:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002d061:	52                   	push   %edx
c002d062:	8d 90 34 9b ff ff    	lea    -0x64cc(%eax),%edx
c002d068:	52                   	push   %edx
c002d069:	68 ee 00 00 00       	push   $0xee
c002d06e:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002d074:	52                   	push   %edx
c002d075:	89 c3                	mov    %eax,%ebx
c002d077:	e8 e8 e6 ff ff       	call   c002b764 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002d07c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002d07f:	8b 55 10             	mov    0x10(%ebp),%edx
c002d082:	01 d1                	add    %edx,%ecx
c002d084:	8b 55 08             	mov    0x8(%ebp),%edx
c002d087:	8b 12                	mov    (%edx),%edx
c002d089:	39 d1                	cmp    %edx,%ecx
c002d08b:	76 2b                	jbe    c002d0b8 <bitmap_count+0xb9>
c002d08d:	83 ec 0c             	sub    $0xc,%esp
c002d090:	8d 90 c4 9a ff ff    	lea    -0x653c(%eax),%edx
c002d096:	52                   	push   %edx
c002d097:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002d09d:	52                   	push   %edx
c002d09e:	8d 90 34 9b ff ff    	lea    -0x64cc(%eax),%edx
c002d0a4:	52                   	push   %edx
c002d0a5:	68 ef 00 00 00       	push   $0xef
c002d0aa:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002d0b0:	52                   	push   %edx
c002d0b1:	89 c3                	mov    %eax,%ebx
c002d0b3:	e8 ac e6 ff ff       	call   c002b764 <debug_panic>

  value_cnt = 0;
c002d0b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002d0bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d0c6:	eb 24                	jmp    c002d0ec <bitmap_count+0xed>
    if (bitmap_test (b, start + i) == value)
c002d0c8:	8b 55 0c             	mov    0xc(%ebp),%edx
c002d0cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d0ce:	01 d0                	add    %edx,%eax
c002d0d0:	83 ec 08             	sub    $0x8,%esp
c002d0d3:	50                   	push   %eax
c002d0d4:	ff 75 08             	push   0x8(%ebp)
c002d0d7:	e8 17 fd ff ff       	call   c002cdf3 <bitmap_test>
c002d0dc:	83 c4 10             	add    $0x10,%esp
c002d0df:	38 45 e4             	cmp    %al,-0x1c(%ebp)
c002d0e2:	75 04                	jne    c002d0e8 <bitmap_count+0xe9>
      value_cnt++;
c002d0e4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002d0e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d0ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d0ef:	3b 45 10             	cmp    0x10(%ebp),%eax
c002d0f2:	72 d4                	jb     c002d0c8 <bitmap_count+0xc9>
  return value_cnt;
c002d0f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002d0f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d0fa:	c9                   	leave  
c002d0fb:	c3                   	ret    

c002d0fc <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002d0fc:	55                   	push   %ebp
c002d0fd:	89 e5                	mov    %esp,%ebp
c002d0ff:	53                   	push   %ebx
c002d100:	83 ec 24             	sub    $0x24,%esp
c002d103:	e8 20 43 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d108:	05 70 d2 00 00       	add    $0xd270,%eax
c002d10d:	8b 55 14             	mov    0x14(%ebp),%edx
c002d110:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002d113:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002d117:	75 2b                	jne    c002d144 <bitmap_contains+0x48>
c002d119:	83 ec 0c             	sub    $0xc,%esp
c002d11c:	8d 90 95 9a ff ff    	lea    -0x656b(%eax),%edx
c002d122:	52                   	push   %edx
c002d123:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002d129:	52                   	push   %edx
c002d12a:	8d 90 44 9b ff ff    	lea    -0x64bc(%eax),%edx
c002d130:	52                   	push   %edx
c002d131:	68 ff 00 00 00       	push   $0xff
c002d136:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002d13c:	52                   	push   %edx
c002d13d:	89 c3                	mov    %eax,%ebx
c002d13f:	e8 20 e6 ff ff       	call   c002b764 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002d144:	8b 55 08             	mov    0x8(%ebp),%edx
c002d147:	8b 12                	mov    (%edx),%edx
c002d149:	39 55 0c             	cmp    %edx,0xc(%ebp)
c002d14c:	76 2b                	jbe    c002d179 <bitmap_contains+0x7d>
c002d14e:	83 ec 0c             	sub    $0xc,%esp
c002d151:	8d 90 b0 9a ff ff    	lea    -0x6550(%eax),%edx
c002d157:	52                   	push   %edx
c002d158:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002d15e:	52                   	push   %edx
c002d15f:	8d 90 44 9b ff ff    	lea    -0x64bc(%eax),%edx
c002d165:	52                   	push   %edx
c002d166:	68 00 01 00 00       	push   $0x100
c002d16b:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002d171:	52                   	push   %edx
c002d172:	89 c3                	mov    %eax,%ebx
c002d174:	e8 eb e5 ff ff       	call   c002b764 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002d179:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002d17c:	8b 55 10             	mov    0x10(%ebp),%edx
c002d17f:	01 d1                	add    %edx,%ecx
c002d181:	8b 55 08             	mov    0x8(%ebp),%edx
c002d184:	8b 12                	mov    (%edx),%edx
c002d186:	39 d1                	cmp    %edx,%ecx
c002d188:	76 2b                	jbe    c002d1b5 <bitmap_contains+0xb9>
c002d18a:	83 ec 0c             	sub    $0xc,%esp
c002d18d:	8d 90 c4 9a ff ff    	lea    -0x653c(%eax),%edx
c002d193:	52                   	push   %edx
c002d194:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002d19a:	52                   	push   %edx
c002d19b:	8d 90 44 9b ff ff    	lea    -0x64bc(%eax),%edx
c002d1a1:	52                   	push   %edx
c002d1a2:	68 01 01 00 00       	push   $0x101
c002d1a7:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002d1ad:	52                   	push   %edx
c002d1ae:	89 c3                	mov    %eax,%ebx
c002d1b0:	e8 af e5 ff ff       	call   c002b764 <debug_panic>

  for (i = 0; i < cnt; i++)
c002d1b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d1bc:	eb 27                	jmp    c002d1e5 <bitmap_contains+0xe9>
    if (bitmap_test (b, start + i) == value)
c002d1be:	8b 55 0c             	mov    0xc(%ebp),%edx
c002d1c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d1c4:	01 d0                	add    %edx,%eax
c002d1c6:	83 ec 08             	sub    $0x8,%esp
c002d1c9:	50                   	push   %eax
c002d1ca:	ff 75 08             	push   0x8(%ebp)
c002d1cd:	e8 21 fc ff ff       	call   c002cdf3 <bitmap_test>
c002d1d2:	83 c4 10             	add    $0x10,%esp
c002d1d5:	38 45 e4             	cmp    %al,-0x1c(%ebp)
c002d1d8:	75 07                	jne    c002d1e1 <bitmap_contains+0xe5>
      return true;
c002d1da:	b8 01 00 00 00       	mov    $0x1,%eax
c002d1df:	eb 11                	jmp    c002d1f2 <bitmap_contains+0xf6>
  for (i = 0; i < cnt; i++)
c002d1e1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d1e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d1e8:	3b 45 10             	cmp    0x10(%ebp),%eax
c002d1eb:	72 d1                	jb     c002d1be <bitmap_contains+0xc2>
  return false;
c002d1ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002d1f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d1f5:	c9                   	leave  
c002d1f6:	c3                   	ret    

c002d1f7 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002d1f7:	55                   	push   %ebp
c002d1f8:	89 e5                	mov    %esp,%ebp
c002d1fa:	83 ec 08             	sub    $0x8,%esp
c002d1fd:	e8 26 42 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d202:	05 76 d1 00 00       	add    $0xd176,%eax
  return bitmap_contains (b, start, cnt, true);
c002d207:	6a 01                	push   $0x1
c002d209:	ff 75 10             	push   0x10(%ebp)
c002d20c:	ff 75 0c             	push   0xc(%ebp)
c002d20f:	ff 75 08             	push   0x8(%ebp)
c002d212:	e8 e5 fe ff ff       	call   c002d0fc <bitmap_contains>
c002d217:	83 c4 10             	add    $0x10,%esp
}
c002d21a:	c9                   	leave  
c002d21b:	c3                   	ret    

c002d21c <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002d21c:	55                   	push   %ebp
c002d21d:	89 e5                	mov    %esp,%ebp
c002d21f:	83 ec 08             	sub    $0x8,%esp
c002d222:	e8 01 42 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d227:	05 51 d1 00 00       	add    $0xd151,%eax
  return !bitmap_contains (b, start, cnt, true);
c002d22c:	6a 01                	push   $0x1
c002d22e:	ff 75 10             	push   0x10(%ebp)
c002d231:	ff 75 0c             	push   0xc(%ebp)
c002d234:	ff 75 08             	push   0x8(%ebp)
c002d237:	e8 c0 fe ff ff       	call   c002d0fc <bitmap_contains>
c002d23c:	83 c4 10             	add    $0x10,%esp
c002d23f:	0f b6 c0             	movzbl %al,%eax
c002d242:	85 c0                	test   %eax,%eax
c002d244:	0f 95 c0             	setne  %al
c002d247:	83 f0 01             	xor    $0x1,%eax
c002d24a:	0f b6 c0             	movzbl %al,%eax
c002d24d:	83 e0 01             	and    $0x1,%eax
}
c002d250:	c9                   	leave  
c002d251:	c3                   	ret    

c002d252 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002d252:	55                   	push   %ebp
c002d253:	89 e5                	mov    %esp,%ebp
c002d255:	83 ec 08             	sub    $0x8,%esp
c002d258:	e8 cb 41 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d25d:	05 1b d1 00 00       	add    $0xd11b,%eax
  return !bitmap_contains (b, start, cnt, false);
c002d262:	6a 00                	push   $0x0
c002d264:	ff 75 10             	push   0x10(%ebp)
c002d267:	ff 75 0c             	push   0xc(%ebp)
c002d26a:	ff 75 08             	push   0x8(%ebp)
c002d26d:	e8 8a fe ff ff       	call   c002d0fc <bitmap_contains>
c002d272:	83 c4 10             	add    $0x10,%esp
c002d275:	0f b6 c0             	movzbl %al,%eax
c002d278:	85 c0                	test   %eax,%eax
c002d27a:	0f 95 c0             	setne  %al
c002d27d:	83 f0 01             	xor    $0x1,%eax
c002d280:	0f b6 c0             	movzbl %al,%eax
c002d283:	83 e0 01             	and    $0x1,%eax
}
c002d286:	c9                   	leave  
c002d287:	c3                   	ret    

c002d288 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002d288:	55                   	push   %ebp
c002d289:	89 e5                	mov    %esp,%ebp
c002d28b:	53                   	push   %ebx
c002d28c:	83 ec 24             	sub    $0x24,%esp
c002d28f:	e8 94 41 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d294:	05 e4 d0 00 00       	add    $0xd0e4,%eax
c002d299:	8b 55 14             	mov    0x14(%ebp),%edx
c002d29c:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  ASSERT (b != NULL);
c002d29f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002d2a3:	75 2b                	jne    c002d2d0 <bitmap_scan+0x48>
c002d2a5:	83 ec 0c             	sub    $0xc,%esp
c002d2a8:	8d 90 95 9a ff ff    	lea    -0x656b(%eax),%edx
c002d2ae:	52                   	push   %edx
c002d2af:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002d2b5:	52                   	push   %edx
c002d2b6:	8d 90 54 9b ff ff    	lea    -0x64ac(%eax),%edx
c002d2bc:	52                   	push   %edx
c002d2bd:	68 2a 01 00 00       	push   $0x12a
c002d2c2:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002d2c8:	52                   	push   %edx
c002d2c9:	89 c3                	mov    %eax,%ebx
c002d2cb:	e8 94 e4 ff ff       	call   c002b764 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002d2d0:	8b 55 08             	mov    0x8(%ebp),%edx
c002d2d3:	8b 12                	mov    (%edx),%edx
c002d2d5:	39 55 0c             	cmp    %edx,0xc(%ebp)
c002d2d8:	76 2b                	jbe    c002d305 <bitmap_scan+0x7d>
c002d2da:	83 ec 0c             	sub    $0xc,%esp
c002d2dd:	8d 90 b0 9a ff ff    	lea    -0x6550(%eax),%edx
c002d2e3:	52                   	push   %edx
c002d2e4:	8d 90 64 9a ff ff    	lea    -0x659c(%eax),%edx
c002d2ea:	52                   	push   %edx
c002d2eb:	8d 90 54 9b ff ff    	lea    -0x64ac(%eax),%edx
c002d2f1:	52                   	push   %edx
c002d2f2:	68 2b 01 00 00       	push   $0x12b
c002d2f7:	8d 90 7b 9a ff ff    	lea    -0x6585(%eax),%edx
c002d2fd:	52                   	push   %edx
c002d2fe:	89 c3                	mov    %eax,%ebx
c002d300:	e8 5f e4 ff ff       	call   c002b764 <debug_panic>

  if (cnt <= b->bit_cnt) 
c002d305:	8b 45 08             	mov    0x8(%ebp),%eax
c002d308:	8b 00                	mov    (%eax),%eax
c002d30a:	39 45 10             	cmp    %eax,0x10(%ebp)
c002d30d:	77 52                	ja     c002d361 <bitmap_scan+0xd9>
    {
      size_t last = b->bit_cnt - cnt;
c002d30f:	8b 45 08             	mov    0x8(%ebp),%eax
c002d312:	8b 00                	mov    (%eax),%eax
c002d314:	2b 45 10             	sub    0x10(%ebp),%eax
c002d317:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t i;
      for (i = start; i <= last; i++)
c002d31a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d31d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002d320:	eb 37                	jmp    c002d359 <bitmap_scan+0xd1>
        if (!bitmap_contains (b, i, cnt, !value))
c002d322:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002d326:	85 c0                	test   %eax,%eax
c002d328:	0f 95 c0             	setne  %al
c002d32b:	83 f0 01             	xor    $0x1,%eax
c002d32e:	0f b6 c0             	movzbl %al,%eax
c002d331:	83 e0 01             	and    $0x1,%eax
c002d334:	0f b6 c0             	movzbl %al,%eax
c002d337:	50                   	push   %eax
c002d338:	ff 75 10             	push   0x10(%ebp)
c002d33b:	ff 75 f4             	push   -0xc(%ebp)
c002d33e:	ff 75 08             	push   0x8(%ebp)
c002d341:	e8 b6 fd ff ff       	call   c002d0fc <bitmap_contains>
c002d346:	83 c4 10             	add    $0x10,%esp
c002d349:	83 f0 01             	xor    $0x1,%eax
c002d34c:	84 c0                	test   %al,%al
c002d34e:	74 05                	je     c002d355 <bitmap_scan+0xcd>
          return i; 
c002d350:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d353:	eb 11                	jmp    c002d366 <bitmap_scan+0xde>
      for (i = start; i <= last; i++)
c002d355:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d359:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d35c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002d35f:	76 c1                	jbe    c002d322 <bitmap_scan+0x9a>
    }
  return BITMAP_ERROR;
c002d361:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002d366:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d369:	c9                   	leave  
c002d36a:	c3                   	ret    

c002d36b <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002d36b:	55                   	push   %ebp
c002d36c:	89 e5                	mov    %esp,%ebp
c002d36e:	83 ec 28             	sub    $0x28,%esp
c002d371:	e8 b2 40 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d376:	05 02 d0 00 00       	add    $0xd002,%eax
c002d37b:	8b 45 14             	mov    0x14(%ebp),%eax
c002d37e:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t idx = bitmap_scan (b, start, cnt, value);
c002d381:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002d385:	50                   	push   %eax
c002d386:	ff 75 10             	push   0x10(%ebp)
c002d389:	ff 75 0c             	push   0xc(%ebp)
c002d38c:	ff 75 08             	push   0x8(%ebp)
c002d38f:	e8 f4 fe ff ff       	call   c002d288 <bitmap_scan>
c002d394:	83 c4 10             	add    $0x10,%esp
c002d397:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (idx != BITMAP_ERROR) 
c002d39a:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002d39e:	74 27                	je     c002d3c7 <bitmap_scan_and_flip+0x5c>
    bitmap_set_multiple (b, idx, cnt, !value);
c002d3a0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002d3a4:	85 c0                	test   %eax,%eax
c002d3a6:	0f 95 c0             	setne  %al
c002d3a9:	83 f0 01             	xor    $0x1,%eax
c002d3ac:	0f b6 c0             	movzbl %al,%eax
c002d3af:	83 e0 01             	and    $0x1,%eax
c002d3b2:	0f b6 c0             	movzbl %al,%eax
c002d3b5:	50                   	push   %eax
c002d3b6:	ff 75 10             	push   0x10(%ebp)
c002d3b9:	ff 75 f4             	push   -0xc(%ebp)
c002d3bc:	ff 75 08             	push   0x8(%ebp)
c002d3bf:	e8 4a fb ff ff       	call   c002cf0e <bitmap_set_multiple>
c002d3c4:	83 c4 10             	add    $0x10,%esp
  return idx;
c002d3c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002d3ca:	c9                   	leave  
c002d3cb:	c3                   	ret    

c002d3cc <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002d3cc:	55                   	push   %ebp
c002d3cd:	89 e5                	mov    %esp,%ebp
c002d3cf:	53                   	push   %ebx
c002d3d0:	83 ec 04             	sub    $0x4,%esp
c002d3d3:	e8 54 40 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002d3d8:	81 c3 a0 cf 00 00    	add    $0xcfa0,%ebx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002d3de:	8b 45 08             	mov    0x8(%ebp),%eax
c002d3e1:	8b 00                	mov    (%eax),%eax
c002d3e3:	50                   	push   %eax
c002d3e4:	e8 fd f6 ff ff       	call   c002cae6 <byte_cnt>
c002d3e9:	83 c4 04             	add    $0x4,%esp
c002d3ec:	8b 55 08             	mov    0x8(%ebp),%edx
c002d3ef:	8b 52 04             	mov    0x4(%edx),%edx
c002d3f2:	6a 00                	push   $0x0
c002d3f4:	50                   	push   %eax
c002d3f5:	52                   	push   %edx
c002d3f6:	6a 00                	push   $0x0
c002d3f8:	e8 22 c7 ff ff       	call   c0029b1f <hex_dump>
c002d3fd:	83 c4 10             	add    $0x10,%esp
}
c002d400:	90                   	nop
c002d401:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d404:	c9                   	leave  
c002d405:	c3                   	ret    

c002d406 <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002d406:	55                   	push   %ebp
c002d407:	89 e5                	mov    %esp,%ebp
c002d409:	53                   	push   %ebx
c002d40a:	83 ec 04             	sub    $0x4,%esp
c002d40d:	e8 16 40 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d412:	05 66 cf 00 00       	add    $0xcf66,%eax
  h->elem_cnt = 0;
c002d417:	8b 55 08             	mov    0x8(%ebp),%edx
c002d41a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  h->bucket_cnt = 4;
c002d420:	8b 55 08             	mov    0x8(%ebp),%edx
c002d423:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002d42a:	8b 55 08             	mov    0x8(%ebp),%edx
c002d42d:	8b 52 04             	mov    0x4(%edx),%edx
c002d430:	c1 e2 04             	shl    $0x4,%edx
c002d433:	83 ec 0c             	sub    $0xc,%esp
c002d436:	52                   	push   %edx
c002d437:	89 c3                	mov    %eax,%ebx
c002d439:	e8 d5 72 ff ff       	call   c0024713 <malloc>
c002d43e:	83 c4 10             	add    $0x10,%esp
c002d441:	89 c2                	mov    %eax,%edx
c002d443:	8b 45 08             	mov    0x8(%ebp),%eax
c002d446:	89 50 08             	mov    %edx,0x8(%eax)
  h->hash = hash;
c002d449:	8b 45 08             	mov    0x8(%ebp),%eax
c002d44c:	8b 55 0c             	mov    0xc(%ebp),%edx
c002d44f:	89 50 0c             	mov    %edx,0xc(%eax)
  h->less = less;
c002d452:	8b 45 08             	mov    0x8(%ebp),%eax
c002d455:	8b 55 10             	mov    0x10(%ebp),%edx
c002d458:	89 50 10             	mov    %edx,0x10(%eax)
  h->aux = aux;
c002d45b:	8b 45 08             	mov    0x8(%ebp),%eax
c002d45e:	8b 55 14             	mov    0x14(%ebp),%edx
c002d461:	89 50 14             	mov    %edx,0x14(%eax)

  if (h->buckets != NULL) 
c002d464:	8b 45 08             	mov    0x8(%ebp),%eax
c002d467:	8b 40 08             	mov    0x8(%eax),%eax
c002d46a:	85 c0                	test   %eax,%eax
c002d46c:	74 17                	je     c002d485 <hash_init+0x7f>
    {
      hash_clear (h, NULL);
c002d46e:	83 ec 08             	sub    $0x8,%esp
c002d471:	6a 00                	push   $0x0
c002d473:	ff 75 08             	push   0x8(%ebp)
c002d476:	e8 14 00 00 00       	call   c002d48f <hash_clear>
c002d47b:	83 c4 10             	add    $0x10,%esp
      return true;
c002d47e:	b8 01 00 00 00       	mov    $0x1,%eax
c002d483:	eb 05                	jmp    c002d48a <hash_init+0x84>
    }
  else
    return false;
c002d485:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002d48a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d48d:	c9                   	leave  
c002d48e:	c3                   	ret    

c002d48f <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002d48f:	55                   	push   %ebp
c002d490:	89 e5                	mov    %esp,%ebp
c002d492:	53                   	push   %ebx
c002d493:	83 ec 14             	sub    $0x14,%esp
c002d496:	e8 91 3f 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002d49b:	81 c3 dd ce 00 00    	add    $0xcedd,%ebx
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002d4a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d4a8:	eb 72                	jmp    c002d51c <hash_clear+0x8d>
    {
      struct list *bucket = &h->buckets[i];
c002d4aa:	8b 45 08             	mov    0x8(%ebp),%eax
c002d4ad:	8b 50 08             	mov    0x8(%eax),%edx
c002d4b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d4b3:	c1 e0 04             	shl    $0x4,%eax
c002d4b6:	01 d0                	add    %edx,%eax
c002d4b8:	89 45 f0             	mov    %eax,-0x10(%ebp)

      if (destructor != NULL) 
c002d4bb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002d4bf:	74 49                	je     c002d50a <hash_clear+0x7b>
        while (!list_empty (bucket)) 
c002d4c1:	eb 32                	jmp    c002d4f5 <hash_clear+0x66>
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c002d4c3:	83 ec 0c             	sub    $0xc,%esp
c002d4c6:	ff 75 f0             	push   -0x10(%ebp)
c002d4c9:	e8 1c eb ff ff       	call   c002bfea <list_pop_front>
c002d4ce:	83 c4 10             	add    $0x10,%esp
c002d4d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
c002d4d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d4d7:	83 c0 04             	add    $0x4,%eax
c002d4da:	83 e8 04             	sub    $0x4,%eax
c002d4dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
            destructor (hash_elem, h->aux);
c002d4e0:	8b 45 08             	mov    0x8(%ebp),%eax
c002d4e3:	8b 40 14             	mov    0x14(%eax),%eax
c002d4e6:	83 ec 08             	sub    $0x8,%esp
c002d4e9:	50                   	push   %eax
c002d4ea:	ff 75 e8             	push   -0x18(%ebp)
c002d4ed:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d4f0:	ff d0                	call   *%eax
c002d4f2:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c002d4f5:	83 ec 0c             	sub    $0xc,%esp
c002d4f8:	ff 75 f0             	push   -0x10(%ebp)
c002d4fb:	e8 5f ec ff ff       	call   c002c15f <list_empty>
c002d500:	83 c4 10             	add    $0x10,%esp
c002d503:	83 f0 01             	xor    $0x1,%eax
c002d506:	84 c0                	test   %al,%al
c002d508:	75 b9                	jne    c002d4c3 <hash_clear+0x34>
          }

      list_init (bucket); 
c002d50a:	83 ec 0c             	sub    $0xc,%esp
c002d50d:	ff 75 f0             	push   -0x10(%ebp)
c002d510:	e8 2f e5 ff ff       	call   c002ba44 <list_init>
c002d515:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
c002d518:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d51c:	8b 45 08             	mov    0x8(%ebp),%eax
c002d51f:	8b 40 04             	mov    0x4(%eax),%eax
c002d522:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002d525:	72 83                	jb     c002d4aa <hash_clear+0x1b>
    }    

  h->elem_cnt = 0;
c002d527:	8b 45 08             	mov    0x8(%ebp),%eax
c002d52a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c002d530:	90                   	nop
c002d531:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d534:	c9                   	leave  
c002d535:	c3                   	ret    

c002d536 <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c002d536:	55                   	push   %ebp
c002d537:	89 e5                	mov    %esp,%ebp
c002d539:	53                   	push   %ebx
c002d53a:	83 ec 04             	sub    $0x4,%esp
c002d53d:	e8 ea 3e 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002d542:	81 c3 36 ce 00 00    	add    $0xce36,%ebx
  if (destructor != NULL)
c002d548:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002d54c:	74 11                	je     c002d55f <hash_destroy+0x29>
    hash_clear (h, destructor);
c002d54e:	83 ec 08             	sub    $0x8,%esp
c002d551:	ff 75 0c             	push   0xc(%ebp)
c002d554:	ff 75 08             	push   0x8(%ebp)
c002d557:	e8 33 ff ff ff       	call   c002d48f <hash_clear>
c002d55c:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002d55f:	8b 45 08             	mov    0x8(%ebp),%eax
c002d562:	8b 40 08             	mov    0x8(%eax),%eax
c002d565:	83 ec 0c             	sub    $0xc,%esp
c002d568:	50                   	push   %eax
c002d569:	e8 e4 74 ff ff       	call   c0024a52 <free>
c002d56e:	83 c4 10             	add    $0x10,%esp
}
c002d571:	90                   	nop
c002d572:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d575:	c9                   	leave  
c002d576:	c3                   	ret    

c002d577 <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c002d577:	55                   	push   %ebp
c002d578:	89 e5                	mov    %esp,%ebp
c002d57a:	83 ec 18             	sub    $0x18,%esp
c002d57d:	e8 a6 3e 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d582:	05 f6 cd 00 00       	add    $0xcdf6,%eax
  struct list *bucket = find_bucket (h, new);
c002d587:	83 ec 08             	sub    $0x8,%esp
c002d58a:	ff 75 0c             	push   0xc(%ebp)
c002d58d:	ff 75 08             	push   0x8(%ebp)
c002d590:	e8 1f 05 00 00       	call   c002dab4 <find_bucket>
c002d595:	83 c4 10             	add    $0x10,%esp
c002d598:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002d59b:	83 ec 04             	sub    $0x4,%esp
c002d59e:	ff 75 0c             	push   0xc(%ebp)
c002d5a1:	ff 75 f4             	push   -0xc(%ebp)
c002d5a4:	ff 75 08             	push   0x8(%ebp)
c002d5a7:	e8 50 05 00 00       	call   c002dafc <find_elem>
c002d5ac:	83 c4 10             	add    $0x10,%esp
c002d5af:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old == NULL) 
c002d5b2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002d5b6:	75 14                	jne    c002d5cc <hash_insert+0x55>
    insert_elem (h, bucket, new);
c002d5b8:	83 ec 04             	sub    $0x4,%esp
c002d5bb:	ff 75 0c             	push   0xc(%ebp)
c002d5be:	ff 75 f4             	push   -0xc(%ebp)
c002d5c1:	ff 75 08             	push   0x8(%ebp)
c002d5c4:	e8 d9 07 00 00       	call   c002dda2 <insert_elem>
c002d5c9:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002d5cc:	83 ec 0c             	sub    $0xc,%esp
c002d5cf:	ff 75 08             	push   0x8(%ebp)
c002d5d2:	e8 15 06 00 00       	call   c002dbec <rehash>
c002d5d7:	83 c4 10             	add    $0x10,%esp

  return old; 
c002d5da:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002d5dd:	c9                   	leave  
c002d5de:	c3                   	ret    

c002d5df <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002d5df:	55                   	push   %ebp
c002d5e0:	89 e5                	mov    %esp,%ebp
c002d5e2:	83 ec 18             	sub    $0x18,%esp
c002d5e5:	e8 3e 3e 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d5ea:	05 8e cd 00 00       	add    $0xcd8e,%eax
  struct list *bucket = find_bucket (h, new);
c002d5ef:	83 ec 08             	sub    $0x8,%esp
c002d5f2:	ff 75 0c             	push   0xc(%ebp)
c002d5f5:	ff 75 08             	push   0x8(%ebp)
c002d5f8:	e8 b7 04 00 00       	call   c002dab4 <find_bucket>
c002d5fd:	83 c4 10             	add    $0x10,%esp
c002d600:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002d603:	83 ec 04             	sub    $0x4,%esp
c002d606:	ff 75 0c             	push   0xc(%ebp)
c002d609:	ff 75 f4             	push   -0xc(%ebp)
c002d60c:	ff 75 08             	push   0x8(%ebp)
c002d60f:	e8 e8 04 00 00       	call   c002dafc <find_elem>
c002d614:	83 c4 10             	add    $0x10,%esp
c002d617:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old != NULL)
c002d61a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002d61e:	74 11                	je     c002d631 <hash_replace+0x52>
    remove_elem (h, old);
c002d620:	83 ec 08             	sub    $0x8,%esp
c002d623:	ff 75 f0             	push   -0x10(%ebp)
c002d626:	ff 75 08             	push   0x8(%ebp)
c002d629:	e8 ac 07 00 00       	call   c002ddda <remove_elem>
c002d62e:	83 c4 10             	add    $0x10,%esp
  insert_elem (h, bucket, new);
c002d631:	83 ec 04             	sub    $0x4,%esp
c002d634:	ff 75 0c             	push   0xc(%ebp)
c002d637:	ff 75 f4             	push   -0xc(%ebp)
c002d63a:	ff 75 08             	push   0x8(%ebp)
c002d63d:	e8 60 07 00 00       	call   c002dda2 <insert_elem>
c002d642:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002d645:	83 ec 0c             	sub    $0xc,%esp
c002d648:	ff 75 08             	push   0x8(%ebp)
c002d64b:	e8 9c 05 00 00       	call   c002dbec <rehash>
c002d650:	83 c4 10             	add    $0x10,%esp

  return old;
c002d653:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002d656:	c9                   	leave  
c002d657:	c3                   	ret    

c002d658 <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c002d658:	55                   	push   %ebp
c002d659:	89 e5                	mov    %esp,%ebp
c002d65b:	83 ec 08             	sub    $0x8,%esp
c002d65e:	e8 c5 3d 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d663:	05 15 cd 00 00       	add    $0xcd15,%eax
  return find_elem (h, find_bucket (h, e), e);
c002d668:	83 ec 08             	sub    $0x8,%esp
c002d66b:	ff 75 0c             	push   0xc(%ebp)
c002d66e:	ff 75 08             	push   0x8(%ebp)
c002d671:	e8 3e 04 00 00       	call   c002dab4 <find_bucket>
c002d676:	83 c4 10             	add    $0x10,%esp
c002d679:	83 ec 04             	sub    $0x4,%esp
c002d67c:	ff 75 0c             	push   0xc(%ebp)
c002d67f:	50                   	push   %eax
c002d680:	ff 75 08             	push   0x8(%ebp)
c002d683:	e8 74 04 00 00       	call   c002dafc <find_elem>
c002d688:	83 c4 10             	add    $0x10,%esp
}
c002d68b:	c9                   	leave  
c002d68c:	c3                   	ret    

c002d68d <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c002d68d:	55                   	push   %ebp
c002d68e:	89 e5                	mov    %esp,%ebp
c002d690:	83 ec 18             	sub    $0x18,%esp
c002d693:	e8 90 3d 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d698:	05 e0 cc 00 00       	add    $0xcce0,%eax
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002d69d:	83 ec 08             	sub    $0x8,%esp
c002d6a0:	ff 75 0c             	push   0xc(%ebp)
c002d6a3:	ff 75 08             	push   0x8(%ebp)
c002d6a6:	e8 09 04 00 00       	call   c002dab4 <find_bucket>
c002d6ab:	83 c4 10             	add    $0x10,%esp
c002d6ae:	83 ec 04             	sub    $0x4,%esp
c002d6b1:	ff 75 0c             	push   0xc(%ebp)
c002d6b4:	50                   	push   %eax
c002d6b5:	ff 75 08             	push   0x8(%ebp)
c002d6b8:	e8 3f 04 00 00       	call   c002dafc <find_elem>
c002d6bd:	83 c4 10             	add    $0x10,%esp
c002d6c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (found != NULL) 
c002d6c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d6c7:	74 1f                	je     c002d6e8 <hash_delete+0x5b>
    {
      remove_elem (h, found);
c002d6c9:	83 ec 08             	sub    $0x8,%esp
c002d6cc:	ff 75 f4             	push   -0xc(%ebp)
c002d6cf:	ff 75 08             	push   0x8(%ebp)
c002d6d2:	e8 03 07 00 00       	call   c002ddda <remove_elem>
c002d6d7:	83 c4 10             	add    $0x10,%esp
      rehash (h); 
c002d6da:	83 ec 0c             	sub    $0xc,%esp
c002d6dd:	ff 75 08             	push   0x8(%ebp)
c002d6e0:	e8 07 05 00 00       	call   c002dbec <rehash>
c002d6e5:	83 c4 10             	add    $0x10,%esp
    }
  return found;
c002d6e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002d6eb:	c9                   	leave  
c002d6ec:	c3                   	ret    

c002d6ed <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c002d6ed:	55                   	push   %ebp
c002d6ee:	89 e5                	mov    %esp,%ebp
c002d6f0:	53                   	push   %ebx
c002d6f1:	83 ec 14             	sub    $0x14,%esp
c002d6f4:	e8 33 3d 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002d6f9:	81 c3 7f cc 00 00    	add    $0xcc7f,%ebx
  size_t i;
  
  ASSERT (action != NULL);
c002d6ff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002d703:	75 29                	jne    c002d72e <hash_apply+0x41>
c002d705:	83 ec 0c             	sub    $0xc,%esp
c002d708:	8d 83 60 9b ff ff    	lea    -0x64a0(%ebx),%eax
c002d70e:	50                   	push   %eax
c002d70f:	8d 83 6f 9b ff ff    	lea    -0x6491(%ebx),%eax
c002d715:	50                   	push   %eax
c002d716:	8d 83 c8 9b ff ff    	lea    -0x6438(%ebx),%eax
c002d71c:	50                   	push   %eax
c002d71d:	68 a7 00 00 00       	push   $0xa7
c002d722:	8d 83 86 9b ff ff    	lea    -0x647a(%ebx),%eax
c002d728:	50                   	push   %eax
c002d729:	e8 36 e0 ff ff       	call   c002b764 <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
c002d72e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d735:	eb 6e                	jmp    c002d7a5 <hash_apply+0xb8>
    {
      struct list *bucket = &h->buckets[i];
c002d737:	8b 45 08             	mov    0x8(%ebp),%eax
c002d73a:	8b 50 08             	mov    0x8(%eax),%edx
c002d73d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d740:	c1 e0 04             	shl    $0x4,%eax
c002d743:	01 d0                	add    %edx,%eax
c002d745:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002d748:	83 ec 0c             	sub    $0xc,%esp
c002d74b:	ff 75 ec             	push   -0x14(%ebp)
c002d74e:	e8 5e e3 ff ff       	call   c002bab1 <list_begin>
c002d753:	83 c4 10             	add    $0x10,%esp
c002d756:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002d759:	eb 33                	jmp    c002d78e <hash_apply+0xa1>
        {
          next = list_next (elem);
c002d75b:	83 ec 0c             	sub    $0xc,%esp
c002d75e:	ff 75 f0             	push   -0x10(%ebp)
c002d761:	e8 95 e3 ff ff       	call   c002bafb <list_next>
c002d766:	83 c4 10             	add    $0x10,%esp
c002d769:	89 45 e8             	mov    %eax,-0x18(%ebp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002d76c:	8b 45 08             	mov    0x8(%ebp),%eax
c002d76f:	8b 40 14             	mov    0x14(%eax),%eax
c002d772:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d775:	83 c2 04             	add    $0x4,%edx
c002d778:	83 ea 04             	sub    $0x4,%edx
c002d77b:	83 ec 08             	sub    $0x8,%esp
c002d77e:	50                   	push   %eax
c002d77f:	52                   	push   %edx
c002d780:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d783:	ff d0                	call   *%eax
c002d785:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002d788:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d78b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002d78e:	83 ec 0c             	sub    $0xc,%esp
c002d791:	ff 75 ec             	push   -0x14(%ebp)
c002d794:	e8 c3 e3 ff ff       	call   c002bb5c <list_end>
c002d799:	83 c4 10             	add    $0x10,%esp
c002d79c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002d79f:	75 ba                	jne    c002d75b <hash_apply+0x6e>
  for (i = 0; i < h->bucket_cnt; i++) 
c002d7a1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d7a5:	8b 45 08             	mov    0x8(%ebp),%eax
c002d7a8:	8b 40 04             	mov    0x4(%eax),%eax
c002d7ab:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002d7ae:	72 87                	jb     c002d737 <hash_apply+0x4a>
        }
    }
}
c002d7b0:	90                   	nop
c002d7b1:	90                   	nop
c002d7b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d7b5:	c9                   	leave  
c002d7b6:	c3                   	ret    

c002d7b7 <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c002d7b7:	55                   	push   %ebp
c002d7b8:	89 e5                	mov    %esp,%ebp
c002d7ba:	53                   	push   %ebx
c002d7bb:	83 ec 04             	sub    $0x4,%esp
c002d7be:	e8 65 3c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d7c3:	05 b5 cb 00 00       	add    $0xcbb5,%eax
  ASSERT (i != NULL);
c002d7c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002d7cc:	75 2b                	jne    c002d7f9 <hash_first+0x42>
c002d7ce:	83 ec 0c             	sub    $0xc,%esp
c002d7d1:	8d 90 9e 9b ff ff    	lea    -0x6462(%eax),%edx
c002d7d7:	52                   	push   %edx
c002d7d8:	8d 90 6f 9b ff ff    	lea    -0x6491(%eax),%edx
c002d7de:	52                   	push   %edx
c002d7df:	8d 90 d4 9b ff ff    	lea    -0x642c(%eax),%edx
c002d7e5:	52                   	push   %edx
c002d7e6:	68 ca 00 00 00       	push   $0xca
c002d7eb:	8d 90 86 9b ff ff    	lea    -0x647a(%eax),%edx
c002d7f1:	52                   	push   %edx
c002d7f2:	89 c3                	mov    %eax,%ebx
c002d7f4:	e8 6b df ff ff       	call   c002b764 <debug_panic>
  ASSERT (h != NULL);
c002d7f9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002d7fd:	75 2b                	jne    c002d82a <hash_first+0x73>
c002d7ff:	83 ec 0c             	sub    $0xc,%esp
c002d802:	8d 90 a8 9b ff ff    	lea    -0x6458(%eax),%edx
c002d808:	52                   	push   %edx
c002d809:	8d 90 6f 9b ff ff    	lea    -0x6491(%eax),%edx
c002d80f:	52                   	push   %edx
c002d810:	8d 90 d4 9b ff ff    	lea    -0x642c(%eax),%edx
c002d816:	52                   	push   %edx
c002d817:	68 cb 00 00 00       	push   $0xcb
c002d81c:	8d 90 86 9b ff ff    	lea    -0x647a(%eax),%edx
c002d822:	52                   	push   %edx
c002d823:	89 c3                	mov    %eax,%ebx
c002d825:	e8 3a df ff ff       	call   c002b764 <debug_panic>

  i->hash = h;
c002d82a:	8b 55 08             	mov    0x8(%ebp),%edx
c002d82d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002d830:	89 0a                	mov    %ecx,(%edx)
  i->bucket = i->hash->buckets;
c002d832:	8b 55 08             	mov    0x8(%ebp),%edx
c002d835:	8b 12                	mov    (%edx),%edx
c002d837:	8b 4a 08             	mov    0x8(%edx),%ecx
c002d83a:	8b 55 08             	mov    0x8(%ebp),%edx
c002d83d:	89 4a 04             	mov    %ecx,0x4(%edx)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002d840:	8b 55 08             	mov    0x8(%ebp),%edx
c002d843:	8b 52 04             	mov    0x4(%edx),%edx
c002d846:	83 ec 0c             	sub    $0xc,%esp
c002d849:	52                   	push   %edx
c002d84a:	89 c3                	mov    %eax,%ebx
c002d84c:	e8 49 e4 ff ff       	call   c002bc9a <list_head>
c002d851:	83 c4 10             	add    $0x10,%esp
c002d854:	83 c0 04             	add    $0x4,%eax
c002d857:	8d 50 fc             	lea    -0x4(%eax),%edx
c002d85a:	8b 45 08             	mov    0x8(%ebp),%eax
c002d85d:	89 50 08             	mov    %edx,0x8(%eax)
}
c002d860:	90                   	nop
c002d861:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d864:	c9                   	leave  
c002d865:	c3                   	ret    

c002d866 <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002d866:	55                   	push   %ebp
c002d867:	89 e5                	mov    %esp,%ebp
c002d869:	56                   	push   %esi
c002d86a:	53                   	push   %ebx
c002d86b:	e8 bc 3b 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002d870:	81 c3 08 cb 00 00    	add    $0xcb08,%ebx
  ASSERT (i != NULL);
c002d876:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002d87a:	75 29                	jne    c002d8a5 <hash_next+0x3f>
c002d87c:	83 ec 0c             	sub    $0xc,%esp
c002d87f:	8d 83 9e 9b ff ff    	lea    -0x6462(%ebx),%eax
c002d885:	50                   	push   %eax
c002d886:	8d 83 6f 9b ff ff    	lea    -0x6491(%ebx),%eax
c002d88c:	50                   	push   %eax
c002d88d:	8d 83 e0 9b ff ff    	lea    -0x6420(%ebx),%eax
c002d893:	50                   	push   %eax
c002d894:	68 dd 00 00 00       	push   $0xdd
c002d899:	8d 83 86 9b ff ff    	lea    -0x647a(%ebx),%eax
c002d89f:	50                   	push   %eax
c002d8a0:	e8 bf de ff ff       	call   c002b764 <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002d8a5:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8a8:	8b 40 08             	mov    0x8(%eax),%eax
c002d8ab:	83 ec 0c             	sub    $0xc,%esp
c002d8ae:	50                   	push   %eax
c002d8af:	e8 47 e2 ff ff       	call   c002bafb <list_next>
c002d8b4:	83 c4 10             	add    $0x10,%esp
c002d8b7:	83 c0 04             	add    $0x4,%eax
c002d8ba:	8d 50 fc             	lea    -0x4(%eax),%edx
c002d8bd:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8c0:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002d8c3:	eb 58                	jmp    c002d91d <hash_next+0xb7>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002d8c5:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8c8:	8b 40 04             	mov    0x4(%eax),%eax
c002d8cb:	8d 50 10             	lea    0x10(%eax),%edx
c002d8ce:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8d1:	89 50 04             	mov    %edx,0x4(%eax)
c002d8d4:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8d7:	8b 50 04             	mov    0x4(%eax),%edx
c002d8da:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8dd:	8b 00                	mov    (%eax),%eax
c002d8df:	8b 48 08             	mov    0x8(%eax),%ecx
c002d8e2:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8e5:	8b 00                	mov    (%eax),%eax
c002d8e7:	8b 40 04             	mov    0x4(%eax),%eax
c002d8ea:	c1 e0 04             	shl    $0x4,%eax
c002d8ed:	01 c8                	add    %ecx,%eax
c002d8ef:	39 c2                	cmp    %eax,%edx
c002d8f1:	72 0c                	jb     c002d8ff <hash_next+0x99>
        {
          i->elem = NULL;
c002d8f3:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8f6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          break;
c002d8fd:	eb 40                	jmp    c002d93f <hash_next+0xd9>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002d8ff:	8b 45 08             	mov    0x8(%ebp),%eax
c002d902:	8b 40 04             	mov    0x4(%eax),%eax
c002d905:	83 ec 0c             	sub    $0xc,%esp
c002d908:	50                   	push   %eax
c002d909:	e8 a3 e1 ff ff       	call   c002bab1 <list_begin>
c002d90e:	83 c4 10             	add    $0x10,%esp
c002d911:	83 c0 04             	add    $0x4,%eax
c002d914:	8d 50 fc             	lea    -0x4(%eax),%edx
c002d917:	8b 45 08             	mov    0x8(%ebp),%eax
c002d91a:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002d91d:	8b 45 08             	mov    0x8(%ebp),%eax
c002d920:	8b 70 08             	mov    0x8(%eax),%esi
c002d923:	8b 45 08             	mov    0x8(%ebp),%eax
c002d926:	8b 40 04             	mov    0x4(%eax),%eax
c002d929:	83 ec 0c             	sub    $0xc,%esp
c002d92c:	50                   	push   %eax
c002d92d:	e8 2a e2 ff ff       	call   c002bb5c <list_end>
c002d932:	83 c4 10             	add    $0x10,%esp
c002d935:	83 c0 04             	add    $0x4,%eax
c002d938:	83 e8 04             	sub    $0x4,%eax
c002d93b:	39 c6                	cmp    %eax,%esi
c002d93d:	74 86                	je     c002d8c5 <hash_next+0x5f>
    }
  
  return i->elem;
c002d93f:	8b 45 08             	mov    0x8(%ebp),%eax
c002d942:	8b 40 08             	mov    0x8(%eax),%eax
}
c002d945:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002d948:	5b                   	pop    %ebx
c002d949:	5e                   	pop    %esi
c002d94a:	5d                   	pop    %ebp
c002d94b:	c3                   	ret    

c002d94c <hash_cur>:
/* Returns the current element in the hash table iteration, or a
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
c002d94c:	55                   	push   %ebp
c002d94d:	89 e5                	mov    %esp,%ebp
c002d94f:	e8 d4 3a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d954:	05 24 ca 00 00       	add    $0xca24,%eax
  return i->elem;
c002d959:	8b 45 08             	mov    0x8(%ebp),%eax
c002d95c:	8b 40 08             	mov    0x8(%eax),%eax
}
c002d95f:	5d                   	pop    %ebp
c002d960:	c3                   	ret    

c002d961 <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
c002d961:	55                   	push   %ebp
c002d962:	89 e5                	mov    %esp,%ebp
c002d964:	e8 bf 3a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d969:	05 0f ca 00 00       	add    $0xca0f,%eax
  return h->elem_cnt;
c002d96e:	8b 45 08             	mov    0x8(%ebp),%eax
c002d971:	8b 00                	mov    (%eax),%eax
}
c002d973:	5d                   	pop    %ebp
c002d974:	c3                   	ret    

c002d975 <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
c002d975:	55                   	push   %ebp
c002d976:	89 e5                	mov    %esp,%ebp
c002d978:	e8 ab 3a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d97d:	05 fb c9 00 00       	add    $0xc9fb,%eax
  return h->elem_cnt == 0;
c002d982:	8b 45 08             	mov    0x8(%ebp),%eax
c002d985:	8b 00                	mov    (%eax),%eax
c002d987:	85 c0                	test   %eax,%eax
c002d989:	0f 94 c0             	sete   %al
}
c002d98c:	5d                   	pop    %ebp
c002d98d:	c3                   	ret    

c002d98e <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c002d98e:	55                   	push   %ebp
c002d98f:	89 e5                	mov    %esp,%ebp
c002d991:	53                   	push   %ebx
c002d992:	83 ec 14             	sub    $0x14,%esp
c002d995:	e8 8e 3a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002d99a:	05 de c9 00 00       	add    $0xc9de,%eax
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
c002d99f:	8b 55 08             	mov    0x8(%ebp),%edx
c002d9a2:	89 55 f4             	mov    %edx,-0xc(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);
c002d9a5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d9a9:	75 2b                	jne    c002d9d6 <hash_bytes+0x48>
c002d9ab:	83 ec 0c             	sub    $0xc,%esp
c002d9ae:	8d 90 b2 9b ff ff    	lea    -0x644e(%eax),%edx
c002d9b4:	52                   	push   %edx
c002d9b5:	8d 90 6f 9b ff ff    	lea    -0x6491(%eax),%edx
c002d9bb:	52                   	push   %edx
c002d9bc:	8d 90 ec 9b ff ff    	lea    -0x6414(%eax),%edx
c002d9c2:	52                   	push   %edx
c002d9c3:	68 10 01 00 00       	push   $0x110
c002d9c8:	8d 90 86 9b ff ff    	lea    -0x647a(%eax),%edx
c002d9ce:	52                   	push   %edx
c002d9cf:	89 c3                	mov    %eax,%ebx
c002d9d1:	e8 8e dd ff ff       	call   c002b764 <debug_panic>

  hash = FNV_32_BASIS;
c002d9d6:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (size-- > 0)
c002d9dd:	eb 1d                	jmp    c002d9fc <hash_bytes+0x6e>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002d9df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d9e2:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002d9e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d9eb:	8d 50 01             	lea    0x1(%eax),%edx
c002d9ee:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002d9f1:	0f b6 00             	movzbl (%eax),%eax
c002d9f4:	0f b6 c0             	movzbl %al,%eax
c002d9f7:	31 c8                	xor    %ecx,%eax
c002d9f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (size-- > 0)
c002d9fc:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d9ff:	8d 50 ff             	lea    -0x1(%eax),%edx
c002da02:	89 55 0c             	mov    %edx,0xc(%ebp)
c002da05:	85 c0                	test   %eax,%eax
c002da07:	75 d6                	jne    c002d9df <hash_bytes+0x51>

  return hash;
c002da09:	8b 45 f0             	mov    -0x10(%ebp),%eax
} 
c002da0c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002da0f:	c9                   	leave  
c002da10:	c3                   	ret    

c002da11 <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002da11:	55                   	push   %ebp
c002da12:	89 e5                	mov    %esp,%ebp
c002da14:	53                   	push   %ebx
c002da15:	83 ec 14             	sub    $0x14,%esp
c002da18:	e8 0b 3a 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002da1d:	05 5b c9 00 00       	add    $0xc95b,%eax
  const unsigned char *s = (const unsigned char *) s_;
c002da22:	8b 55 08             	mov    0x8(%ebp),%edx
c002da25:	89 55 f4             	mov    %edx,-0xc(%ebp)
  unsigned hash;

  ASSERT (s != NULL);
c002da28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002da2c:	75 2b                	jne    c002da59 <hash_string+0x48>
c002da2e:	83 ec 0c             	sub    $0xc,%esp
c002da31:	8d 90 be 9b ff ff    	lea    -0x6442(%eax),%edx
c002da37:	52                   	push   %edx
c002da38:	8d 90 6f 9b ff ff    	lea    -0x6491(%eax),%edx
c002da3e:	52                   	push   %edx
c002da3f:	8d 90 f8 9b ff ff    	lea    -0x6408(%eax),%edx
c002da45:	52                   	push   %edx
c002da46:	68 20 01 00 00       	push   $0x120
c002da4b:	8d 90 86 9b ff ff    	lea    -0x647a(%eax),%edx
c002da51:	52                   	push   %edx
c002da52:	89 c3                	mov    %eax,%ebx
c002da54:	e8 0b dd ff ff       	call   c002b764 <debug_panic>

  hash = FNV_32_BASIS;
c002da59:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (*s != '\0')
c002da60:	eb 1d                	jmp    c002da7f <hash_string+0x6e>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002da62:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002da65:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002da6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002da6e:	8d 50 01             	lea    0x1(%eax),%edx
c002da71:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002da74:	0f b6 00             	movzbl (%eax),%eax
c002da77:	0f b6 c0             	movzbl %al,%eax
c002da7a:	31 c8                	xor    %ecx,%eax
c002da7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (*s != '\0')
c002da7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002da82:	0f b6 00             	movzbl (%eax),%eax
c002da85:	84 c0                	test   %al,%al
c002da87:	75 d9                	jne    c002da62 <hash_string+0x51>

  return hash;
c002da89:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002da8c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002da8f:	c9                   	leave  
c002da90:	c3                   	ret    

c002da91 <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c002da91:	55                   	push   %ebp
c002da92:	89 e5                	mov    %esp,%ebp
c002da94:	83 ec 08             	sub    $0x8,%esp
c002da97:	e8 8c 39 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002da9c:	05 dc c8 00 00       	add    $0xc8dc,%eax
  return hash_bytes (&i, sizeof i);
c002daa1:	83 ec 08             	sub    $0x8,%esp
c002daa4:	6a 04                	push   $0x4
c002daa6:	8d 45 08             	lea    0x8(%ebp),%eax
c002daa9:	50                   	push   %eax
c002daaa:	e8 df fe ff ff       	call   c002d98e <hash_bytes>
c002daaf:	83 c4 10             	add    $0x10,%esp
}
c002dab2:	c9                   	leave  
c002dab3:	c3                   	ret    

c002dab4 <find_bucket>:

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002dab4:	55                   	push   %ebp
c002dab5:	89 e5                	mov    %esp,%ebp
c002dab7:	83 ec 18             	sub    $0x18,%esp
c002daba:	e8 69 39 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002dabf:	05 b9 c8 00 00       	add    $0xc8b9,%eax
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002dac4:	8b 45 08             	mov    0x8(%ebp),%eax
c002dac7:	8b 40 0c             	mov    0xc(%eax),%eax
c002daca:	8b 55 08             	mov    0x8(%ebp),%edx
c002dacd:	8b 52 14             	mov    0x14(%edx),%edx
c002dad0:	83 ec 08             	sub    $0x8,%esp
c002dad3:	52                   	push   %edx
c002dad4:	ff 75 0c             	push   0xc(%ebp)
c002dad7:	ff d0                	call   *%eax
c002dad9:	83 c4 10             	add    $0x10,%esp
c002dadc:	89 c2                	mov    %eax,%edx
c002dade:	8b 45 08             	mov    0x8(%ebp),%eax
c002dae1:	8b 40 04             	mov    0x4(%eax),%eax
c002dae4:	83 e8 01             	sub    $0x1,%eax
c002dae7:	21 d0                	and    %edx,%eax
c002dae9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return &h->buckets[bucket_idx];
c002daec:	8b 45 08             	mov    0x8(%ebp),%eax
c002daef:	8b 50 08             	mov    0x8(%eax),%edx
c002daf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002daf5:	c1 e0 04             	shl    $0x4,%eax
c002daf8:	01 d0                	add    %edx,%eax
}
c002dafa:	c9                   	leave  
c002dafb:	c3                   	ret    

c002dafc <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002dafc:	55                   	push   %ebp
c002dafd:	89 e5                	mov    %esp,%ebp
c002daff:	53                   	push   %ebx
c002db00:	83 ec 14             	sub    $0x14,%esp
c002db03:	e8 24 39 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002db08:	81 c3 70 c8 00 00    	add    $0xc870,%ebx
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002db0e:	83 ec 0c             	sub    $0xc,%esp
c002db11:	ff 75 0c             	push   0xc(%ebp)
c002db14:	e8 98 df ff ff       	call   c002bab1 <list_begin>
c002db19:	83 c4 10             	add    $0x10,%esp
c002db1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002db1f:	eb 66                	jmp    c002db87 <find_elem+0x8b>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
c002db21:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002db24:	83 c0 04             	add    $0x4,%eax
c002db27:	83 e8 04             	sub    $0x4,%eax
c002db2a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002db2d:	8b 45 08             	mov    0x8(%ebp),%eax
c002db30:	8b 40 10             	mov    0x10(%eax),%eax
c002db33:	8b 55 08             	mov    0x8(%ebp),%edx
c002db36:	8b 52 14             	mov    0x14(%edx),%edx
c002db39:	83 ec 04             	sub    $0x4,%esp
c002db3c:	52                   	push   %edx
c002db3d:	ff 75 10             	push   0x10(%ebp)
c002db40:	ff 75 f0             	push   -0x10(%ebp)
c002db43:	ff d0                	call   *%eax
c002db45:	83 c4 10             	add    $0x10,%esp
c002db48:	83 f0 01             	xor    $0x1,%eax
c002db4b:	84 c0                	test   %al,%al
c002db4d:	74 27                	je     c002db76 <find_elem+0x7a>
c002db4f:	8b 45 08             	mov    0x8(%ebp),%eax
c002db52:	8b 40 10             	mov    0x10(%eax),%eax
c002db55:	8b 55 08             	mov    0x8(%ebp),%edx
c002db58:	8b 52 14             	mov    0x14(%edx),%edx
c002db5b:	83 ec 04             	sub    $0x4,%esp
c002db5e:	52                   	push   %edx
c002db5f:	ff 75 f0             	push   -0x10(%ebp)
c002db62:	ff 75 10             	push   0x10(%ebp)
c002db65:	ff d0                	call   *%eax
c002db67:	83 c4 10             	add    $0x10,%esp
c002db6a:	83 f0 01             	xor    $0x1,%eax
c002db6d:	84 c0                	test   %al,%al
c002db6f:	74 05                	je     c002db76 <find_elem+0x7a>
        return hi; 
c002db71:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002db74:	eb 29                	jmp    c002db9f <find_elem+0xa3>
  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002db76:	83 ec 0c             	sub    $0xc,%esp
c002db79:	ff 75 f4             	push   -0xc(%ebp)
c002db7c:	e8 7a df ff ff       	call   c002bafb <list_next>
c002db81:	83 c4 10             	add    $0x10,%esp
c002db84:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002db87:	83 ec 0c             	sub    $0xc,%esp
c002db8a:	ff 75 0c             	push   0xc(%ebp)
c002db8d:	e8 ca df ff ff       	call   c002bb5c <list_end>
c002db92:	83 c4 10             	add    $0x10,%esp
c002db95:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002db98:	75 87                	jne    c002db21 <find_elem+0x25>
    }
  return NULL;
c002db9a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002db9f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dba2:	c9                   	leave  
c002dba3:	c3                   	ret    

c002dba4 <turn_off_least_1bit>:

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
c002dba4:	55                   	push   %ebp
c002dba5:	89 e5                	mov    %esp,%ebp
c002dba7:	e8 7c 38 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002dbac:	05 cc c7 00 00       	add    $0xc7cc,%eax
  return x & (x - 1);
c002dbb1:	8b 45 08             	mov    0x8(%ebp),%eax
c002dbb4:	83 e8 01             	sub    $0x1,%eax
c002dbb7:	23 45 08             	and    0x8(%ebp),%eax
}
c002dbba:	5d                   	pop    %ebp
c002dbbb:	c3                   	ret    

c002dbbc <is_power_of_2>:

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
c002dbbc:	55                   	push   %ebp
c002dbbd:	89 e5                	mov    %esp,%ebp
c002dbbf:	e8 64 38 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002dbc4:	05 b4 c7 00 00       	add    $0xc7b4,%eax
  return x != 0 && turn_off_least_1bit (x) == 0;
c002dbc9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002dbcd:	74 16                	je     c002dbe5 <is_power_of_2+0x29>
c002dbcf:	ff 75 08             	push   0x8(%ebp)
c002dbd2:	e8 cd ff ff ff       	call   c002dba4 <turn_off_least_1bit>
c002dbd7:	83 c4 04             	add    $0x4,%esp
c002dbda:	85 c0                	test   %eax,%eax
c002dbdc:	75 07                	jne    c002dbe5 <is_power_of_2+0x29>
c002dbde:	b8 01 00 00 00       	mov    $0x1,%eax
c002dbe3:	eb 05                	jmp    c002dbea <is_power_of_2+0x2e>
c002dbe5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002dbea:	c9                   	leave  
c002dbeb:	c3                   	ret    

c002dbec <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002dbec:	55                   	push   %ebp
c002dbed:	89 e5                	mov    %esp,%ebp
c002dbef:	53                   	push   %ebx
c002dbf0:	83 ec 34             	sub    $0x34,%esp
c002dbf3:	e8 34 38 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002dbf8:	81 c3 80 c7 00 00    	add    $0xc780,%ebx
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002dbfe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002dc02:	75 29                	jne    c002dc2d <rehash+0x41>
c002dc04:	83 ec 0c             	sub    $0xc,%esp
c002dc07:	8d 83 a8 9b ff ff    	lea    -0x6458(%ebx),%eax
c002dc0d:	50                   	push   %eax
c002dc0e:	8d 83 6f 9b ff ff    	lea    -0x6491(%ebx),%eax
c002dc14:	50                   	push   %eax
c002dc15:	8d 83 04 9c ff ff    	lea    -0x63fc(%ebx),%eax
c002dc1b:	50                   	push   %eax
c002dc1c:	68 66 01 00 00       	push   $0x166
c002dc21:	8d 83 86 9b ff ff    	lea    -0x647a(%ebx),%eax
c002dc27:	50                   	push   %eax
c002dc28:	e8 37 db ff ff       	call   c002b764 <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c002dc2d:	8b 45 08             	mov    0x8(%ebp),%eax
c002dc30:	8b 40 08             	mov    0x8(%eax),%eax
c002dc33:	89 45 e8             	mov    %eax,-0x18(%ebp)
  old_bucket_cnt = h->bucket_cnt;
c002dc36:	8b 45 08             	mov    0x8(%ebp),%eax
c002dc39:	8b 40 04             	mov    0x4(%eax),%eax
c002dc3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002dc3f:	8b 45 08             	mov    0x8(%ebp),%eax
c002dc42:	8b 00                	mov    (%eax),%eax
c002dc44:	d1 e8                	shr    %eax
c002dc46:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (new_bucket_cnt < 4)
c002dc49:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002dc4d:	77 1a                	ja     c002dc69 <rehash+0x7d>
    new_bucket_cnt = 4;
c002dc4f:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002dc56:	eb 11                	jmp    c002dc69 <rehash+0x7d>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);
c002dc58:	83 ec 0c             	sub    $0xc,%esp
c002dc5b:	ff 75 f4             	push   -0xc(%ebp)
c002dc5e:	e8 41 ff ff ff       	call   c002dba4 <turn_off_least_1bit>
c002dc63:	83 c4 10             	add    $0x10,%esp
c002dc66:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002dc69:	83 ec 0c             	sub    $0xc,%esp
c002dc6c:	ff 75 f4             	push   -0xc(%ebp)
c002dc6f:	e8 48 ff ff ff       	call   c002dbbc <is_power_of_2>
c002dc74:	83 c4 10             	add    $0x10,%esp
c002dc77:	85 c0                	test   %eax,%eax
c002dc79:	74 dd                	je     c002dc58 <rehash+0x6c>

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002dc7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dc7e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002dc81:	0f 84 12 01 00 00    	je     c002dd99 <rehash+0x1ad>
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002dc87:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dc8a:	c1 e0 04             	shl    $0x4,%eax
c002dc8d:	83 ec 0c             	sub    $0xc,%esp
c002dc90:	50                   	push   %eax
c002dc91:	e8 7d 6a ff ff       	call   c0024713 <malloc>
c002dc96:	83 c4 10             	add    $0x10,%esp
c002dc99:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (new_buckets == NULL) 
c002dc9c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002dca0:	0f 84 f6 00 00 00    	je     c002dd9c <rehash+0x1b0>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002dca6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002dcad:	eb 1d                	jmp    c002dccc <rehash+0xe0>
    list_init (&new_buckets[i]);
c002dcaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dcb2:	c1 e0 04             	shl    $0x4,%eax
c002dcb5:	89 c2                	mov    %eax,%edx
c002dcb7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002dcba:	01 d0                	add    %edx,%eax
c002dcbc:	83 ec 0c             	sub    $0xc,%esp
c002dcbf:	50                   	push   %eax
c002dcc0:	e8 7f dd ff ff       	call   c002ba44 <list_init>
c002dcc5:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < new_bucket_cnt; i++) 
c002dcc8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002dccc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dccf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002dcd2:	72 db                	jb     c002dcaf <rehash+0xc3>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002dcd4:	8b 45 08             	mov    0x8(%ebp),%eax
c002dcd7:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002dcda:	89 50 08             	mov    %edx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002dcdd:	8b 45 08             	mov    0x8(%ebp),%eax
c002dce0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002dce3:	89 50 04             	mov    %edx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002dce6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002dced:	e9 8b 00 00 00       	jmp    c002dd7d <rehash+0x191>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002dcf2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dcf5:	c1 e0 04             	shl    $0x4,%eax
c002dcf8:	89 c2                	mov    %eax,%edx
c002dcfa:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002dcfd:	01 d0                	add    %edx,%eax
c002dcff:	89 45 dc             	mov    %eax,-0x24(%ebp)
      for (elem = list_begin (old_bucket);
c002dd02:	83 ec 0c             	sub    $0xc,%esp
c002dd05:	ff 75 dc             	push   -0x24(%ebp)
c002dd08:	e8 a4 dd ff ff       	call   c002bab1 <list_begin>
c002dd0d:	83 c4 10             	add    $0x10,%esp
c002dd10:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002dd13:	eb 51                	jmp    c002dd66 <rehash+0x17a>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002dd15:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002dd18:	83 c0 04             	add    $0x4,%eax
c002dd1b:	83 e8 04             	sub    $0x4,%eax
c002dd1e:	83 ec 08             	sub    $0x8,%esp
c002dd21:	50                   	push   %eax
c002dd22:	ff 75 08             	push   0x8(%ebp)
c002dd25:	e8 8a fd ff ff       	call   c002dab4 <find_bucket>
c002dd2a:	83 c4 10             	add    $0x10,%esp
c002dd2d:	89 45 d8             	mov    %eax,-0x28(%ebp)
          next = list_next (elem);
c002dd30:	83 ec 0c             	sub    $0xc,%esp
c002dd33:	ff 75 ec             	push   -0x14(%ebp)
c002dd36:	e8 c0 dd ff ff       	call   c002bafb <list_next>
c002dd3b:	83 c4 10             	add    $0x10,%esp
c002dd3e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          list_remove (elem);
c002dd41:	83 ec 0c             	sub    $0xc,%esp
c002dd44:	ff 75 ec             	push   -0x14(%ebp)
c002dd47:	e8 2e e2 ff ff       	call   c002bf7a <list_remove>
c002dd4c:	83 c4 10             	add    $0x10,%esp
          list_push_front (new_bucket, elem);
c002dd4f:	83 ec 08             	sub    $0x8,%esp
c002dd52:	ff 75 ec             	push   -0x14(%ebp)
c002dd55:	ff 75 d8             	push   -0x28(%ebp)
c002dd58:	e8 bd e1 ff ff       	call   c002bf1a <list_push_front>
c002dd5d:	83 c4 10             	add    $0x10,%esp
           elem != list_end (old_bucket); elem = next) 
c002dd60:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002dd63:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002dd66:	83 ec 0c             	sub    $0xc,%esp
c002dd69:	ff 75 dc             	push   -0x24(%ebp)
c002dd6c:	e8 eb dd ff ff       	call   c002bb5c <list_end>
c002dd71:	83 c4 10             	add    $0x10,%esp
c002dd74:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c002dd77:	75 9c                	jne    c002dd15 <rehash+0x129>
  for (i = 0; i < old_bucket_cnt; i++) 
c002dd79:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002dd7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dd80:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002dd83:	0f 82 69 ff ff ff    	jb     c002dcf2 <rehash+0x106>
        }
    }

  free (old_buckets);
c002dd89:	83 ec 0c             	sub    $0xc,%esp
c002dd8c:	ff 75 e8             	push   -0x18(%ebp)
c002dd8f:	e8 be 6c ff ff       	call   c0024a52 <free>
c002dd94:	83 c4 10             	add    $0x10,%esp
c002dd97:	eb 04                	jmp    c002dd9d <rehash+0x1b1>
    return;
c002dd99:	90                   	nop
c002dd9a:	eb 01                	jmp    c002dd9d <rehash+0x1b1>
      return;
c002dd9c:	90                   	nop
}
c002dd9d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dda0:	c9                   	leave  
c002dda1:	c3                   	ret    

c002dda2 <insert_elem>:

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002dda2:	55                   	push   %ebp
c002dda3:	89 e5                	mov    %esp,%ebp
c002dda5:	53                   	push   %ebx
c002dda6:	83 ec 04             	sub    $0x4,%esp
c002dda9:	e8 7a 36 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002ddae:	05 ca c5 00 00       	add    $0xc5ca,%eax
  h->elem_cnt++;
c002ddb3:	8b 55 08             	mov    0x8(%ebp),%edx
c002ddb6:	8b 12                	mov    (%edx),%edx
c002ddb8:	8d 4a 01             	lea    0x1(%edx),%ecx
c002ddbb:	8b 55 08             	mov    0x8(%ebp),%edx
c002ddbe:	89 0a                	mov    %ecx,(%edx)
  list_push_front (bucket, &e->list_elem);
c002ddc0:	8b 55 10             	mov    0x10(%ebp),%edx
c002ddc3:	83 ec 08             	sub    $0x8,%esp
c002ddc6:	52                   	push   %edx
c002ddc7:	ff 75 0c             	push   0xc(%ebp)
c002ddca:	89 c3                	mov    %eax,%ebx
c002ddcc:	e8 49 e1 ff ff       	call   c002bf1a <list_push_front>
c002ddd1:	83 c4 10             	add    $0x10,%esp
}
c002ddd4:	90                   	nop
c002ddd5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ddd8:	c9                   	leave  
c002ddd9:	c3                   	ret    

c002ddda <remove_elem>:

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
c002ddda:	55                   	push   %ebp
c002dddb:	89 e5                	mov    %esp,%ebp
c002dddd:	53                   	push   %ebx
c002ddde:	83 ec 04             	sub    $0x4,%esp
c002dde1:	e8 42 36 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002dde6:	05 92 c5 00 00       	add    $0xc592,%eax
  h->elem_cnt--;
c002ddeb:	8b 55 08             	mov    0x8(%ebp),%edx
c002ddee:	8b 12                	mov    (%edx),%edx
c002ddf0:	8d 4a ff             	lea    -0x1(%edx),%ecx
c002ddf3:	8b 55 08             	mov    0x8(%ebp),%edx
c002ddf6:	89 0a                	mov    %ecx,(%edx)
  list_remove (&e->list_elem);
c002ddf8:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ddfb:	83 ec 0c             	sub    $0xc,%esp
c002ddfe:	52                   	push   %edx
c002ddff:	89 c3                	mov    %eax,%ebx
c002de01:	e8 74 e1 ff ff       	call   c002bf7a <list_remove>
c002de06:	83 c4 10             	add    $0x10,%esp
}
c002de09:	90                   	nop
c002de0a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002de0d:	c9                   	leave  
c002de0e:	c3                   	ret    

c002de0f <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c002de0f:	55                   	push   %ebp
c002de10:	89 e5                	mov    %esp,%ebp
c002de12:	53                   	push   %ebx
c002de13:	83 ec 04             	sub    $0x4,%esp
c002de16:	e8 11 36 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002de1b:	81 c3 5d c5 00 00    	add    $0xc55d,%ebx
  lock_init (&console_lock);
c002de21:	83 ec 0c             	sub    $0xc,%esp
c002de24:	8d 83 70 22 00 00    	lea    0x2270(%ebx),%eax
c002de2a:	50                   	push   %eax
c002de2b:	e8 a2 59 ff ff       	call   c00237d2 <lock_init>
c002de30:	83 c4 10             	add    $0x10,%esp
  use_console_lock = true;
c002de33:	c6 83 88 22 00 00 01 	movb   $0x1,0x2288(%ebx)
}
c002de3a:	90                   	nop
c002de3b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002de3e:	c9                   	leave  
c002de3f:	c3                   	ret    

c002de40 <console_panic>:
/* Notifies the console that a kernel panic is underway,
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
c002de40:	55                   	push   %ebp
c002de41:	89 e5                	mov    %esp,%ebp
c002de43:	e8 e0 35 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002de48:	05 30 c5 00 00       	add    $0xc530,%eax
  use_console_lock = false;
c002de4d:	c6 80 88 22 00 00 00 	movb   $0x0,0x2288(%eax)
}
c002de54:	90                   	nop
c002de55:	5d                   	pop    %ebp
c002de56:	c3                   	ret    

c002de57 <console_print_stats>:

/* Prints console statistics. */
void
console_print_stats (void) 
{
c002de57:	55                   	push   %ebp
c002de58:	89 e5                	mov    %esp,%ebp
c002de5a:	53                   	push   %ebx
c002de5b:	83 ec 04             	sub    $0x4,%esp
c002de5e:	e8 d1 35 00 00       	call   c0031434 <__x86.get_pc_thunk.cx>
c002de63:	81 c1 15 c5 00 00    	add    $0xc515,%ecx
  printf ("Console: %lld characters output\n", write_cnt);
c002de69:	8b 81 90 22 00 00    	mov    0x2290(%ecx),%eax
c002de6f:	8b 91 94 22 00 00    	mov    0x2294(%ecx),%edx
c002de75:	83 ec 04             	sub    $0x4,%esp
c002de78:	52                   	push   %edx
c002de79:	50                   	push   %eax
c002de7a:	8d 81 0c 9c ff ff    	lea    -0x63f4(%ecx),%eax
c002de80:	50                   	push   %eax
c002de81:	89 cb                	mov    %ecx,%ebx
c002de83:	e8 5d b0 ff ff       	call   c0028ee5 <printf>
c002de88:	83 c4 10             	add    $0x10,%esp
}
c002de8b:	90                   	nop
c002de8c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002de8f:	c9                   	leave  
c002de90:	c3                   	ret    

c002de91 <acquire_console>:

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c002de91:	55                   	push   %ebp
c002de92:	89 e5                	mov    %esp,%ebp
c002de94:	53                   	push   %ebx
c002de95:	83 ec 04             	sub    $0x4,%esp
c002de98:	e8 8f 35 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002de9d:	81 c3 db c4 00 00    	add    $0xc4db,%ebx
  if (!intr_context () && use_console_lock) 
c002dea3:	e8 9c 43 ff ff       	call   c0022244 <intr_context>
c002dea8:	83 f0 01             	xor    $0x1,%eax
c002deab:	84 c0                	test   %al,%al
c002dead:	74 44                	je     c002def3 <acquire_console+0x62>
c002deaf:	0f b6 83 88 22 00 00 	movzbl 0x2288(%ebx),%eax
c002deb6:	84 c0                	test   %al,%al
c002deb8:	74 39                	je     c002def3 <acquire_console+0x62>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c002deba:	83 ec 0c             	sub    $0xc,%esp
c002debd:	8d 83 70 22 00 00    	lea    0x2270(%ebx),%eax
c002dec3:	50                   	push   %eax
c002dec4:	e8 1e 5e ff ff       	call   c0023ce7 <lock_held_by_current_thread>
c002dec9:	83 c4 10             	add    $0x10,%esp
c002decc:	84 c0                	test   %al,%al
c002dece:	74 11                	je     c002dee1 <acquire_console+0x50>
        console_lock_depth++; 
c002ded0:	8b 83 8c 22 00 00    	mov    0x228c(%ebx),%eax
c002ded6:	83 c0 01             	add    $0x1,%eax
c002ded9:	89 83 8c 22 00 00    	mov    %eax,0x228c(%ebx)
      else
        lock_acquire (&console_lock); 
    }
}
c002dedf:	eb 12                	jmp    c002def3 <acquire_console+0x62>
        lock_acquire (&console_lock); 
c002dee1:	83 ec 0c             	sub    $0xc,%esp
c002dee4:	8d 83 70 22 00 00    	lea    0x2270(%ebx),%eax
c002deea:	50                   	push   %eax
c002deeb:	e8 47 59 ff ff       	call   c0023837 <lock_acquire>
c002def0:	83 c4 10             	add    $0x10,%esp
}
c002def3:	90                   	nop
c002def4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002def7:	c9                   	leave  
c002def8:	c3                   	ret    

c002def9 <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c002def9:	55                   	push   %ebp
c002defa:	89 e5                	mov    %esp,%ebp
c002defc:	53                   	push   %ebx
c002defd:	83 ec 04             	sub    $0x4,%esp
c002df00:	e8 27 35 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002df05:	81 c3 73 c4 00 00    	add    $0xc473,%ebx
  if (!intr_context () && use_console_lock) 
c002df0b:	e8 34 43 ff ff       	call   c0022244 <intr_context>
c002df10:	83 f0 01             	xor    $0x1,%eax
c002df13:	84 c0                	test   %al,%al
c002df15:	74 38                	je     c002df4f <release_console+0x56>
c002df17:	0f b6 83 88 22 00 00 	movzbl 0x2288(%ebx),%eax
c002df1e:	84 c0                	test   %al,%al
c002df20:	74 2d                	je     c002df4f <release_console+0x56>
    {
      if (console_lock_depth > 0)
c002df22:	8b 83 8c 22 00 00    	mov    0x228c(%ebx),%eax
c002df28:	85 c0                	test   %eax,%eax
c002df2a:	7e 11                	jle    c002df3d <release_console+0x44>
        console_lock_depth--;
c002df2c:	8b 83 8c 22 00 00    	mov    0x228c(%ebx),%eax
c002df32:	83 e8 01             	sub    $0x1,%eax
c002df35:	89 83 8c 22 00 00    	mov    %eax,0x228c(%ebx)
      else
        lock_release (&console_lock); 
    }
}
c002df3b:	eb 12                	jmp    c002df4f <release_console+0x56>
        lock_release (&console_lock); 
c002df3d:	83 ec 0c             	sub    $0xc,%esp
c002df40:	8d 83 70 22 00 00    	lea    0x2270(%ebx),%eax
c002df46:	50                   	push   %eax
c002df47:	e8 99 5b ff ff       	call   c0023ae5 <lock_release>
c002df4c:	83 c4 10             	add    $0x10,%esp
}
c002df4f:	90                   	nop
c002df50:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002df53:	c9                   	leave  
c002df54:	c3                   	ret    

c002df55 <console_locked_by_current_thread>:

/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
c002df55:	55                   	push   %ebp
c002df56:	89 e5                	mov    %esp,%ebp
c002df58:	53                   	push   %ebx
c002df59:	83 ec 04             	sub    $0x4,%esp
c002df5c:	e8 cb 34 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002df61:	81 c3 17 c4 00 00    	add    $0xc417,%ebx
  return (intr_context ()
c002df67:	e8 d8 42 ff ff       	call   c0022244 <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c002df6c:	84 c0                	test   %al,%al
c002df6e:	75 24                	jne    c002df94 <console_locked_by_current_thread+0x3f>
          || !use_console_lock
c002df70:	0f b6 83 88 22 00 00 	movzbl 0x2288(%ebx),%eax
c002df77:	83 f0 01             	xor    $0x1,%eax
c002df7a:	84 c0                	test   %al,%al
c002df7c:	75 16                	jne    c002df94 <console_locked_by_current_thread+0x3f>
          || lock_held_by_current_thread (&console_lock));
c002df7e:	83 ec 0c             	sub    $0xc,%esp
c002df81:	8d 83 70 22 00 00    	lea    0x2270(%ebx),%eax
c002df87:	50                   	push   %eax
c002df88:	e8 5a 5d ff ff       	call   c0023ce7 <lock_held_by_current_thread>
c002df8d:	83 c4 10             	add    $0x10,%esp
c002df90:	84 c0                	test   %al,%al
c002df92:	74 07                	je     c002df9b <console_locked_by_current_thread+0x46>
c002df94:	b8 01 00 00 00       	mov    $0x1,%eax
c002df99:	eb 05                	jmp    c002dfa0 <console_locked_by_current_thread+0x4b>
c002df9b:	b8 00 00 00 00       	mov    $0x0,%eax
c002dfa0:	83 e0 01             	and    $0x1,%eax
}
c002dfa3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dfa6:	c9                   	leave  
c002dfa7:	c3                   	ret    

c002dfa8 <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c002dfa8:	55                   	push   %ebp
c002dfa9:	89 e5                	mov    %esp,%ebp
c002dfab:	53                   	push   %ebx
c002dfac:	83 ec 14             	sub    $0x14,%esp
c002dfaf:	e8 78 34 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002dfb4:	81 c3 c4 c3 00 00    	add    $0xc3c4,%ebx
  int char_cnt = 0;
c002dfba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  acquire_console ();
c002dfc1:	e8 cb fe ff ff       	call   c002de91 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002dfc6:	8d 45 f4             	lea    -0xc(%ebp),%eax
c002dfc9:	50                   	push   %eax
c002dfca:	8d 83 41 3d ff ff    	lea    -0xc2bf(%ebx),%eax
c002dfd0:	50                   	push   %eax
c002dfd1:	ff 75 0c             	push   0xc(%ebp)
c002dfd4:	ff 75 08             	push   0x8(%ebp)
c002dfd7:	e8 3f af ff ff       	call   c0028f1b <__vprintf>
c002dfdc:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002dfdf:	e8 15 ff ff ff       	call   c002def9 <release_console>

  return char_cnt;
c002dfe4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002dfe7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dfea:	c9                   	leave  
c002dfeb:	c3                   	ret    

c002dfec <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c002dfec:	55                   	push   %ebp
c002dfed:	89 e5                	mov    %esp,%ebp
c002dfef:	83 ec 08             	sub    $0x8,%esp
c002dff2:	e8 31 34 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002dff7:	05 81 c3 00 00       	add    $0xc381,%eax
  acquire_console ();
c002dffc:	e8 90 fe ff ff       	call   c002de91 <acquire_console>
  while (*s != '\0')
c002e001:	eb 1b                	jmp    c002e01e <puts+0x32>
    putchar_have_lock (*s++);
c002e003:	8b 45 08             	mov    0x8(%ebp),%eax
c002e006:	8d 50 01             	lea    0x1(%eax),%edx
c002e009:	89 55 08             	mov    %edx,0x8(%ebp)
c002e00c:	0f b6 00             	movzbl (%eax),%eax
c002e00f:	0f b6 c0             	movzbl %al,%eax
c002e012:	83 ec 0c             	sub    $0xc,%esp
c002e015:	50                   	push   %eax
c002e016:	e8 dd 00 00 00       	call   c002e0f8 <putchar_have_lock>
c002e01b:	83 c4 10             	add    $0x10,%esp
  while (*s != '\0')
c002e01e:	8b 45 08             	mov    0x8(%ebp),%eax
c002e021:	0f b6 00             	movzbl (%eax),%eax
c002e024:	84 c0                	test   %al,%al
c002e026:	75 db                	jne    c002e003 <puts+0x17>
  putchar_have_lock ('\n');
c002e028:	83 ec 0c             	sub    $0xc,%esp
c002e02b:	6a 0a                	push   $0xa
c002e02d:	e8 c6 00 00 00       	call   c002e0f8 <putchar_have_lock>
c002e032:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002e035:	e8 bf fe ff ff       	call   c002def9 <release_console>

  return 0;
c002e03a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002e03f:	c9                   	leave  
c002e040:	c3                   	ret    

c002e041 <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c002e041:	55                   	push   %ebp
c002e042:	89 e5                	mov    %esp,%ebp
c002e044:	83 ec 08             	sub    $0x8,%esp
c002e047:	e8 dc 33 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002e04c:	05 2c c3 00 00       	add    $0xc32c,%eax
  acquire_console ();
c002e051:	e8 3b fe ff ff       	call   c002de91 <acquire_console>
  while (n-- > 0)
c002e056:	eb 1b                	jmp    c002e073 <putbuf+0x32>
    putchar_have_lock (*buffer++);
c002e058:	8b 45 08             	mov    0x8(%ebp),%eax
c002e05b:	8d 50 01             	lea    0x1(%eax),%edx
c002e05e:	89 55 08             	mov    %edx,0x8(%ebp)
c002e061:	0f b6 00             	movzbl (%eax),%eax
c002e064:	0f b6 c0             	movzbl %al,%eax
c002e067:	83 ec 0c             	sub    $0xc,%esp
c002e06a:	50                   	push   %eax
c002e06b:	e8 88 00 00 00       	call   c002e0f8 <putchar_have_lock>
c002e070:	83 c4 10             	add    $0x10,%esp
  while (n-- > 0)
c002e073:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e076:	8d 50 ff             	lea    -0x1(%eax),%edx
c002e079:	89 55 0c             	mov    %edx,0xc(%ebp)
c002e07c:	85 c0                	test   %eax,%eax
c002e07e:	75 d8                	jne    c002e058 <putbuf+0x17>
  release_console ();
c002e080:	e8 74 fe ff ff       	call   c002def9 <release_console>
}
c002e085:	90                   	nop
c002e086:	c9                   	leave  
c002e087:	c3                   	ret    

c002e088 <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c002e088:	55                   	push   %ebp
c002e089:	89 e5                	mov    %esp,%ebp
c002e08b:	83 ec 08             	sub    $0x8,%esp
c002e08e:	e8 95 33 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002e093:	05 e5 c2 00 00       	add    $0xc2e5,%eax
  acquire_console ();
c002e098:	e8 f4 fd ff ff       	call   c002de91 <acquire_console>
  putchar_have_lock (c);
c002e09d:	8b 45 08             	mov    0x8(%ebp),%eax
c002e0a0:	0f b6 c0             	movzbl %al,%eax
c002e0a3:	83 ec 0c             	sub    $0xc,%esp
c002e0a6:	50                   	push   %eax
c002e0a7:	e8 4c 00 00 00       	call   c002e0f8 <putchar_have_lock>
c002e0ac:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002e0af:	e8 45 fe ff ff       	call   c002def9 <release_console>
  
  return c;
c002e0b4:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002e0b7:	c9                   	leave  
c002e0b8:	c3                   	ret    

c002e0b9 <vprintf_helper>:

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c002e0b9:	55                   	push   %ebp
c002e0ba:	89 e5                	mov    %esp,%ebp
c002e0bc:	83 ec 28             	sub    $0x28,%esp
c002e0bf:	e8 64 33 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002e0c4:	05 b4 c2 00 00       	add    $0xc2b4,%eax
c002e0c9:	8b 45 08             	mov    0x8(%ebp),%eax
c002e0cc:	88 45 e4             	mov    %al,-0x1c(%ebp)
  int *char_cnt = char_cnt_;
c002e0cf:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e0d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  (*char_cnt)++;
c002e0d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e0d8:	8b 00                	mov    (%eax),%eax
c002e0da:	8d 50 01             	lea    0x1(%eax),%edx
c002e0dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e0e0:	89 10                	mov    %edx,(%eax)
  putchar_have_lock (c);
c002e0e2:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002e0e6:	0f b6 c0             	movzbl %al,%eax
c002e0e9:	83 ec 0c             	sub    $0xc,%esp
c002e0ec:	50                   	push   %eax
c002e0ed:	e8 06 00 00 00       	call   c002e0f8 <putchar_have_lock>
c002e0f2:	83 c4 10             	add    $0x10,%esp
}
c002e0f5:	90                   	nop
c002e0f6:	c9                   	leave  
c002e0f7:	c3                   	ret    

c002e0f8 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002e0f8:	55                   	push   %ebp
c002e0f9:	89 e5                	mov    %esp,%ebp
c002e0fb:	53                   	push   %ebx
c002e0fc:	83 ec 14             	sub    $0x14,%esp
c002e0ff:	e8 28 33 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002e104:	81 c3 74 c2 00 00    	add    $0xc274,%ebx
c002e10a:	8b 45 08             	mov    0x8(%ebp),%eax
c002e10d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (console_locked_by_current_thread ());
c002e110:	e8 40 fe ff ff       	call   c002df55 <console_locked_by_current_thread>
c002e115:	84 c0                	test   %al,%al
c002e117:	75 29                	jne    c002e142 <putchar_have_lock+0x4a>
c002e119:	83 ec 0c             	sub    $0xc,%esp
c002e11c:	8d 83 30 9c ff ff    	lea    -0x63d0(%ebx),%eax
c002e122:	50                   	push   %eax
c002e123:	8d 83 54 9c ff ff    	lea    -0x63ac(%ebx),%eax
c002e129:	50                   	push   %eax
c002e12a:	8d 83 88 9c ff ff    	lea    -0x6378(%ebx),%eax
c002e130:	50                   	push   %eax
c002e131:	68 bb 00 00 00       	push   $0xbb
c002e136:	8d 83 6b 9c ff ff    	lea    -0x6395(%ebx),%eax
c002e13c:	50                   	push   %eax
c002e13d:	e8 22 d6 ff ff       	call   c002b764 <debug_panic>
  write_cnt++;
c002e142:	8b 83 90 22 00 00    	mov    0x2290(%ebx),%eax
c002e148:	8b 93 94 22 00 00    	mov    0x2294(%ebx),%edx
c002e14e:	83 c0 01             	add    $0x1,%eax
c002e151:	83 d2 00             	adc    $0x0,%edx
c002e154:	89 83 90 22 00 00    	mov    %eax,0x2290(%ebx)
c002e15a:	89 93 94 22 00 00    	mov    %edx,0x2294(%ebx)
  serial_putc (c);
c002e160:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002e164:	83 ec 0c             	sub    $0xc,%esp
c002e167:	50                   	push   %eax
c002e168:	e8 57 7f ff ff       	call   c00260c4 <serial_putc>
c002e16d:	83 c4 10             	add    $0x10,%esp
  vga_putc (c);
c002e170:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002e174:	83 ec 0c             	sub    $0xc,%esp
c002e177:	50                   	push   %eax
c002e178:	e8 23 7a ff ff       	call   c0025ba0 <vga_putc>
c002e17d:	83 c4 10             	add    $0x10,%esp
}
c002e180:	90                   	nop
c002e181:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e184:	c9                   	leave  
c002e185:	c3                   	ret    

c002e186 <run_test>:
static const char *test_name;

/* Runs the test named NAME. */
void
run_test (const char *name) 
{
c002e186:	55                   	push   %ebp
c002e187:	89 e5                	mov    %esp,%ebp
c002e189:	53                   	push   %ebx
c002e18a:	83 ec 14             	sub    $0x14,%esp
c002e18d:	e8 9a 32 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002e192:	81 c3 e6 c1 00 00    	add    $0xc1e6,%ebx
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002e198:	8d 83 48 06 00 00    	lea    0x648(%ebx),%eax
c002e19e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002e1a1:	eb 53                	jmp    c002e1f6 <run_test+0x70>
    if (!strcmp (name, t->name))
c002e1a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e1a6:	8b 00                	mov    (%eax),%eax
c002e1a8:	83 ec 08             	sub    $0x8,%esp
c002e1ab:	50                   	push   %eax
c002e1ac:	ff 75 08             	push   0x8(%ebp)
c002e1af:	e8 92 c3 ff ff       	call   c002a546 <strcmp>
c002e1b4:	83 c4 10             	add    $0x10,%esp
c002e1b7:	85 c0                	test   %eax,%eax
c002e1b9:	75 37                	jne    c002e1f2 <run_test+0x6c>
      {
        test_name = name;
c002e1bb:	8b 45 08             	mov    0x8(%ebp),%eax
c002e1be:	89 83 98 22 00 00    	mov    %eax,0x2298(%ebx)
        msg ("begin");
c002e1c4:	83 ec 0c             	sub    $0xc,%esp
c002e1c7:	8d 83 5a 9e ff ff    	lea    -0x61a6(%ebx),%eax
c002e1cd:	50                   	push   %eax
c002e1ce:	e8 55 00 00 00       	call   c002e228 <msg>
c002e1d3:	83 c4 10             	add    $0x10,%esp
        t->function ();
c002e1d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e1d9:	8b 40 04             	mov    0x4(%eax),%eax
c002e1dc:	ff d0                	call   *%eax
        msg ("end");
c002e1de:	83 ec 0c             	sub    $0xc,%esp
c002e1e1:	8d 83 60 9e ff ff    	lea    -0x61a0(%ebx),%eax
c002e1e7:	50                   	push   %eax
c002e1e8:	e8 3b 00 00 00       	call   c002e228 <msg>
c002e1ed:	83 c4 10             	add    $0x10,%esp
        return;
c002e1f0:	eb 31                	jmp    c002e223 <run_test+0x9d>
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002e1f2:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
c002e1f6:	8d 83 20 07 00 00    	lea    0x720(%ebx),%eax
c002e1fc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002e1ff:	72 a2                	jb     c002e1a3 <run_test+0x1d>
      }
  PANIC ("no test named \"%s\"", name);
c002e201:	83 ec 0c             	sub    $0xc,%esp
c002e204:	ff 75 08             	push   0x8(%ebp)
c002e207:	8d 83 64 9e ff ff    	lea    -0x619c(%ebx),%eax
c002e20d:	50                   	push   %eax
c002e20e:	8d 83 bc 9e ff ff    	lea    -0x6144(%ebx),%eax
c002e214:	50                   	push   %eax
c002e215:	6a 3c                	push   $0x3c
c002e217:	8d 83 77 9e ff ff    	lea    -0x6189(%ebx),%eax
c002e21d:	50                   	push   %eax
c002e21e:	e8 41 d5 ff ff       	call   c002b764 <debug_panic>
}
c002e223:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e226:	c9                   	leave  
c002e227:	c3                   	ret    

c002e228 <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c002e228:	55                   	push   %ebp
c002e229:	89 e5                	mov    %esp,%ebp
c002e22b:	53                   	push   %ebx
c002e22c:	83 ec 14             	sub    $0x14,%esp
c002e22f:	e8 f8 31 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002e234:	81 c3 44 c1 00 00    	add    $0xc144,%ebx
  va_list args;
  
  printf ("(%s) ", test_name);
c002e23a:	8b 83 98 22 00 00    	mov    0x2298(%ebx),%eax
c002e240:	83 ec 08             	sub    $0x8,%esp
c002e243:	50                   	push   %eax
c002e244:	8d 83 93 9e ff ff    	lea    -0x616d(%ebx),%eax
c002e24a:	50                   	push   %eax
c002e24b:	e8 95 ac ff ff       	call   c0028ee5 <printf>
c002e250:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002e253:	8d 45 0c             	lea    0xc(%ebp),%eax
c002e256:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002e259:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e25c:	83 ec 08             	sub    $0x8,%esp
c002e25f:	50                   	push   %eax
c002e260:	ff 75 08             	push   0x8(%ebp)
c002e263:	e8 40 fd ff ff       	call   c002dfa8 <vprintf>
c002e268:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002e26b:	83 ec 0c             	sub    $0xc,%esp
c002e26e:	6a 0a                	push   $0xa
c002e270:	e8 13 fe ff ff       	call   c002e088 <putchar>
c002e275:	83 c4 10             	add    $0x10,%esp
}
c002e278:	90                   	nop
c002e279:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e27c:	c9                   	leave  
c002e27d:	c3                   	ret    

c002e27e <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002e27e:	55                   	push   %ebp
c002e27f:	89 e5                	mov    %esp,%ebp
c002e281:	53                   	push   %ebx
c002e282:	83 ec 14             	sub    $0x14,%esp
c002e285:	e8 a2 31 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002e28a:	81 c3 ee c0 00 00    	add    $0xc0ee,%ebx
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002e290:	8b 83 98 22 00 00    	mov    0x2298(%ebx),%eax
c002e296:	83 ec 08             	sub    $0x8,%esp
c002e299:	50                   	push   %eax
c002e29a:	8d 83 99 9e ff ff    	lea    -0x6167(%ebx),%eax
c002e2a0:	50                   	push   %eax
c002e2a1:	e8 3f ac ff ff       	call   c0028ee5 <printf>
c002e2a6:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002e2a9:	8d 45 0c             	lea    0xc(%ebp),%eax
c002e2ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002e2af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e2b2:	83 ec 08             	sub    $0x8,%esp
c002e2b5:	50                   	push   %eax
c002e2b6:	ff 75 08             	push   0x8(%ebp)
c002e2b9:	e8 ea fc ff ff       	call   c002dfa8 <vprintf>
c002e2be:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002e2c1:	83 ec 0c             	sub    $0xc,%esp
c002e2c4:	6a 0a                	push   $0xa
c002e2c6:	e8 bd fd ff ff       	call   c002e088 <putchar>
c002e2cb:	83 c4 10             	add    $0x10,%esp

  PANIC ("test failed");
c002e2ce:	8d 83 a5 9e ff ff    	lea    -0x615b(%ebx),%eax
c002e2d4:	50                   	push   %eax
c002e2d5:	8d 83 c8 9e ff ff    	lea    -0x6138(%ebx),%eax
c002e2db:	50                   	push   %eax
c002e2dc:	6a 5d                	push   $0x5d
c002e2de:	8d 83 77 9e ff ff    	lea    -0x6189(%ebx),%eax
c002e2e4:	50                   	push   %eax
c002e2e5:	e8 7a d4 ff ff       	call   c002b764 <debug_panic>

c002e2ea <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c002e2ea:	55                   	push   %ebp
c002e2eb:	89 e5                	mov    %esp,%ebp
c002e2ed:	53                   	push   %ebx
c002e2ee:	83 ec 04             	sub    $0x4,%esp
c002e2f1:	e8 32 31 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002e2f6:	05 82 c0 00 00       	add    $0xc082,%eax
  printf ("(%s) PASS\n", test_name);
c002e2fb:	8b 90 98 22 00 00    	mov    0x2298(%eax),%edx
c002e301:	83 ec 08             	sub    $0x8,%esp
c002e304:	52                   	push   %edx
c002e305:	8d 90 b1 9e ff ff    	lea    -0x614f(%eax),%edx
c002e30b:	52                   	push   %edx
c002e30c:	89 c3                	mov    %eax,%ebx
c002e30e:	e8 d2 ab ff ff       	call   c0028ee5 <printf>
c002e313:	83 c4 10             	add    $0x10,%esp
}
c002e316:	90                   	nop
c002e317:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e31a:	c9                   	leave  
c002e31b:	c3                   	ret    

c002e31c <test_alarm_single>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_single (void) 
{
c002e31c:	55                   	push   %ebp
c002e31d:	89 e5                	mov    %esp,%ebp
c002e31f:	83 ec 08             	sub    $0x8,%esp
c002e322:	e8 01 31 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002e327:	05 51 c0 00 00       	add    $0xc051,%eax
  test_sleep (5, 1);
c002e32c:	83 ec 08             	sub    $0x8,%esp
c002e32f:	6a 01                	push   $0x1
c002e331:	6a 05                	push   $0x5
c002e333:	e8 28 00 00 00       	call   c002e360 <test_sleep>
c002e338:	83 c4 10             	add    $0x10,%esp
}
c002e33b:	90                   	nop
c002e33c:	c9                   	leave  
c002e33d:	c3                   	ret    

c002e33e <test_alarm_multiple>:

void
test_alarm_multiple (void) 
{
c002e33e:	55                   	push   %ebp
c002e33f:	89 e5                	mov    %esp,%ebp
c002e341:	83 ec 08             	sub    $0x8,%esp
c002e344:	e8 df 30 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002e349:	05 2f c0 00 00       	add    $0xc02f,%eax
  test_sleep (5, 7);
c002e34e:	83 ec 08             	sub    $0x8,%esp
c002e351:	6a 07                	push   $0x7
c002e353:	6a 05                	push   $0x5
c002e355:	e8 06 00 00 00       	call   c002e360 <test_sleep>
c002e35a:	83 c4 10             	add    $0x10,%esp
}
c002e35d:	90                   	nop
c002e35e:	c9                   	leave  
c002e35f:	c3                   	ret    

c002e360 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002e360:	55                   	push   %ebp
c002e361:	89 e5                	mov    %esp,%ebp
c002e363:	53                   	push   %ebx
c002e364:	83 ec 64             	sub    $0x64,%esp
c002e367:	e8 c0 30 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002e36c:	81 c3 0c c0 00 00    	add    $0xc00c,%ebx
  int *output, *op;
  int product;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002e372:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002e378:	0f b6 00             	movzbl (%eax),%eax
c002e37b:	83 f0 01             	xor    $0x1,%eax
c002e37e:	84 c0                	test   %al,%al
c002e380:	75 26                	jne    c002e3a8 <test_sleep+0x48>
c002e382:	83 ec 0c             	sub    $0xc,%esp
c002e385:	8d 83 d0 9e ff ff    	lea    -0x6130(%ebx),%eax
c002e38b:	50                   	push   %eax
c002e38c:	8d 83 de 9e ff ff    	lea    -0x6122(%ebx),%eax
c002e392:	50                   	push   %eax
c002e393:	8d 83 e4 a0 ff ff    	lea    -0x5f1c(%ebx),%eax
c002e399:	50                   	push   %eax
c002e39a:	6a 3c                	push   $0x3c
c002e39c:	8d 83 f8 9e ff ff    	lea    -0x6108(%ebx),%eax
c002e3a2:	50                   	push   %eax
c002e3a3:	e8 bc d3 ff ff       	call   c002b764 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002e3a8:	83 ec 04             	sub    $0x4,%esp
c002e3ab:	ff 75 0c             	push   0xc(%ebp)
c002e3ae:	ff 75 08             	push   0x8(%ebp)
c002e3b1:	8d 83 1c 9f ff ff    	lea    -0x60e4(%ebx),%eax
c002e3b7:	50                   	push   %eax
c002e3b8:	e8 6b fe ff ff       	call   c002e228 <msg>
c002e3bd:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 0 sleeps 10 ticks each time,");
c002e3c0:	83 ec 0c             	sub    $0xc,%esp
c002e3c3:	8d 83 48 9f ff ff    	lea    -0x60b8(%ebx),%eax
c002e3c9:	50                   	push   %eax
c002e3ca:	e8 59 fe ff ff       	call   c002e228 <msg>
c002e3cf:	83 c4 10             	add    $0x10,%esp
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c002e3d2:	83 ec 0c             	sub    $0xc,%esp
c002e3d5:	8d 83 6c 9f ff ff    	lea    -0x6094(%ebx),%eax
c002e3db:	50                   	push   %eax
c002e3dc:	e8 47 fe ff ff       	call   c002e228 <msg>
c002e3e1:	83 c4 10             	add    $0x10,%esp
  msg ("If successful, product of iteration count and");
c002e3e4:	83 ec 0c             	sub    $0xc,%esp
c002e3e7:	8d 83 9c 9f ff ff    	lea    -0x6064(%ebx),%eax
c002e3ed:	50                   	push   %eax
c002e3ee:	e8 35 fe ff ff       	call   c002e228 <msg>
c002e3f3:	83 c4 10             	add    $0x10,%esp
  msg ("sleep duration will appear in nondescending order.");
c002e3f6:	83 ec 0c             	sub    $0xc,%esp
c002e3f9:	8d 83 cc 9f ff ff    	lea    -0x6034(%ebx),%eax
c002e3ff:	50                   	push   %eax
c002e400:	e8 23 fe ff ff       	call   c002e228 <msg>
c002e405:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  threads = malloc (sizeof *threads * thread_cnt);
c002e408:	8b 45 08             	mov    0x8(%ebp),%eax
c002e40b:	c1 e0 04             	shl    $0x4,%eax
c002e40e:	83 ec 0c             	sub    $0xc,%esp
c002e411:	50                   	push   %eax
c002e412:	e8 fc 62 ff ff       	call   c0024713 <malloc>
c002e417:	83 c4 10             	add    $0x10,%esp
c002e41a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002e41d:	8b 55 0c             	mov    0xc(%ebp),%edx
c002e420:	8b 45 08             	mov    0x8(%ebp),%eax
c002e423:	0f af c2             	imul   %edx,%eax
c002e426:	c1 e0 03             	shl    $0x3,%eax
c002e429:	83 ec 0c             	sub    $0xc,%esp
c002e42c:	50                   	push   %eax
c002e42d:	e8 e1 62 ff ff       	call   c0024713 <malloc>
c002e432:	83 c4 10             	add    $0x10,%esp
c002e435:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (threads == NULL || output == NULL)
c002e438:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002e43c:	74 06                	je     c002e444 <test_sleep+0xe4>
c002e43e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002e442:	75 1c                	jne    c002e460 <test_sleep+0x100>
    PANIC ("couldn't allocate memory for test");
c002e444:	8d 83 00 a0 ff ff    	lea    -0x6000(%ebx),%eax
c002e44a:	50                   	push   %eax
c002e44b:	8d 83 e4 a0 ff ff    	lea    -0x5f1c(%ebx),%eax
c002e451:	50                   	push   %eax
c002e452:	6a 48                	push   $0x48
c002e454:	8d 83 f8 9e ff ff    	lea    -0x6108(%ebx),%eax
c002e45a:	50                   	push   %eax
c002e45b:	e8 04 d3 ff ff       	call   c002b764 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002e460:	e8 2a 6c ff ff       	call   c002508f <timer_ticks>
c002e465:	83 c0 64             	add    $0x64,%eax
c002e468:	83 d2 00             	adc    $0x0,%edx
c002e46b:	89 45 b0             	mov    %eax,-0x50(%ebp)
c002e46e:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  test.iterations = iterations;
c002e471:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e474:	89 45 b8             	mov    %eax,-0x48(%ebp)
  lock_init (&test.output_lock);
c002e477:	83 ec 0c             	sub    $0xc,%esp
c002e47a:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002e47d:	83 c0 0c             	add    $0xc,%eax
c002e480:	50                   	push   %eax
c002e481:	e8 4c 53 ff ff       	call   c00237d2 <lock_init>
c002e486:	83 c4 10             	add    $0x10,%esp
  test.output_pos = output;
c002e489:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e48c:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002e48f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002e493:	75 26                	jne    c002e4bb <test_sleep+0x15b>
c002e495:	83 ec 0c             	sub    $0xc,%esp
c002e498:	8d 83 22 a0 ff ff    	lea    -0x5fde(%ebx),%eax
c002e49e:	50                   	push   %eax
c002e49f:	8d 83 de 9e ff ff    	lea    -0x6122(%ebx),%eax
c002e4a5:	50                   	push   %eax
c002e4a6:	8d 83 e4 a0 ff ff    	lea    -0x5f1c(%ebx),%eax
c002e4ac:	50                   	push   %eax
c002e4ad:	6a 51                	push   $0x51
c002e4af:	8d 83 f8 9e ff ff    	lea    -0x6108(%ebx),%eax
c002e4b5:	50                   	push   %eax
c002e4b6:	e8 a9 d2 ff ff       	call   c002b764 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002e4bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002e4c2:	eb 76                	jmp    c002e53a <test_sleep+0x1da>
    {
      struct sleep_thread *t = threads + i;
c002e4c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e4c7:	c1 e0 04             	shl    $0x4,%eax
c002e4ca:	89 c2                	mov    %eax,%edx
c002e4cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e4cf:	01 d0                	add    %edx,%eax
c002e4d1:	89 45 d8             	mov    %eax,-0x28(%ebp)
      char name[16];
      
      t->test = &test;
c002e4d4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002e4d7:	8d 55 b0             	lea    -0x50(%ebp),%edx
c002e4da:	89 10                	mov    %edx,(%eax)
      t->id = i;
c002e4dc:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002e4df:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002e4e2:	89 50 04             	mov    %edx,0x4(%eax)
      t->duration = (i + 1) * 10;
c002e4e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e4e8:	8d 50 01             	lea    0x1(%eax),%edx
c002e4eb:	89 d0                	mov    %edx,%eax
c002e4ed:	c1 e0 02             	shl    $0x2,%eax
c002e4f0:	01 d0                	add    %edx,%eax
c002e4f2:	01 c0                	add    %eax,%eax
c002e4f4:	89 c2                	mov    %eax,%edx
c002e4f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002e4f9:	89 50 08             	mov    %edx,0x8(%eax)
      t->iterations = 0;
c002e4fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002e4ff:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

      snprintf (name, sizeof name, "thread %d", i);
c002e506:	ff 75 ec             	push   -0x14(%ebp)
c002e509:	8d 83 31 a0 ff ff    	lea    -0x5fcf(%ebx),%eax
c002e50f:	50                   	push   %eax
c002e510:	6a 10                	push   $0x10
c002e512:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002e515:	50                   	push   %eax
c002e516:	e8 97 a9 ff ff       	call   c0028eb2 <snprintf>
c002e51b:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002e51e:	ff 75 d8             	push   -0x28(%ebp)
c002e521:	8d 83 69 43 ff ff    	lea    -0xbc97(%ebx),%eax
c002e527:	50                   	push   %eax
c002e528:	6a 1f                	push   $0x1f
c002e52a:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002e52d:	50                   	push   %eax
c002e52e:	e8 71 2b ff ff       	call   c00210a4 <thread_create>
c002e533:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002e536:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002e53a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e53d:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e540:	7c 82                	jl     c002e4c4 <test_sleep+0x164>
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002e542:	8b 45 08             	mov    0x8(%ebp),%eax
c002e545:	0f af 45 0c          	imul   0xc(%ebp),%eax
c002e549:	89 c2                	mov    %eax,%edx
c002e54b:	89 d0                	mov    %edx,%eax
c002e54d:	c1 e0 02             	shl    $0x2,%eax
c002e550:	01 d0                	add    %edx,%eax
c002e552:	01 c0                	add    %eax,%eax
c002e554:	05 c8 00 00 00       	add    $0xc8,%eax
c002e559:	99                   	cltd   
c002e55a:	83 ec 08             	sub    $0x8,%esp
c002e55d:	52                   	push   %edx
c002e55e:	50                   	push   %eax
c002e55f:	e8 99 6b ff ff       	call   c00250fd <timer_sleep>
c002e564:	83 c4 10             	add    $0x10,%esp

  /* Acquire the output lock in case some rogue thread is still
     running. */
  lock_acquire (&test.output_lock);
c002e567:	83 ec 0c             	sub    $0xc,%esp
c002e56a:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002e56d:	83 c0 0c             	add    $0xc,%eax
c002e570:	50                   	push   %eax
c002e571:	e8 c1 52 ff ff       	call   c0023837 <lock_acquire>
c002e576:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  product = 0;
c002e579:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (op = output; op < test.output_pos; op++) 
c002e580:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e583:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002e586:	e9 c6 00 00 00       	jmp    c002e651 <test_sleep+0x2f1>
    {
      struct sleep_thread *t;
      int new_prod;

      ASSERT (*op >= 0 && *op < thread_cnt);
c002e58b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e58e:	8b 00                	mov    (%eax),%eax
c002e590:	85 c0                	test   %eax,%eax
c002e592:	78 0a                	js     c002e59e <test_sleep+0x23e>
c002e594:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e597:	8b 00                	mov    (%eax),%eax
c002e599:	39 45 08             	cmp    %eax,0x8(%ebp)
c002e59c:	7f 26                	jg     c002e5c4 <test_sleep+0x264>
c002e59e:	83 ec 0c             	sub    $0xc,%esp
c002e5a1:	8d 83 3b a0 ff ff    	lea    -0x5fc5(%ebx),%eax
c002e5a7:	50                   	push   %eax
c002e5a8:	8d 83 de 9e ff ff    	lea    -0x6122(%ebx),%eax
c002e5ae:	50                   	push   %eax
c002e5af:	8d 83 e4 a0 ff ff    	lea    -0x5f1c(%ebx),%eax
c002e5b5:	50                   	push   %eax
c002e5b6:	6a 6e                	push   $0x6e
c002e5b8:	8d 83 f8 9e ff ff    	lea    -0x6108(%ebx),%eax
c002e5be:	50                   	push   %eax
c002e5bf:	e8 a0 d1 ff ff       	call   c002b764 <debug_panic>
      t = threads + *op;
c002e5c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e5c7:	8b 00                	mov    (%eax),%eax
c002e5c9:	c1 e0 04             	shl    $0x4,%eax
c002e5cc:	89 c2                	mov    %eax,%edx
c002e5ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e5d1:	01 d0                	add    %edx,%eax
c002e5d3:	89 45 e0             	mov    %eax,-0x20(%ebp)

      new_prod = ++t->iterations * t->duration;
c002e5d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e5d9:	8b 40 0c             	mov    0xc(%eax),%eax
c002e5dc:	8d 50 01             	lea    0x1(%eax),%edx
c002e5df:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e5e2:	89 50 0c             	mov    %edx,0xc(%eax)
c002e5e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e5e8:	8b 50 0c             	mov    0xc(%eax),%edx
c002e5eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e5ee:	8b 40 08             	mov    0x8(%eax),%eax
c002e5f1:	0f af c2             	imul   %edx,%eax
c002e5f4:	89 45 dc             	mov    %eax,-0x24(%ebp)
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002e5f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e5fa:	8b 48 0c             	mov    0xc(%eax),%ecx
c002e5fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e600:	8b 50 08             	mov    0x8(%eax),%edx
c002e603:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e606:	8b 40 04             	mov    0x4(%eax),%eax
c002e609:	83 ec 0c             	sub    $0xc,%esp
c002e60c:	ff 75 dc             	push   -0x24(%ebp)
c002e60f:	51                   	push   %ecx
c002e610:	52                   	push   %edx
c002e611:	50                   	push   %eax
c002e612:	8d 83 58 a0 ff ff    	lea    -0x5fa8(%ebx),%eax
c002e618:	50                   	push   %eax
c002e619:	e8 0a fc ff ff       	call   c002e228 <msg>
c002e61e:	83 c4 20             	add    $0x20,%esp
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
c002e621:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e624:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002e627:	7c 08                	jl     c002e631 <test_sleep+0x2d1>
        product = new_prod;
c002e629:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e62c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e62f:	eb 1c                	jmp    c002e64d <test_sleep+0x2ed>
      else
        fail ("thread %d woke up out of order (%d > %d)!",
c002e631:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e634:	8b 40 04             	mov    0x4(%eax),%eax
c002e637:	ff 75 dc             	push   -0x24(%ebp)
c002e63a:	ff 75 f0             	push   -0x10(%ebp)
c002e63d:	50                   	push   %eax
c002e63e:	8d 83 8c a0 ff ff    	lea    -0x5f74(%ebx),%eax
c002e644:	50                   	push   %eax
c002e645:	e8 34 fc ff ff       	call   c002e27e <fail>
c002e64a:	83 c4 10             	add    $0x10,%esp
  for (op = output; op < test.output_pos; op++) 
c002e64d:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002e651:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e654:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002e657:	0f 82 2e ff ff ff    	jb     c002e58b <test_sleep+0x22b>
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002e65d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002e664:	eb 3f                	jmp    c002e6a5 <test_sleep+0x345>
    if (threads[i].iterations != iterations)
c002e666:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e669:	c1 e0 04             	shl    $0x4,%eax
c002e66c:	89 c2                	mov    %eax,%edx
c002e66e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e671:	01 d0                	add    %edx,%eax
c002e673:	8b 40 0c             	mov    0xc(%eax),%eax
c002e676:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002e679:	74 26                	je     c002e6a1 <test_sleep+0x341>
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
c002e67b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e67e:	c1 e0 04             	shl    $0x4,%eax
c002e681:	89 c2                	mov    %eax,%edx
c002e683:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e686:	01 d0                	add    %edx,%eax
      fail ("thread %d woke up %d times instead of %d",
c002e688:	8b 40 0c             	mov    0xc(%eax),%eax
c002e68b:	ff 75 0c             	push   0xc(%ebp)
c002e68e:	50                   	push   %eax
c002e68f:	ff 75 ec             	push   -0x14(%ebp)
c002e692:	8d 83 b8 a0 ff ff    	lea    -0x5f48(%ebx),%eax
c002e698:	50                   	push   %eax
c002e699:	e8 e0 fb ff ff       	call   c002e27e <fail>
c002e69e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002e6a1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002e6a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e6a8:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e6ab:	7c b9                	jl     c002e666 <test_sleep+0x306>
  
  lock_release (&test.output_lock);
c002e6ad:	83 ec 0c             	sub    $0xc,%esp
c002e6b0:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002e6b3:	83 c0 0c             	add    $0xc,%eax
c002e6b6:	50                   	push   %eax
c002e6b7:	e8 29 54 ff ff       	call   c0023ae5 <lock_release>
c002e6bc:	83 c4 10             	add    $0x10,%esp
  free (output);
c002e6bf:	83 ec 0c             	sub    $0xc,%esp
c002e6c2:	ff 75 e4             	push   -0x1c(%ebp)
c002e6c5:	e8 88 63 ff ff       	call   c0024a52 <free>
c002e6ca:	83 c4 10             	add    $0x10,%esp
  free (threads);
c002e6cd:	83 ec 0c             	sub    $0xc,%esp
c002e6d0:	ff 75 e8             	push   -0x18(%ebp)
c002e6d3:	e8 7a 63 ff ff       	call   c0024a52 <free>
c002e6d8:	83 c4 10             	add    $0x10,%esp
}
c002e6db:	90                   	nop
c002e6dc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e6df:	c9                   	leave  
c002e6e0:	c3                   	ret    

c002e6e1 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c002e6e1:	55                   	push   %ebp
c002e6e2:	89 e5                	mov    %esp,%ebp
c002e6e4:	57                   	push   %edi
c002e6e5:	56                   	push   %esi
c002e6e6:	53                   	push   %ebx
c002e6e7:	83 ec 2c             	sub    $0x2c,%esp
c002e6ea:	e8 3d 2d 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002e6ef:	81 c3 89 bc 00 00    	add    $0xbc89,%ebx
  struct sleep_thread *t = t_;
c002e6f5:	8b 45 08             	mov    0x8(%ebp),%eax
c002e6f8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  struct sleep_test *test = t->test;
c002e6fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e6fe:	8b 00                	mov    (%eax),%eax
c002e700:	89 45 dc             	mov    %eax,-0x24(%ebp)
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002e703:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
c002e70a:	eb 7c                	jmp    c002e788 <sleeper+0xa7>
    {
      int64_t sleep_until = test->start + i * t->duration;
c002e70c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e70f:	8b 30                	mov    (%eax),%esi
c002e711:	8b 78 04             	mov    0x4(%eax),%edi
c002e714:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e717:	8b 40 08             	mov    0x8(%eax),%eax
c002e71a:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
c002e71e:	99                   	cltd   
c002e71f:	01 f0                	add    %esi,%eax
c002e721:	11 fa                	adc    %edi,%edx
c002e723:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002e726:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002e729:	e8 61 69 ff ff       	call   c002508f <timer_ticks>
c002e72e:	89 c6                	mov    %eax,%esi
c002e730:	89 d7                	mov    %edx,%edi
c002e732:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e735:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e738:	29 f0                	sub    %esi,%eax
c002e73a:	19 fa                	sbb    %edi,%edx
c002e73c:	83 ec 08             	sub    $0x8,%esp
c002e73f:	52                   	push   %edx
c002e740:	50                   	push   %eax
c002e741:	e8 b7 69 ff ff       	call   c00250fd <timer_sleep>
c002e746:	83 c4 10             	add    $0x10,%esp
      lock_acquire (&test->output_lock);
c002e749:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e74c:	83 c0 0c             	add    $0xc,%eax
c002e74f:	83 ec 0c             	sub    $0xc,%esp
c002e752:	50                   	push   %eax
c002e753:	e8 df 50 ff ff       	call   c0023837 <lock_acquire>
c002e758:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = t->id;
c002e75b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e75e:	8b 40 24             	mov    0x24(%eax),%eax
c002e761:	8d 48 04             	lea    0x4(%eax),%ecx
c002e764:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002e767:	89 4a 24             	mov    %ecx,0x24(%edx)
c002e76a:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002e76d:	8b 52 04             	mov    0x4(%edx),%edx
c002e770:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c002e772:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e775:	83 c0 0c             	add    $0xc,%eax
c002e778:	83 ec 0c             	sub    $0xc,%esp
c002e77b:	50                   	push   %eax
c002e77c:	e8 64 53 ff ff       	call   c0023ae5 <lock_release>
c002e781:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i <= test->iterations; i++) 
c002e784:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c002e788:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e78b:	8b 40 08             	mov    0x8(%eax),%eax
c002e78e:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c002e791:	0f 8e 75 ff ff ff    	jle    c002e70c <sleeper+0x2b>
    }
}
c002e797:	90                   	nop
c002e798:	90                   	nop
c002e799:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002e79c:	5b                   	pop    %ebx
c002e79d:	5e                   	pop    %esi
c002e79e:	5f                   	pop    %edi
c002e79f:	5d                   	pop    %ebp
c002e7a0:	c3                   	ret    

c002e7a1 <test_alarm_simultaneous>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_simultaneous (void) 
{
c002e7a1:	55                   	push   %ebp
c002e7a2:	89 e5                	mov    %esp,%ebp
c002e7a4:	83 ec 08             	sub    $0x8,%esp
c002e7a7:	e8 7c 2c 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002e7ac:	05 cc bb 00 00       	add    $0xbbcc,%eax
  test_sleep (3, 5);
c002e7b1:	83 ec 08             	sub    $0x8,%esp
c002e7b4:	6a 05                	push   $0x5
c002e7b6:	6a 03                	push   $0x3
c002e7b8:	e8 06 00 00 00       	call   c002e7c3 <test_sleep>
c002e7bd:	83 c4 10             	add    $0x10,%esp
}
c002e7c0:	90                   	nop
c002e7c1:	c9                   	leave  
c002e7c2:	c3                   	ret    

c002e7c3 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002e7c3:	55                   	push   %ebp
c002e7c4:	89 e5                	mov    %esp,%ebp
c002e7c6:	56                   	push   %esi
c002e7c7:	53                   	push   %ebx
c002e7c8:	83 ec 30             	sub    $0x30,%esp
c002e7cb:	e8 5c 2c 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002e7d0:	81 c3 a8 bb 00 00    	add    $0xbba8,%ebx
  struct sleep_test test;
  int *output;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002e7d6:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002e7dc:	0f b6 00             	movzbl (%eax),%eax
c002e7df:	83 f0 01             	xor    $0x1,%eax
c002e7e2:	84 c0                	test   %al,%al
c002e7e4:	75 26                	jne    c002e80c <test_sleep+0x49>
c002e7e6:	83 ec 0c             	sub    $0xc,%esp
c002e7e9:	8d 83 f0 a0 ff ff    	lea    -0x5f10(%ebx),%eax
c002e7ef:	50                   	push   %eax
c002e7f0:	8d 83 fe a0 ff ff    	lea    -0x5f02(%ebx),%eax
c002e7f6:	50                   	push   %eax
c002e7f7:	8d 83 78 a2 ff ff    	lea    -0x5d88(%ebx),%eax
c002e7fd:	50                   	push   %eax
c002e7fe:	6a 28                	push   $0x28
c002e800:	8d 83 18 a1 ff ff    	lea    -0x5ee8(%ebx),%eax
c002e806:	50                   	push   %eax
c002e807:	e8 58 cf ff ff       	call   c002b764 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002e80c:	83 ec 04             	sub    $0x4,%esp
c002e80f:	ff 75 0c             	push   0xc(%ebp)
c002e812:	ff 75 08             	push   0x8(%ebp)
c002e815:	8d 83 44 a1 ff ff    	lea    -0x5ebc(%ebx),%eax
c002e81b:	50                   	push   %eax
c002e81c:	e8 07 fa ff ff       	call   c002e228 <msg>
c002e821:	83 c4 10             	add    $0x10,%esp
  msg ("Each thread sleeps 10 ticks each time.");
c002e824:	83 ec 0c             	sub    $0xc,%esp
c002e827:	8d 83 70 a1 ff ff    	lea    -0x5e90(%ebx),%eax
c002e82d:	50                   	push   %eax
c002e82e:	e8 f5 f9 ff ff       	call   c002e228 <msg>
c002e833:	83 c4 10             	add    $0x10,%esp
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002e836:	83 ec 0c             	sub    $0xc,%esp
c002e839:	8d 83 98 a1 ff ff    	lea    -0x5e68(%ebx),%eax
c002e83f:	50                   	push   %eax
c002e840:	e8 e3 f9 ff ff       	call   c002e228 <msg>
c002e845:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002e848:	8b 55 0c             	mov    0xc(%ebp),%edx
c002e84b:	8b 45 08             	mov    0x8(%ebp),%eax
c002e84e:	0f af c2             	imul   %edx,%eax
c002e851:	c1 e0 03             	shl    $0x3,%eax
c002e854:	83 ec 0c             	sub    $0xc,%esp
c002e857:	50                   	push   %eax
c002e858:	e8 b6 5e ff ff       	call   c0024713 <malloc>
c002e85d:	83 c4 10             	add    $0x10,%esp
c002e860:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (output == NULL)
c002e863:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002e867:	75 1c                	jne    c002e885 <test_sleep+0xc2>
    PANIC ("couldn't allocate memory for test");
c002e869:	8d 83 dc a1 ff ff    	lea    -0x5e24(%ebx),%eax
c002e86f:	50                   	push   %eax
c002e870:	8d 83 78 a2 ff ff    	lea    -0x5d88(%ebx),%eax
c002e876:	50                   	push   %eax
c002e877:	6a 31                	push   $0x31
c002e879:	8d 83 18 a1 ff ff    	lea    -0x5ee8(%ebx),%eax
c002e87f:	50                   	push   %eax
c002e880:	e8 df ce ff ff       	call   c002b764 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002e885:	e8 05 68 ff ff       	call   c002508f <timer_ticks>
c002e88a:	83 c0 64             	add    $0x64,%eax
c002e88d:	83 d2 00             	adc    $0x0,%edx
c002e890:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002e893:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  test.iterations = iterations;
c002e896:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e899:	89 45 e8             	mov    %eax,-0x18(%ebp)
  test.output_pos = output;
c002e89c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e89f:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002e8a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002e8a6:	75 26                	jne    c002e8ce <test_sleep+0x10b>
c002e8a8:	83 ec 0c             	sub    $0xc,%esp
c002e8ab:	8d 83 fe a1 ff ff    	lea    -0x5e02(%ebx),%eax
c002e8b1:	50                   	push   %eax
c002e8b2:	8d 83 fe a0 ff ff    	lea    -0x5f02(%ebx),%eax
c002e8b8:	50                   	push   %eax
c002e8b9:	8d 83 78 a2 ff ff    	lea    -0x5d88(%ebx),%eax
c002e8bf:	50                   	push   %eax
c002e8c0:	6a 39                	push   $0x39
c002e8c2:	8d 83 18 a1 ff ff    	lea    -0x5ee8(%ebx),%eax
c002e8c8:	50                   	push   %eax
c002e8c9:	e8 96 ce ff ff       	call   c002b764 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002e8ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002e8d5:	eb 35                	jmp    c002e90c <test_sleep+0x149>
    {
      char name[16];
      snprintf (name, sizeof name, "thread %d", i);
c002e8d7:	ff 75 f4             	push   -0xc(%ebp)
c002e8da:	8d 83 0d a2 ff ff    	lea    -0x5df3(%ebx),%eax
c002e8e0:	50                   	push   %eax
c002e8e1:	6a 10                	push   $0x10
c002e8e3:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002e8e6:	50                   	push   %eax
c002e8e7:	e8 c6 a5 ff ff       	call   c0028eb2 <snprintf>
c002e8ec:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002e8ef:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002e8f2:	50                   	push   %eax
c002e8f3:	8d 83 52 46 ff ff    	lea    -0xb9ae(%ebx),%eax
c002e8f9:	50                   	push   %eax
c002e8fa:	6a 1f                	push   $0x1f
c002e8fc:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002e8ff:	50                   	push   %eax
c002e900:	e8 9f 27 ff ff       	call   c00210a4 <thread_create>
c002e905:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002e908:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002e90c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e90f:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e912:	7c c3                	jl     c002e8d7 <test_sleep+0x114>
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);
c002e914:	8b 55 0c             	mov    0xc(%ebp),%edx
c002e917:	89 d0                	mov    %edx,%eax
c002e919:	c1 e0 02             	shl    $0x2,%eax
c002e91c:	01 d0                	add    %edx,%eax
c002e91e:	01 c0                	add    %eax,%eax
c002e920:	05 c8 00 00 00       	add    $0xc8,%eax
c002e925:	99                   	cltd   
c002e926:	83 ec 08             	sub    $0x8,%esp
c002e929:	52                   	push   %edx
c002e92a:	50                   	push   %eax
c002e92b:	e8 cd 67 ff ff       	call   c00250fd <timer_sleep>
c002e930:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002e933:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e936:	8b 00                	mov    (%eax),%eax
c002e938:	83 ec 08             	sub    $0x8,%esp
c002e93b:	50                   	push   %eax
c002e93c:	8d 83 18 a2 ff ff    	lea    -0x5de8(%ebx),%eax
c002e942:	50                   	push   %eax
c002e943:	e8 e0 f8 ff ff       	call   c002e228 <msg>
c002e948:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002e94b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002e952:	eb 52                	jmp    c002e9a6 <test_sleep+0x1e3>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
c002e954:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e957:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002e95e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e961:	01 d0                	add    %edx,%eax
c002e963:	8b 00                	mov    (%eax),%eax
c002e965:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002e968:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
c002e96e:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c002e975:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002e978:	01 ca                	add    %ecx,%edx
c002e97a:	8b 12                	mov    (%edx),%edx
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002e97c:	29 d0                	sub    %edx,%eax
c002e97e:	89 c1                	mov    %eax,%ecx
c002e980:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e983:	99                   	cltd   
c002e984:	f7 7d 08             	idivl  0x8(%ebp)
c002e987:	89 d6                	mov    %edx,%esi
c002e989:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e98c:	99                   	cltd   
c002e98d:	f7 7d 08             	idivl  0x8(%ebp)
c002e990:	51                   	push   %ecx
c002e991:	56                   	push   %esi
c002e992:	50                   	push   %eax
c002e993:	8d 83 48 a2 ff ff    	lea    -0x5db8(%ebx),%eax
c002e999:	50                   	push   %eax
c002e99a:	e8 89 f8 ff ff       	call   c002e228 <msg>
c002e99f:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002e9a2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002e9a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e9a9:	2b 45 f0             	sub    -0x10(%ebp),%eax
c002e9ac:	c1 f8 02             	sar    $0x2,%eax
c002e9af:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002e9b2:	7c a0                	jl     c002e954 <test_sleep+0x191>
  
  free (output);
c002e9b4:	83 ec 0c             	sub    $0xc,%esp
c002e9b7:	ff 75 f0             	push   -0x10(%ebp)
c002e9ba:	e8 93 60 ff ff       	call   c0024a52 <free>
c002e9bf:	83 c4 10             	add    $0x10,%esp
}
c002e9c2:	90                   	nop
c002e9c3:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002e9c6:	5b                   	pop    %ebx
c002e9c7:	5e                   	pop    %esi
c002e9c8:	5d                   	pop    %ebp
c002e9c9:	c3                   	ret    

c002e9ca <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002e9ca:	55                   	push   %ebp
c002e9cb:	89 e5                	mov    %esp,%ebp
c002e9cd:	57                   	push   %edi
c002e9ce:	56                   	push   %esi
c002e9cf:	53                   	push   %ebx
c002e9d0:	83 ec 1c             	sub    $0x1c,%esp
c002e9d3:	e8 54 2a 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002e9d8:	81 c3 a0 b9 00 00    	add    $0xb9a0,%ebx
  struct sleep_test *test = test_;
c002e9de:	8b 45 08             	mov    0x8(%ebp),%eax
c002e9e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002e9e4:	83 ec 08             	sub    $0x8,%esp
c002e9e7:	6a 00                	push   $0x0
c002e9e9:	6a 01                	push   $0x1
c002e9eb:	e8 0d 67 ff ff       	call   c00250fd <timer_sleep>
c002e9f0:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i <= test->iterations; i++) 
c002e9f3:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
c002e9fa:	eb 6e                	jmp    c002ea6a <sleeper+0xa0>
    {
      int64_t sleep_until = test->start + i * 10;
c002e9fc:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e9ff:	8b 30                	mov    (%eax),%esi
c002ea01:	8b 78 04             	mov    0x4(%eax),%edi
c002ea04:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002ea07:	89 d0                	mov    %edx,%eax
c002ea09:	c1 e0 02             	shl    $0x2,%eax
c002ea0c:	01 d0                	add    %edx,%eax
c002ea0e:	01 c0                	add    %eax,%eax
c002ea10:	99                   	cltd   
c002ea11:	01 f0                	add    %esi,%eax
c002ea13:	11 fa                	adc    %edi,%edx
c002ea15:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002ea18:	89 55 dc             	mov    %edx,-0x24(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002ea1b:	e8 6f 66 ff ff       	call   c002508f <timer_ticks>
c002ea20:	89 c6                	mov    %eax,%esi
c002ea22:	89 d7                	mov    %edx,%edi
c002ea24:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002ea27:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002ea2a:	29 f0                	sub    %esi,%eax
c002ea2c:	19 fa                	sbb    %edi,%edx
c002ea2e:	83 ec 08             	sub    $0x8,%esp
c002ea31:	52                   	push   %edx
c002ea32:	50                   	push   %eax
c002ea33:	e8 c5 66 ff ff       	call   c00250fd <timer_sleep>
c002ea38:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = timer_ticks () - test->start;
c002ea3b:	e8 4f 66 ff ff       	call   c002508f <timer_ticks>
c002ea40:	89 c1                	mov    %eax,%ecx
c002ea42:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002ea45:	8b 50 04             	mov    0x4(%eax),%edx
c002ea48:	8b 00                	mov    (%eax),%eax
c002ea4a:	29 c1                	sub    %eax,%ecx
c002ea4c:	89 ce                	mov    %ecx,%esi
c002ea4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002ea51:	8b 40 0c             	mov    0xc(%eax),%eax
c002ea54:	8d 48 04             	lea    0x4(%eax),%ecx
c002ea57:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002ea5a:	89 4a 0c             	mov    %ecx,0xc(%edx)
c002ea5d:	89 f2                	mov    %esi,%edx
c002ea5f:	89 10                	mov    %edx,(%eax)
      thread_yield ();
c002ea61:	e8 54 2a ff ff       	call   c00214ba <thread_yield>
  for (i = 1; i <= test->iterations; i++) 
c002ea66:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c002ea6a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002ea6d:	8b 40 08             	mov    0x8(%eax),%eax
c002ea70:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c002ea73:	7e 87                	jle    c002e9fc <sleeper+0x32>
    }
}
c002ea75:	90                   	nop
c002ea76:	90                   	nop
c002ea77:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002ea7a:	5b                   	pop    %ebx
c002ea7b:	5e                   	pop    %esi
c002ea7c:	5f                   	pop    %edi
c002ea7d:	5d                   	pop    %ebp
c002ea7e:	c3                   	ret    

c002ea7f <test_alarm_priority>:
static int64_t wake_time;
static struct semaphore wait_sema;

void
test_alarm_priority (void) 
{
c002ea7f:	55                   	push   %ebp
c002ea80:	89 e5                	mov    %esp,%ebp
c002ea82:	56                   	push   %esi
c002ea83:	53                   	push   %ebx
c002ea84:	83 ec 20             	sub    $0x20,%esp
c002ea87:	e8 a0 29 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002ea8c:	81 c3 ec b8 00 00    	add    $0xb8ec,%ebx
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ea92:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002ea98:	0f b6 00             	movzbl (%eax),%eax
c002ea9b:	83 f0 01             	xor    $0x1,%eax
c002ea9e:	84 c0                	test   %al,%al
c002eaa0:	75 26                	jne    c002eac8 <test_alarm_priority+0x49>
c002eaa2:	83 ec 0c             	sub    $0xc,%esp
c002eaa5:	8d 83 84 a2 ff ff    	lea    -0x5d7c(%ebx),%eax
c002eaab:	50                   	push   %eax
c002eaac:	8d 83 92 a2 ff ff    	lea    -0x5d6e(%ebx),%eax
c002eab2:	50                   	push   %eax
c002eab3:	8d 83 f0 a2 ff ff    	lea    -0x5d10(%ebx),%eax
c002eab9:	50                   	push   %eax
c002eaba:	6a 16                	push   $0x16
c002eabc:	8d 83 ac a2 ff ff    	lea    -0x5d54(%ebx),%eax
c002eac2:	50                   	push   %eax
c002eac3:	e8 9c cc ff ff       	call   c002b764 <debug_panic>

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002eac8:	e8 c2 65 ff ff       	call   c002508f <timer_ticks>
c002eacd:	05 f4 01 00 00       	add    $0x1f4,%eax
c002ead2:	83 d2 00             	adc    $0x0,%edx
c002ead5:	89 83 a0 22 00 00    	mov    %eax,0x22a0(%ebx)
c002eadb:	89 93 a4 22 00 00    	mov    %edx,0x22a4(%ebx)
  sema_init (&wait_sema, 0);
c002eae1:	83 ec 08             	sub    $0x8,%esp
c002eae4:	6a 00                	push   $0x0
c002eae6:	8d 83 a8 22 00 00    	lea    0x22a8(%ebx),%eax
c002eaec:	50                   	push   %eax
c002eaed:	e8 7c 49 ff ff       	call   c002346e <sema_init>
c002eaf2:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 10; i++) 
c002eaf5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002eafc:	eb 68                	jmp    c002eb66 <test_alarm_priority+0xe7>
    {
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002eafe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002eb01:	8d 48 05             	lea    0x5(%eax),%ecx
c002eb04:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002eb09:	89 c8                	mov    %ecx,%eax
c002eb0b:	f7 ea                	imul   %edx
c002eb0d:	89 d0                	mov    %edx,%eax
c002eb0f:	c1 f8 02             	sar    $0x2,%eax
c002eb12:	89 ce                	mov    %ecx,%esi
c002eb14:	c1 fe 1f             	sar    $0x1f,%esi
c002eb17:	29 f0                	sub    %esi,%eax
c002eb19:	89 c2                	mov    %eax,%edx
c002eb1b:	89 d0                	mov    %edx,%eax
c002eb1d:	c1 e0 02             	shl    $0x2,%eax
c002eb20:	01 d0                	add    %edx,%eax
c002eb22:	01 c0                	add    %eax,%eax
c002eb24:	29 c1                	sub    %eax,%ecx
c002eb26:	89 ca                	mov    %ecx,%edx
c002eb28:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002eb2d:	29 d0                	sub    %edx,%eax
c002eb2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002eb32:	ff 75 f0             	push   -0x10(%ebp)
c002eb35:	8d 83 d1 a2 ff ff    	lea    -0x5d2f(%ebx),%eax
c002eb3b:	50                   	push   %eax
c002eb3c:	6a 10                	push   $0x10
c002eb3e:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002eb41:	50                   	push   %eax
c002eb42:	e8 6b a3 ff ff       	call   c0028eb2 <snprintf>
c002eb47:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
c002eb4a:	6a 00                	push   $0x0
c002eb4c:	8d 83 2f 48 ff ff    	lea    -0xb7d1(%ebx),%eax
c002eb52:	50                   	push   %eax
c002eb53:	ff 75 f0             	push   -0x10(%ebp)
c002eb56:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002eb59:	50                   	push   %eax
c002eb5a:	e8 45 25 ff ff       	call   c00210a4 <thread_create>
c002eb5f:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002eb62:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002eb66:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002eb6a:	7e 92                	jle    c002eafe <test_alarm_priority+0x7f>
    }

  thread_set_priority (PRI_MIN);
c002eb6c:	83 ec 0c             	sub    $0xc,%esp
c002eb6f:	6a 00                	push   $0x0
c002eb71:	e8 a4 2a ff ff       	call   c002161a <thread_set_priority>
c002eb76:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 10; i++)
c002eb79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002eb80:	eb 16                	jmp    c002eb98 <test_alarm_priority+0x119>
    sema_down (&wait_sema);
c002eb82:	83 ec 0c             	sub    $0xc,%esp
c002eb85:	8d 83 a8 22 00 00    	lea    0x22a8(%ebx),%eax
c002eb8b:	50                   	push   %eax
c002eb8c:	e8 3e 49 ff ff       	call   c00234cf <sema_down>
c002eb91:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++)
c002eb94:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002eb98:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002eb9c:	7e e4                	jle    c002eb82 <test_alarm_priority+0x103>
}
c002eb9e:	90                   	nop
c002eb9f:	90                   	nop
c002eba0:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002eba3:	5b                   	pop    %ebx
c002eba4:	5e                   	pop    %esi
c002eba5:	5d                   	pop    %ebp
c002eba6:	c3                   	ret    

c002eba7 <alarm_priority_thread>:

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002eba7:	55                   	push   %ebp
c002eba8:	89 e5                	mov    %esp,%ebp
c002ebaa:	57                   	push   %edi
c002ebab:	56                   	push   %esi
c002ebac:	53                   	push   %ebx
c002ebad:	83 ec 1c             	sub    $0x1c,%esp
c002ebb0:	e8 77 28 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002ebb5:	81 c3 c3 b7 00 00    	add    $0xb7c3,%ebx
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002ebbb:	e8 cf 64 ff ff       	call   c002508f <timer_ticks>
c002ebc0:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002ebc3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  while (timer_elapsed (start_time) == 0)
c002ebc6:	eb 01                	jmp    c002ebc9 <alarm_priority_thread+0x22>
    continue;
c002ebc8:	90                   	nop
  while (timer_elapsed (start_time) == 0)
c002ebc9:	83 ec 08             	sub    $0x8,%esp
c002ebcc:	ff 75 e4             	push   -0x1c(%ebp)
c002ebcf:	ff 75 e0             	push   -0x20(%ebp)
c002ebd2:	e8 fd 64 ff ff       	call   c00250d4 <timer_elapsed>
c002ebd7:	83 c4 10             	add    $0x10,%esp
c002ebda:	89 c1                	mov    %eax,%ecx
c002ebdc:	80 f5 00             	xor    $0x0,%ch
c002ebdf:	89 ce                	mov    %ecx,%esi
c002ebe1:	89 d0                	mov    %edx,%eax
c002ebe3:	80 f4 00             	xor    $0x0,%ah
c002ebe6:	89 c7                	mov    %eax,%edi
c002ebe8:	89 f8                	mov    %edi,%eax
c002ebea:	09 f0                	or     %esi,%eax
c002ebec:	85 c0                	test   %eax,%eax
c002ebee:	74 d8                	je     c002ebc8 <alarm_priority_thread+0x21>

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002ebf0:	8b b3 a0 22 00 00    	mov    0x22a0(%ebx),%esi
c002ebf6:	8b bb a4 22 00 00    	mov    0x22a4(%ebx),%edi
c002ebfc:	e8 8e 64 ff ff       	call   c002508f <timer_ticks>
c002ec01:	29 c6                	sub    %eax,%esi
c002ec03:	19 d7                	sbb    %edx,%edi
c002ec05:	89 f0                	mov    %esi,%eax
c002ec07:	89 fa                	mov    %edi,%edx
c002ec09:	83 ec 08             	sub    $0x8,%esp
c002ec0c:	52                   	push   %edx
c002ec0d:	50                   	push   %eax
c002ec0e:	e8 ea 64 ff ff       	call   c00250fd <timer_sleep>
c002ec13:	83 c4 10             	add    $0x10,%esp

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002ec16:	e8 4c 27 ff ff       	call   c0021367 <thread_name>
c002ec1b:	83 ec 08             	sub    $0x8,%esp
c002ec1e:	50                   	push   %eax
c002ec1f:	8d 83 dd a2 ff ff    	lea    -0x5d23(%ebx),%eax
c002ec25:	50                   	push   %eax
c002ec26:	e8 fd f5 ff ff       	call   c002e228 <msg>
c002ec2b:	83 c4 10             	add    $0x10,%esp

  sema_up (&wait_sema);
c002ec2e:	83 ec 0c             	sub    $0xc,%esp
c002ec31:	8d 83 a8 22 00 00    	lea    0x22a8(%ebx),%eax
c002ec37:	50                   	push   %eax
c002ec38:	e8 d3 49 ff ff       	call   c0023610 <sema_up>
c002ec3d:	83 c4 10             	add    $0x10,%esp
}
c002ec40:	90                   	nop
c002ec41:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002ec44:	5b                   	pop    %ebx
c002ec45:	5e                   	pop    %esi
c002ec46:	5f                   	pop    %edi
c002ec47:	5d                   	pop    %ebp
c002ec48:	c3                   	ret    

c002ec49 <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002ec49:	55                   	push   %ebp
c002ec4a:	89 e5                	mov    %esp,%ebp
c002ec4c:	53                   	push   %ebx
c002ec4d:	83 ec 04             	sub    $0x4,%esp
c002ec50:	e8 d7 27 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002ec55:	81 c3 23 b7 00 00    	add    $0xb723,%ebx
  timer_sleep (0);
c002ec5b:	83 ec 08             	sub    $0x8,%esp
c002ec5e:	6a 00                	push   $0x0
c002ec60:	6a 00                	push   $0x0
c002ec62:	e8 96 64 ff ff       	call   c00250fd <timer_sleep>
c002ec67:	83 c4 10             	add    $0x10,%esp
  pass ();
c002ec6a:	e8 7b f6 ff ff       	call   c002e2ea <pass>
}
c002ec6f:	90                   	nop
c002ec70:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ec73:	c9                   	leave  
c002ec74:	c3                   	ret    

c002ec75 <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002ec75:	55                   	push   %ebp
c002ec76:	89 e5                	mov    %esp,%ebp
c002ec78:	53                   	push   %ebx
c002ec79:	83 ec 04             	sub    $0x4,%esp
c002ec7c:	e8 ab 27 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002ec81:	81 c3 f7 b6 00 00    	add    $0xb6f7,%ebx
  timer_sleep (-100);
c002ec87:	83 ec 08             	sub    $0x8,%esp
c002ec8a:	6a ff                	push   $0xffffffff
c002ec8c:	6a 9c                	push   $0xffffff9c
c002ec8e:	e8 6a 64 ff ff       	call   c00250fd <timer_sleep>
c002ec93:	83 c4 10             	add    $0x10,%esp
  pass ();
c002ec96:	e8 4f f6 ff ff       	call   c002e2ea <pass>
}
c002ec9b:	90                   	nop
c002ec9c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ec9f:	c9                   	leave  
c002eca0:	c3                   	ret    

c002eca1 <test_priority_change>:

static thread_func changing_thread;

void
test_priority_change (void) 
{
c002eca1:	55                   	push   %ebp
c002eca2:	89 e5                	mov    %esp,%ebp
c002eca4:	53                   	push   %ebx
c002eca5:	83 ec 04             	sub    $0x4,%esp
c002eca8:	e8 7f 27 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002ecad:	81 c3 cb b6 00 00    	add    $0xb6cb,%ebx
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ecb3:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002ecb9:	0f b6 00             	movzbl (%eax),%eax
c002ecbc:	83 f0 01             	xor    $0x1,%eax
c002ecbf:	84 c0                	test   %al,%al
c002ecc1:	75 26                	jne    c002ece9 <test_priority_change+0x48>
c002ecc3:	83 ec 0c             	sub    $0xc,%esp
c002ecc6:	8d 83 04 a3 ff ff    	lea    -0x5cfc(%ebx),%eax
c002eccc:	50                   	push   %eax
c002eccd:	8d 83 12 a3 ff ff    	lea    -0x5cee(%ebx),%eax
c002ecd3:	50                   	push   %eax
c002ecd4:	8d 83 08 a4 ff ff    	lea    -0x5bf8(%ebx),%eax
c002ecda:	50                   	push   %eax
c002ecdb:	6a 10                	push   $0x10
c002ecdd:	8d 83 2c a3 ff ff    	lea    -0x5cd4(%ebx),%eax
c002ece3:	50                   	push   %eax
c002ece4:	e8 7b ca ff ff       	call   c002b764 <debug_panic>

  msg ("Creating a high-priority thread 2.");
c002ece9:	83 ec 0c             	sub    $0xc,%esp
c002ecec:	8d 83 54 a3 ff ff    	lea    -0x5cac(%ebx),%eax
c002ecf2:	50                   	push   %eax
c002ecf3:	e8 30 f5 ff ff       	call   c002e228 <msg>
c002ecf8:	83 c4 10             	add    $0x10,%esp
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002ecfb:	6a 00                	push   $0x0
c002ecfd:	8d 83 d4 49 ff ff    	lea    -0xb62c(%ebx),%eax
c002ed03:	50                   	push   %eax
c002ed04:	6a 20                	push   $0x20
c002ed06:	8d 83 77 a3 ff ff    	lea    -0x5c89(%ebx),%eax
c002ed0c:	50                   	push   %eax
c002ed0d:	e8 92 23 ff ff       	call   c00210a4 <thread_create>
c002ed12:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just lowered its priority.");
c002ed15:	83 ec 0c             	sub    $0xc,%esp
c002ed18:	8d 83 80 a3 ff ff    	lea    -0x5c80(%ebx),%eax
c002ed1e:	50                   	push   %eax
c002ed1f:	e8 04 f5 ff ff       	call   c002e228 <msg>
c002ed24:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 2);
c002ed27:	83 ec 0c             	sub    $0xc,%esp
c002ed2a:	6a 1d                	push   $0x1d
c002ed2c:	e8 e9 28 ff ff       	call   c002161a <thread_set_priority>
c002ed31:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just exited.");
c002ed34:	83 ec 0c             	sub    $0xc,%esp
c002ed37:	8d 83 b0 a3 ff ff    	lea    -0x5c50(%ebx),%eax
c002ed3d:	50                   	push   %eax
c002ed3e:	e8 e5 f4 ff ff       	call   c002e228 <msg>
c002ed43:	83 c4 10             	add    $0x10,%esp
}
c002ed46:	90                   	nop
c002ed47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ed4a:	c9                   	leave  
c002ed4b:	c3                   	ret    

c002ed4c <changing_thread>:

static void
changing_thread (void *aux UNUSED) 
{
c002ed4c:	55                   	push   %ebp
c002ed4d:	89 e5                	mov    %esp,%ebp
c002ed4f:	53                   	push   %ebx
c002ed50:	83 ec 04             	sub    $0x4,%esp
c002ed53:	e8 d4 26 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002ed58:	81 c3 20 b6 00 00    	add    $0xb620,%ebx
  msg ("Thread 2 now lowering priority.");
c002ed5e:	83 ec 0c             	sub    $0xc,%esp
c002ed61:	8d 83 d4 a3 ff ff    	lea    -0x5c2c(%ebx),%eax
c002ed67:	50                   	push   %eax
c002ed68:	e8 bb f4 ff ff       	call   c002e228 <msg>
c002ed6d:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 1);
c002ed70:	83 ec 0c             	sub    $0xc,%esp
c002ed73:	6a 1e                	push   $0x1e
c002ed75:	e8 a0 28 ff ff       	call   c002161a <thread_set_priority>
c002ed7a:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 exiting.");
c002ed7d:	83 ec 0c             	sub    $0xc,%esp
c002ed80:	8d 83 f4 a3 ff ff    	lea    -0x5c0c(%ebx),%eax
c002ed86:	50                   	push   %eax
c002ed87:	e8 9c f4 ff ff       	call   c002e228 <msg>
c002ed8c:	83 c4 10             	add    $0x10,%esp
}
c002ed8f:	90                   	nop
c002ed90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ed93:	c9                   	leave  
c002ed94:	c3                   	ret    

c002ed95 <test_priority_donate_one>:
static thread_func acquire1_thread_func;
static thread_func acquire2_thread_func;

void
test_priority_donate_one (void) 
{
c002ed95:	55                   	push   %ebp
c002ed96:	89 e5                	mov    %esp,%ebp
c002ed98:	53                   	push   %ebx
c002ed99:	83 ec 24             	sub    $0x24,%esp
c002ed9c:	e8 8b 26 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002eda1:	81 c3 d7 b5 00 00    	add    $0xb5d7,%ebx
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002eda7:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002edad:	0f b6 00             	movzbl (%eax),%eax
c002edb0:	83 f0 01             	xor    $0x1,%eax
c002edb3:	84 c0                	test   %al,%al
c002edb5:	75 26                	jne    c002eddd <test_priority_donate_one+0x48>
c002edb7:	83 ec 0c             	sub    $0xc,%esp
c002edba:	8d 83 20 a4 ff ff    	lea    -0x5be0(%ebx),%eax
c002edc0:	50                   	push   %eax
c002edc1:	8d 83 2e a4 ff ff    	lea    -0x5bd2(%ebx),%eax
c002edc7:	50                   	push   %eax
c002edc8:	8d 83 b0 a5 ff ff    	lea    -0x5a50(%ebx),%eax
c002edce:	50                   	push   %eax
c002edcf:	6a 1b                	push   $0x1b
c002edd1:	8d 83 48 a4 ff ff    	lea    -0x5bb8(%ebx),%eax
c002edd7:	50                   	push   %eax
c002edd8:	e8 87 c9 ff ff       	call   c002b764 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002eddd:	e8 1a 29 ff ff       	call   c00216fc <thread_get_priority>
c002ede2:	83 f8 1f             	cmp    $0x1f,%eax
c002ede5:	74 26                	je     c002ee0d <test_priority_donate_one+0x78>
c002ede7:	83 ec 0c             	sub    $0xc,%esp
c002edea:	8d 83 74 a4 ff ff    	lea    -0x5b8c(%ebx),%eax
c002edf0:	50                   	push   %eax
c002edf1:	8d 83 2e a4 ff ff    	lea    -0x5bd2(%ebx),%eax
c002edf7:	50                   	push   %eax
c002edf8:	8d 83 b0 a5 ff ff    	lea    -0x5a50(%ebx),%eax
c002edfe:	50                   	push   %eax
c002edff:	6a 1e                	push   $0x1e
c002ee01:	8d 83 48 a4 ff ff    	lea    -0x5bb8(%ebx),%eax
c002ee07:	50                   	push   %eax
c002ee08:	e8 57 c9 ff ff       	call   c002b764 <debug_panic>

  lock_init (&lock);
c002ee0d:	83 ec 0c             	sub    $0xc,%esp
c002ee10:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ee13:	50                   	push   %eax
c002ee14:	e8 b9 49 ff ff       	call   c00237d2 <lock_init>
c002ee19:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002ee1c:	83 ec 0c             	sub    $0xc,%esp
c002ee1f:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ee22:	50                   	push   %eax
c002ee23:	e8 0f 4a ff ff       	call   c0023837 <lock_acquire>
c002ee28:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002ee2b:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ee2e:	50                   	push   %eax
c002ee2f:	8d 83 58 4b ff ff    	lea    -0xb4a8(%ebx),%eax
c002ee35:	50                   	push   %eax
c002ee36:	6a 20                	push   $0x20
c002ee38:	8d 83 9a a4 ff ff    	lea    -0x5b66(%ebx),%eax
c002ee3e:	50                   	push   %eax
c002ee3f:	e8 60 22 ff ff       	call   c00210a4 <thread_create>
c002ee44:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002ee47:	e8 b0 28 ff ff       	call   c00216fc <thread_get_priority>
c002ee4c:	83 ec 04             	sub    $0x4,%esp
c002ee4f:	50                   	push   %eax
c002ee50:	6a 20                	push   $0x20
c002ee52:	8d 83 a4 a4 ff ff    	lea    -0x5b5c(%ebx),%eax
c002ee58:	50                   	push   %eax
c002ee59:	e8 ca f3 ff ff       	call   c002e228 <msg>
c002ee5e:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002ee61:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ee64:	50                   	push   %eax
c002ee65:	8d 83 b6 4b ff ff    	lea    -0xb44a(%ebx),%eax
c002ee6b:	50                   	push   %eax
c002ee6c:	6a 21                	push   $0x21
c002ee6e:	8d 83 df a4 ff ff    	lea    -0x5b21(%ebx),%eax
c002ee74:	50                   	push   %eax
c002ee75:	e8 2a 22 ff ff       	call   c00210a4 <thread_create>
c002ee7a:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002ee7d:	e8 7a 28 ff ff       	call   c00216fc <thread_get_priority>
c002ee82:	83 ec 04             	sub    $0x4,%esp
c002ee85:	50                   	push   %eax
c002ee86:	6a 21                	push   $0x21
c002ee88:	8d 83 a4 a4 ff ff    	lea    -0x5b5c(%ebx),%eax
c002ee8e:	50                   	push   %eax
c002ee8f:	e8 94 f3 ff ff       	call   c002e228 <msg>
c002ee94:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  lock_release (&lock);
c002ee97:	83 ec 0c             	sub    $0xc,%esp
c002ee9a:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ee9d:	50                   	push   %eax
c002ee9e:	e8 42 4c ff ff       	call   c0023ae5 <lock_release>
c002eea3:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002eea6:	83 ec 0c             	sub    $0xc,%esp
c002eea9:	8d 83 e8 a4 ff ff    	lea    -0x5b18(%ebx),%eax
c002eeaf:	50                   	push   %eax
c002eeb0:	e8 73 f3 ff ff       	call   c002e228 <msg>
c002eeb5:	83 c4 10             	add    $0x10,%esp
  msg ("This should be the last line before finishing this test.");
c002eeb8:	83 ec 0c             	sub    $0xc,%esp
c002eebb:	8d 83 28 a5 ff ff    	lea    -0x5ad8(%ebx),%eax
c002eec1:	50                   	push   %eax
c002eec2:	e8 61 f3 ff ff       	call   c002e228 <msg>
c002eec7:	83 c4 10             	add    $0x10,%esp
}
c002eeca:	90                   	nop
c002eecb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002eece:	c9                   	leave  
c002eecf:	c3                   	ret    

c002eed0 <acquire1_thread_func>:

static void
acquire1_thread_func (void *lock_) 
{
c002eed0:	55                   	push   %ebp
c002eed1:	89 e5                	mov    %esp,%ebp
c002eed3:	53                   	push   %ebx
c002eed4:	83 ec 14             	sub    $0x14,%esp
c002eed7:	e8 50 25 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002eedc:	81 c3 9c b4 00 00    	add    $0xb49c,%ebx
  struct lock *lock = lock_;
c002eee2:	8b 45 08             	mov    0x8(%ebp),%eax
c002eee5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002eee8:	83 ec 0c             	sub    $0xc,%esp
c002eeeb:	ff 75 f4             	push   -0xc(%ebp)
c002eeee:	e8 44 49 ff ff       	call   c0023837 <lock_acquire>
c002eef3:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: got the lock");
c002eef6:	83 ec 0c             	sub    $0xc,%esp
c002eef9:	8d 83 61 a5 ff ff    	lea    -0x5a9f(%ebx),%eax
c002eeff:	50                   	push   %eax
c002ef00:	e8 23 f3 ff ff       	call   c002e228 <msg>
c002ef05:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002ef08:	83 ec 0c             	sub    $0xc,%esp
c002ef0b:	ff 75 f4             	push   -0xc(%ebp)
c002ef0e:	e8 d2 4b ff ff       	call   c0023ae5 <lock_release>
c002ef13:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: done");
c002ef16:	83 ec 0c             	sub    $0xc,%esp
c002ef19:	8d 83 78 a5 ff ff    	lea    -0x5a88(%ebx),%eax
c002ef1f:	50                   	push   %eax
c002ef20:	e8 03 f3 ff ff       	call   c002e228 <msg>
c002ef25:	83 c4 10             	add    $0x10,%esp
}
c002ef28:	90                   	nop
c002ef29:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ef2c:	c9                   	leave  
c002ef2d:	c3                   	ret    

c002ef2e <acquire2_thread_func>:

static void
acquire2_thread_func (void *lock_) 
{
c002ef2e:	55                   	push   %ebp
c002ef2f:	89 e5                	mov    %esp,%ebp
c002ef31:	53                   	push   %ebx
c002ef32:	83 ec 14             	sub    $0x14,%esp
c002ef35:	e8 f2 24 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002ef3a:	81 c3 3e b4 00 00    	add    $0xb43e,%ebx
  struct lock *lock = lock_;
c002ef40:	8b 45 08             	mov    0x8(%ebp),%eax
c002ef43:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002ef46:	83 ec 0c             	sub    $0xc,%esp
c002ef49:	ff 75 f4             	push   -0xc(%ebp)
c002ef4c:	e8 e6 48 ff ff       	call   c0023837 <lock_acquire>
c002ef51:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: got the lock");
c002ef54:	83 ec 0c             	sub    $0xc,%esp
c002ef57:	8d 83 87 a5 ff ff    	lea    -0x5a79(%ebx),%eax
c002ef5d:	50                   	push   %eax
c002ef5e:	e8 c5 f2 ff ff       	call   c002e228 <msg>
c002ef63:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002ef66:	83 ec 0c             	sub    $0xc,%esp
c002ef69:	ff 75 f4             	push   -0xc(%ebp)
c002ef6c:	e8 74 4b ff ff       	call   c0023ae5 <lock_release>
c002ef71:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: done");
c002ef74:	83 ec 0c             	sub    $0xc,%esp
c002ef77:	8d 83 9e a5 ff ff    	lea    -0x5a62(%ebx),%eax
c002ef7d:	50                   	push   %eax
c002ef7e:	e8 a5 f2 ff ff       	call   c002e228 <msg>
c002ef83:	83 c4 10             	add    $0x10,%esp
}
c002ef86:	90                   	nop
c002ef87:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ef8a:	c9                   	leave  
c002ef8b:	c3                   	ret    

c002ef8c <test_priority_donate_multiple>:
static thread_func a_thread_func;
static thread_func b_thread_func;

void
test_priority_donate_multiple (void) 
{
c002ef8c:	55                   	push   %ebp
c002ef8d:	89 e5                	mov    %esp,%ebp
c002ef8f:	53                   	push   %ebx
c002ef90:	83 ec 34             	sub    $0x34,%esp
c002ef93:	e8 94 24 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002ef98:	81 c3 e0 b3 00 00    	add    $0xb3e0,%ebx
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ef9e:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002efa4:	0f b6 00             	movzbl (%eax),%eax
c002efa7:	83 f0 01             	xor    $0x1,%eax
c002efaa:	84 c0                	test   %al,%al
c002efac:	75 26                	jne    c002efd4 <test_priority_donate_multiple+0x48>
c002efae:	83 ec 0c             	sub    $0xc,%esp
c002efb1:	8d 83 cc a5 ff ff    	lea    -0x5a34(%ebx),%eax
c002efb7:	50                   	push   %eax
c002efb8:	8d 83 da a5 ff ff    	lea    -0x5a26(%ebx),%eax
c002efbe:	50                   	push   %eax
c002efbf:	8d 83 30 a7 ff ff    	lea    -0x58d0(%ebx),%eax
c002efc5:	50                   	push   %eax
c002efc6:	6a 1b                	push   $0x1b
c002efc8:	8d 83 f4 a5 ff ff    	lea    -0x5a0c(%ebx),%eax
c002efce:	50                   	push   %eax
c002efcf:	e8 90 c7 ff ff       	call   c002b764 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002efd4:	e8 23 27 ff ff       	call   c00216fc <thread_get_priority>
c002efd9:	83 f8 1f             	cmp    $0x1f,%eax
c002efdc:	74 26                	je     c002f004 <test_priority_donate_multiple+0x78>
c002efde:	83 ec 0c             	sub    $0xc,%esp
c002efe1:	8d 83 24 a6 ff ff    	lea    -0x59dc(%ebx),%eax
c002efe7:	50                   	push   %eax
c002efe8:	8d 83 da a5 ff ff    	lea    -0x5a26(%ebx),%eax
c002efee:	50                   	push   %eax
c002efef:	8d 83 30 a7 ff ff    	lea    -0x58d0(%ebx),%eax
c002eff5:	50                   	push   %eax
c002eff6:	6a 1e                	push   $0x1e
c002eff8:	8d 83 f4 a5 ff ff    	lea    -0x5a0c(%ebx),%eax
c002effe:	50                   	push   %eax
c002efff:	e8 60 c7 ff ff       	call   c002b764 <debug_panic>

  lock_init (&a);
c002f004:	83 ec 0c             	sub    $0xc,%esp
c002f007:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f00a:	50                   	push   %eax
c002f00b:	e8 c2 47 ff ff       	call   c00237d2 <lock_init>
c002f010:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002f013:	83 ec 0c             	sub    $0xc,%esp
c002f016:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f019:	50                   	push   %eax
c002f01a:	e8 b3 47 ff ff       	call   c00237d2 <lock_init>
c002f01f:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002f022:	83 ec 0c             	sub    $0xc,%esp
c002f025:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f028:	50                   	push   %eax
c002f029:	e8 09 48 ff ff       	call   c0023837 <lock_acquire>
c002f02e:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002f031:	83 ec 0c             	sub    $0xc,%esp
c002f034:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f037:	50                   	push   %eax
c002f038:	e8 fa 47 ff ff       	call   c0023837 <lock_acquire>
c002f03d:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002f040:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f043:	50                   	push   %eax
c002f044:	8d 83 b0 4d ff ff    	lea    -0xb250(%ebx),%eax
c002f04a:	50                   	push   %eax
c002f04b:	6a 20                	push   $0x20
c002f04d:	8d 83 4a a6 ff ff    	lea    -0x59b6(%ebx),%eax
c002f053:	50                   	push   %eax
c002f054:	e8 4b 20 ff ff       	call   c00210a4 <thread_create>
c002f059:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002f05c:	e8 9b 26 ff ff       	call   c00216fc <thread_get_priority>
c002f061:	83 ec 04             	sub    $0x4,%esp
c002f064:	50                   	push   %eax
c002f065:	6a 20                	push   $0x20
c002f067:	8d 83 4c a6 ff ff    	lea    -0x59b4(%ebx),%eax
c002f06d:	50                   	push   %eax
c002f06e:	e8 b5 f1 ff ff       	call   c002e228 <msg>
c002f073:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002f076:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f079:	50                   	push   %eax
c002f07a:	8d 83 0e 4e ff ff    	lea    -0xb1f2(%ebx),%eax
c002f080:	50                   	push   %eax
c002f081:	6a 21                	push   $0x21
c002f083:	8d 83 87 a6 ff ff    	lea    -0x5979(%ebx),%eax
c002f089:	50                   	push   %eax
c002f08a:	e8 15 20 ff ff       	call   c00210a4 <thread_create>
c002f08f:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002f092:	e8 65 26 ff ff       	call   c00216fc <thread_get_priority>
c002f097:	83 ec 04             	sub    $0x4,%esp
c002f09a:	50                   	push   %eax
c002f09b:	6a 21                	push   $0x21
c002f09d:	8d 83 4c a6 ff ff    	lea    -0x59b4(%ebx),%eax
c002f0a3:	50                   	push   %eax
c002f0a4:	e8 7f f1 ff ff       	call   c002e228 <msg>
c002f0a9:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&b);
c002f0ac:	83 ec 0c             	sub    $0xc,%esp
c002f0af:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f0b2:	50                   	push   %eax
c002f0b3:	e8 2d 4a ff ff       	call   c0023ae5 <lock_release>
c002f0b8:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b should have just finished.");
c002f0bb:	83 ec 0c             	sub    $0xc,%esp
c002f0be:	8d 83 8c a6 ff ff    	lea    -0x5974(%ebx),%eax
c002f0c4:	50                   	push   %eax
c002f0c5:	e8 5e f1 ff ff       	call   c002e228 <msg>
c002f0ca:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002f0cd:	e8 2a 26 ff ff       	call   c00216fc <thread_get_priority>
c002f0d2:	83 ec 04             	sub    $0x4,%esp
c002f0d5:	50                   	push   %eax
c002f0d6:	6a 20                	push   $0x20
c002f0d8:	8d 83 4c a6 ff ff    	lea    -0x59b4(%ebx),%eax
c002f0de:	50                   	push   %eax
c002f0df:	e8 44 f1 ff ff       	call   c002e228 <msg>
c002f0e4:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  lock_release (&a);
c002f0e7:	83 ec 0c             	sub    $0xc,%esp
c002f0ea:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f0ed:	50                   	push   %eax
c002f0ee:	e8 f2 49 ff ff       	call   c0023ae5 <lock_release>
c002f0f3:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a should have just finished.");
c002f0f6:	83 ec 0c             	sub    $0xc,%esp
c002f0f9:	8d 83 b0 a6 ff ff    	lea    -0x5950(%ebx),%eax
c002f0ff:	50                   	push   %eax
c002f100:	e8 23 f1 ff ff       	call   c002e228 <msg>
c002f105:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002f108:	e8 ef 25 ff ff       	call   c00216fc <thread_get_priority>
c002f10d:	83 ec 04             	sub    $0x4,%esp
c002f110:	50                   	push   %eax
c002f111:	6a 1f                	push   $0x1f
c002f113:	8d 83 4c a6 ff ff    	lea    -0x59b4(%ebx),%eax
c002f119:	50                   	push   %eax
c002f11a:	e8 09 f1 ff ff       	call   c002e228 <msg>
c002f11f:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002f122:	90                   	nop
c002f123:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f126:	c9                   	leave  
c002f127:	c3                   	ret    

c002f128 <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002f128:	55                   	push   %ebp
c002f129:	89 e5                	mov    %esp,%ebp
c002f12b:	53                   	push   %ebx
c002f12c:	83 ec 14             	sub    $0x14,%esp
c002f12f:	e8 f8 22 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f134:	81 c3 44 b2 00 00    	add    $0xb244,%ebx
  struct lock *lock = lock_;
c002f13a:	8b 45 08             	mov    0x8(%ebp),%eax
c002f13d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002f140:	83 ec 0c             	sub    $0xc,%esp
c002f143:	ff 75 f4             	push   -0xc(%ebp)
c002f146:	e8 ec 46 ff ff       	call   c0023837 <lock_acquire>
c002f14b:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002f14e:	83 ec 0c             	sub    $0xc,%esp
c002f151:	8d 83 d4 a6 ff ff    	lea    -0x592c(%ebx),%eax
c002f157:	50                   	push   %eax
c002f158:	e8 cb f0 ff ff       	call   c002e228 <msg>
c002f15d:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002f160:	83 ec 0c             	sub    $0xc,%esp
c002f163:	ff 75 f4             	push   -0xc(%ebp)
c002f166:	e8 7a 49 ff ff       	call   c0023ae5 <lock_release>
c002f16b:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002f16e:	83 ec 0c             	sub    $0xc,%esp
c002f171:	8d 83 ee a6 ff ff    	lea    -0x5912(%ebx),%eax
c002f177:	50                   	push   %eax
c002f178:	e8 ab f0 ff ff       	call   c002e228 <msg>
c002f17d:	83 c4 10             	add    $0x10,%esp
}
c002f180:	90                   	nop
c002f181:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f184:	c9                   	leave  
c002f185:	c3                   	ret    

c002f186 <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002f186:	55                   	push   %ebp
c002f187:	89 e5                	mov    %esp,%ebp
c002f189:	53                   	push   %ebx
c002f18a:	83 ec 14             	sub    $0x14,%esp
c002f18d:	e8 9a 22 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f192:	81 c3 e6 b1 00 00    	add    $0xb1e6,%ebx
  struct lock *lock = lock_;
c002f198:	8b 45 08             	mov    0x8(%ebp),%eax
c002f19b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002f19e:	83 ec 0c             	sub    $0xc,%esp
c002f1a1:	ff 75 f4             	push   -0xc(%ebp)
c002f1a4:	e8 8e 46 ff ff       	call   c0023837 <lock_acquire>
c002f1a9:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002f1ac:	83 ec 0c             	sub    $0xc,%esp
c002f1af:	8d 83 01 a7 ff ff    	lea    -0x58ff(%ebx),%eax
c002f1b5:	50                   	push   %eax
c002f1b6:	e8 6d f0 ff ff       	call   c002e228 <msg>
c002f1bb:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002f1be:	83 ec 0c             	sub    $0xc,%esp
c002f1c1:	ff 75 f4             	push   -0xc(%ebp)
c002f1c4:	e8 1c 49 ff ff       	call   c0023ae5 <lock_release>
c002f1c9:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002f1cc:	83 ec 0c             	sub    $0xc,%esp
c002f1cf:	8d 83 1b a7 ff ff    	lea    -0x58e5(%ebx),%eax
c002f1d5:	50                   	push   %eax
c002f1d6:	e8 4d f0 ff ff       	call   c002e228 <msg>
c002f1db:	83 c4 10             	add    $0x10,%esp
}
c002f1de:	90                   	nop
c002f1df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f1e2:	c9                   	leave  
c002f1e3:	c3                   	ret    

c002f1e4 <test_priority_donate_multiple2>:
static thread_func b_thread_func;
static thread_func c_thread_func;

void
test_priority_donate_multiple2 (void) 
{
c002f1e4:	55                   	push   %ebp
c002f1e5:	89 e5                	mov    %esp,%ebp
c002f1e7:	53                   	push   %ebx
c002f1e8:	83 ec 34             	sub    $0x34,%esp
c002f1eb:	e8 3c 22 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f1f0:	81 c3 88 b1 00 00    	add    $0xb188,%ebx
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002f1f6:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002f1fc:	0f b6 00             	movzbl (%eax),%eax
c002f1ff:	83 f0 01             	xor    $0x1,%eax
c002f202:	84 c0                	test   %al,%al
c002f204:	75 26                	jne    c002f22c <test_priority_donate_multiple2+0x48>
c002f206:	83 ec 0c             	sub    $0xc,%esp
c002f209:	8d 83 50 a7 ff ff    	lea    -0x58b0(%ebx),%eax
c002f20f:	50                   	push   %eax
c002f210:	8d 83 5e a7 ff ff    	lea    -0x58a2(%ebx),%eax
c002f216:	50                   	push   %eax
c002f217:	8d 83 b8 a8 ff ff    	lea    -0x5748(%ebx),%eax
c002f21d:	50                   	push   %eax
c002f21e:	6a 21                	push   $0x21
c002f220:	8d 83 78 a7 ff ff    	lea    -0x5888(%ebx),%eax
c002f226:	50                   	push   %eax
c002f227:	e8 38 c5 ff ff       	call   c002b764 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002f22c:	e8 cb 24 ff ff       	call   c00216fc <thread_get_priority>
c002f231:	83 f8 1f             	cmp    $0x1f,%eax
c002f234:	74 26                	je     c002f25c <test_priority_donate_multiple2+0x78>
c002f236:	83 ec 0c             	sub    $0xc,%esp
c002f239:	8d 83 a8 a7 ff ff    	lea    -0x5858(%ebx),%eax
c002f23f:	50                   	push   %eax
c002f240:	8d 83 5e a7 ff ff    	lea    -0x58a2(%ebx),%eax
c002f246:	50                   	push   %eax
c002f247:	8d 83 b8 a8 ff ff    	lea    -0x5748(%ebx),%eax
c002f24d:	50                   	push   %eax
c002f24e:	6a 24                	push   $0x24
c002f250:	8d 83 78 a7 ff ff    	lea    -0x5888(%ebx),%eax
c002f256:	50                   	push   %eax
c002f257:	e8 08 c5 ff ff       	call   c002b764 <debug_panic>

  lock_init (&a);
c002f25c:	83 ec 0c             	sub    $0xc,%esp
c002f25f:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f262:	50                   	push   %eax
c002f263:	e8 6a 45 ff ff       	call   c00237d2 <lock_init>
c002f268:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002f26b:	83 ec 0c             	sub    $0xc,%esp
c002f26e:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f271:	50                   	push   %eax
c002f272:	e8 5b 45 ff ff       	call   c00237d2 <lock_init>
c002f277:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002f27a:	83 ec 0c             	sub    $0xc,%esp
c002f27d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f280:	50                   	push   %eax
c002f281:	e8 b1 45 ff ff       	call   c0023837 <lock_acquire>
c002f286:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002f289:	83 ec 0c             	sub    $0xc,%esp
c002f28c:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f28f:	50                   	push   %eax
c002f290:	e8 a2 45 ff ff       	call   c0023837 <lock_acquire>
c002f295:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002f298:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f29b:	50                   	push   %eax
c002f29c:	8d 83 10 50 ff ff    	lea    -0xaff0(%ebx),%eax
c002f2a2:	50                   	push   %eax
c002f2a3:	6a 22                	push   $0x22
c002f2a5:	8d 83 ce a7 ff ff    	lea    -0x5832(%ebx),%eax
c002f2ab:	50                   	push   %eax
c002f2ac:	e8 f3 1d ff ff       	call   c00210a4 <thread_create>
c002f2b1:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002f2b4:	e8 43 24 ff ff       	call   c00216fc <thread_get_priority>
c002f2b9:	83 ec 04             	sub    $0x4,%esp
c002f2bc:	50                   	push   %eax
c002f2bd:	6a 22                	push   $0x22
c002f2bf:	8d 83 d0 a7 ff ff    	lea    -0x5830(%ebx),%eax
c002f2c5:	50                   	push   %eax
c002f2c6:	e8 5d ef ff ff       	call   c002e228 <msg>
c002f2cb:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 3, thread_get_priority ());

  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002f2ce:	6a 00                	push   $0x0
c002f2d0:	8d 83 cc 50 ff ff    	lea    -0xaf34(%ebx),%eax
c002f2d6:	50                   	push   %eax
c002f2d7:	6a 20                	push   $0x20
c002f2d9:	8d 83 0b a8 ff ff    	lea    -0x57f5(%ebx),%eax
c002f2df:	50                   	push   %eax
c002f2e0:	e8 bf 1d ff ff       	call   c00210a4 <thread_create>
c002f2e5:	83 c4 10             	add    $0x10,%esp

  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002f2e8:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f2eb:	50                   	push   %eax
c002f2ec:	8d 83 6e 50 ff ff    	lea    -0xaf92(%ebx),%eax
c002f2f2:	50                   	push   %eax
c002f2f3:	6a 24                	push   $0x24
c002f2f5:	8d 83 0d a8 ff ff    	lea    -0x57f3(%ebx),%eax
c002f2fb:	50                   	push   %eax
c002f2fc:	e8 a3 1d ff ff       	call   c00210a4 <thread_create>
c002f301:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002f304:	e8 f3 23 ff ff       	call   c00216fc <thread_get_priority>
c002f309:	83 ec 04             	sub    $0x4,%esp
c002f30c:	50                   	push   %eax
c002f30d:	6a 24                	push   $0x24
c002f30f:	8d 83 d0 a7 ff ff    	lea    -0x5830(%ebx),%eax
c002f315:	50                   	push   %eax
c002f316:	e8 0d ef ff ff       	call   c002e228 <msg>
c002f31b:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&a);
c002f31e:	83 ec 0c             	sub    $0xc,%esp
c002f321:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f324:	50                   	push   %eax
c002f325:	e8 bb 47 ff ff       	call   c0023ae5 <lock_release>
c002f32a:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002f32d:	e8 ca 23 ff ff       	call   c00216fc <thread_get_priority>
c002f332:	83 ec 04             	sub    $0x4,%esp
c002f335:	50                   	push   %eax
c002f336:	6a 24                	push   $0x24
c002f338:	8d 83 d0 a7 ff ff    	lea    -0x5830(%ebx),%eax
c002f33e:	50                   	push   %eax
c002f33f:	e8 e4 ee ff ff       	call   c002e228 <msg>
c002f344:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&b);
c002f347:	83 ec 0c             	sub    $0xc,%esp
c002f34a:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f34d:	50                   	push   %eax
c002f34e:	e8 92 47 ff ff       	call   c0023ae5 <lock_release>
c002f353:	83 c4 10             	add    $0x10,%esp
  msg ("Threads b, a, c should have just finished, in that order.");
c002f356:	83 ec 0c             	sub    $0xc,%esp
c002f359:	8d 83 10 a8 ff ff    	lea    -0x57f0(%ebx),%eax
c002f35f:	50                   	push   %eax
c002f360:	e8 c3 ee ff ff       	call   c002e228 <msg>
c002f365:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002f368:	e8 8f 23 ff ff       	call   c00216fc <thread_get_priority>
c002f36d:	83 ec 04             	sub    $0x4,%esp
c002f370:	50                   	push   %eax
c002f371:	6a 1f                	push   $0x1f
c002f373:	8d 83 d0 a7 ff ff    	lea    -0x5830(%ebx),%eax
c002f379:	50                   	push   %eax
c002f37a:	e8 a9 ee ff ff       	call   c002e228 <msg>
c002f37f:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002f382:	90                   	nop
c002f383:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f386:	c9                   	leave  
c002f387:	c3                   	ret    

c002f388 <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002f388:	55                   	push   %ebp
c002f389:	89 e5                	mov    %esp,%ebp
c002f38b:	53                   	push   %ebx
c002f38c:	83 ec 14             	sub    $0x14,%esp
c002f38f:	e8 98 20 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f394:	81 c3 e4 af 00 00    	add    $0xafe4,%ebx
  struct lock *lock = lock_;
c002f39a:	8b 45 08             	mov    0x8(%ebp),%eax
c002f39d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002f3a0:	83 ec 0c             	sub    $0xc,%esp
c002f3a3:	ff 75 f4             	push   -0xc(%ebp)
c002f3a6:	e8 8c 44 ff ff       	call   c0023837 <lock_acquire>
c002f3ab:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002f3ae:	83 ec 0c             	sub    $0xc,%esp
c002f3b1:	8d 83 4a a8 ff ff    	lea    -0x57b6(%ebx),%eax
c002f3b7:	50                   	push   %eax
c002f3b8:	e8 6b ee ff ff       	call   c002e228 <msg>
c002f3bd:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002f3c0:	83 ec 0c             	sub    $0xc,%esp
c002f3c3:	ff 75 f4             	push   -0xc(%ebp)
c002f3c6:	e8 1a 47 ff ff       	call   c0023ae5 <lock_release>
c002f3cb:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002f3ce:	83 ec 0c             	sub    $0xc,%esp
c002f3d1:	8d 83 64 a8 ff ff    	lea    -0x579c(%ebx),%eax
c002f3d7:	50                   	push   %eax
c002f3d8:	e8 4b ee ff ff       	call   c002e228 <msg>
c002f3dd:	83 c4 10             	add    $0x10,%esp
}
c002f3e0:	90                   	nop
c002f3e1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f3e4:	c9                   	leave  
c002f3e5:	c3                   	ret    

c002f3e6 <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002f3e6:	55                   	push   %ebp
c002f3e7:	89 e5                	mov    %esp,%ebp
c002f3e9:	53                   	push   %ebx
c002f3ea:	83 ec 14             	sub    $0x14,%esp
c002f3ed:	e8 3a 20 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f3f2:	81 c3 86 af 00 00    	add    $0xaf86,%ebx
  struct lock *lock = lock_;
c002f3f8:	8b 45 08             	mov    0x8(%ebp),%eax
c002f3fb:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002f3fe:	83 ec 0c             	sub    $0xc,%esp
c002f401:	ff 75 f4             	push   -0xc(%ebp)
c002f404:	e8 2e 44 ff ff       	call   c0023837 <lock_acquire>
c002f409:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002f40c:	83 ec 0c             	sub    $0xc,%esp
c002f40f:	8d 83 77 a8 ff ff    	lea    -0x5789(%ebx),%eax
c002f415:	50                   	push   %eax
c002f416:	e8 0d ee ff ff       	call   c002e228 <msg>
c002f41b:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002f41e:	83 ec 0c             	sub    $0xc,%esp
c002f421:	ff 75 f4             	push   -0xc(%ebp)
c002f424:	e8 bc 46 ff ff       	call   c0023ae5 <lock_release>
c002f429:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002f42c:	83 ec 0c             	sub    $0xc,%esp
c002f42f:	8d 83 91 a8 ff ff    	lea    -0x576f(%ebx),%eax
c002f435:	50                   	push   %eax
c002f436:	e8 ed ed ff ff       	call   c002e228 <msg>
c002f43b:	83 c4 10             	add    $0x10,%esp
}
c002f43e:	90                   	nop
c002f43f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f442:	c9                   	leave  
c002f443:	c3                   	ret    

c002f444 <c_thread_func>:

static void
c_thread_func (void *a_ UNUSED) 
{
c002f444:	55                   	push   %ebp
c002f445:	89 e5                	mov    %esp,%ebp
c002f447:	53                   	push   %ebx
c002f448:	83 ec 04             	sub    $0x4,%esp
c002f44b:	e8 d8 1f 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c002f450:	05 28 af 00 00       	add    $0xaf28,%eax
  msg ("Thread c finished.");
c002f455:	83 ec 0c             	sub    $0xc,%esp
c002f458:	8d 90 a4 a8 ff ff    	lea    -0x575c(%eax),%edx
c002f45e:	52                   	push   %edx
c002f45f:	89 c3                	mov    %eax,%ebx
c002f461:	e8 c2 ed ff ff       	call   c002e228 <msg>
c002f466:	83 c4 10             	add    $0x10,%esp
}
c002f469:	90                   	nop
c002f46a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f46d:	c9                   	leave  
c002f46e:	c3                   	ret    

c002f46f <test_priority_donate_nest>:
static thread_func medium_thread_func;
static thread_func high_thread_func;

void
test_priority_donate_nest (void) 
{
c002f46f:	55                   	push   %ebp
c002f470:	89 e5                	mov    %esp,%ebp
c002f472:	53                   	push   %ebx
c002f473:	83 ec 44             	sub    $0x44,%esp
c002f476:	e8 b1 1f 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f47b:	81 c3 fd ae 00 00    	add    $0xaefd,%ebx
  struct lock a, b;
  struct locks locks;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002f481:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002f487:	0f b6 00             	movzbl (%eax),%eax
c002f48a:	83 f0 01             	xor    $0x1,%eax
c002f48d:	84 c0                	test   %al,%al
c002f48f:	75 26                	jne    c002f4b7 <test_priority_donate_nest+0x48>
c002f491:	83 ec 0c             	sub    $0xc,%esp
c002f494:	8d 83 d8 a8 ff ff    	lea    -0x5728(%ebx),%eax
c002f49a:	50                   	push   %eax
c002f49b:	8d 83 e6 a8 ff ff    	lea    -0x571a(%ebx),%eax
c002f4a1:	50                   	push   %eax
c002f4a2:	8d 83 94 aa ff ff    	lea    -0x556c(%ebx),%eax
c002f4a8:	50                   	push   %eax
c002f4a9:	6a 22                	push   $0x22
c002f4ab:	8d 83 00 a9 ff ff    	lea    -0x5700(%ebx),%eax
c002f4b1:	50                   	push   %eax
c002f4b2:	e8 ad c2 ff ff       	call   c002b764 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002f4b7:	e8 40 22 ff ff       	call   c00216fc <thread_get_priority>
c002f4bc:	83 f8 1f             	cmp    $0x1f,%eax
c002f4bf:	74 26                	je     c002f4e7 <test_priority_donate_nest+0x78>
c002f4c1:	83 ec 0c             	sub    $0xc,%esp
c002f4c4:	8d 83 2c a9 ff ff    	lea    -0x56d4(%ebx),%eax
c002f4ca:	50                   	push   %eax
c002f4cb:	8d 83 e6 a8 ff ff    	lea    -0x571a(%ebx),%eax
c002f4d1:	50                   	push   %eax
c002f4d2:	8d 83 94 aa ff ff    	lea    -0x556c(%ebx),%eax
c002f4d8:	50                   	push   %eax
c002f4d9:	6a 25                	push   $0x25
c002f4db:	8d 83 00 a9 ff ff    	lea    -0x5700(%ebx),%eax
c002f4e1:	50                   	push   %eax
c002f4e2:	e8 7d c2 ff ff       	call   c002b764 <debug_panic>

  lock_init (&a);
c002f4e7:	83 ec 0c             	sub    $0xc,%esp
c002f4ea:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f4ed:	50                   	push   %eax
c002f4ee:	e8 df 42 ff ff       	call   c00237d2 <lock_init>
c002f4f3:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002f4f6:	83 ec 0c             	sub    $0xc,%esp
c002f4f9:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f4fc:	50                   	push   %eax
c002f4fd:	e8 d0 42 ff ff       	call   c00237d2 <lock_init>
c002f502:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002f505:	83 ec 0c             	sub    $0xc,%esp
c002f508:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f50b:	50                   	push   %eax
c002f50c:	e8 26 43 ff ff       	call   c0023837 <lock_acquire>
c002f511:	83 c4 10             	add    $0x10,%esp

  locks.a = &a;
c002f514:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f517:	89 45 c0             	mov    %eax,-0x40(%ebp)
  locks.b = &b;
c002f51a:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f51d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002f520:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002f523:	50                   	push   %eax
c002f524:	8d 83 64 52 ff ff    	lea    -0xad9c(%ebx),%eax
c002f52a:	50                   	push   %eax
c002f52b:	6a 20                	push   $0x20
c002f52d:	8d 83 52 a9 ff ff    	lea    -0x56ae(%ebx),%eax
c002f533:	50                   	push   %eax
c002f534:	e8 6b 1b ff ff       	call   c00210a4 <thread_create>
c002f539:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002f53c:	e8 79 1f ff ff       	call   c00214ba <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002f541:	e8 b6 21 ff ff       	call   c00216fc <thread_get_priority>
c002f546:	83 ec 04             	sub    $0x4,%esp
c002f549:	50                   	push   %eax
c002f54a:	6a 20                	push   $0x20
c002f54c:	8d 83 5c a9 ff ff    	lea    -0x56a4(%ebx),%eax
c002f552:	50                   	push   %eax
c002f553:	e8 d0 ec ff ff       	call   c002e228 <msg>
c002f558:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002f55b:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002f55e:	50                   	push   %eax
c002f55f:	8d 83 22 53 ff ff    	lea    -0xacde(%ebx),%eax
c002f565:	50                   	push   %eax
c002f566:	6a 21                	push   $0x21
c002f568:	8d 83 96 a9 ff ff    	lea    -0x566a(%ebx),%eax
c002f56e:	50                   	push   %eax
c002f56f:	e8 30 1b ff ff       	call   c00210a4 <thread_create>
c002f574:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002f577:	e8 3e 1f ff ff       	call   c00214ba <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002f57c:	e8 7b 21 ff ff       	call   c00216fc <thread_get_priority>
c002f581:	83 ec 04             	sub    $0x4,%esp
c002f584:	50                   	push   %eax
c002f585:	6a 21                	push   $0x21
c002f587:	8d 83 5c a9 ff ff    	lea    -0x56a4(%ebx),%eax
c002f58d:	50                   	push   %eax
c002f58e:	e8 95 ec ff ff       	call   c002e228 <msg>
c002f593:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&a);
c002f596:	83 ec 0c             	sub    $0xc,%esp
c002f599:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f59c:	50                   	push   %eax
c002f59d:	e8 43 45 ff ff       	call   c0023ae5 <lock_release>
c002f5a2:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002f5a5:	e8 10 1f ff ff       	call   c00214ba <thread_yield>
  msg ("Medium thread should just have finished.");
c002f5aa:	83 ec 0c             	sub    $0xc,%esp
c002f5ad:	8d 83 9c a9 ff ff    	lea    -0x5664(%ebx),%eax
c002f5b3:	50                   	push   %eax
c002f5b4:	e8 6f ec ff ff       	call   c002e228 <msg>
c002f5b9:	83 c4 10             	add    $0x10,%esp
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002f5bc:	e8 3b 21 ff ff       	call   c00216fc <thread_get_priority>
c002f5c1:	83 ec 04             	sub    $0x4,%esp
c002f5c4:	50                   	push   %eax
c002f5c5:	6a 1f                	push   $0x1f
c002f5c7:	8d 83 5c a9 ff ff    	lea    -0x56a4(%ebx),%eax
c002f5cd:	50                   	push   %eax
c002f5ce:	e8 55 ec ff ff       	call   c002e228 <msg>
c002f5d3:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002f5d6:	90                   	nop
c002f5d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f5da:	c9                   	leave  
c002f5db:	c3                   	ret    

c002f5dc <medium_thread_func>:

static void
medium_thread_func (void *locks_) 
{
c002f5dc:	55                   	push   %ebp
c002f5dd:	89 e5                	mov    %esp,%ebp
c002f5df:	53                   	push   %ebx
c002f5e0:	83 ec 14             	sub    $0x14,%esp
c002f5e3:	e8 44 1e 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f5e8:	81 c3 90 ad 00 00    	add    $0xad90,%ebx
  struct locks *locks = locks_;
c002f5ee:	8b 45 08             	mov    0x8(%ebp),%eax
c002f5f1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (locks->b);
c002f5f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f5f7:	8b 40 04             	mov    0x4(%eax),%eax
c002f5fa:	83 ec 0c             	sub    $0xc,%esp
c002f5fd:	50                   	push   %eax
c002f5fe:	e8 34 42 ff ff       	call   c0023837 <lock_acquire>
c002f603:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->a);
c002f606:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f609:	8b 00                	mov    (%eax),%eax
c002f60b:	83 ec 0c             	sub    $0xc,%esp
c002f60e:	50                   	push   %eax
c002f60f:	e8 23 42 ff ff       	call   c0023837 <lock_acquire>
c002f614:	83 c4 10             	add    $0x10,%esp

  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002f617:	e8 e0 20 ff ff       	call   c00216fc <thread_get_priority>
c002f61c:	83 ec 04             	sub    $0x4,%esp
c002f61f:	50                   	push   %eax
c002f620:	6a 21                	push   $0x21
c002f622:	8d 83 c8 a9 ff ff    	lea    -0x5638(%ebx),%eax
c002f628:	50                   	push   %eax
c002f629:	e8 fa eb ff ff       	call   c002e228 <msg>
c002f62e:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  msg ("Medium thread got the lock.");
c002f631:	83 ec 0c             	sub    $0xc,%esp
c002f634:	8d 83 05 aa ff ff    	lea    -0x55fb(%ebx),%eax
c002f63a:	50                   	push   %eax
c002f63b:	e8 e8 eb ff ff       	call   c002e228 <msg>
c002f640:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->a);
c002f643:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f646:	8b 00                	mov    (%eax),%eax
c002f648:	83 ec 0c             	sub    $0xc,%esp
c002f64b:	50                   	push   %eax
c002f64c:	e8 94 44 ff ff       	call   c0023ae5 <lock_release>
c002f651:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002f654:	e8 61 1e ff ff       	call   c00214ba <thread_yield>

  lock_release (locks->b);
c002f659:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f65c:	8b 40 04             	mov    0x4(%eax),%eax
c002f65f:	83 ec 0c             	sub    $0xc,%esp
c002f662:	50                   	push   %eax
c002f663:	e8 7d 44 ff ff       	call   c0023ae5 <lock_release>
c002f668:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002f66b:	e8 4a 1e ff ff       	call   c00214ba <thread_yield>

  msg ("High thread should have just finished.");
c002f670:	83 ec 0c             	sub    $0xc,%esp
c002f673:	8d 83 24 aa ff ff    	lea    -0x55dc(%ebx),%eax
c002f679:	50                   	push   %eax
c002f67a:	e8 a9 eb ff ff       	call   c002e228 <msg>
c002f67f:	83 c4 10             	add    $0x10,%esp
  msg ("Middle thread finished.");
c002f682:	83 ec 0c             	sub    $0xc,%esp
c002f685:	8d 83 4b aa ff ff    	lea    -0x55b5(%ebx),%eax
c002f68b:	50                   	push   %eax
c002f68c:	e8 97 eb ff ff       	call   c002e228 <msg>
c002f691:	83 c4 10             	add    $0x10,%esp
}
c002f694:	90                   	nop
c002f695:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f698:	c9                   	leave  
c002f699:	c3                   	ret    

c002f69a <high_thread_func>:

static void
high_thread_func (void *lock_) 
{
c002f69a:	55                   	push   %ebp
c002f69b:	89 e5                	mov    %esp,%ebp
c002f69d:	53                   	push   %ebx
c002f69e:	83 ec 14             	sub    $0x14,%esp
c002f6a1:	e8 86 1d 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f6a6:	81 c3 d2 ac 00 00    	add    $0xacd2,%ebx
  struct lock *lock = lock_;
c002f6ac:	8b 45 08             	mov    0x8(%ebp),%eax
c002f6af:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002f6b2:	83 ec 0c             	sub    $0xc,%esp
c002f6b5:	ff 75 f4             	push   -0xc(%ebp)
c002f6b8:	e8 7a 41 ff ff       	call   c0023837 <lock_acquire>
c002f6bd:	83 c4 10             	add    $0x10,%esp
  msg ("High thread got the lock.");
c002f6c0:	83 ec 0c             	sub    $0xc,%esp
c002f6c3:	8d 83 63 aa ff ff    	lea    -0x559d(%ebx),%eax
c002f6c9:	50                   	push   %eax
c002f6ca:	e8 59 eb ff ff       	call   c002e228 <msg>
c002f6cf:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002f6d2:	83 ec 0c             	sub    $0xc,%esp
c002f6d5:	ff 75 f4             	push   -0xc(%ebp)
c002f6d8:	e8 08 44 ff ff       	call   c0023ae5 <lock_release>
c002f6dd:	83 c4 10             	add    $0x10,%esp
  msg ("High thread finished.");
c002f6e0:	83 ec 0c             	sub    $0xc,%esp
c002f6e3:	8d 83 7d aa ff ff    	lea    -0x5583(%ebx),%eax
c002f6e9:	50                   	push   %eax
c002f6ea:	e8 39 eb ff ff       	call   c002e228 <msg>
c002f6ef:	83 c4 10             	add    $0x10,%esp
}
c002f6f2:	90                   	nop
c002f6f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f6f6:	c9                   	leave  
c002f6f7:	c3                   	ret    

c002f6f8 <test_priority_donate_sema>:
static thread_func m_thread_func;
static thread_func h_thread_func;

void
test_priority_donate_sema (void) 
{
c002f6f8:	55                   	push   %ebp
c002f6f9:	89 e5                	mov    %esp,%ebp
c002f6fb:	53                   	push   %ebx
c002f6fc:	83 ec 34             	sub    $0x34,%esp
c002f6ff:	e8 28 1d 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f704:	81 c3 74 ac 00 00    	add    $0xac74,%ebx
  struct lock_and_sema ls;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002f70a:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002f710:	0f b6 00             	movzbl (%eax),%eax
c002f713:	83 f0 01             	xor    $0x1,%eax
c002f716:	84 c0                	test   %al,%al
c002f718:	75 26                	jne    c002f740 <test_priority_donate_sema+0x48>
c002f71a:	83 ec 0c             	sub    $0xc,%esp
c002f71d:	8d 83 b0 aa ff ff    	lea    -0x5550(%ebx),%eax
c002f723:	50                   	push   %eax
c002f724:	8d 83 be aa ff ff    	lea    -0x5542(%ebx),%eax
c002f72a:	50                   	push   %eax
c002f72b:	8d 83 d4 ab ff ff    	lea    -0x542c(%ebx),%eax
c002f731:	50                   	push   %eax
c002f732:	6a 23                	push   $0x23
c002f734:	8d 83 d8 aa ff ff    	lea    -0x5528(%ebx),%eax
c002f73a:	50                   	push   %eax
c002f73b:	e8 24 c0 ff ff       	call   c002b764 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002f740:	e8 b7 1f ff ff       	call   c00216fc <thread_get_priority>
c002f745:	83 f8 1f             	cmp    $0x1f,%eax
c002f748:	74 26                	je     c002f770 <test_priority_donate_sema+0x78>
c002f74a:	83 ec 0c             	sub    $0xc,%esp
c002f74d:	8d 83 04 ab ff ff    	lea    -0x54fc(%ebx),%eax
c002f753:	50                   	push   %eax
c002f754:	8d 83 be aa ff ff    	lea    -0x5542(%ebx),%eax
c002f75a:	50                   	push   %eax
c002f75b:	8d 83 d4 ab ff ff    	lea    -0x542c(%ebx),%eax
c002f761:	50                   	push   %eax
c002f762:	6a 26                	push   $0x26
c002f764:	8d 83 d8 aa ff ff    	lea    -0x5528(%ebx),%eax
c002f76a:	50                   	push   %eax
c002f76b:	e8 f4 bf ff ff       	call   c002b764 <debug_panic>

  lock_init (&ls.lock);
c002f770:	83 ec 0c             	sub    $0xc,%esp
c002f773:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002f776:	50                   	push   %eax
c002f777:	e8 56 40 ff ff       	call   c00237d2 <lock_init>
c002f77c:	83 c4 10             	add    $0x10,%esp
  sema_init (&ls.sema, 0);
c002f77f:	83 ec 08             	sub    $0x8,%esp
c002f782:	6a 00                	push   $0x0
c002f784:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002f787:	83 c0 18             	add    $0x18,%eax
c002f78a:	50                   	push   %eax
c002f78b:	e8 de 3c ff ff       	call   c002346e <sema_init>
c002f790:	83 c4 10             	add    $0x10,%esp
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002f793:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002f796:	50                   	push   %eax
c002f797:	8d 83 99 54 ff ff    	lea    -0xab67(%ebx),%eax
c002f79d:	50                   	push   %eax
c002f79e:	6a 20                	push   $0x20
c002f7a0:	8d 83 2a ab ff ff    	lea    -0x54d6(%ebx),%eax
c002f7a6:	50                   	push   %eax
c002f7a7:	e8 f8 18 ff ff       	call   c00210a4 <thread_create>
c002f7ac:	83 c4 10             	add    $0x10,%esp
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002f7af:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002f7b2:	50                   	push   %eax
c002f7b3:	8d 83 1d 55 ff ff    	lea    -0xaae3(%ebx),%eax
c002f7b9:	50                   	push   %eax
c002f7ba:	6a 22                	push   $0x22
c002f7bc:	8d 83 2e ab ff ff    	lea    -0x54d2(%ebx),%eax
c002f7c2:	50                   	push   %eax
c002f7c3:	e8 dc 18 ff ff       	call   c00210a4 <thread_create>
c002f7c8:	83 c4 10             	add    $0x10,%esp
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002f7cb:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002f7ce:	50                   	push   %eax
c002f7cf:	8d 83 5f 55 ff ff    	lea    -0xaaa1(%ebx),%eax
c002f7d5:	50                   	push   %eax
c002f7d6:	6a 24                	push   $0x24
c002f7d8:	8d 83 32 ab ff ff    	lea    -0x54ce(%ebx),%eax
c002f7de:	50                   	push   %eax
c002f7df:	e8 c0 18 ff ff       	call   c00210a4 <thread_create>
c002f7e4:	83 c4 10             	add    $0x10,%esp
  sema_up (&ls.sema);
c002f7e7:	83 ec 0c             	sub    $0xc,%esp
c002f7ea:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002f7ed:	83 c0 18             	add    $0x18,%eax
c002f7f0:	50                   	push   %eax
c002f7f1:	e8 1a 3e ff ff       	call   c0023610 <sema_up>
c002f7f6:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread finished.");
c002f7f9:	83 ec 0c             	sub    $0xc,%esp
c002f7fc:	8d 83 37 ab ff ff    	lea    -0x54c9(%ebx),%eax
c002f802:	50                   	push   %eax
c002f803:	e8 20 ea ff ff       	call   c002e228 <msg>
c002f808:	83 c4 10             	add    $0x10,%esp
}
c002f80b:	90                   	nop
c002f80c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f80f:	c9                   	leave  
c002f810:	c3                   	ret    

c002f811 <l_thread_func>:

static void
l_thread_func (void *ls_) 
{
c002f811:	55                   	push   %ebp
c002f812:	89 e5                	mov    %esp,%ebp
c002f814:	53                   	push   %ebx
c002f815:	83 ec 14             	sub    $0x14,%esp
c002f818:	e8 0f 1c 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f81d:	81 c3 5b ab 00 00    	add    $0xab5b,%ebx
  struct lock_and_sema *ls = ls_;
c002f823:	8b 45 08             	mov    0x8(%ebp),%eax
c002f826:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002f829:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f82c:	83 ec 0c             	sub    $0xc,%esp
c002f82f:	50                   	push   %eax
c002f830:	e8 02 40 ff ff       	call   c0023837 <lock_acquire>
c002f835:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L acquired lock.");
c002f838:	83 ec 0c             	sub    $0xc,%esp
c002f83b:	8d 83 4d ab ff ff    	lea    -0x54b3(%ebx),%eax
c002f841:	50                   	push   %eax
c002f842:	e8 e1 e9 ff ff       	call   c002e228 <msg>
c002f847:	83 c4 10             	add    $0x10,%esp
  sema_down (&ls->sema);
c002f84a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f84d:	83 c0 18             	add    $0x18,%eax
c002f850:	83 ec 0c             	sub    $0xc,%esp
c002f853:	50                   	push   %eax
c002f854:	e8 76 3c ff ff       	call   c00234cf <sema_down>
c002f859:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L downed semaphore.");
c002f85c:	83 ec 0c             	sub    $0xc,%esp
c002f85f:	8d 83 65 ab ff ff    	lea    -0x549b(%ebx),%eax
c002f865:	50                   	push   %eax
c002f866:	e8 bd e9 ff ff       	call   c002e228 <msg>
c002f86b:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002f86e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f871:	83 ec 0c             	sub    $0xc,%esp
c002f874:	50                   	push   %eax
c002f875:	e8 6b 42 ff ff       	call   c0023ae5 <lock_release>
c002f87a:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L finished.");
c002f87d:	83 ec 0c             	sub    $0xc,%esp
c002f880:	8d 83 80 ab ff ff    	lea    -0x5480(%ebx),%eax
c002f886:	50                   	push   %eax
c002f887:	e8 9c e9 ff ff       	call   c002e228 <msg>
c002f88c:	83 c4 10             	add    $0x10,%esp
}
c002f88f:	90                   	nop
c002f890:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f893:	c9                   	leave  
c002f894:	c3                   	ret    

c002f895 <m_thread_func>:

static void
m_thread_func (void *ls_) 
{
c002f895:	55                   	push   %ebp
c002f896:	89 e5                	mov    %esp,%ebp
c002f898:	53                   	push   %ebx
c002f899:	83 ec 14             	sub    $0x14,%esp
c002f89c:	e8 8b 1b 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f8a1:	81 c3 d7 aa 00 00    	add    $0xaad7,%ebx
  struct lock_and_sema *ls = ls_;
c002f8a7:	8b 45 08             	mov    0x8(%ebp),%eax
c002f8aa:	89 45 f4             	mov    %eax,-0xc(%ebp)

  sema_down (&ls->sema);
c002f8ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f8b0:	83 c0 18             	add    $0x18,%eax
c002f8b3:	83 ec 0c             	sub    $0xc,%esp
c002f8b6:	50                   	push   %eax
c002f8b7:	e8 13 3c ff ff       	call   c00234cf <sema_down>
c002f8bc:	83 c4 10             	add    $0x10,%esp
  msg ("Thread M finished.");
c002f8bf:	83 ec 0c             	sub    $0xc,%esp
c002f8c2:	8d 83 93 ab ff ff    	lea    -0x546d(%ebx),%eax
c002f8c8:	50                   	push   %eax
c002f8c9:	e8 5a e9 ff ff       	call   c002e228 <msg>
c002f8ce:	83 c4 10             	add    $0x10,%esp
}
c002f8d1:	90                   	nop
c002f8d2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f8d5:	c9                   	leave  
c002f8d6:	c3                   	ret    

c002f8d7 <h_thread_func>:

static void
h_thread_func (void *ls_) 
{
c002f8d7:	55                   	push   %ebp
c002f8d8:	89 e5                	mov    %esp,%ebp
c002f8da:	53                   	push   %ebx
c002f8db:	83 ec 14             	sub    $0x14,%esp
c002f8de:	e8 49 1b 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f8e3:	81 c3 95 aa 00 00    	add    $0xaa95,%ebx
  struct lock_and_sema *ls = ls_;
c002f8e9:	8b 45 08             	mov    0x8(%ebp),%eax
c002f8ec:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002f8ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f8f2:	83 ec 0c             	sub    $0xc,%esp
c002f8f5:	50                   	push   %eax
c002f8f6:	e8 3c 3f ff ff       	call   c0023837 <lock_acquire>
c002f8fb:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H acquired lock.");
c002f8fe:	83 ec 0c             	sub    $0xc,%esp
c002f901:	8d 83 a6 ab ff ff    	lea    -0x545a(%ebx),%eax
c002f907:	50                   	push   %eax
c002f908:	e8 1b e9 ff ff       	call   c002e228 <msg>
c002f90d:	83 c4 10             	add    $0x10,%esp

  sema_up (&ls->sema);
c002f910:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f913:	83 c0 18             	add    $0x18,%eax
c002f916:	83 ec 0c             	sub    $0xc,%esp
c002f919:	50                   	push   %eax
c002f91a:	e8 f1 3c ff ff       	call   c0023610 <sema_up>
c002f91f:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002f922:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f925:	83 ec 0c             	sub    $0xc,%esp
c002f928:	50                   	push   %eax
c002f929:	e8 b7 41 ff ff       	call   c0023ae5 <lock_release>
c002f92e:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H finished.");
c002f931:	83 ec 0c             	sub    $0xc,%esp
c002f934:	8d 83 be ab ff ff    	lea    -0x5442(%ebx),%eax
c002f93a:	50                   	push   %eax
c002f93b:	e8 e8 e8 ff ff       	call   c002e228 <msg>
c002f940:	83 c4 10             	add    $0x10,%esp
}
c002f943:	90                   	nop
c002f944:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f947:	c9                   	leave  
c002f948:	c3                   	ret    

c002f949 <test_priority_donate_lower>:

static thread_func acquire_thread_func;

void
test_priority_donate_lower (void) 
{
c002f949:	55                   	push   %ebp
c002f94a:	89 e5                	mov    %esp,%ebp
c002f94c:	53                   	push   %ebx
c002f94d:	83 ec 24             	sub    $0x24,%esp
c002f950:	e8 d7 1a 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002f955:	81 c3 23 aa 00 00    	add    $0xaa23,%ebx
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002f95b:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002f961:	0f b6 00             	movzbl (%eax),%eax
c002f964:	83 f0 01             	xor    $0x1,%eax
c002f967:	84 c0                	test   %al,%al
c002f969:	75 26                	jne    c002f991 <test_priority_donate_lower+0x48>
c002f96b:	83 ec 0c             	sub    $0xc,%esp
c002f96e:	8d 83 f0 ab ff ff    	lea    -0x5410(%ebx),%eax
c002f974:	50                   	push   %eax
c002f975:	8d 83 fe ab ff ff    	lea    -0x5402(%ebx),%eax
c002f97b:	50                   	push   %eax
c002f97c:	8d 83 14 ad ff ff    	lea    -0x52ec(%ebx),%eax
c002f982:	50                   	push   %eax
c002f983:	6a 15                	push   $0x15
c002f985:	8d 83 18 ac ff ff    	lea    -0x53e8(%ebx),%eax
c002f98b:	50                   	push   %eax
c002f98c:	e8 d3 bd ff ff       	call   c002b764 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002f991:	e8 66 1d ff ff       	call   c00216fc <thread_get_priority>
c002f996:	83 f8 1f             	cmp    $0x1f,%eax
c002f999:	74 26                	je     c002f9c1 <test_priority_donate_lower+0x78>
c002f99b:	83 ec 0c             	sub    $0xc,%esp
c002f99e:	8d 83 44 ac ff ff    	lea    -0x53bc(%ebx),%eax
c002f9a4:	50                   	push   %eax
c002f9a5:	8d 83 fe ab ff ff    	lea    -0x5402(%ebx),%eax
c002f9ab:	50                   	push   %eax
c002f9ac:	8d 83 14 ad ff ff    	lea    -0x52ec(%ebx),%eax
c002f9b2:	50                   	push   %eax
c002f9b3:	6a 18                	push   $0x18
c002f9b5:	8d 83 18 ac ff ff    	lea    -0x53e8(%ebx),%eax
c002f9bb:	50                   	push   %eax
c002f9bc:	e8 a3 bd ff ff       	call   c002b764 <debug_panic>

  lock_init (&lock);
c002f9c1:	83 ec 0c             	sub    $0xc,%esp
c002f9c4:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f9c7:	50                   	push   %eax
c002f9c8:	e8 05 3e ff ff       	call   c00237d2 <lock_init>
c002f9cd:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002f9d0:	83 ec 0c             	sub    $0xc,%esp
c002f9d3:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f9d6:	50                   	push   %eax
c002f9d7:	e8 5b 3e ff ff       	call   c0023837 <lock_acquire>
c002f9dc:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002f9df:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002f9e2:	50                   	push   %eax
c002f9e3:	8d 83 17 57 ff ff    	lea    -0xa8e9(%ebx),%eax
c002f9e9:	50                   	push   %eax
c002f9ea:	6a 29                	push   $0x29
c002f9ec:	8d 83 6a ac ff ff    	lea    -0x5396(%ebx),%eax
c002f9f2:	50                   	push   %eax
c002f9f3:	e8 ac 16 ff ff       	call   c00210a4 <thread_create>
c002f9f8:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002f9fb:	e8 fc 1c ff ff       	call   c00216fc <thread_get_priority>
c002fa00:	83 ec 04             	sub    $0x4,%esp
c002fa03:	50                   	push   %eax
c002fa04:	6a 29                	push   $0x29
c002fa06:	8d 83 74 ac ff ff    	lea    -0x538c(%ebx),%eax
c002fa0c:	50                   	push   %eax
c002fa0d:	e8 16 e8 ff ff       	call   c002e228 <msg>
c002fa12:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());

  msg ("Lowering base priority...");
c002fa15:	83 ec 0c             	sub    $0xc,%esp
c002fa18:	8d 83 af ac ff ff    	lea    -0x5351(%ebx),%eax
c002fa1e:	50                   	push   %eax
c002fa1f:	e8 04 e8 ff ff       	call   c002e228 <msg>
c002fa24:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 10);
c002fa27:	83 ec 0c             	sub    $0xc,%esp
c002fa2a:	6a 15                	push   $0x15
c002fa2c:	e8 e9 1b ff ff       	call   c002161a <thread_set_priority>
c002fa31:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002fa34:	e8 c3 1c ff ff       	call   c00216fc <thread_get_priority>
c002fa39:	83 ec 04             	sub    $0x4,%esp
c002fa3c:	50                   	push   %eax
c002fa3d:	6a 29                	push   $0x29
c002fa3f:	8d 83 74 ac ff ff    	lea    -0x538c(%ebx),%eax
c002fa45:	50                   	push   %eax
c002fa46:	e8 dd e7 ff ff       	call   c002e228 <msg>
c002fa4b:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());
  lock_release (&lock);
c002fa4e:	83 ec 0c             	sub    $0xc,%esp
c002fa51:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002fa54:	50                   	push   %eax
c002fa55:	e8 8b 40 ff ff       	call   c0023ae5 <lock_release>
c002fa5a:	83 c4 10             	add    $0x10,%esp
  msg ("acquire must already have finished.");
c002fa5d:	83 ec 0c             	sub    $0xc,%esp
c002fa60:	8d 83 cc ac ff ff    	lea    -0x5334(%ebx),%eax
c002fa66:	50                   	push   %eax
c002fa67:	e8 bc e7 ff ff       	call   c002e228 <msg>
c002fa6c:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002fa6f:	e8 88 1c ff ff       	call   c00216fc <thread_get_priority>
c002fa74:	83 ec 04             	sub    $0x4,%esp
c002fa77:	50                   	push   %eax
c002fa78:	6a 15                	push   $0x15
c002fa7a:	8d 83 74 ac ff ff    	lea    -0x538c(%ebx),%eax
c002fa80:	50                   	push   %eax
c002fa81:	e8 a2 e7 ff ff       	call   c002e228 <msg>
c002fa86:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT - 10, thread_get_priority ());
}
c002fa89:	90                   	nop
c002fa8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002fa8d:	c9                   	leave  
c002fa8e:	c3                   	ret    

c002fa8f <acquire_thread_func>:

static void
acquire_thread_func (void *lock_) 
{
c002fa8f:	55                   	push   %ebp
c002fa90:	89 e5                	mov    %esp,%ebp
c002fa92:	53                   	push   %ebx
c002fa93:	83 ec 14             	sub    $0x14,%esp
c002fa96:	e8 91 19 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002fa9b:	81 c3 dd a8 00 00    	add    $0xa8dd,%ebx
  struct lock *lock = lock_;
c002faa1:	8b 45 08             	mov    0x8(%ebp),%eax
c002faa4:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002faa7:	83 ec 0c             	sub    $0xc,%esp
c002faaa:	ff 75 f4             	push   -0xc(%ebp)
c002faad:	e8 85 3d ff ff       	call   c0023837 <lock_acquire>
c002fab2:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: got the lock");
c002fab5:	83 ec 0c             	sub    $0xc,%esp
c002fab8:	8d 83 f0 ac ff ff    	lea    -0x5310(%ebx),%eax
c002fabe:	50                   	push   %eax
c002fabf:	e8 64 e7 ff ff       	call   c002e228 <msg>
c002fac4:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002fac7:	83 ec 0c             	sub    $0xc,%esp
c002faca:	ff 75 f4             	push   -0xc(%ebp)
c002facd:	e8 13 40 ff ff       	call   c0023ae5 <lock_release>
c002fad2:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: done");
c002fad5:	83 ec 0c             	sub    $0xc,%esp
c002fad8:	8d 83 06 ad ff ff    	lea    -0x52fa(%ebx),%eax
c002fade:	50                   	push   %eax
c002fadf:	e8 44 e7 ff ff       	call   c002e228 <msg>
c002fae4:	83 c4 10             	add    $0x10,%esp
}
c002fae7:	90                   	nop
c002fae8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002faeb:	c9                   	leave  
c002faec:	c3                   	ret    

c002faed <test_priority_fifo>:

static thread_func simple_thread_func;

void
test_priority_fifo (void) 
{
c002faed:	55                   	push   %ebp
c002faee:	89 e5                	mov    %esp,%ebp
c002faf0:	53                   	push   %ebx
c002faf1:	81 ec 44 01 00 00    	sub    $0x144,%esp
c002faf7:	e8 30 19 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002fafc:	81 c3 7c a8 00 00    	add    $0xa87c,%ebx
  struct lock lock;
  int *output, *op;
  int i, cnt;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002fb02:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002fb08:	0f b6 00             	movzbl (%eax),%eax
c002fb0b:	83 f0 01             	xor    $0x1,%eax
c002fb0e:	84 c0                	test   %al,%al
c002fb10:	75 26                	jne    c002fb38 <test_priority_fifo+0x4b>
c002fb12:	83 ec 0c             	sub    $0xc,%esp
c002fb15:	8d 83 30 ad ff ff    	lea    -0x52d0(%ebx),%eax
c002fb1b:	50                   	push   %eax
c002fb1c:	8d 83 3e ad ff ff    	lea    -0x52c2(%ebx),%eax
c002fb22:	50                   	push   %eax
c002fb23:	8d 83 78 ae ff ff    	lea    -0x5188(%ebx),%eax
c002fb29:	50                   	push   %eax
c002fb2a:	6a 28                	push   $0x28
c002fb2c:	8d 83 58 ad ff ff    	lea    -0x52a8(%ebx),%eax
c002fb32:	50                   	push   %eax
c002fb33:	e8 2c bc ff ff       	call   c002b764 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002fb38:	e8 bf 1b ff ff       	call   c00216fc <thread_get_priority>
c002fb3d:	83 f8 1f             	cmp    $0x1f,%eax
c002fb40:	74 26                	je     c002fb68 <test_priority_fifo+0x7b>
c002fb42:	83 ec 0c             	sub    $0xc,%esp
c002fb45:	8d 83 7c ad ff ff    	lea    -0x5284(%ebx),%eax
c002fb4b:	50                   	push   %eax
c002fb4c:	8d 83 3e ad ff ff    	lea    -0x52c2(%ebx),%eax
c002fb52:	50                   	push   %eax
c002fb53:	8d 83 78 ae ff ff    	lea    -0x5188(%ebx),%eax
c002fb59:	50                   	push   %eax
c002fb5a:	6a 2b                	push   $0x2b
c002fb5c:	8d 83 58 ad ff ff    	lea    -0x52a8(%ebx),%eax
c002fb62:	50                   	push   %eax
c002fb63:	e8 fc bb ff ff       	call   c002b764 <debug_panic>

  msg ("%d threads will iterate %d times in the same order each time.",
c002fb68:	83 ec 04             	sub    $0x4,%esp
c002fb6b:	6a 10                	push   $0x10
c002fb6d:	6a 10                	push   $0x10
c002fb6f:	8d 83 a4 ad ff ff    	lea    -0x525c(%ebx),%eax
c002fb75:	50                   	push   %eax
c002fb76:	e8 ad e6 ff ff       	call   c002e228 <msg>
c002fb7b:	83 c4 10             	add    $0x10,%esp
       THREAD_CNT, ITER_CNT);
  msg ("If the order varies then there is a bug.");
c002fb7e:	83 ec 0c             	sub    $0xc,%esp
c002fb81:	8d 83 e4 ad ff ff    	lea    -0x521c(%ebx),%eax
c002fb87:	50                   	push   %eax
c002fb88:	e8 9b e6 ff ff       	call   c002e228 <msg>
c002fb8d:	83 c4 10             	add    $0x10,%esp

  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002fb90:	83 ec 0c             	sub    $0xc,%esp
c002fb93:	68 00 08 00 00       	push   $0x800
c002fb98:	e8 76 4b ff ff       	call   c0024713 <malloc>
c002fb9d:	83 c4 10             	add    $0x10,%esp
c002fba0:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
c002fba6:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002fbac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (output != NULL);
c002fbaf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002fbb3:	75 26                	jne    c002fbdb <test_priority_fifo+0xee>
c002fbb5:	83 ec 0c             	sub    $0xc,%esp
c002fbb8:	8d 83 0d ae ff ff    	lea    -0x51f3(%ebx),%eax
c002fbbe:	50                   	push   %eax
c002fbbf:	8d 83 3e ad ff ff    	lea    -0x52c2(%ebx),%eax
c002fbc5:	50                   	push   %eax
c002fbc6:	8d 83 78 ae ff ff    	lea    -0x5188(%ebx),%eax
c002fbcc:	50                   	push   %eax
c002fbcd:	6a 32                	push   $0x32
c002fbcf:	8d 83 58 ad ff ff    	lea    -0x52a8(%ebx),%eax
c002fbd5:	50                   	push   %eax
c002fbd6:	e8 89 bb ff ff       	call   c002b764 <debug_panic>
  lock_init (&lock);
c002fbdb:	83 ec 0c             	sub    $0xc,%esp
c002fbde:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
c002fbe4:	50                   	push   %eax
c002fbe5:	e8 e8 3b ff ff       	call   c00237d2 <lock_init>
c002fbea:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_DEFAULT + 2);
c002fbed:	83 ec 0c             	sub    $0xc,%esp
c002fbf0:	6a 21                	push   $0x21
c002fbf2:	e8 23 1a ff ff       	call   c002161a <thread_set_priority>
c002fbf7:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002fbfa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002fc01:	eb 77                	jmp    c002fc7a <test_priority_fifo+0x18d>
    {
      char name[16];
      struct simple_thread_data *d = data + i;
c002fc03:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002fc06:	c1 e0 04             	shl    $0x4,%eax
c002fc09:	89 c2                	mov    %eax,%edx
c002fc0b:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002fc11:	01 d0                	add    %edx,%eax
c002fc13:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      snprintf (name, sizeof name, "%d", i);
c002fc16:	ff 75 f0             	push   -0x10(%ebp)
c002fc19:	8d 83 1c ae ff ff    	lea    -0x51e4(%ebx),%eax
c002fc1f:	50                   	push   %eax
c002fc20:	6a 10                	push   $0x10
c002fc22:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002fc28:	50                   	push   %eax
c002fc29:	e8 84 92 ff ff       	call   c0028eb2 <snprintf>
c002fc2e:	83 c4 10             	add    $0x10,%esp
      d->id = i;
c002fc31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002fc34:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002fc37:	89 10                	mov    %edx,(%eax)
      d->iterations = 0;
c002fc39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002fc3c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      d->lock = &lock;
c002fc43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002fc46:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
c002fc4c:	89 50 08             	mov    %edx,0x8(%eax)
      d->op = &op;
c002fc4f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002fc52:	8d 95 c8 fe ff ff    	lea    -0x138(%ebp),%edx
c002fc58:	89 50 0c             	mov    %edx,0xc(%eax)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002fc5b:	ff 75 e4             	push   -0x1c(%ebp)
c002fc5e:	8d 83 17 5a ff ff    	lea    -0xa5e9(%ebx),%eax
c002fc64:	50                   	push   %eax
c002fc65:	6a 20                	push   $0x20
c002fc67:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002fc6d:	50                   	push   %eax
c002fc6e:	e8 31 14 ff ff       	call   c00210a4 <thread_create>
c002fc73:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002fc76:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002fc7a:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c002fc7e:	7e 83                	jle    c002fc03 <test_priority_fifo+0x116>
    }

  thread_set_priority (PRI_DEFAULT);
c002fc80:	83 ec 0c             	sub    $0xc,%esp
c002fc83:	6a 1f                	push   $0x1f
c002fc85:	e8 90 19 ff ff       	call   c002161a <thread_set_priority>
c002fc8a:	83 c4 10             	add    $0x10,%esp
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);
c002fc8d:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
c002fc93:	85 c0                	test   %eax,%eax
c002fc95:	74 26                	je     c002fcbd <test_priority_fifo+0x1d0>
c002fc97:	83 ec 0c             	sub    $0xc,%esp
c002fc9a:	8d 83 1f ae ff ff    	lea    -0x51e1(%ebx),%eax
c002fca0:	50                   	push   %eax
c002fca1:	8d 83 3e ad ff ff    	lea    -0x52c2(%ebx),%eax
c002fca7:	50                   	push   %eax
c002fca8:	8d 83 78 ae ff ff    	lea    -0x5188(%ebx),%eax
c002fcae:	50                   	push   %eax
c002fcaf:	6a 44                	push   $0x44
c002fcb1:	8d 83 58 ad ff ff    	lea    -0x52a8(%ebx),%eax
c002fcb7:	50                   	push   %eax
c002fcb8:	e8 a7 ba ff ff       	call   c002b764 <debug_panic>

  cnt = 0;
c002fcbd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  for (; output < op; output++) 
c002fcc4:	e9 b0 00 00 00       	jmp    c002fd79 <test_priority_fifo+0x28c>
    {
      struct simple_thread_data *d;

      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002fcc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002fccc:	8b 00                	mov    (%eax),%eax
c002fcce:	85 c0                	test   %eax,%eax
c002fcd0:	78 0a                	js     c002fcdc <test_priority_fifo+0x1ef>
c002fcd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002fcd5:	8b 00                	mov    (%eax),%eax
c002fcd7:	83 f8 0f             	cmp    $0xf,%eax
c002fcda:	7e 26                	jle    c002fd02 <test_priority_fifo+0x215>
c002fcdc:	83 ec 0c             	sub    $0xc,%esp
c002fcdf:	8d 83 34 ae ff ff    	lea    -0x51cc(%ebx),%eax
c002fce5:	50                   	push   %eax
c002fce6:	8d 83 3e ad ff ff    	lea    -0x52c2(%ebx),%eax
c002fcec:	50                   	push   %eax
c002fced:	8d 83 78 ae ff ff    	lea    -0x5188(%ebx),%eax
c002fcf3:	50                   	push   %eax
c002fcf4:	6a 4b                	push   $0x4b
c002fcf6:	8d 83 58 ad ff ff    	lea    -0x52a8(%ebx),%eax
c002fcfc:	50                   	push   %eax
c002fcfd:	e8 62 ba ff ff       	call   c002b764 <debug_panic>
      d = data + *output;
c002fd02:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002fd05:	8b 00                	mov    (%eax),%eax
c002fd07:	c1 e0 04             	shl    $0x4,%eax
c002fd0a:	89 c2                	mov    %eax,%edx
c002fd0c:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002fd12:	01 d0                	add    %edx,%eax
c002fd14:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (cnt % THREAD_CNT == 0)
c002fd17:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002fd1a:	83 e0 0f             	and    $0xf,%eax
c002fd1d:	85 c0                	test   %eax,%eax
c002fd1f:	75 12                	jne    c002fd33 <test_priority_fifo+0x246>
        printf ("(priority-fifo) iteration:");
c002fd21:	83 ec 0c             	sub    $0xc,%esp
c002fd24:	8d 83 59 ae ff ff    	lea    -0x51a7(%ebx),%eax
c002fd2a:	50                   	push   %eax
c002fd2b:	e8 b5 91 ff ff       	call   c0028ee5 <printf>
c002fd30:	83 c4 10             	add    $0x10,%esp
      printf (" %d", d->id);
c002fd33:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002fd36:	8b 00                	mov    (%eax),%eax
c002fd38:	83 ec 08             	sub    $0x8,%esp
c002fd3b:	50                   	push   %eax
c002fd3c:	8d 83 74 ae ff ff    	lea    -0x518c(%ebx),%eax
c002fd42:	50                   	push   %eax
c002fd43:	e8 9d 91 ff ff       	call   c0028ee5 <printf>
c002fd48:	83 c4 10             	add    $0x10,%esp
      if (++cnt % THREAD_CNT == 0)
c002fd4b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002fd4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002fd52:	83 e0 0f             	and    $0xf,%eax
c002fd55:	85 c0                	test   %eax,%eax
c002fd57:	75 0d                	jne    c002fd66 <test_priority_fifo+0x279>
        printf ("\n");
c002fd59:	83 ec 0c             	sub    $0xc,%esp
c002fd5c:	6a 0a                	push   $0xa
c002fd5e:	e8 25 e3 ff ff       	call   c002e088 <putchar>
c002fd63:	83 c4 10             	add    $0x10,%esp
      d->iterations++;
c002fd66:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002fd69:	8b 40 04             	mov    0x4(%eax),%eax
c002fd6c:	8d 50 01             	lea    0x1(%eax),%edx
c002fd6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002fd72:	89 50 04             	mov    %edx,0x4(%eax)
  for (; output < op; output++) 
c002fd75:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002fd79:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002fd7f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002fd82:	0f 82 41 ff ff ff    	jb     c002fcc9 <test_priority_fifo+0x1dc>
    }
}
c002fd88:	90                   	nop
c002fd89:	90                   	nop
c002fd8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002fd8d:	c9                   	leave  
c002fd8e:	c3                   	ret    

c002fd8f <simple_thread_func>:

static void 
simple_thread_func (void *data_) 
{
c002fd8f:	55                   	push   %ebp
c002fd90:	89 e5                	mov    %esp,%ebp
c002fd92:	53                   	push   %ebx
c002fd93:	83 ec 14             	sub    $0x14,%esp
c002fd96:	e8 91 16 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002fd9b:	81 c3 dd a5 00 00    	add    $0xa5dd,%ebx
  struct simple_thread_data *data = data_;
c002fda1:	8b 45 08             	mov    0x8(%ebp),%eax
c002fda4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002fda7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002fdae:	eb 41                	jmp    c002fdf1 <simple_thread_func+0x62>
    {
      lock_acquire (data->lock);
c002fdb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002fdb3:	8b 40 08             	mov    0x8(%eax),%eax
c002fdb6:	83 ec 0c             	sub    $0xc,%esp
c002fdb9:	50                   	push   %eax
c002fdba:	e8 78 3a ff ff       	call   c0023837 <lock_acquire>
c002fdbf:	83 c4 10             	add    $0x10,%esp
      *(*data->op)++ = data->id;
c002fdc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002fdc5:	8b 40 0c             	mov    0xc(%eax),%eax
c002fdc8:	8b 10                	mov    (%eax),%edx
c002fdca:	8d 4a 04             	lea    0x4(%edx),%ecx
c002fdcd:	89 08                	mov    %ecx,(%eax)
c002fdcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002fdd2:	8b 00                	mov    (%eax),%eax
c002fdd4:	89 02                	mov    %eax,(%edx)
      lock_release (data->lock);
c002fdd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002fdd9:	8b 40 08             	mov    0x8(%eax),%eax
c002fddc:	83 ec 0c             	sub    $0xc,%esp
c002fddf:	50                   	push   %eax
c002fde0:	e8 00 3d ff ff       	call   c0023ae5 <lock_release>
c002fde5:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002fde8:	e8 cd 16 ff ff       	call   c00214ba <thread_yield>
  for (i = 0; i < ITER_CNT; i++) 
c002fded:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002fdf1:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
c002fdf5:	7e b9                	jle    c002fdb0 <simple_thread_func+0x21>
    }
}
c002fdf7:	90                   	nop
c002fdf8:	90                   	nop
c002fdf9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002fdfc:	c9                   	leave  
c002fdfd:	c3                   	ret    

c002fdfe <test_priority_preempt>:

static thread_func simple_thread_func;

void
test_priority_preempt (void) 
{
c002fdfe:	55                   	push   %ebp
c002fdff:	89 e5                	mov    %esp,%ebp
c002fe01:	53                   	push   %ebx
c002fe02:	83 ec 04             	sub    $0x4,%esp
c002fe05:	e8 22 16 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002fe0a:	81 c3 6e a5 00 00    	add    $0xa56e,%ebx
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002fe10:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002fe16:	0f b6 00             	movzbl (%eax),%eax
c002fe19:	83 f0 01             	xor    $0x1,%eax
c002fe1c:	84 c0                	test   %al,%al
c002fe1e:	75 26                	jne    c002fe46 <test_priority_preempt+0x48>
c002fe20:	83 ec 0c             	sub    $0xc,%esp
c002fe23:	8d 83 8c ae ff ff    	lea    -0x5174(%ebx),%eax
c002fe29:	50                   	push   %eax
c002fe2a:	8d 83 9a ae ff ff    	lea    -0x5166(%ebx),%eax
c002fe30:	50                   	push   %eax
c002fe31:	8d 83 70 af ff ff    	lea    -0x5090(%ebx),%eax
c002fe37:	50                   	push   %eax
c002fe38:	6a 15                	push   $0x15
c002fe3a:	8d 83 b4 ae ff ff    	lea    -0x514c(%ebx),%eax
c002fe40:	50                   	push   %eax
c002fe41:	e8 1e b9 ff ff       	call   c002b764 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002fe46:	e8 b1 18 ff ff       	call   c00216fc <thread_get_priority>
c002fe4b:	83 f8 1f             	cmp    $0x1f,%eax
c002fe4e:	74 26                	je     c002fe76 <test_priority_preempt+0x78>
c002fe50:	83 ec 0c             	sub    $0xc,%esp
c002fe53:	8d 83 dc ae ff ff    	lea    -0x5124(%ebx),%eax
c002fe59:	50                   	push   %eax
c002fe5a:	8d 83 9a ae ff ff    	lea    -0x5166(%ebx),%eax
c002fe60:	50                   	push   %eax
c002fe61:	8d 83 70 af ff ff    	lea    -0x5090(%ebx),%eax
c002fe67:	50                   	push   %eax
c002fe68:	6a 18                	push   $0x18
c002fe6a:	8d 83 b4 ae ff ff    	lea    -0x514c(%ebx),%eax
c002fe70:	50                   	push   %eax
c002fe71:	e8 ee b8 ff ff       	call   c002b764 <debug_panic>

  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002fe76:	6a 00                	push   $0x0
c002fe78:	8d 83 30 5b ff ff    	lea    -0xa4d0(%ebx),%eax
c002fe7e:	50                   	push   %eax
c002fe7f:	6a 20                	push   $0x20
c002fe81:	8d 83 02 af ff ff    	lea    -0x50fe(%ebx),%eax
c002fe87:	50                   	push   %eax
c002fe88:	e8 17 12 ff ff       	call   c00210a4 <thread_create>
c002fe8d:	83 c4 10             	add    $0x10,%esp
  msg ("The high-priority thread should have already completed.");
c002fe90:	83 ec 0c             	sub    $0xc,%esp
c002fe93:	8d 83 10 af ff ff    	lea    -0x50f0(%ebx),%eax
c002fe99:	50                   	push   %eax
c002fe9a:	e8 89 e3 ff ff       	call   c002e228 <msg>
c002fe9f:	83 c4 10             	add    $0x10,%esp
}
c002fea2:	90                   	nop
c002fea3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002fea6:	c9                   	leave  
c002fea7:	c3                   	ret    

c002fea8 <simple_thread_func>:

static void 
simple_thread_func (void *aux UNUSED) 
{
c002fea8:	55                   	push   %ebp
c002fea9:	89 e5                	mov    %esp,%ebp
c002feab:	53                   	push   %ebx
c002feac:	83 ec 14             	sub    $0x14,%esp
c002feaf:	e8 78 15 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002feb4:	81 c3 c4 a4 00 00    	add    $0xa4c4,%ebx
  int i;
  
  for (i = 0; i < 5; i++) 
c002feba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002fec1:	eb 24                	jmp    c002fee7 <simple_thread_func+0x3f>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002fec3:	e8 9f 14 ff ff       	call   c0021367 <thread_name>
c002fec8:	83 ec 04             	sub    $0x4,%esp
c002fecb:	ff 75 f4             	push   -0xc(%ebp)
c002fece:	50                   	push   %eax
c002fecf:	8d 83 48 af ff ff    	lea    -0x50b8(%ebx),%eax
c002fed5:	50                   	push   %eax
c002fed6:	e8 4d e3 ff ff       	call   c002e228 <msg>
c002fedb:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002fede:	e8 d7 15 ff ff       	call   c00214ba <thread_yield>
  for (i = 0; i < 5; i++) 
c002fee3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002fee7:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c002feeb:	7e d6                	jle    c002fec3 <simple_thread_func+0x1b>
    }
  msg ("Thread %s done!", thread_name ());
c002feed:	e8 75 14 ff ff       	call   c0021367 <thread_name>
c002fef2:	83 ec 08             	sub    $0x8,%esp
c002fef5:	50                   	push   %eax
c002fef6:	8d 83 5f af ff ff    	lea    -0x50a1(%ebx),%eax
c002fefc:	50                   	push   %eax
c002fefd:	e8 26 e3 ff ff       	call   c002e228 <msg>
c002ff02:	83 c4 10             	add    $0x10,%esp
}
c002ff05:	90                   	nop
c002ff06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ff09:	c9                   	leave  
c002ff0a:	c3                   	ret    

c002ff0b <test_priority_sema>:
static thread_func priority_sema_thread;
static struct semaphore sema;

void
test_priority_sema (void) 
{
c002ff0b:	55                   	push   %ebp
c002ff0c:	89 e5                	mov    %esp,%ebp
c002ff0e:	56                   	push   %esi
c002ff0f:	53                   	push   %ebx
c002ff10:	83 ec 20             	sub    $0x20,%esp
c002ff13:	e8 14 15 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c002ff18:	81 c3 60 a4 00 00    	add    $0xa460,%ebx
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ff1e:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c002ff24:	0f b6 00             	movzbl (%eax),%eax
c002ff27:	83 f0 01             	xor    $0x1,%eax
c002ff2a:	84 c0                	test   %al,%al
c002ff2c:	75 26                	jne    c002ff54 <test_priority_sema+0x49>
c002ff2e:	83 ec 0c             	sub    $0xc,%esp
c002ff31:	8d 83 88 af ff ff    	lea    -0x5078(%ebx),%eax
c002ff37:	50                   	push   %eax
c002ff38:	8d 83 96 af ff ff    	lea    -0x506a(%ebx),%eax
c002ff3e:	50                   	push   %eax
c002ff3f:	8d 83 08 b0 ff ff    	lea    -0x4ff8(%ebx),%eax
c002ff45:	50                   	push   %eax
c002ff46:	6a 15                	push   $0x15
c002ff48:	8d 83 b0 af ff ff    	lea    -0x5050(%ebx),%eax
c002ff4e:	50                   	push   %eax
c002ff4f:	e8 10 b8 ff ff       	call   c002b764 <debug_panic>

  sema_init (&sema, 0);
c002ff54:	83 ec 08             	sub    $0x8,%esp
c002ff57:	6a 00                	push   $0x0
c002ff59:	8d 83 bc 22 00 00    	lea    0x22bc(%ebx),%eax
c002ff5f:	50                   	push   %eax
c002ff60:	e8 09 35 ff ff       	call   c002346e <sema_init>
c002ff65:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_MIN);
c002ff68:	83 ec 0c             	sub    $0xc,%esp
c002ff6b:	6a 00                	push   $0x0
c002ff6d:	e8 a8 16 ff ff       	call   c002161a <thread_set_priority>
c002ff72:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002ff75:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ff7c:	eb 68                	jmp    c002ffe6 <test_priority_sema+0xdb>
    {
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002ff7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ff81:	8d 48 03             	lea    0x3(%eax),%ecx
c002ff84:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002ff89:	89 c8                	mov    %ecx,%eax
c002ff8b:	f7 ea                	imul   %edx
c002ff8d:	89 d0                	mov    %edx,%eax
c002ff8f:	c1 f8 02             	sar    $0x2,%eax
c002ff92:	89 ce                	mov    %ecx,%esi
c002ff94:	c1 fe 1f             	sar    $0x1f,%esi
c002ff97:	29 f0                	sub    %esi,%eax
c002ff99:	89 c2                	mov    %eax,%edx
c002ff9b:	89 d0                	mov    %edx,%eax
c002ff9d:	c1 e0 02             	shl    $0x2,%eax
c002ffa0:	01 d0                	add    %edx,%eax
c002ffa2:	01 c0                	add    %eax,%eax
c002ffa4:	29 c1                	sub    %eax,%ecx
c002ffa6:	89 ca                	mov    %ecx,%edx
c002ffa8:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002ffad:	29 d0                	sub    %edx,%eax
c002ffaf:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002ffb2:	ff 75 f0             	push   -0x10(%ebp)
c002ffb5:	8d 83 d4 af ff ff    	lea    -0x502c(%ebx),%eax
c002ffbb:	50                   	push   %eax
c002ffbc:	6a 10                	push   $0x10
c002ffbe:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ffc1:	50                   	push   %eax
c002ffc2:	e8 eb 8e ff ff       	call   c0028eb2 <snprintf>
c002ffc7:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_sema_thread, NULL);
c002ffca:	6a 00                	push   $0x0
c002ffcc:	8d 83 b4 5c ff ff    	lea    -0xa34c(%ebx),%eax
c002ffd2:	50                   	push   %eax
c002ffd3:	ff 75 f0             	push   -0x10(%ebp)
c002ffd6:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ffd9:	50                   	push   %eax
c002ffda:	e8 c5 10 ff ff       	call   c00210a4 <thread_create>
c002ffdf:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002ffe2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002ffe6:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002ffea:	7e 92                	jle    c002ff7e <test_priority_sema+0x73>
    }

  for (i = 0; i < 10; i++) 
c002ffec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002fff3:	eb 28                	jmp    c003001d <test_priority_sema+0x112>
    {
      sema_up (&sema);
c002fff5:	83 ec 0c             	sub    $0xc,%esp
c002fff8:	8d 83 bc 22 00 00    	lea    0x22bc(%ebx),%eax
c002fffe:	50                   	push   %eax
c002ffff:	e8 0c 36 ff ff       	call   c0023610 <sema_up>
c0030004:	83 c4 10             	add    $0x10,%esp
      msg ("Back in main thread."); 
c0030007:	83 ec 0c             	sub    $0xc,%esp
c003000a:	8d 83 e0 af ff ff    	lea    -0x5020(%ebx),%eax
c0030010:	50                   	push   %eax
c0030011:	e8 12 e2 ff ff       	call   c002e228 <msg>
c0030016:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0030019:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c003001d:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0030021:	7e d2                	jle    c002fff5 <test_priority_sema+0xea>
    }
}
c0030023:	90                   	nop
c0030024:	90                   	nop
c0030025:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0030028:	5b                   	pop    %ebx
c0030029:	5e                   	pop    %esi
c003002a:	5d                   	pop    %ebp
c003002b:	c3                   	ret    

c003002c <priority_sema_thread>:

static void
priority_sema_thread (void *aux UNUSED) 
{
c003002c:	55                   	push   %ebp
c003002d:	89 e5                	mov    %esp,%ebp
c003002f:	53                   	push   %ebx
c0030030:	83 ec 04             	sub    $0x4,%esp
c0030033:	e8 f4 13 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030038:	81 c3 40 a3 00 00    	add    $0xa340,%ebx
  sema_down (&sema);
c003003e:	83 ec 0c             	sub    $0xc,%esp
c0030041:	8d 83 bc 22 00 00    	lea    0x22bc(%ebx),%eax
c0030047:	50                   	push   %eax
c0030048:	e8 82 34 ff ff       	call   c00234cf <sema_down>
c003004d:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c0030050:	e8 12 13 ff ff       	call   c0021367 <thread_name>
c0030055:	83 ec 08             	sub    $0x8,%esp
c0030058:	50                   	push   %eax
c0030059:	8d 83 f5 af ff ff    	lea    -0x500b(%ebx),%eax
c003005f:	50                   	push   %eax
c0030060:	e8 c3 e1 ff ff       	call   c002e228 <msg>
c0030065:	83 c4 10             	add    $0x10,%esp
}
c0030068:	90                   	nop
c0030069:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c003006c:	c9                   	leave  
c003006d:	c3                   	ret    

c003006e <test_priority_condvar>:
static struct lock lock;
static struct condition condition;

void
test_priority_condvar (void) 
{
c003006e:	55                   	push   %ebp
c003006f:	89 e5                	mov    %esp,%ebp
c0030071:	56                   	push   %esi
c0030072:	53                   	push   %ebx
c0030073:	83 ec 20             	sub    $0x20,%esp
c0030076:	e8 b1 13 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c003007b:	81 c3 fd a2 00 00    	add    $0xa2fd,%ebx
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c0030081:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c0030087:	0f b6 00             	movzbl (%eax),%eax
c003008a:	83 f0 01             	xor    $0x1,%eax
c003008d:	84 c0                	test   %al,%al
c003008f:	75 26                	jne    c00300b7 <test_priority_condvar+0x49>
c0030091:	83 ec 0c             	sub    $0xc,%esp
c0030094:	8d 83 1c b0 ff ff    	lea    -0x4fe4(%ebx),%eax
c003009a:	50                   	push   %eax
c003009b:	8d 83 2a b0 ff ff    	lea    -0x4fd6(%ebx),%eax
c00300a1:	50                   	push   %eax
c00300a2:	8d 83 ac b0 ff ff    	lea    -0x4f54(%ebx),%eax
c00300a8:	50                   	push   %eax
c00300a9:	6a 16                	push   $0x16
c00300ab:	8d 83 44 b0 ff ff    	lea    -0x4fbc(%ebx),%eax
c00300b1:	50                   	push   %eax
c00300b2:	e8 ad b6 ff ff       	call   c002b764 <debug_panic>

  lock_init (&lock);
c00300b7:	83 ec 0c             	sub    $0xc,%esp
c00300ba:	8d 83 d0 22 00 00    	lea    0x22d0(%ebx),%eax
c00300c0:	50                   	push   %eax
c00300c1:	e8 0c 37 ff ff       	call   c00237d2 <lock_init>
c00300c6:	83 c4 10             	add    $0x10,%esp
  cond_init (&condition);
c00300c9:	83 ec 0c             	sub    $0xc,%esp
c00300cc:	8d 83 e8 22 00 00    	lea    0x22e8(%ebx),%eax
c00300d2:	50                   	push   %eax
c00300d3:	e8 67 3c ff ff       	call   c0023d3f <cond_init>
c00300d8:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_MIN);
c00300db:	83 ec 0c             	sub    $0xc,%esp
c00300de:	6a 00                	push   $0x0
c00300e0:	e8 35 15 ff ff       	call   c002161a <thread_set_priority>
c00300e5:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c00300e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00300ef:	eb 68                	jmp    c0030159 <test_priority_condvar+0xeb>
    {
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c00300f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00300f4:	8d 48 07             	lea    0x7(%eax),%ecx
c00300f7:	ba 67 66 66 66       	mov    $0x66666667,%edx
c00300fc:	89 c8                	mov    %ecx,%eax
c00300fe:	f7 ea                	imul   %edx
c0030100:	89 d0                	mov    %edx,%eax
c0030102:	c1 f8 02             	sar    $0x2,%eax
c0030105:	89 ce                	mov    %ecx,%esi
c0030107:	c1 fe 1f             	sar    $0x1f,%esi
c003010a:	29 f0                	sub    %esi,%eax
c003010c:	89 c2                	mov    %eax,%edx
c003010e:	89 d0                	mov    %edx,%eax
c0030110:	c1 e0 02             	shl    $0x2,%eax
c0030113:	01 d0                	add    %edx,%eax
c0030115:	01 c0                	add    %eax,%eax
c0030117:	29 c1                	sub    %eax,%ecx
c0030119:	89 ca                	mov    %ecx,%edx
c003011b:	b8 1e 00 00 00       	mov    $0x1e,%eax
c0030120:	29 d0                	sub    %edx,%eax
c0030122:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c0030125:	ff 75 f0             	push   -0x10(%ebp)
c0030128:	8d 83 6b b0 ff ff    	lea    -0x4f95(%ebx),%eax
c003012e:	50                   	push   %eax
c003012f:	6a 10                	push   $0x10
c0030131:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0030134:	50                   	push   %eax
c0030135:	e8 78 8d ff ff       	call   c0028eb2 <snprintf>
c003013a:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_condvar_thread, NULL);
c003013d:	6a 00                	push   $0x0
c003013f:	8d 83 52 5e ff ff    	lea    -0xa1ae(%ebx),%eax
c0030145:	50                   	push   %eax
c0030146:	ff 75 f0             	push   -0x10(%ebp)
c0030149:	8d 45 e0             	lea    -0x20(%ebp),%eax
c003014c:	50                   	push   %eax
c003014d:	e8 52 0f ff ff       	call   c00210a4 <thread_create>
c0030152:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0030155:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0030159:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c003015d:	7e 92                	jle    c00300f1 <test_priority_condvar+0x83>
    }

  for (i = 0; i < 10; i++) 
c003015f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0030166:	eb 53                	jmp    c00301bb <test_priority_condvar+0x14d>
    {
      lock_acquire (&lock);
c0030168:	83 ec 0c             	sub    $0xc,%esp
c003016b:	8d 83 d0 22 00 00    	lea    0x22d0(%ebx),%eax
c0030171:	50                   	push   %eax
c0030172:	e8 c0 36 ff ff       	call   c0023837 <lock_acquire>
c0030177:	83 c4 10             	add    $0x10,%esp
      msg ("Signaling...");
c003017a:	83 ec 0c             	sub    $0xc,%esp
c003017d:	8d 83 77 b0 ff ff    	lea    -0x4f89(%ebx),%eax
c0030183:	50                   	push   %eax
c0030184:	e8 9f e0 ff ff       	call   c002e228 <msg>
c0030189:	83 c4 10             	add    $0x10,%esp
      cond_signal (&condition, &lock);
c003018c:	83 ec 08             	sub    $0x8,%esp
c003018f:	8d 83 d0 22 00 00    	lea    0x22d0(%ebx),%eax
c0030195:	50                   	push   %eax
c0030196:	8d 83 e8 22 00 00    	lea    0x22e8(%ebx),%eax
c003019c:	50                   	push   %eax
c003019d:	e8 31 3d ff ff       	call   c0023ed3 <cond_signal>
c00301a2:	83 c4 10             	add    $0x10,%esp
      lock_release (&lock);
c00301a5:	83 ec 0c             	sub    $0xc,%esp
c00301a8:	8d 83 d0 22 00 00    	lea    0x22d0(%ebx),%eax
c00301ae:	50                   	push   %eax
c00301af:	e8 31 39 ff ff       	call   c0023ae5 <lock_release>
c00301b4:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c00301b7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00301bb:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c00301bf:	7e a7                	jle    c0030168 <test_priority_condvar+0xfa>
    }
}
c00301c1:	90                   	nop
c00301c2:	90                   	nop
c00301c3:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00301c6:	5b                   	pop    %ebx
c00301c7:	5e                   	pop    %esi
c00301c8:	5d                   	pop    %ebp
c00301c9:	c3                   	ret    

c00301ca <priority_condvar_thread>:

static void
priority_condvar_thread (void *aux UNUSED) 
{
c00301ca:	55                   	push   %ebp
c00301cb:	89 e5                	mov    %esp,%ebp
c00301cd:	53                   	push   %ebx
c00301ce:	83 ec 04             	sub    $0x4,%esp
c00301d1:	e8 56 12 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00301d6:	81 c3 a2 a1 00 00    	add    $0xa1a2,%ebx
  msg ("Thread %s starting.", thread_name ());
c00301dc:	e8 86 11 ff ff       	call   c0021367 <thread_name>
c00301e1:	83 ec 08             	sub    $0x8,%esp
c00301e4:	50                   	push   %eax
c00301e5:	8d 83 84 b0 ff ff    	lea    -0x4f7c(%ebx),%eax
c00301eb:	50                   	push   %eax
c00301ec:	e8 37 e0 ff ff       	call   c002e228 <msg>
c00301f1:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c00301f4:	83 ec 0c             	sub    $0xc,%esp
c00301f7:	8d 83 d0 22 00 00    	lea    0x22d0(%ebx),%eax
c00301fd:	50                   	push   %eax
c00301fe:	e8 34 36 ff ff       	call   c0023837 <lock_acquire>
c0030203:	83 c4 10             	add    $0x10,%esp
  cond_wait (&condition, &lock);
c0030206:	83 ec 08             	sub    $0x8,%esp
c0030209:	8d 83 d0 22 00 00    	lea    0x22d0(%ebx),%eax
c003020f:	50                   	push   %eax
c0030210:	8d 83 e8 22 00 00    	lea    0x22e8(%ebx),%eax
c0030216:	50                   	push   %eax
c0030217:	e8 7c 3b ff ff       	call   c0023d98 <cond_wait>
c003021c:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c003021f:	e8 43 11 ff ff       	call   c0021367 <thread_name>
c0030224:	83 ec 08             	sub    $0x8,%esp
c0030227:	50                   	push   %eax
c0030228:	8d 83 98 b0 ff ff    	lea    -0x4f68(%ebx),%eax
c003022e:	50                   	push   %eax
c003022f:	e8 f4 df ff ff       	call   c002e228 <msg>
c0030234:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c0030237:	83 ec 0c             	sub    $0xc,%esp
c003023a:	8d 83 d0 22 00 00    	lea    0x22d0(%ebx),%eax
c0030240:	50                   	push   %eax
c0030241:	e8 9f 38 ff ff       	call   c0023ae5 <lock_release>
c0030246:	83 c4 10             	add    $0x10,%esp
}
c0030249:	90                   	nop
c003024a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c003024d:	c9                   	leave  
c003024e:	c3                   	ret    

c003024f <test_priority_donate_chain>:
static thread_func donor_thread_func;
static thread_func interloper_thread_func;

void
test_priority_donate_chain (void) 
{
c003024f:	55                   	push   %ebp
c0030250:	89 e5                	mov    %esp,%ebp
c0030252:	56                   	push   %esi
c0030253:	53                   	push   %ebx
c0030254:	81 ec 00 01 00 00    	sub    $0x100,%esp
c003025a:	e8 cd 11 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c003025f:	81 c3 19 a1 00 00    	add    $0xa119,%ebx
  int i;  
  struct lock locks[NESTING_DEPTH - 1];
  struct lock_pair lock_pairs[NESTING_DEPTH];

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c0030265:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c003026b:	0f b6 00             	movzbl (%eax),%eax
c003026e:	83 f0 01             	xor    $0x1,%eax
c0030271:	84 c0                	test   %al,%al
c0030273:	75 26                	jne    c003029b <test_priority_donate_chain+0x4c>
c0030275:	83 ec 0c             	sub    $0xc,%esp
c0030278:	8d 83 c4 b0 ff ff    	lea    -0x4f3c(%ebx),%eax
c003027e:	50                   	push   %eax
c003027f:	8d 83 d2 b0 ff ff    	lea    -0x4f2e(%ebx),%eax
c0030285:	50                   	push   %eax
c0030286:	8d 83 dc b1 ff ff    	lea    -0x4e24(%ebx),%eax
c003028c:	50                   	push   %eax
c003028d:	6a 34                	push   $0x34
c003028f:	8d 83 ec b0 ff ff    	lea    -0x4f14(%ebx),%eax
c0030295:	50                   	push   %eax
c0030296:	e8 c9 b4 ff ff       	call   c002b764 <debug_panic>

  thread_set_priority (PRI_MIN);
c003029b:	83 ec 0c             	sub    $0xc,%esp
c003029e:	6a 00                	push   $0x0
c00302a0:	e8 75 13 ff ff       	call   c002161a <thread_set_priority>
c00302a5:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c00302a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00302af:	eb 24                	jmp    c00302d5 <test_priority_donate_chain+0x86>
    lock_init (&locks[i]);
c00302b1:	8d 8d 48 ff ff ff    	lea    -0xb8(%ebp),%ecx
c00302b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00302ba:	89 d0                	mov    %edx,%eax
c00302bc:	01 c0                	add    %eax,%eax
c00302be:	01 d0                	add    %edx,%eax
c00302c0:	c1 e0 03             	shl    $0x3,%eax
c00302c3:	01 c8                	add    %ecx,%eax
c00302c5:	83 ec 0c             	sub    $0xc,%esp
c00302c8:	50                   	push   %eax
c00302c9:	e8 04 35 ff ff       	call   c00237d2 <lock_init>
c00302ce:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NESTING_DEPTH - 1; i++)
c00302d1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00302d5:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c00302d9:	7e d6                	jle    c00302b1 <test_priority_donate_chain+0x62>

  lock_acquire (&locks[0]);
c00302db:	83 ec 0c             	sub    $0xc,%esp
c00302de:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c00302e4:	50                   	push   %eax
c00302e5:	e8 4d 35 ff ff       	call   c0023837 <lock_acquire>
c00302ea:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock.", thread_name ());
c00302ed:	e8 75 10 ff ff       	call   c0021367 <thread_name>
c00302f2:	83 ec 08             	sub    $0x8,%esp
c00302f5:	50                   	push   %eax
c00302f6:	8d 83 18 b1 ff ff    	lea    -0x4ee8(%ebx),%eax
c00302fc:	50                   	push   %eax
c00302fd:	e8 26 df ff ff       	call   c002e228 <msg>
c0030302:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i < NESTING_DEPTH; i++)
c0030305:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c003030c:	e9 ff 00 00 00       	jmp    c0030410 <test_priority_donate_chain+0x1c1>
    {
      char name[16];
      int thread_priority;

      snprintf (name, sizeof name, "thread %d", i);
c0030311:	ff 75 f4             	push   -0xc(%ebp)
c0030314:	8d 83 25 b1 ff ff    	lea    -0x4edb(%ebx),%eax
c003031a:	50                   	push   %eax
c003031b:	6a 10                	push   $0x10
c003031d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c0030323:	50                   	push   %eax
c0030324:	e8 89 8b ff ff       	call   c0028eb2 <snprintf>
c0030329:	83 c4 10             	add    $0x10,%esp
      thread_priority = PRI_MIN + i * 3;
c003032c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c003032f:	89 d0                	mov    %edx,%eax
c0030331:	01 c0                	add    %eax,%eax
c0030333:	01 d0                	add    %edx,%eax
c0030335:	89 45 f0             	mov    %eax,-0x10(%ebp)
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c0030338:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c003033c:	7f 18                	jg     c0030356 <test_priority_donate_chain+0x107>
c003033e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0030341:	89 d0                	mov    %edx,%eax
c0030343:	01 c0                	add    %eax,%eax
c0030345:	01 d0                	add    %edx,%eax
c0030347:	c1 e0 03             	shl    $0x3,%eax
c003034a:	89 c2                	mov    %eax,%edx
c003034c:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c0030352:	01 c2                	add    %eax,%edx
c0030354:	eb 05                	jmp    c003035b <test_priority_donate_chain+0x10c>
c0030356:	ba 00 00 00 00       	mov    $0x0,%edx
c003035b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c003035e:	89 94 c5 0c ff ff ff 	mov    %edx,-0xf4(%ebp,%eax,8)
      lock_pairs[i].second = locks + i - 1;
c0030365:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0030368:	89 d0                	mov    %edx,%eax
c003036a:	01 c0                	add    %eax,%eax
c003036c:	01 d0                	add    %edx,%eax
c003036e:	c1 e0 03             	shl    $0x3,%eax
c0030371:	8d 50 e8             	lea    -0x18(%eax),%edx
c0030374:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c003037a:	01 c2                	add    %eax,%edx
c003037c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c003037f:	89 94 c5 08 ff ff ff 	mov    %edx,-0xf8(%ebp,%eax,8)

      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c0030386:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0030389:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0030390:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
c0030396:	01 d0                	add    %edx,%eax
c0030398:	50                   	push   %eax
c0030399:	8d 83 dc 60 ff ff    	lea    -0x9f24(%ebx),%eax
c003039f:	50                   	push   %eax
c00303a0:	ff 75 f0             	push   -0x10(%ebp)
c00303a3:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c00303a9:	50                   	push   %eax
c00303aa:	e8 f5 0c ff ff       	call   c00210a4 <thread_create>
c00303af:	83 c4 10             	add    $0x10,%esp
      msg ("%s should have priority %d.  Actual priority: %d.",
c00303b2:	e8 45 13 ff ff       	call   c00216fc <thread_get_priority>
c00303b7:	89 c6                	mov    %eax,%esi
c00303b9:	e8 a9 0f ff ff       	call   c0021367 <thread_name>
c00303be:	56                   	push   %esi
c00303bf:	ff 75 f0             	push   -0x10(%ebp)
c00303c2:	50                   	push   %eax
c00303c3:	8d 83 30 b1 ff ff    	lea    -0x4ed0(%ebx),%eax
c00303c9:	50                   	push   %eax
c00303ca:	e8 59 de ff ff       	call   c002e228 <msg>
c00303cf:	83 c4 10             	add    $0x10,%esp
          thread_name (), thread_priority, thread_get_priority ());

      snprintf (name, sizeof name, "interloper %d", i);
c00303d2:	ff 75 f4             	push   -0xc(%ebp)
c00303d5:	8d 83 62 b1 ff ff    	lea    -0x4e9e(%ebx),%eax
c00303db:	50                   	push   %eax
c00303dc:	6a 10                	push   $0x10
c00303de:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c00303e4:	50                   	push   %eax
c00303e5:	e8 c8 8a ff ff       	call   c0028eb2 <snprintf>
c00303ea:	83 c4 10             	add    $0x10,%esp
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c00303ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00303f0:	8d 50 ff             	lea    -0x1(%eax),%edx
c00303f3:	6a 00                	push   $0x0
c00303f5:	8d 83 ae 61 ff ff    	lea    -0x9e52(%ebx),%eax
c00303fb:	50                   	push   %eax
c00303fc:	52                   	push   %edx
c00303fd:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c0030403:	50                   	push   %eax
c0030404:	e8 9b 0c ff ff       	call   c00210a4 <thread_create>
c0030409:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < NESTING_DEPTH; i++)
c003040c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0030410:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c0030414:	0f 8e f7 fe ff ff    	jle    c0030311 <test_priority_donate_chain+0xc2>
    }

  lock_release (&locks[0]);
c003041a:	83 ec 0c             	sub    $0xc,%esp
c003041d:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c0030423:	50                   	push   %eax
c0030424:	e8 bc 36 ff ff       	call   c0023ae5 <lock_release>
c0030429:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c003042c:	e8 cb 12 ff ff       	call   c00216fc <thread_get_priority>
c0030431:	89 c6                	mov    %eax,%esi
c0030433:	e8 2f 0f ff ff       	call   c0021367 <thread_name>
c0030438:	83 ec 04             	sub    $0x4,%esp
c003043b:	56                   	push   %esi
c003043c:	50                   	push   %eax
c003043d:	8d 83 70 b1 ff ff    	lea    -0x4e90(%ebx),%eax
c0030443:	50                   	push   %eax
c0030444:	e8 df dd ff ff       	call   c002e228 <msg>
c0030449:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c003044c:	90                   	nop
c003044d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0030450:	5b                   	pop    %ebx
c0030451:	5e                   	pop    %esi
c0030452:	5d                   	pop    %ebp
c0030453:	c3                   	ret    

c0030454 <donor_thread_func>:

static void
donor_thread_func (void *locks_) 
{
c0030454:	55                   	push   %ebp
c0030455:	89 e5                	mov    %esp,%ebp
c0030457:	56                   	push   %esi
c0030458:	53                   	push   %ebx
c0030459:	83 ec 10             	sub    $0x10,%esp
c003045c:	e8 cb 0f 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030461:	81 c3 17 9f 00 00    	add    $0x9f17,%ebx
  struct lock_pair *locks = locks_;
c0030467:	8b 45 08             	mov    0x8(%ebp),%eax
c003046a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (locks->first)
c003046d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0030470:	8b 40 04             	mov    0x4(%eax),%eax
c0030473:	85 c0                	test   %eax,%eax
c0030475:	74 12                	je     c0030489 <donor_thread_func+0x35>
    lock_acquire (locks->first);
c0030477:	8b 45 f4             	mov    -0xc(%ebp),%eax
c003047a:	8b 40 04             	mov    0x4(%eax),%eax
c003047d:	83 ec 0c             	sub    $0xc,%esp
c0030480:	50                   	push   %eax
c0030481:	e8 b1 33 ff ff       	call   c0023837 <lock_acquire>
c0030486:	83 c4 10             	add    $0x10,%esp

  lock_acquire (locks->second);
c0030489:	8b 45 f4             	mov    -0xc(%ebp),%eax
c003048c:	8b 00                	mov    (%eax),%eax
c003048e:	83 ec 0c             	sub    $0xc,%esp
c0030491:	50                   	push   %eax
c0030492:	e8 a0 33 ff ff       	call   c0023837 <lock_acquire>
c0030497:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock", thread_name ());
c003049a:	e8 c8 0e ff ff       	call   c0021367 <thread_name>
c003049f:	83 ec 08             	sub    $0x8,%esp
c00304a2:	50                   	push   %eax
c00304a3:	8d 83 8f b1 ff ff    	lea    -0x4e71(%ebx),%eax
c00304a9:	50                   	push   %eax
c00304aa:	e8 79 dd ff ff       	call   c002e228 <msg>
c00304af:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->second);
c00304b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00304b5:	8b 00                	mov    (%eax),%eax
c00304b7:	83 ec 0c             	sub    $0xc,%esp
c00304ba:	50                   	push   %eax
c00304bb:	e8 25 36 ff ff       	call   c0023ae5 <lock_release>
c00304c0:	83 c4 10             	add    $0x10,%esp
  msg ("%s should have priority %d. Actual priority: %d", 
c00304c3:	e8 34 12 ff ff       	call   c00216fc <thread_get_priority>
c00304c8:	89 c6                	mov    %eax,%esi
c00304ca:	e8 98 0e ff ff       	call   c0021367 <thread_name>
c00304cf:	56                   	push   %esi
c00304d0:	6a 15                	push   $0x15
c00304d2:	50                   	push   %eax
c00304d3:	8d 83 9c b1 ff ff    	lea    -0x4e64(%ebx),%eax
c00304d9:	50                   	push   %eax
c00304da:	e8 49 dd ff ff       	call   c002e228 <msg>
c00304df:	83 c4 10             	add    $0x10,%esp
        thread_name (), (NESTING_DEPTH - 1) * 3,
        thread_get_priority ());

  if (locks->first)
c00304e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00304e5:	8b 40 04             	mov    0x4(%eax),%eax
c00304e8:	85 c0                	test   %eax,%eax
c00304ea:	74 12                	je     c00304fe <donor_thread_func+0xaa>
    lock_release (locks->first);
c00304ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00304ef:	8b 40 04             	mov    0x4(%eax),%eax
c00304f2:	83 ec 0c             	sub    $0xc,%esp
c00304f5:	50                   	push   %eax
c00304f6:	e8 ea 35 ff ff       	call   c0023ae5 <lock_release>
c00304fb:	83 c4 10             	add    $0x10,%esp

  msg ("%s finishing with priority %d.", thread_name (),
c00304fe:	e8 f9 11 ff ff       	call   c00216fc <thread_get_priority>
c0030503:	89 c6                	mov    %eax,%esi
c0030505:	e8 5d 0e ff ff       	call   c0021367 <thread_name>
c003050a:	83 ec 04             	sub    $0x4,%esp
c003050d:	56                   	push   %esi
c003050e:	50                   	push   %eax
c003050f:	8d 83 70 b1 ff ff    	lea    -0x4e90(%ebx),%eax
c0030515:	50                   	push   %eax
c0030516:	e8 0d dd ff ff       	call   c002e228 <msg>
c003051b:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c003051e:	90                   	nop
c003051f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0030522:	5b                   	pop    %ebx
c0030523:	5e                   	pop    %esi
c0030524:	5d                   	pop    %ebp
c0030525:	c3                   	ret    

c0030526 <interloper_thread_func>:

static void
interloper_thread_func (void *arg_ UNUSED)
{
c0030526:	55                   	push   %ebp
c0030527:	89 e5                	mov    %esp,%ebp
c0030529:	53                   	push   %ebx
c003052a:	83 ec 04             	sub    $0x4,%esp
c003052d:	e8 fa 0e 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030532:	81 c3 46 9e 00 00    	add    $0x9e46,%ebx
  msg ("%s finished.", thread_name ());
c0030538:	e8 2a 0e ff ff       	call   c0021367 <thread_name>
c003053d:	83 ec 08             	sub    $0x8,%esp
c0030540:	50                   	push   %eax
c0030541:	8d 83 cc b1 ff ff    	lea    -0x4e34(%ebx),%eax
c0030547:	50                   	push   %eax
c0030548:	e8 db dc ff ff       	call   c002e228 <msg>
c003054d:	83 c4 10             	add    $0x10,%esp
}
c0030550:	90                   	nop
c0030551:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0030554:	c9                   	leave  
c0030555:	c3                   	ret    

c0030556 <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c0030556:	55                   	push   %ebp
c0030557:	89 e5                	mov    %esp,%ebp
c0030559:	56                   	push   %esi
c003055a:	53                   	push   %ebx
c003055b:	83 ec 10             	sub    $0x10,%esp
c003055e:	e8 c9 0e 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030563:	81 c3 15 9e 00 00    	add    $0x9e15,%ebx
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c0030569:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c003056f:	0f b6 00             	movzbl (%eax),%eax
c0030572:	84 c0                	test   %al,%al
c0030574:	75 26                	jne    c003059c <test_mlfqs_load_1+0x46>
c0030576:	83 ec 0c             	sub    $0xc,%esp
c0030579:	8d 83 f8 b1 ff ff    	lea    -0x4e08(%ebx),%eax
c003057f:	50                   	push   %eax
c0030580:	8d 83 05 b2 ff ff    	lea    -0x4dfb(%ebx),%eax
c0030586:	50                   	push   %eax
c0030587:	8d 83 14 b4 ff ff    	lea    -0x4bec(%ebx),%eax
c003058d:	50                   	push   %eax
c003058e:	6a 18                	push   $0x18
c0030590:	8d 83 1c b2 ff ff    	lea    -0x4de4(%ebx),%eax
c0030596:	50                   	push   %eax
c0030597:	e8 c8 b1 ff ff       	call   c002b764 <debug_panic>

  msg ("spinning for up to 45 seconds, please wait...");
c003059c:	83 ec 0c             	sub    $0xc,%esp
c003059f:	8d 83 40 b2 ff ff    	lea    -0x4dc0(%ebx),%eax
c00305a5:	50                   	push   %eax
c00305a6:	e8 7d dc ff ff       	call   c002e228 <msg>
c00305ab:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c00305ae:	e8 dc 4a ff ff       	call   c002508f <timer_ticks>
c00305b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00305b6:	89 55 f4             	mov    %edx,-0xc(%ebp)
  for (;;) 
    {
      load_avg = thread_get_load_avg ();
c00305b9:	e8 93 11 ff ff       	call   c0021751 <thread_get_load_avg>
c00305be:	89 45 ec             	mov    %eax,-0x14(%ebp)
      ASSERT (load_avg >= 0);
c00305c1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00305c5:	79 26                	jns    c00305ed <test_mlfqs_load_1+0x97>
c00305c7:	83 ec 0c             	sub    $0xc,%esp
c00305ca:	8d 83 6e b2 ff ff    	lea    -0x4d92(%ebx),%eax
c00305d0:	50                   	push   %eax
c00305d1:	8d 83 05 b2 ff ff    	lea    -0x4dfb(%ebx),%eax
c00305d7:	50                   	push   %eax
c00305d8:	8d 83 14 b4 ff ff    	lea    -0x4bec(%ebx),%eax
c00305de:	50                   	push   %eax
c00305df:	6a 20                	push   $0x20
c00305e1:	8d 83 1c b2 ff ff    	lea    -0x4de4(%ebx),%eax
c00305e7:	50                   	push   %eax
c00305e8:	e8 77 b1 ff ff       	call   c002b764 <debug_panic>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c00305ed:	83 ec 08             	sub    $0x8,%esp
c00305f0:	ff 75 f4             	push   -0xc(%ebp)
c00305f3:	ff 75 f0             	push   -0x10(%ebp)
c00305f6:	e8 d9 4a ff ff       	call   c00250d4 <timer_elapsed>
c00305fb:	83 c4 10             	add    $0x10,%esp
c00305fe:	6a 00                	push   $0x0
c0030600:	6a 64                	push   $0x64
c0030602:	52                   	push   %edx
c0030603:	50                   	push   %eax
c0030604:	e8 95 aa ff ff       	call   c002b09e <__divdi3>
c0030609:	83 c4 10             	add    $0x10,%esp
c003060c:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (load_avg > 100)
c003060f:	83 7d ec 64          	cmpl   $0x64,-0x14(%ebp)
c0030613:	7e 52                	jle    c0030667 <test_mlfqs_load_1+0x111>
        fail ("load average is %d.%02d "
c0030615:	8b 75 ec             	mov    -0x14(%ebp),%esi
c0030618:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c003061d:	89 f0                	mov    %esi,%eax
c003061f:	f7 ea                	imul   %edx
c0030621:	89 d0                	mov    %edx,%eax
c0030623:	c1 f8 05             	sar    $0x5,%eax
c0030626:	89 f2                	mov    %esi,%edx
c0030628:	c1 fa 1f             	sar    $0x1f,%edx
c003062b:	29 d0                	sub    %edx,%eax
c003062d:	89 c1                	mov    %eax,%ecx
c003062f:	6b c1 64             	imul   $0x64,%ecx,%eax
c0030632:	89 f1                	mov    %esi,%ecx
c0030634:	29 c1                	sub    %eax,%ecx
c0030636:	8b 75 ec             	mov    -0x14(%ebp),%esi
c0030639:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c003063e:	89 f0                	mov    %esi,%eax
c0030640:	f7 ea                	imul   %edx
c0030642:	89 d0                	mov    %edx,%eax
c0030644:	c1 f8 05             	sar    $0x5,%eax
c0030647:	c1 fe 1f             	sar    $0x1f,%esi
c003064a:	89 f2                	mov    %esi,%edx
c003064c:	29 d0                	sub    %edx,%eax
c003064e:	ff 75 e8             	push   -0x18(%ebp)
c0030651:	51                   	push   %ecx
c0030652:	50                   	push   %eax
c0030653:	8d 83 7c b2 ff ff    	lea    -0x4d84(%ebx),%eax
c0030659:	50                   	push   %eax
c003065a:	e8 1f dc ff ff       	call   c002e27e <fail>
c003065f:	83 c4 10             	add    $0x10,%esp
c0030662:	e9 52 ff ff ff       	jmp    c00305b9 <test_mlfqs_load_1+0x63>
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
c0030667:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c003066b:	7f 21                	jg     c003068e <test_mlfqs_load_1+0x138>
        break;
      else if (elapsed > 45)
c003066d:	83 7d e8 2d          	cmpl   $0x2d,-0x18(%ebp)
c0030671:	0f 8e 42 ff ff ff    	jle    c00305b9 <test_mlfqs_load_1+0x63>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c0030677:	83 ec 0c             	sub    $0xc,%esp
c003067a:	8d 83 c8 b2 ff ff    	lea    -0x4d38(%ebx),%eax
c0030680:	50                   	push   %eax
c0030681:	e8 f8 db ff ff       	call   c002e27e <fail>
c0030686:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c0030689:	e9 2b ff ff ff       	jmp    c00305b9 <test_mlfqs_load_1+0x63>
        break;
c003068e:	90                   	nop
    }

  if (elapsed < 38)
c003068f:	83 7d e8 25          	cmpl   $0x25,-0x18(%ebp)
c0030693:	7f 15                	jg     c00306aa <test_mlfqs_load_1+0x154>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c0030695:	83 ec 08             	sub    $0x8,%esp
c0030698:	ff 75 e8             	push   -0x18(%ebp)
c003069b:	8d 83 00 b3 ff ff    	lea    -0x4d00(%ebx),%eax
c00306a1:	50                   	push   %eax
c00306a2:	e8 d7 db ff ff       	call   c002e27e <fail>
c00306a7:	83 c4 10             	add    $0x10,%esp
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c00306aa:	83 ec 08             	sub    $0x8,%esp
c00306ad:	ff 75 e8             	push   -0x18(%ebp)
c00306b0:	8d 83 34 b3 ff ff    	lea    -0x4ccc(%ebx),%eax
c00306b6:	50                   	push   %eax
c00306b7:	e8 6c db ff ff       	call   c002e228 <msg>
c00306bc:	83 c4 10             	add    $0x10,%esp

  msg ("sleeping for another 10 seconds, please wait...");
c00306bf:	83 ec 0c             	sub    $0xc,%esp
c00306c2:	8d 83 60 b3 ff ff    	lea    -0x4ca0(%ebx),%eax
c00306c8:	50                   	push   %eax
c00306c9:	e8 5a db ff ff       	call   c002e228 <msg>
c00306ce:	83 c4 10             	add    $0x10,%esp
  timer_sleep (TIMER_FREQ * 10);
c00306d1:	83 ec 08             	sub    $0x8,%esp
c00306d4:	6a 00                	push   $0x0
c00306d6:	68 e8 03 00 00       	push   $0x3e8
c00306db:	e8 1d 4a ff ff       	call   c00250fd <timer_sleep>
c00306e0:	83 c4 10             	add    $0x10,%esp

  load_avg = thread_get_load_avg ();
c00306e3:	e8 69 10 ff ff       	call   c0021751 <thread_get_load_avg>
c00306e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (load_avg < 0)
c00306eb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00306ef:	79 12                	jns    c0030703 <test_mlfqs_load_1+0x1ad>
    fail ("load average fell below 0");
c00306f1:	83 ec 0c             	sub    $0xc,%esp
c00306f4:	8d 83 90 b3 ff ff    	lea    -0x4c70(%ebx),%eax
c00306fa:	50                   	push   %eax
c00306fb:	e8 7e db ff ff       	call   c002e27e <fail>
c0030700:	83 c4 10             	add    $0x10,%esp
  if (load_avg > 50)
c0030703:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c0030707:	7e 12                	jle    c003071b <test_mlfqs_load_1+0x1c5>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c0030709:	83 ec 0c             	sub    $0xc,%esp
c003070c:	8d 83 ac b3 ff ff    	lea    -0x4c54(%ebx),%eax
c0030712:	50                   	push   %eax
c0030713:	e8 66 db ff ff       	call   c002e27e <fail>
c0030718:	83 c4 10             	add    $0x10,%esp
  msg ("load average fell back below 0.5 (to %d.%02d)",
c003071b:	8b 75 ec             	mov    -0x14(%ebp),%esi
c003071e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030723:	89 f0                	mov    %esi,%eax
c0030725:	f7 ea                	imul   %edx
c0030727:	89 d0                	mov    %edx,%eax
c0030729:	c1 f8 05             	sar    $0x5,%eax
c003072c:	89 f2                	mov    %esi,%edx
c003072e:	c1 fa 1f             	sar    $0x1f,%edx
c0030731:	29 d0                	sub    %edx,%eax
c0030733:	89 c1                	mov    %eax,%ecx
c0030735:	6b c1 64             	imul   $0x64,%ecx,%eax
c0030738:	89 f1                	mov    %esi,%ecx
c003073a:	29 c1                	sub    %eax,%ecx
c003073c:	8b 75 ec             	mov    -0x14(%ebp),%esi
c003073f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030744:	89 f0                	mov    %esi,%eax
c0030746:	f7 ea                	imul   %edx
c0030748:	89 d0                	mov    %edx,%eax
c003074a:	c1 f8 05             	sar    $0x5,%eax
c003074d:	c1 fe 1f             	sar    $0x1f,%esi
c0030750:	89 f2                	mov    %esi,%edx
c0030752:	29 d0                	sub    %edx,%eax
c0030754:	83 ec 04             	sub    $0x4,%esp
c0030757:	51                   	push   %ecx
c0030758:	50                   	push   %eax
c0030759:	8d 83 e4 b3 ff ff    	lea    -0x4c1c(%ebx),%eax
c003075f:	50                   	push   %eax
c0030760:	e8 c3 da ff ff       	call   c002e228 <msg>
c0030765:	83 c4 10             	add    $0x10,%esp
       load_avg / 100, load_avg % 100);

  pass ();
c0030768:	e8 7d db ff ff       	call   c002e2ea <pass>
}
c003076d:	90                   	nop
c003076e:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0030771:	5b                   	pop    %ebx
c0030772:	5e                   	pop    %esi
c0030773:	5d                   	pop    %ebp
c0030774:	c3                   	ret    

c0030775 <test_mlfqs_load_60>:

#define THREAD_CNT 60

void
test_mlfqs_load_60 (void) 
{
c0030775:	55                   	push   %ebp
c0030776:	89 e5                	mov    %esp,%ebp
c0030778:	57                   	push   %edi
c0030779:	56                   	push   %esi
c003077a:	53                   	push   %ebx
c003077b:	83 ec 3c             	sub    $0x3c,%esp
c003077e:	e8 a9 0c 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030783:	81 c3 f5 9b 00 00    	add    $0x9bf5,%ebx
  int i;
  
  ASSERT (thread_mlfqs);
c0030789:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c003078f:	0f b6 00             	movzbl (%eax),%eax
c0030792:	84 c0                	test   %al,%al
c0030794:	75 26                	jne    c00307bc <test_mlfqs_load_60+0x47>
c0030796:	83 ec 0c             	sub    $0xc,%esp
c0030799:	8d 83 28 b4 ff ff    	lea    -0x4bd8(%ebx),%eax
c003079f:	50                   	push   %eax
c00307a0:	8d 83 35 b4 ff ff    	lea    -0x4bcb(%ebx),%eax
c00307a6:	50                   	push   %eax
c00307a7:	8d 83 e8 b4 ff ff    	lea    -0x4b18(%ebx),%eax
c00307ad:	50                   	push   %eax
c00307ae:	6a 77                	push   $0x77
c00307b0:	8d 83 4c b4 ff ff    	lea    -0x4bb4(%ebx),%eax
c00307b6:	50                   	push   %eax
c00307b7:	e8 a8 af ff ff       	call   c002b764 <debug_panic>

  start_time = timer_ticks ();
c00307bc:	e8 ce 48 ff ff       	call   c002508f <timer_ticks>
c00307c1:	89 83 f8 22 00 00    	mov    %eax,0x22f8(%ebx)
c00307c7:	89 93 fc 22 00 00    	mov    %edx,0x22fc(%ebx)
  msg ("Starting %d niced load threads...", THREAD_CNT);
c00307cd:	83 ec 08             	sub    $0x8,%esp
c00307d0:	6a 3c                	push   $0x3c
c00307d2:	8d 83 70 b4 ff ff    	lea    -0x4b90(%ebx),%eax
c00307d8:	50                   	push   %eax
c00307d9:	e8 4a da ff ff       	call   c002e228 <msg>
c00307de:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c00307e1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c00307e8:	eb 33                	jmp    c003081d <test_mlfqs_load_60+0xa8>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c00307ea:	ff 75 e4             	push   -0x1c(%ebp)
c00307ed:	8d 83 92 b4 ff ff    	lea    -0x4b6e(%ebx),%eax
c00307f3:	50                   	push   %eax
c00307f4:	6a 10                	push   $0x10
c00307f6:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c00307f9:	50                   	push   %eax
c00307fa:	e8 b3 86 ff ff       	call   c0028eb2 <snprintf>
c00307ff:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c0030802:	6a 00                	push   $0x0
c0030804:	8d 83 ab 65 ff ff    	lea    -0x9a55(%ebx),%eax
c003080a:	50                   	push   %eax
c003080b:	6a 1f                	push   $0x1f
c003080d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c0030810:	50                   	push   %eax
c0030811:	e8 8e 08 ff ff       	call   c00210a4 <thread_create>
c0030816:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c0030819:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c003081d:	83 7d e4 3b          	cmpl   $0x3b,-0x1c(%ebp)
c0030821:	7e c7                	jle    c00307ea <test_mlfqs_load_60+0x75>
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c0030823:	8b 83 f8 22 00 00    	mov    0x22f8(%ebx),%eax
c0030829:	8b 93 fc 22 00 00    	mov    0x22fc(%ebx),%edx
c003082f:	83 ec 08             	sub    $0x8,%esp
c0030832:	52                   	push   %edx
c0030833:	50                   	push   %eax
c0030834:	e8 9b 48 ff ff       	call   c00250d4 <timer_elapsed>
c0030839:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %d seconds.",
c003083c:	6a 00                	push   $0x0
c003083e:	6a 64                	push   $0x64
c0030840:	52                   	push   %edx
c0030841:	50                   	push   %eax
c0030842:	e8 57 a8 ff ff       	call   c002b09e <__divdi3>
c0030847:	83 c4 10             	add    $0x10,%esp
c003084a:	83 ec 04             	sub    $0x4,%esp
c003084d:	52                   	push   %edx
c003084e:	50                   	push   %eax
c003084f:	8d 83 9c b4 ff ff    	lea    -0x4b64(%ebx),%eax
c0030855:	50                   	push   %eax
c0030856:	e8 cd d9 ff ff       	call   c002e228 <msg>
c003085b:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 90; i++) 
c003085e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0030865:	e9 a5 00 00 00       	jmp    c003090f <test_mlfqs_load_60+0x19a>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c003086a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c003086d:	83 c0 05             	add    $0x5,%eax
c0030870:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c0030876:	89 c6                	mov    %eax,%esi
c0030878:	89 c7                	mov    %eax,%edi
c003087a:	c1 ff 1f             	sar    $0x1f,%edi
c003087d:	8b 83 f8 22 00 00    	mov    0x22f8(%ebx),%eax
c0030883:	8b 93 fc 22 00 00    	mov    0x22fc(%ebx),%edx
c0030889:	01 f0                	add    %esi,%eax
c003088b:	11 fa                	adc    %edi,%edx
c003088d:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0030890:	89 55 dc             	mov    %edx,-0x24(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c0030893:	e8 f7 47 ff ff       	call   c002508f <timer_ticks>
c0030898:	89 c6                	mov    %eax,%esi
c003089a:	89 d7                	mov    %edx,%edi
c003089c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c003089f:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00308a2:	29 f0                	sub    %esi,%eax
c00308a4:	19 fa                	sbb    %edi,%edx
c00308a6:	83 ec 08             	sub    $0x8,%esp
c00308a9:	52                   	push   %edx
c00308aa:	50                   	push   %eax
c00308ab:	e8 4d 48 ff ff       	call   c00250fd <timer_sleep>
c00308b0:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c00308b3:	e8 99 0e ff ff       	call   c0021751 <thread_get_load_avg>
c00308b8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c00308bb:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c00308be:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c00308c3:	89 f0                	mov    %esi,%eax
c00308c5:	f7 ea                	imul   %edx
c00308c7:	89 d0                	mov    %edx,%eax
c00308c9:	c1 f8 05             	sar    $0x5,%eax
c00308cc:	89 f2                	mov    %esi,%edx
c00308ce:	c1 fa 1f             	sar    $0x1f,%edx
c00308d1:	29 d0                	sub    %edx,%eax
c00308d3:	89 c1                	mov    %eax,%ecx
c00308d5:	6b c1 64             	imul   $0x64,%ecx,%eax
c00308d8:	89 f1                	mov    %esi,%ecx
c00308da:	29 c1                	sub    %eax,%ecx
c00308dc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c00308df:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c00308e4:	89 f0                	mov    %esi,%eax
c00308e6:	f7 ea                	imul   %edx
c00308e8:	89 d0                	mov    %edx,%eax
c00308ea:	c1 f8 05             	sar    $0x5,%eax
c00308ed:	c1 fe 1f             	sar    $0x1f,%esi
c00308f0:	29 f0                	sub    %esi,%eax
c00308f2:	89 c2                	mov    %eax,%edx
c00308f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00308f7:	01 c0                	add    %eax,%eax
c00308f9:	51                   	push   %ecx
c00308fa:	52                   	push   %edx
c00308fb:	50                   	push   %eax
c00308fc:	8d 83 c0 b4 ff ff    	lea    -0x4b40(%ebx),%eax
c0030902:	50                   	push   %eax
c0030903:	e8 20 d9 ff ff       	call   c002e228 <msg>
c0030908:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 90; i++) 
c003090b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c003090f:	83 7d e4 59          	cmpl   $0x59,-0x1c(%ebp)
c0030913:	0f 8e 51 ff ff ff    	jle    c003086a <test_mlfqs_load_60+0xf5>
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c0030919:	90                   	nop
c003091a:	90                   	nop
c003091b:	8d 65 f4             	lea    -0xc(%ebp),%esp
c003091e:	5b                   	pop    %ebx
c003091f:	5e                   	pop    %esi
c0030920:	5f                   	pop    %edi
c0030921:	5d                   	pop    %ebp
c0030922:	c3                   	ret    

c0030923 <load_thread>:

static void
load_thread (void *aux UNUSED) 
{
c0030923:	55                   	push   %ebp
c0030924:	89 e5                	mov    %esp,%ebp
c0030926:	57                   	push   %edi
c0030927:	56                   	push   %esi
c0030928:	53                   	push   %ebx
c0030929:	83 ec 2c             	sub    $0x2c,%esp
c003092c:	e8 fb 0a 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030931:	81 c3 47 9a 00 00    	add    $0x9a47,%ebx
  int64_t sleep_time = 10 * TIMER_FREQ;
c0030937:	c7 45 e0 e8 03 00 00 	movl   $0x3e8,-0x20(%ebp)
c003093e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
c0030945:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0030948:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c003094b:	05 70 17 00 00       	add    $0x1770,%eax
c0030950:	83 d2 00             	adc    $0x0,%edx
c0030953:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0030956:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;
c0030959:	8b 45 d8             	mov    -0x28(%ebp),%eax
c003095c:	8b 55 dc             	mov    -0x24(%ebp),%edx
c003095f:	05 70 17 00 00       	add    $0x1770,%eax
c0030964:	83 d2 00             	adc    $0x0,%edx
c0030967:	89 45 d0             	mov    %eax,-0x30(%ebp)
c003096a:	89 55 d4             	mov    %edx,-0x2c(%ebp)

  thread_set_nice (20);
c003096d:	83 ec 0c             	sub    $0xc,%esp
c0030970:	6a 14                	push   $0x14
c0030972:	e8 9f 0d ff ff       	call   c0021716 <thread_set_nice>
c0030977:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (start_time));
c003097a:	8b 83 f8 22 00 00    	mov    0x22f8(%ebx),%eax
c0030980:	8b 93 fc 22 00 00    	mov    0x22fc(%ebx),%edx
c0030986:	83 ec 08             	sub    $0x8,%esp
c0030989:	52                   	push   %edx
c003098a:	50                   	push   %eax
c003098b:	e8 44 47 ff ff       	call   c00250d4 <timer_elapsed>
c0030990:	83 c4 10             	add    $0x10,%esp
c0030993:	89 c6                	mov    %eax,%esi
c0030995:	89 d7                	mov    %edx,%edi
c0030997:	8b 45 e0             	mov    -0x20(%ebp),%eax
c003099a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c003099d:	29 f0                	sub    %esi,%eax
c003099f:	19 fa                	sbb    %edi,%edx
c00309a1:	83 ec 08             	sub    $0x8,%esp
c00309a4:	52                   	push   %edx
c00309a5:	50                   	push   %eax
c00309a6:	e8 52 47 ff ff       	call   c00250fd <timer_sleep>
c00309ab:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c00309ae:	eb 01                	jmp    c00309b1 <load_thread+0x8e>
    continue;
c00309b0:	90                   	nop
  while (timer_elapsed (start_time) < spin_time)
c00309b1:	8b 83 f8 22 00 00    	mov    0x22f8(%ebx),%eax
c00309b7:	8b 93 fc 22 00 00    	mov    0x22fc(%ebx),%edx
c00309bd:	83 ec 08             	sub    $0x8,%esp
c00309c0:	52                   	push   %edx
c00309c1:	50                   	push   %eax
c00309c2:	e8 0d 47 ff ff       	call   c00250d4 <timer_elapsed>
c00309c7:	83 c4 10             	add    $0x10,%esp
c00309ca:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c00309cd:	89 d0                	mov    %edx,%eax
c00309cf:	1b 45 dc             	sbb    -0x24(%ebp),%eax
c00309d2:	7c dc                	jl     c00309b0 <load_thread+0x8d>
  timer_sleep (exit_time - timer_elapsed (start_time));
c00309d4:	8b 83 f8 22 00 00    	mov    0x22f8(%ebx),%eax
c00309da:	8b 93 fc 22 00 00    	mov    0x22fc(%ebx),%edx
c00309e0:	83 ec 08             	sub    $0x8,%esp
c00309e3:	52                   	push   %edx
c00309e4:	50                   	push   %eax
c00309e5:	e8 ea 46 ff ff       	call   c00250d4 <timer_elapsed>
c00309ea:	83 c4 10             	add    $0x10,%esp
c00309ed:	89 c6                	mov    %eax,%esi
c00309ef:	89 d7                	mov    %edx,%edi
c00309f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00309f4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c00309f7:	29 f0                	sub    %esi,%eax
c00309f9:	19 fa                	sbb    %edi,%edx
c00309fb:	83 ec 08             	sub    $0x8,%esp
c00309fe:	52                   	push   %edx
c00309ff:	50                   	push   %eax
c0030a00:	e8 f8 46 ff ff       	call   c00250fd <timer_sleep>
c0030a05:	83 c4 10             	add    $0x10,%esp
}
c0030a08:	90                   	nop
c0030a09:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0030a0c:	5b                   	pop    %ebx
c0030a0d:	5e                   	pop    %esi
c0030a0e:	5f                   	pop    %edi
c0030a0f:	5d                   	pop    %ebp
c0030a10:	c3                   	ret    

c0030a11 <test_mlfqs_load_avg>:

#define THREAD_CNT 60

void
test_mlfqs_load_avg (void) 
{
c0030a11:	55                   	push   %ebp
c0030a12:	89 e5                	mov    %esp,%ebp
c0030a14:	57                   	push   %edi
c0030a15:	56                   	push   %esi
c0030a16:	53                   	push   %ebx
c0030a17:	83 ec 3c             	sub    $0x3c,%esp
c0030a1a:	e8 0d 0a 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030a1f:	81 c3 59 99 00 00    	add    $0x9959,%ebx
  int i;
  
  ASSERT (thread_mlfqs);
c0030a25:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c0030a2b:	0f b6 00             	movzbl (%eax),%eax
c0030a2e:	84 c0                	test   %al,%al
c0030a30:	75 29                	jne    c0030a5b <test_mlfqs_load_avg+0x4a>
c0030a32:	83 ec 0c             	sub    $0xc,%esp
c0030a35:	8d 83 fc b4 ff ff    	lea    -0x4b04(%ebx),%eax
c0030a3b:	50                   	push   %eax
c0030a3c:	8d 83 09 b5 ff ff    	lea    -0x4af7(%ebx),%eax
c0030a42:	50                   	push   %eax
c0030a43:	8d 83 b8 b5 ff ff    	lea    -0x4a48(%ebx),%eax
c0030a49:	50                   	push   %eax
c0030a4a:	68 82 00 00 00       	push   $0x82
c0030a4f:	8d 83 20 b5 ff ff    	lea    -0x4ae0(%ebx),%eax
c0030a55:	50                   	push   %eax
c0030a56:	e8 09 ad ff ff       	call   c002b764 <debug_panic>

  start_time = timer_ticks ();
c0030a5b:	e8 2f 46 ff ff       	call   c002508f <timer_ticks>
c0030a60:	89 83 00 23 00 00    	mov    %eax,0x2300(%ebx)
c0030a66:	89 93 04 23 00 00    	mov    %edx,0x2304(%ebx)
  msg ("Starting %d load threads...", THREAD_CNT);
c0030a6c:	83 ec 08             	sub    $0x8,%esp
c0030a6f:	6a 3c                	push   $0x3c
c0030a71:	8d 83 45 b5 ff ff    	lea    -0x4abb(%ebx),%eax
c0030a77:	50                   	push   %eax
c0030a78:	e8 ab d7 ff ff       	call   c002e228 <msg>
c0030a7d:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c0030a80:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0030a87:	eb 35                	jmp    c0030abe <test_mlfqs_load_avg+0xad>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c0030a89:	ff 75 e4             	push   -0x1c(%ebp)
c0030a8c:	8d 83 61 b5 ff ff    	lea    -0x4a9f(%ebx),%eax
c0030a92:	50                   	push   %eax
c0030a93:	6a 10                	push   $0x10
c0030a95:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c0030a98:	50                   	push   %eax
c0030a99:	e8 14 84 ff ff       	call   c0028eb2 <snprintf>
c0030a9e:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c0030aa1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0030aa4:	50                   	push   %eax
c0030aa5:	8d 83 59 68 ff ff    	lea    -0x97a7(%ebx),%eax
c0030aab:	50                   	push   %eax
c0030aac:	6a 1f                	push   $0x1f
c0030aae:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c0030ab1:	50                   	push   %eax
c0030ab2:	e8 ed 05 ff ff       	call   c00210a4 <thread_create>
c0030ab7:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c0030aba:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0030abe:	83 7d e4 3b          	cmpl   $0x3b,-0x1c(%ebp)
c0030ac2:	7e c5                	jle    c0030a89 <test_mlfqs_load_avg+0x78>
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c0030ac4:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
c0030aca:	8b 93 04 23 00 00    	mov    0x2304(%ebx),%edx
c0030ad0:	83 ec 08             	sub    $0x8,%esp
c0030ad3:	52                   	push   %edx
c0030ad4:	50                   	push   %eax
c0030ad5:	e8 fa 45 ff ff       	call   c00250d4 <timer_elapsed>
c0030ada:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %d seconds.",
c0030add:	6a 00                	push   $0x0
c0030adf:	6a 64                	push   $0x64
c0030ae1:	52                   	push   %edx
c0030ae2:	50                   	push   %eax
c0030ae3:	e8 b6 a5 ff ff       	call   c002b09e <__divdi3>
c0030ae8:	83 c4 10             	add    $0x10,%esp
c0030aeb:	83 ec 04             	sub    $0x4,%esp
c0030aee:	52                   	push   %edx
c0030aef:	50                   	push   %eax
c0030af0:	8d 83 6c b5 ff ff    	lea    -0x4a94(%ebx),%eax
c0030af6:	50                   	push   %eax
c0030af7:	e8 2c d7 ff ff       	call   c002e228 <msg>
c0030afc:	83 c4 10             	add    $0x10,%esp
  thread_set_nice (-20);
c0030aff:	83 ec 0c             	sub    $0xc,%esp
c0030b02:	6a ec                	push   $0xffffffec
c0030b04:	e8 0d 0c ff ff       	call   c0021716 <thread_set_nice>
c0030b09:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 90; i++) 
c0030b0c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0030b13:	e9 a5 00 00 00       	jmp    c0030bbd <test_mlfqs_load_avg+0x1ac>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c0030b18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0030b1b:	83 c0 05             	add    $0x5,%eax
c0030b1e:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c0030b24:	89 c6                	mov    %eax,%esi
c0030b26:	89 c7                	mov    %eax,%edi
c0030b28:	c1 ff 1f             	sar    $0x1f,%edi
c0030b2b:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
c0030b31:	8b 93 04 23 00 00    	mov    0x2304(%ebx),%edx
c0030b37:	01 f0                	add    %esi,%eax
c0030b39:	11 fa                	adc    %edi,%edx
c0030b3b:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0030b3e:	89 55 dc             	mov    %edx,-0x24(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c0030b41:	e8 49 45 ff ff       	call   c002508f <timer_ticks>
c0030b46:	89 c6                	mov    %eax,%esi
c0030b48:	89 d7                	mov    %edx,%edi
c0030b4a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0030b4d:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0030b50:	29 f0                	sub    %esi,%eax
c0030b52:	19 fa                	sbb    %edi,%edx
c0030b54:	83 ec 08             	sub    $0x8,%esp
c0030b57:	52                   	push   %edx
c0030b58:	50                   	push   %eax
c0030b59:	e8 9f 45 ff ff       	call   c00250fd <timer_sleep>
c0030b5e:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c0030b61:	e8 eb 0b ff ff       	call   c0021751 <thread_get_load_avg>
c0030b66:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c0030b69:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c0030b6c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030b71:	89 f0                	mov    %esi,%eax
c0030b73:	f7 ea                	imul   %edx
c0030b75:	89 d0                	mov    %edx,%eax
c0030b77:	c1 f8 05             	sar    $0x5,%eax
c0030b7a:	89 f2                	mov    %esi,%edx
c0030b7c:	c1 fa 1f             	sar    $0x1f,%edx
c0030b7f:	29 d0                	sub    %edx,%eax
c0030b81:	89 c1                	mov    %eax,%ecx
c0030b83:	6b c1 64             	imul   $0x64,%ecx,%eax
c0030b86:	89 f1                	mov    %esi,%ecx
c0030b88:	29 c1                	sub    %eax,%ecx
c0030b8a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
c0030b8d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030b92:	89 f0                	mov    %esi,%eax
c0030b94:	f7 ea                	imul   %edx
c0030b96:	89 d0                	mov    %edx,%eax
c0030b98:	c1 f8 05             	sar    $0x5,%eax
c0030b9b:	c1 fe 1f             	sar    $0x1f,%esi
c0030b9e:	29 f0                	sub    %esi,%eax
c0030ba0:	89 c2                	mov    %eax,%edx
c0030ba2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0030ba5:	01 c0                	add    %eax,%eax
c0030ba7:	51                   	push   %ecx
c0030ba8:	52                   	push   %edx
c0030ba9:	50                   	push   %eax
c0030baa:	8d 83 90 b5 ff ff    	lea    -0x4a70(%ebx),%eax
c0030bb0:	50                   	push   %eax
c0030bb1:	e8 72 d6 ff ff       	call   c002e228 <msg>
c0030bb6:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 90; i++) 
c0030bb9:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0030bbd:	83 7d e4 59          	cmpl   $0x59,-0x1c(%ebp)
c0030bc1:	0f 8e 51 ff ff ff    	jle    c0030b18 <test_mlfqs_load_avg+0x107>
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c0030bc7:	90                   	nop
c0030bc8:	90                   	nop
c0030bc9:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0030bcc:	5b                   	pop    %ebx
c0030bcd:	5e                   	pop    %esi
c0030bce:	5f                   	pop    %edi
c0030bcf:	5d                   	pop    %ebp
c0030bd0:	c3                   	ret    

c0030bd1 <load_thread>:

static void
load_thread (void *seq_no_) 
{
c0030bd1:	55                   	push   %ebp
c0030bd2:	89 e5                	mov    %esp,%ebp
c0030bd4:	57                   	push   %edi
c0030bd5:	56                   	push   %esi
c0030bd6:	53                   	push   %ebx
c0030bd7:	83 ec 1c             	sub    $0x1c,%esp
c0030bda:	e8 4d 08 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030bdf:	81 c3 99 97 00 00    	add    $0x9799,%ebx
  int seq_no = (int) seq_no_;
c0030be5:	8b 45 08             	mov    0x8(%ebp),%eax
c0030be8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c0030beb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0030bee:	83 c0 0a             	add    $0xa,%eax
c0030bf1:	6b c0 64             	imul   $0x64,%eax,%eax
c0030bf4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c0030bf7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0030bfa:	05 70 17 00 00       	add    $0x1770,%eax
c0030bff:	89 45 dc             	mov    %eax,-0x24(%ebp)
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);
c0030c02:	c7 45 d8 e0 2e 00 00 	movl   $0x2ee0,-0x28(%ebp)

  timer_sleep (sleep_time - timer_elapsed (start_time));
c0030c09:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0030c0c:	89 c6                	mov    %eax,%esi
c0030c0e:	89 c7                	mov    %eax,%edi
c0030c10:	c1 ff 1f             	sar    $0x1f,%edi
c0030c13:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
c0030c19:	8b 93 04 23 00 00    	mov    0x2304(%ebx),%edx
c0030c1f:	83 ec 08             	sub    $0x8,%esp
c0030c22:	52                   	push   %edx
c0030c23:	50                   	push   %eax
c0030c24:	e8 ab 44 ff ff       	call   c00250d4 <timer_elapsed>
c0030c29:	83 c4 10             	add    $0x10,%esp
c0030c2c:	29 c6                	sub    %eax,%esi
c0030c2e:	19 d7                	sbb    %edx,%edi
c0030c30:	89 f0                	mov    %esi,%eax
c0030c32:	89 fa                	mov    %edi,%edx
c0030c34:	83 ec 08             	sub    $0x8,%esp
c0030c37:	52                   	push   %edx
c0030c38:	50                   	push   %eax
c0030c39:	e8 bf 44 ff ff       	call   c00250fd <timer_sleep>
c0030c3e:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c0030c41:	eb 01                	jmp    c0030c44 <load_thread+0x73>
    continue;
c0030c43:	90                   	nop
  while (timer_elapsed (start_time) < spin_time)
c0030c44:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
c0030c4a:	8b 93 04 23 00 00    	mov    0x2304(%ebx),%edx
c0030c50:	83 ec 08             	sub    $0x8,%esp
c0030c53:	52                   	push   %edx
c0030c54:	50                   	push   %eax
c0030c55:	e8 7a 44 ff ff       	call   c00250d4 <timer_elapsed>
c0030c5a:	83 c4 10             	add    $0x10,%esp
c0030c5d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
c0030c60:	89 ce                	mov    %ecx,%esi
c0030c62:	89 cf                	mov    %ecx,%edi
c0030c64:	c1 ff 1f             	sar    $0x1f,%edi
c0030c67:	39 f0                	cmp    %esi,%eax
c0030c69:	89 d0                	mov    %edx,%eax
c0030c6b:	19 f8                	sbb    %edi,%eax
c0030c6d:	7c d4                	jl     c0030c43 <load_thread+0x72>
  timer_sleep (exit_time - timer_elapsed (start_time));
c0030c6f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0030c72:	89 c6                	mov    %eax,%esi
c0030c74:	89 c7                	mov    %eax,%edi
c0030c76:	c1 ff 1f             	sar    $0x1f,%edi
c0030c79:	8b 83 00 23 00 00    	mov    0x2300(%ebx),%eax
c0030c7f:	8b 93 04 23 00 00    	mov    0x2304(%ebx),%edx
c0030c85:	83 ec 08             	sub    $0x8,%esp
c0030c88:	52                   	push   %edx
c0030c89:	50                   	push   %eax
c0030c8a:	e8 45 44 ff ff       	call   c00250d4 <timer_elapsed>
c0030c8f:	83 c4 10             	add    $0x10,%esp
c0030c92:	29 c6                	sub    %eax,%esi
c0030c94:	19 d7                	sbb    %edx,%edi
c0030c96:	89 f0                	mov    %esi,%eax
c0030c98:	89 fa                	mov    %edi,%edx
c0030c9a:	83 ec 08             	sub    $0x8,%esp
c0030c9d:	52                   	push   %edx
c0030c9e:	50                   	push   %eax
c0030c9f:	e8 59 44 ff ff       	call   c00250fd <timer_sleep>
c0030ca4:	83 c4 10             	add    $0x10,%esp
}
c0030ca7:	90                   	nop
c0030ca8:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0030cab:	5b                   	pop    %ebx
c0030cac:	5e                   	pop    %esi
c0030cad:	5f                   	pop    %edi
c0030cae:	5d                   	pop    %ebp
c0030caf:	c3                   	ret    

c0030cb0 <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c0030cb0:	55                   	push   %ebp
c0030cb1:	89 e5                	mov    %esp,%ebp
c0030cb3:	57                   	push   %edi
c0030cb4:	56                   	push   %esi
c0030cb5:	53                   	push   %ebx
c0030cb6:	83 ec 3c             	sub    $0x3c,%esp
c0030cb9:	e8 6e 07 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030cbe:	81 c3 ba 96 00 00    	add    $0x96ba,%ebx
  int64_t start_time;
  int last_elapsed = 0;
c0030cc4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  
  ASSERT (thread_mlfqs);
c0030ccb:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c0030cd1:	0f b6 00             	movzbl (%eax),%eax
c0030cd4:	84 c0                	test   %al,%al
c0030cd6:	75 26                	jne    c0030cfe <test_mlfqs_recent_1+0x4e>
c0030cd8:	83 ec 0c             	sub    $0xc,%esp
c0030cdb:	8d 83 cc b5 ff ff    	lea    -0x4a34(%ebx),%eax
c0030ce1:	50                   	push   %eax
c0030ce2:	8d 83 d9 b5 ff ff    	lea    -0x4a27(%ebx),%eax
c0030ce8:	50                   	push   %eax
c0030ce9:	8d 83 9c b6 ff ff    	lea    -0x4964(%ebx),%eax
c0030cef:	50                   	push   %eax
c0030cf0:	6a 73                	push   $0x73
c0030cf2:	8d 83 f0 b5 ff ff    	lea    -0x4a10(%ebx),%eax
c0030cf8:	50                   	push   %eax
c0030cf9:	e8 66 aa ff ff       	call   c002b764 <debug_panic>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c0030cfe:	83 ec 0c             	sub    $0xc,%esp
c0030d01:	8d 83 18 b6 ff ff    	lea    -0x49e8(%ebx),%eax
c0030d07:	50                   	push   %eax
c0030d08:	e8 1b d5 ff ff       	call   c002e228 <msg>
c0030d0d:	83 c4 10             	add    $0x10,%esp
      start_time = timer_ticks ();
c0030d10:	e8 7a 43 ff ff       	call   c002508f <timer_ticks>
c0030d15:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0030d18:	89 55 dc             	mov    %edx,-0x24(%ebp)
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c0030d1b:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0030d1e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0030d21:	83 c0 63             	add    $0x63,%eax
c0030d24:	83 d2 00             	adc    $0x0,%edx
c0030d27:	6a 00                	push   $0x0
c0030d29:	6a 64                	push   $0x64
c0030d2b:	52                   	push   %edx
c0030d2c:	50                   	push   %eax
c0030d2d:	e8 6c a3 ff ff       	call   c002b09e <__divdi3>
c0030d32:	83 c4 10             	add    $0x10,%esp
c0030d35:	2b 45 d8             	sub    -0x28(%ebp),%eax
c0030d38:	1b 55 dc             	sbb    -0x24(%ebp),%edx
c0030d3b:	05 e8 03 00 00       	add    $0x3e8,%eax
c0030d40:	83 d2 00             	adc    $0x0,%edx
c0030d43:	83 ec 08             	sub    $0x8,%esp
c0030d46:	52                   	push   %edx
c0030d47:	50                   	push   %eax
c0030d48:	e8 b0 43 ff ff       	call   c00250fd <timer_sleep>
c0030d4d:	83 c4 10             	add    $0x10,%esp
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c0030d50:	e8 25 0a ff ff       	call   c002177a <thread_get_recent_cpu>
c0030d55:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c0030d5a:	7f a2                	jg     c0030cfe <test_mlfqs_recent_1+0x4e>

  start_time = timer_ticks ();
c0030d5c:	e8 2e 43 ff ff       	call   c002508f <timer_ticks>
c0030d61:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0030d64:	89 55 dc             	mov    %edx,-0x24(%ebp)
  for (;;) 
    {
      int elapsed = timer_elapsed (start_time);
c0030d67:	83 ec 08             	sub    $0x8,%esp
c0030d6a:	ff 75 dc             	push   -0x24(%ebp)
c0030d6d:	ff 75 d8             	push   -0x28(%ebp)
c0030d70:	e8 5f 43 ff ff       	call   c00250d4 <timer_elapsed>
c0030d75:	83 c4 10             	add    $0x10,%esp
c0030d78:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c0030d7b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c0030d7e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030d83:	89 c8                	mov    %ecx,%eax
c0030d85:	f7 ea                	imul   %edx
c0030d87:	89 d0                	mov    %edx,%eax
c0030d89:	c1 f8 06             	sar    $0x6,%eax
c0030d8c:	89 ca                	mov    %ecx,%edx
c0030d8e:	c1 fa 1f             	sar    $0x1f,%edx
c0030d91:	29 d0                	sub    %edx,%eax
c0030d93:	69 d0 c8 00 00 00    	imul   $0xc8,%eax,%edx
c0030d99:	89 c8                	mov    %ecx,%eax
c0030d9b:	29 d0                	sub    %edx,%eax
c0030d9d:	85 c0                	test   %eax,%eax
c0030d9f:	0f 85 d0 00 00 00    	jne    c0030e75 <test_mlfqs_recent_1+0x1c5>
c0030da5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0030da8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0030dab:	0f 8e c4 00 00 00    	jle    c0030e75 <test_mlfqs_recent_1+0x1c5>
        {
          int recent_cpu = thread_get_recent_cpu ();
c0030db1:	e8 c4 09 ff ff       	call   c002177a <thread_get_recent_cpu>
c0030db6:	89 45 d0             	mov    %eax,-0x30(%ebp)
          int load_avg = thread_get_load_avg ();
c0030db9:	e8 93 09 ff ff       	call   c0021751 <thread_get_load_avg>
c0030dbe:	89 45 cc             	mov    %eax,-0x34(%ebp)
          int elapsed_seconds = elapsed / TIMER_FREQ;
c0030dc1:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c0030dc4:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030dc9:	89 c8                	mov    %ecx,%eax
c0030dcb:	f7 ea                	imul   %edx
c0030dcd:	89 d0                	mov    %edx,%eax
c0030dcf:	c1 f8 05             	sar    $0x5,%eax
c0030dd2:	c1 f9 1f             	sar    $0x1f,%ecx
c0030dd5:	89 ca                	mov    %ecx,%edx
c0030dd7:	29 d0                	sub    %edx,%eax
c0030dd9:	89 45 c8             	mov    %eax,-0x38(%ebp)
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c0030ddc:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c0030ddf:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030de4:	89 c8                	mov    %ecx,%eax
c0030de6:	f7 ea                	imul   %edx
c0030de8:	89 d0                	mov    %edx,%eax
c0030dea:	c1 f8 05             	sar    $0x5,%eax
c0030ded:	89 ca                	mov    %ecx,%edx
c0030def:	c1 fa 1f             	sar    $0x1f,%edx
c0030df2:	29 d0                	sub    %edx,%eax
c0030df4:	89 c6                	mov    %eax,%esi
c0030df6:	6b c6 64             	imul   $0x64,%esi,%eax
c0030df9:	89 ce                	mov    %ecx,%esi
c0030dfb:	29 c6                	sub    %eax,%esi
c0030dfd:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c0030e00:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030e05:	89 c8                	mov    %ecx,%eax
c0030e07:	f7 ea                	imul   %edx
c0030e09:	89 d0                	mov    %edx,%eax
c0030e0b:	c1 f8 05             	sar    $0x5,%eax
c0030e0e:	c1 f9 1f             	sar    $0x1f,%ecx
c0030e11:	89 ca                	mov    %ecx,%edx
c0030e13:	29 d0                	sub    %edx,%eax
c0030e15:	89 45 c4             	mov    %eax,-0x3c(%ebp)
c0030e18:	8b 7d d0             	mov    -0x30(%ebp),%edi
c0030e1b:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030e20:	89 f8                	mov    %edi,%eax
c0030e22:	f7 ea                	imul   %edx
c0030e24:	c1 fa 05             	sar    $0x5,%edx
c0030e27:	89 d0                	mov    %edx,%eax
c0030e29:	89 fa                	mov    %edi,%edx
c0030e2b:	c1 fa 1f             	sar    $0x1f,%edx
c0030e2e:	89 c1                	mov    %eax,%ecx
c0030e30:	29 d1                	sub    %edx,%ecx
c0030e32:	6b c1 64             	imul   $0x64,%ecx,%eax
c0030e35:	29 c7                	sub    %eax,%edi
c0030e37:	89 f9                	mov    %edi,%ecx
c0030e39:	8b 7d d0             	mov    -0x30(%ebp),%edi
c0030e3c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0030e41:	89 f8                	mov    %edi,%eax
c0030e43:	f7 ea                	imul   %edx
c0030e45:	c1 fa 05             	sar    $0x5,%edx
c0030e48:	89 d0                	mov    %edx,%eax
c0030e4a:	c1 ff 1f             	sar    $0x1f,%edi
c0030e4d:	89 fa                	mov    %edi,%edx
c0030e4f:	29 d0                	sub    %edx,%eax
c0030e51:	83 ec 08             	sub    $0x8,%esp
c0030e54:	56                   	push   %esi
c0030e55:	ff 75 c4             	push   -0x3c(%ebp)
c0030e58:	51                   	push   %ecx
c0030e59:	50                   	push   %eax
c0030e5a:	ff 75 c8             	push   -0x38(%ebp)
c0030e5d:	8d 83 5c b6 ff ff    	lea    -0x49a4(%ebx),%eax
c0030e63:	50                   	push   %eax
c0030e64:	e8 bf d3 ff ff       	call   c002e228 <msg>
c0030e69:	83 c4 20             	add    $0x20,%esp
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c0030e6c:	81 7d c8 b3 00 00 00 	cmpl   $0xb3,-0x38(%ebp)
c0030e73:	7f 0b                	jg     c0030e80 <test_mlfqs_recent_1+0x1d0>
            break;
        } 
      last_elapsed = elapsed;
c0030e75:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0030e78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    {
c0030e7b:	e9 e7 fe ff ff       	jmp    c0030d67 <test_mlfqs_recent_1+0xb7>
            break;
c0030e80:	90                   	nop
    }
}
c0030e81:	90                   	nop
c0030e82:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0030e85:	5b                   	pop    %ebx
c0030e86:	5e                   	pop    %esi
c0030e87:	5f                   	pop    %edi
c0030e88:	5d                   	pop    %ebp
c0030e89:	c3                   	ret    

c0030e8a <test_mlfqs_fair_2>:

static void test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step);

void
test_mlfqs_fair_2 (void) 
{
c0030e8a:	55                   	push   %ebp
c0030e8b:	89 e5                	mov    %esp,%ebp
c0030e8d:	83 ec 08             	sub    $0x8,%esp
c0030e90:	e8 93 05 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0030e95:	05 e3 94 00 00       	add    $0x94e3,%eax
  test_mlfqs_fair (2, 0, 0);
c0030e9a:	83 ec 04             	sub    $0x4,%esp
c0030e9d:	6a 00                	push   $0x0
c0030e9f:	6a 00                	push   $0x0
c0030ea1:	6a 02                	push   $0x2
c0030ea3:	e8 72 00 00 00       	call   c0030f1a <test_mlfqs_fair>
c0030ea8:	83 c4 10             	add    $0x10,%esp
}
c0030eab:	90                   	nop
c0030eac:	c9                   	leave  
c0030ead:	c3                   	ret    

c0030eae <test_mlfqs_fair_20>:

void
test_mlfqs_fair_20 (void) 
{
c0030eae:	55                   	push   %ebp
c0030eaf:	89 e5                	mov    %esp,%ebp
c0030eb1:	83 ec 08             	sub    $0x8,%esp
c0030eb4:	e8 6f 05 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0030eb9:	05 bf 94 00 00       	add    $0x94bf,%eax
  test_mlfqs_fair (20, 0, 0);
c0030ebe:	83 ec 04             	sub    $0x4,%esp
c0030ec1:	6a 00                	push   $0x0
c0030ec3:	6a 00                	push   $0x0
c0030ec5:	6a 14                	push   $0x14
c0030ec7:	e8 4e 00 00 00       	call   c0030f1a <test_mlfqs_fair>
c0030ecc:	83 c4 10             	add    $0x10,%esp
}
c0030ecf:	90                   	nop
c0030ed0:	c9                   	leave  
c0030ed1:	c3                   	ret    

c0030ed2 <test_mlfqs_nice_2>:

void
test_mlfqs_nice_2 (void) 
{
c0030ed2:	55                   	push   %ebp
c0030ed3:	89 e5                	mov    %esp,%ebp
c0030ed5:	83 ec 08             	sub    $0x8,%esp
c0030ed8:	e8 4b 05 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0030edd:	05 9b 94 00 00       	add    $0x949b,%eax
  test_mlfqs_fair (2, 0, 5);
c0030ee2:	83 ec 04             	sub    $0x4,%esp
c0030ee5:	6a 05                	push   $0x5
c0030ee7:	6a 00                	push   $0x0
c0030ee9:	6a 02                	push   $0x2
c0030eeb:	e8 2a 00 00 00       	call   c0030f1a <test_mlfqs_fair>
c0030ef0:	83 c4 10             	add    $0x10,%esp
}
c0030ef3:	90                   	nop
c0030ef4:	c9                   	leave  
c0030ef5:	c3                   	ret    

c0030ef6 <test_mlfqs_nice_10>:

void
test_mlfqs_nice_10 (void) 
{
c0030ef6:	55                   	push   %ebp
c0030ef7:	89 e5                	mov    %esp,%ebp
c0030ef9:	83 ec 08             	sub    $0x8,%esp
c0030efc:	e8 27 05 00 00       	call   c0031428 <__x86.get_pc_thunk.ax>
c0030f01:	05 77 94 00 00       	add    $0x9477,%eax
  test_mlfqs_fair (10, 0, 1);
c0030f06:	83 ec 04             	sub    $0x4,%esp
c0030f09:	6a 01                	push   $0x1
c0030f0b:	6a 00                	push   $0x0
c0030f0d:	6a 0a                	push   $0xa
c0030f0f:	e8 06 00 00 00       	call   c0030f1a <test_mlfqs_fair>
c0030f14:	83 c4 10             	add    $0x10,%esp
}
c0030f17:	90                   	nop
c0030f18:	c9                   	leave  
c0030f19:	c3                   	ret    

c0030f1a <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c0030f1a:	55                   	push   %ebp
c0030f1b:	89 e5                	mov    %esp,%ebp
c0030f1d:	53                   	push   %ebx
c0030f1e:	81 ec 74 01 00 00    	sub    $0x174,%esp
c0030f24:	e8 03 05 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0030f29:	81 c3 4f 94 00 00    	add    $0x944f,%ebx
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c0030f2f:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c0030f35:	0f b6 00             	movzbl (%eax),%eax
c0030f38:	84 c0                	test   %al,%al
c0030f3a:	75 26                	jne    c0030f62 <test_mlfqs_fair+0x48>
c0030f3c:	83 ec 0c             	sub    $0xc,%esp
c0030f3f:	8d 83 b0 b6 ff ff    	lea    -0x4950(%ebx),%eax
c0030f45:	50                   	push   %eax
c0030f46:	8d 83 bd b6 ff ff    	lea    -0x4943(%ebx),%eax
c0030f4c:	50                   	push   %eax
c0030f4d:	8d 83 fc b7 ff ff    	lea    -0x4804(%ebx),%eax
c0030f53:	50                   	push   %eax
c0030f54:	6a 49                	push   $0x49
c0030f56:	8d 83 d4 b6 ff ff    	lea    -0x492c(%ebx),%eax
c0030f5c:	50                   	push   %eax
c0030f5d:	e8 02 a8 ff ff       	call   c002b764 <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c0030f62:	83 7d 08 14          	cmpl   $0x14,0x8(%ebp)
c0030f66:	7e 26                	jle    c0030f8e <test_mlfqs_fair+0x74>
c0030f68:	83 ec 0c             	sub    $0xc,%esp
c0030f6b:	8d 83 f5 b6 ff ff    	lea    -0x490b(%ebx),%eax
c0030f71:	50                   	push   %eax
c0030f72:	8d 83 bd b6 ff ff    	lea    -0x4943(%ebx),%eax
c0030f78:	50                   	push   %eax
c0030f79:	8d 83 fc b7 ff ff    	lea    -0x4804(%ebx),%eax
c0030f7f:	50                   	push   %eax
c0030f80:	6a 4a                	push   $0x4a
c0030f82:	8d 83 d4 b6 ff ff    	lea    -0x492c(%ebx),%eax
c0030f88:	50                   	push   %eax
c0030f89:	e8 d6 a7 ff ff       	call   c002b764 <debug_panic>
  ASSERT (nice_min >= -10);
c0030f8e:	83 7d 0c f6          	cmpl   $0xfffffff6,0xc(%ebp)
c0030f92:	7d 26                	jge    c0030fba <test_mlfqs_fair+0xa0>
c0030f94:	83 ec 0c             	sub    $0xc,%esp
c0030f97:	8d 83 12 b7 ff ff    	lea    -0x48ee(%ebx),%eax
c0030f9d:	50                   	push   %eax
c0030f9e:	8d 83 bd b6 ff ff    	lea    -0x4943(%ebx),%eax
c0030fa4:	50                   	push   %eax
c0030fa5:	8d 83 fc b7 ff ff    	lea    -0x4804(%ebx),%eax
c0030fab:	50                   	push   %eax
c0030fac:	6a 4b                	push   $0x4b
c0030fae:	8d 83 d4 b6 ff ff    	lea    -0x492c(%ebx),%eax
c0030fb4:	50                   	push   %eax
c0030fb5:	e8 aa a7 ff ff       	call   c002b764 <debug_panic>
  ASSERT (nice_step >= 0);
c0030fba:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0030fbe:	79 26                	jns    c0030fe6 <test_mlfqs_fair+0xcc>
c0030fc0:	83 ec 0c             	sub    $0xc,%esp
c0030fc3:	8d 83 22 b7 ff ff    	lea    -0x48de(%ebx),%eax
c0030fc9:	50                   	push   %eax
c0030fca:	8d 83 bd b6 ff ff    	lea    -0x4943(%ebx),%eax
c0030fd0:	50                   	push   %eax
c0030fd1:	8d 83 fc b7 ff ff    	lea    -0x4804(%ebx),%eax
c0030fd7:	50                   	push   %eax
c0030fd8:	6a 4c                	push   $0x4c
c0030fda:	8d 83 d4 b6 ff ff    	lea    -0x492c(%ebx),%eax
c0030fe0:	50                   	push   %eax
c0030fe1:	e8 7e a7 ff ff       	call   c002b764 <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c0030fe6:	8b 45 08             	mov    0x8(%ebp),%eax
c0030fe9:	83 e8 01             	sub    $0x1,%eax
c0030fec:	0f af 45 10          	imul   0x10(%ebp),%eax
c0030ff0:	89 c2                	mov    %eax,%edx
c0030ff2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0030ff5:	01 d0                	add    %edx,%eax
c0030ff7:	83 f8 14             	cmp    $0x14,%eax
c0030ffa:	7e 26                	jle    c0031022 <test_mlfqs_fair+0x108>
c0030ffc:	83 ec 0c             	sub    $0xc,%esp
c0030fff:	8d 83 34 b7 ff ff    	lea    -0x48cc(%ebx),%eax
c0031005:	50                   	push   %eax
c0031006:	8d 83 bd b6 ff ff    	lea    -0x4943(%ebx),%eax
c003100c:	50                   	push   %eax
c003100d:	8d 83 fc b7 ff ff    	lea    -0x4804(%ebx),%eax
c0031013:	50                   	push   %eax
c0031014:	6a 4d                	push   $0x4d
c0031016:	8d 83 d4 b6 ff ff    	lea    -0x492c(%ebx),%eax
c003101c:	50                   	push   %eax
c003101d:	e8 42 a7 ff ff       	call   c002b764 <debug_panic>

  thread_set_nice (-20);
c0031022:	83 ec 0c             	sub    $0xc,%esp
c0031025:	6a ec                	push   $0xffffffec
c0031027:	e8 ea 06 ff ff       	call   c0021716 <thread_set_nice>
c003102c:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c003102f:	e8 5b 40 ff ff       	call   c002508f <timer_ticks>
c0031034:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0031037:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg ("Starting %d threads...", thread_cnt);
c003103a:	83 ec 08             	sub    $0x8,%esp
c003103d:	ff 75 08             	push   0x8(%ebp)
c0031040:	8d 83 62 b7 ff ff    	lea    -0x489e(%ebx),%eax
c0031046:	50                   	push   %eax
c0031047:	e8 dc d1 ff ff       	call   c002e228 <msg>
c003104c:	83 c4 10             	add    $0x10,%esp
  nice = nice_min;
c003104f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0031052:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c0031055:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c003105c:	eb 72                	jmp    c00310d0 <test_mlfqs_fair+0x1b6>
    {
      struct thread_info *ti = &info[i];
c003105e:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
c0031064:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0031067:	c1 e0 04             	shl    $0x4,%eax
c003106a:	01 d0                	add    %edx,%eax
c003106c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      char name[16];

      ti->start_time = start_time;
c003106f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0031072:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0031075:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0031078:	89 01                	mov    %eax,(%ecx)
c003107a:	89 51 04             	mov    %edx,0x4(%ecx)
      ti->tick_count = 0;
c003107d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0031080:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      ti->nice = nice;
c0031087:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c003108a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c003108d:	89 50 0c             	mov    %edx,0xc(%eax)

      snprintf(name, sizeof name, "load %d", i);
c0031090:	ff 75 f0             	push   -0x10(%ebp)
c0031093:	8d 83 79 b7 ff ff    	lea    -0x4887(%ebx),%eax
c0031099:	50                   	push   %eax
c003109a:	6a 10                	push   $0x10
c003109c:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c00310a2:	50                   	push   %eax
c00310a3:	e8 0a 7e ff ff       	call   c0028eb2 <snprintf>
c00310a8:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c00310ab:	ff 75 e4             	push   -0x1c(%ebp)
c00310ae:	8d 83 ed 6d ff ff    	lea    -0x9213(%ebx),%eax
c00310b4:	50                   	push   %eax
c00310b5:	6a 1f                	push   $0x1f
c00310b7:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c00310bd:	50                   	push   %eax
c00310be:	e8 e1 ff fe ff       	call   c00210a4 <thread_create>
c00310c3:	83 c4 10             	add    $0x10,%esp

      nice += nice_step;
c00310c6:	8b 45 10             	mov    0x10(%ebp),%eax
c00310c9:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c00310cc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00310d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00310d3:	3b 45 08             	cmp    0x8(%ebp),%eax
c00310d6:	7c 86                	jl     c003105e <test_mlfqs_fair+0x144>
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c00310d8:	83 ec 08             	sub    $0x8,%esp
c00310db:	ff 75 ec             	push   -0x14(%ebp)
c00310de:	ff 75 e8             	push   -0x18(%ebp)
c00310e1:	e8 ee 3f ff ff       	call   c00250d4 <timer_elapsed>
c00310e6:	83 c4 10             	add    $0x10,%esp
c00310e9:	83 ec 04             	sub    $0x4,%esp
c00310ec:	52                   	push   %edx
c00310ed:	50                   	push   %eax
c00310ee:	8d 83 84 b7 ff ff    	lea    -0x487c(%ebx),%eax
c00310f4:	50                   	push   %eax
c00310f5:	e8 2e d1 ff ff       	call   c002e228 <msg>
c00310fa:	83 c4 10             	add    $0x10,%esp

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c00310fd:	83 ec 0c             	sub    $0xc,%esp
c0031100:	8d 83 a8 b7 ff ff    	lea    -0x4858(%ebx),%eax
c0031106:	50                   	push   %eax
c0031107:	e8 1c d1 ff ff       	call   c002e228 <msg>
c003110c:	83 c4 10             	add    $0x10,%esp
  timer_sleep (40 * TIMER_FREQ);
c003110f:	83 ec 08             	sub    $0x8,%esp
c0031112:	6a 00                	push   $0x0
c0031114:	68 a0 0f 00 00       	push   $0xfa0
c0031119:	e8 df 3f ff ff       	call   c00250fd <timer_sleep>
c003111e:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
c0031121:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0031128:	eb 2c                	jmp    c0031156 <test_mlfqs_fair+0x23c>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c003112a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c003112d:	c1 e0 04             	shl    $0x4,%eax
c0031130:	8d 40 f8             	lea    -0x8(%eax),%eax
c0031133:	01 e8                	add    %ebp,%eax
c0031135:	2d 4c 01 00 00       	sub    $0x14c,%eax
c003113a:	8b 00                	mov    (%eax),%eax
c003113c:	83 ec 04             	sub    $0x4,%esp
c003113f:	50                   	push   %eax
c0031140:	ff 75 f0             	push   -0x10(%ebp)
c0031143:	8d 83 df b7 ff ff    	lea    -0x4821(%ebx),%eax
c0031149:	50                   	push   %eax
c003114a:	e8 d9 d0 ff ff       	call   c002e228 <msg>
c003114f:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c0031152:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0031156:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0031159:	3b 45 08             	cmp    0x8(%ebp),%eax
c003115c:	7c cc                	jl     c003112a <test_mlfqs_fair+0x210>
}
c003115e:	90                   	nop
c003115f:	90                   	nop
c0031160:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0031163:	c9                   	leave  
c0031164:	c3                   	ret    

c0031165 <load_thread>:

static void
load_thread (void *ti_) 
{
c0031165:	55                   	push   %ebp
c0031166:	89 e5                	mov    %esp,%ebp
c0031168:	57                   	push   %edi
c0031169:	56                   	push   %esi
c003116a:	53                   	push   %ebx
c003116b:	83 ec 4c             	sub    $0x4c,%esp
c003116e:	e8 b9 02 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c0031173:	81 c3 05 92 00 00    	add    $0x9205,%ebx
  struct thread_info *ti = ti_;
c0031179:	8b 45 08             	mov    0x8(%ebp),%eax
c003117c:	89 45 dc             	mov    %eax,-0x24(%ebp)
  int64_t sleep_time = 5 * TIMER_FREQ;
c003117f:	c7 45 d0 f4 01 00 00 	movl   $0x1f4,-0x30(%ebp)
c0031186:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
c003118d:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0031190:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0031193:	05 b8 0b 00 00       	add    $0xbb8,%eax
c0031198:	83 d2 00             	adc    $0x0,%edx
c003119b:	89 45 c8             	mov    %eax,-0x38(%ebp)
c003119e:	89 55 cc             	mov    %edx,-0x34(%ebp)
  int64_t last_time = 0;
c00311a1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c00311a8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  thread_set_nice (ti->nice);
c00311af:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00311b2:	8b 40 0c             	mov    0xc(%eax),%eax
c00311b5:	83 ec 0c             	sub    $0xc,%esp
c00311b8:	50                   	push   %eax
c00311b9:	e8 58 05 ff ff       	call   c0021716 <thread_set_nice>
c00311be:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c00311c1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00311c4:	8b 50 04             	mov    0x4(%eax),%edx
c00311c7:	8b 00                	mov    (%eax),%eax
c00311c9:	83 ec 08             	sub    $0x8,%esp
c00311cc:	52                   	push   %edx
c00311cd:	50                   	push   %eax
c00311ce:	e8 01 3f ff ff       	call   c00250d4 <timer_elapsed>
c00311d3:	83 c4 10             	add    $0x10,%esp
c00311d6:	89 45 b0             	mov    %eax,-0x50(%ebp)
c00311d9:	89 55 b4             	mov    %edx,-0x4c(%ebp)
c00311dc:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00311df:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c00311e2:	2b 45 b0             	sub    -0x50(%ebp),%eax
c00311e5:	1b 55 b4             	sbb    -0x4c(%ebp),%edx
c00311e8:	83 ec 08             	sub    $0x8,%esp
c00311eb:	52                   	push   %edx
c00311ec:	50                   	push   %eax
c00311ed:	e8 0b 3f ff ff       	call   c00250fd <timer_sleep>
c00311f2:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (ti->start_time) < spin_time) 
c00311f5:	eb 42                	jmp    c0031239 <load_thread+0xd4>
    {
      int64_t cur_time = timer_ticks ();
c00311f7:	e8 93 3e ff ff       	call   c002508f <timer_ticks>
c00311fc:	89 45 c0             	mov    %eax,-0x40(%ebp)
c00311ff:	89 55 c4             	mov    %edx,-0x3c(%ebp)
      if (cur_time != last_time)
c0031202:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0031205:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c0031208:	89 c1                	mov    %eax,%ecx
c003120a:	33 4d e0             	xor    -0x20(%ebp),%ecx
c003120d:	89 ce                	mov    %ecx,%esi
c003120f:	89 d0                	mov    %edx,%eax
c0031211:	33 45 e4             	xor    -0x1c(%ebp),%eax
c0031214:	89 c7                	mov    %eax,%edi
c0031216:	89 f8                	mov    %edi,%eax
c0031218:	09 f0                	or     %esi,%eax
c003121a:	85 c0                	test   %eax,%eax
c003121c:	74 0f                	je     c003122d <load_thread+0xc8>
        ti->tick_count++;
c003121e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0031221:	8b 40 08             	mov    0x8(%eax),%eax
c0031224:	8d 50 01             	lea    0x1(%eax),%edx
c0031227:	8b 45 dc             	mov    -0x24(%ebp),%eax
c003122a:	89 50 08             	mov    %edx,0x8(%eax)
      last_time = cur_time;
c003122d:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0031230:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c0031233:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0031236:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  while (timer_elapsed (ti->start_time) < spin_time) 
c0031239:	8b 45 dc             	mov    -0x24(%ebp),%eax
c003123c:	8b 50 04             	mov    0x4(%eax),%edx
c003123f:	8b 00                	mov    (%eax),%eax
c0031241:	83 ec 08             	sub    $0x8,%esp
c0031244:	52                   	push   %edx
c0031245:	50                   	push   %eax
c0031246:	e8 89 3e ff ff       	call   c00250d4 <timer_elapsed>
c003124b:	83 c4 10             	add    $0x10,%esp
c003124e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
c0031251:	89 d0                	mov    %edx,%eax
c0031253:	1b 45 cc             	sbb    -0x34(%ebp),%eax
c0031256:	7c 9f                	jl     c00311f7 <load_thread+0x92>
    }
}
c0031258:	90                   	nop
c0031259:	90                   	nop
c003125a:	8d 65 f4             	lea    -0xc(%ebp),%esp
c003125d:	5b                   	pop    %ebx
c003125e:	5e                   	pop    %esi
c003125f:	5f                   	pop    %edi
c0031260:	5d                   	pop    %ebp
c0031261:	c3                   	ret    

c0031262 <test_mlfqs_block>:

static void block_thread (void *lock_);

void
test_mlfqs_block (void) 
{
c0031262:	55                   	push   %ebp
c0031263:	89 e5                	mov    %esp,%ebp
c0031265:	56                   	push   %esi
c0031266:	53                   	push   %ebx
c0031267:	83 ec 20             	sub    $0x20,%esp
c003126a:	e8 bd 01 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c003126f:	81 c3 09 91 00 00    	add    $0x9109,%ebx
  int64_t start_time;
  struct lock lock;
  
  ASSERT (thread_mlfqs);
c0031275:	c7 c0 c8 ab 03 c0    	mov    $0xc003abc8,%eax
c003127b:	0f b6 00             	movzbl (%eax),%eax
c003127e:	84 c0                	test   %al,%al
c0031280:	75 26                	jne    c00312a8 <test_mlfqs_block+0x46>
c0031282:	83 ec 0c             	sub    $0xc,%esp
c0031285:	8d 83 0c b8 ff ff    	lea    -0x47f4(%ebx),%eax
c003128b:	50                   	push   %eax
c003128c:	8d 83 19 b8 ff ff    	lea    -0x47e7(%ebx),%eax
c0031292:	50                   	push   %eax
c0031293:	8d 83 78 b9 ff ff    	lea    -0x4688(%ebx),%eax
c0031299:	50                   	push   %eax
c003129a:	6a 1c                	push   $0x1c
c003129c:	8d 83 30 b8 ff ff    	lea    -0x47d0(%ebx),%eax
c00312a2:	50                   	push   %eax
c00312a3:	e8 bc a4 ff ff       	call   c002b764 <debug_panic>

  msg ("Main thread acquiring lock.");
c00312a8:	83 ec 0c             	sub    $0xc,%esp
c00312ab:	8d 83 52 b8 ff ff    	lea    -0x47ae(%ebx),%eax
c00312b1:	50                   	push   %eax
c00312b2:	e8 71 cf ff ff       	call   c002e228 <msg>
c00312b7:	83 c4 10             	add    $0x10,%esp
  lock_init (&lock);
c00312ba:	83 ec 0c             	sub    $0xc,%esp
c00312bd:	8d 45 d8             	lea    -0x28(%ebp),%eax
c00312c0:	50                   	push   %eax
c00312c1:	e8 0c 25 ff ff       	call   c00237d2 <lock_init>
c00312c6:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c00312c9:	83 ec 0c             	sub    $0xc,%esp
c00312cc:	8d 45 d8             	lea    -0x28(%ebp),%eax
c00312cf:	50                   	push   %eax
c00312d0:	e8 62 25 ff ff       	call   c0023837 <lock_acquire>
c00312d5:	83 c4 10             	add    $0x10,%esp
  
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c00312d8:	83 ec 0c             	sub    $0xc,%esp
c00312db:	8d 83 70 b8 ff ff    	lea    -0x4790(%ebx),%eax
c00312e1:	50                   	push   %eax
c00312e2:	e8 41 cf ff ff       	call   c002e228 <msg>
c00312e7:	83 c4 10             	add    $0x10,%esp
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c00312ea:	8d 45 d8             	lea    -0x28(%ebp),%eax
c00312ed:	50                   	push   %eax
c00312ee:	8d 83 1c 70 ff ff    	lea    -0x8fe4(%ebx),%eax
c00312f4:	50                   	push   %eax
c00312f5:	6a 1f                	push   $0x1f
c00312f7:	8d 83 aa b8 ff ff    	lea    -0x4756(%ebx),%eax
c00312fd:	50                   	push   %eax
c00312fe:	e8 a1 fd fe ff       	call   c00210a4 <thread_create>
c0031303:	83 c4 10             	add    $0x10,%esp
  timer_sleep (25 * TIMER_FREQ);
c0031306:	83 ec 08             	sub    $0x8,%esp
c0031309:	6a 00                	push   $0x0
c003130b:	68 c4 09 00 00       	push   $0x9c4
c0031310:	e8 e8 3d ff ff       	call   c00250fd <timer_sleep>
c0031315:	83 c4 10             	add    $0x10,%esp

  msg ("Main thread spinning for 5 seconds...");
c0031318:	83 ec 0c             	sub    $0xc,%esp
c003131b:	8d 83 b0 b8 ff ff    	lea    -0x4750(%ebx),%eax
c0031321:	50                   	push   %eax
c0031322:	e8 01 cf ff ff       	call   c002e228 <msg>
c0031327:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c003132a:	e8 60 3d ff ff       	call   c002508f <timer_ticks>
c003132f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0031332:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c0031335:	eb 01                	jmp    c0031338 <test_mlfqs_block+0xd6>
    continue;
c0031337:	90                   	nop
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c0031338:	83 ec 08             	sub    $0x8,%esp
c003133b:	ff 75 f4             	push   -0xc(%ebp)
c003133e:	ff 75 f0             	push   -0x10(%ebp)
c0031341:	e8 8e 3d ff ff       	call   c00250d4 <timer_elapsed>
c0031346:	83 c4 10             	add    $0x10,%esp
c0031349:	be f3 01 00 00       	mov    $0x1f3,%esi
c003134e:	b9 00 00 00 00       	mov    $0x0,%ecx
c0031353:	39 c6                	cmp    %eax,%esi
c0031355:	19 d1                	sbb    %edx,%ecx
c0031357:	7d de                	jge    c0031337 <test_mlfqs_block+0xd5>

  msg ("Main thread releasing lock.");
c0031359:	83 ec 0c             	sub    $0xc,%esp
c003135c:	8d 83 d6 b8 ff ff    	lea    -0x472a(%ebx),%eax
c0031362:	50                   	push   %eax
c0031363:	e8 c0 ce ff ff       	call   c002e228 <msg>
c0031368:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c003136b:	83 ec 0c             	sub    $0xc,%esp
c003136e:	8d 45 d8             	lea    -0x28(%ebp),%eax
c0031371:	50                   	push   %eax
c0031372:	e8 6e 27 ff ff       	call   c0023ae5 <lock_release>
c0031377:	83 c4 10             	add    $0x10,%esp

  msg ("Block thread should have already acquired lock.");
c003137a:	83 ec 0c             	sub    $0xc,%esp
c003137d:	8d 83 f4 b8 ff ff    	lea    -0x470c(%ebx),%eax
c0031383:	50                   	push   %eax
c0031384:	e8 9f ce ff ff       	call   c002e228 <msg>
c0031389:	83 c4 10             	add    $0x10,%esp
}
c003138c:	90                   	nop
c003138d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0031390:	5b                   	pop    %ebx
c0031391:	5e                   	pop    %esi
c0031392:	5d                   	pop    %ebp
c0031393:	c3                   	ret    

c0031394 <block_thread>:

static void
block_thread (void *lock_) 
{
c0031394:	55                   	push   %ebp
c0031395:	89 e5                	mov    %esp,%ebp
c0031397:	56                   	push   %esi
c0031398:	53                   	push   %ebx
c0031399:	83 ec 10             	sub    $0x10,%esp
c003139c:	e8 8b 00 00 00       	call   c003142c <__x86.get_pc_thunk.bx>
c00313a1:	81 c3 d7 8f 00 00    	add    $0x8fd7,%ebx
  struct lock *lock = lock_;
c00313a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00313aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c00313ad:	83 ec 0c             	sub    $0xc,%esp
c00313b0:	8d 83 24 b9 ff ff    	lea    -0x46dc(%ebx),%eax
c00313b6:	50                   	push   %eax
c00313b7:	e8 6c ce ff ff       	call   c002e228 <msg>
c00313bc:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c00313bf:	e8 cb 3c ff ff       	call   c002508f <timer_ticks>
c00313c4:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00313c7:	89 55 ec             	mov    %edx,-0x14(%ebp)
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c00313ca:	eb 01                	jmp    c00313cd <block_thread+0x39>
    continue;
c00313cc:	90                   	nop
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c00313cd:	83 ec 08             	sub    $0x8,%esp
c00313d0:	ff 75 ec             	push   -0x14(%ebp)
c00313d3:	ff 75 e8             	push   -0x18(%ebp)
c00313d6:	e8 f9 3c ff ff       	call   c00250d4 <timer_elapsed>
c00313db:	83 c4 10             	add    $0x10,%esp
c00313de:	be cf 07 00 00       	mov    $0x7cf,%esi
c00313e3:	b9 00 00 00 00       	mov    $0x0,%ecx
c00313e8:	39 c6                	cmp    %eax,%esi
c00313ea:	19 d1                	sbb    %edx,%ecx
c00313ec:	7d de                	jge    c00313cc <block_thread+0x38>

  msg ("Block thread acquiring lock...");
c00313ee:	83 ec 0c             	sub    $0xc,%esp
c00313f1:	8d 83 4c b9 ff ff    	lea    -0x46b4(%ebx),%eax
c00313f7:	50                   	push   %eax
c00313f8:	e8 2b ce ff ff       	call   c002e228 <msg>
c00313fd:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c0031400:	83 ec 0c             	sub    $0xc,%esp
c0031403:	ff 75 f4             	push   -0xc(%ebp)
c0031406:	e8 2c 24 ff ff       	call   c0023837 <lock_acquire>
c003140b:	83 c4 10             	add    $0x10,%esp

  msg ("...got it.");
c003140e:	83 ec 0c             	sub    $0xc,%esp
c0031411:	8d 83 6b b9 ff ff    	lea    -0x4695(%ebx),%eax
c0031417:	50                   	push   %eax
c0031418:	e8 0b ce ff ff       	call   c002e228 <msg>
c003141d:	83 c4 10             	add    $0x10,%esp
}
c0031420:	90                   	nop
c0031421:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0031424:	5b                   	pop    %ebx
c0031425:	5e                   	pop    %esi
c0031426:	5d                   	pop    %ebp
c0031427:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.ax:

c0031428 <__x86.get_pc_thunk.ax>:
c0031428:	8b 04 24             	mov    (%esp),%eax
c003142b:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bx:

c003142c <__x86.get_pc_thunk.bx>:
c003142c:	8b 1c 24             	mov    (%esp),%ebx
c003142f:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.si:

c0031430 <__x86.get_pc_thunk.si>:
c0031430:	8b 34 24             	mov    (%esp),%esi
c0031433:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.cx:

c0031434 <__x86.get_pc_thunk.cx>:
c0031434:	8b 0c 24             	mov    (%esp),%ecx
c0031437:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.dx:

c0031438 <__x86.get_pc_thunk.dx>:
c0031438:	8b 14 24             	mov    (%esp),%edx
c003143b:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.di:

c003143c <__x86.get_pc_thunk.di>:
c003143c:	8b 3c 24             	mov    (%esp),%edi
c003143f:	c3                   	ret    
